// ==UserScript==
// @name         Arie's Mod
// @namespace    Quinoa
// @version      2.8.11
// @match        https://1227719606223765687.discordsays.com/*
// @match        https://magiccircle.gg/r/*
// @match        https://magicgarden.gg/r/*
// @match        https://starweaver.org/r/*
// @run-at       document-start
// @inject-into  page
// @grant        GM_xmlhttpRequest
// @grant        GM_info
// @grant        GM_openInTab 
// @grant        GM_registerMenuCommand
// @connect      raw.githubusercontent.com
// @connect      api.github.com
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_download
// @connect      supabase.co

// @downloadURL  https://github.com/Ariedam64/MagicGarden-modMenu/raw/refs/heads/main/quinoa-ws.min.user.js
// @updateURL    https://github.com/Ariedam64/MagicGarden-modMenu/raw/refs/heads/main/quinoa-ws.min.user.js
// ==/UserScript==
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key2 of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key2) && key2 !== except)
          __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);

  // node_modules/jszip/dist/jszip.min.js
  var require_jszip_min = __commonJS({
    "node_modules/jszip/dist/jszip.min.js"(exports, module) {
      !function(t) {
        if ("object" == typeof exports && "undefined" != typeof module) module.exports = t();
        else if ("function" == typeof define && define.amd) define([], t);
        else {
          ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = t();
        }
      }(function() {
        return function s(a, o, h) {
          function u(r, t2) {
            if (!o[r]) {
              if (!a[r]) {
                var e = "function" == typeof __require && __require;
                if (!t2 && e) return e(r, true);
                if (l) return l(r, true);
                var i = new Error("Cannot find module '" + r + "'");
                throw i.code = "MODULE_NOT_FOUND", i;
              }
              var n = o[r] = { exports: {} };
              a[r][0].call(n.exports, function(t3) {
                var e2 = a[r][1][t3];
                return u(e2 || t3);
              }, n, n.exports, s, a, o, h);
            }
            return o[r].exports;
          }
          for (var l = "function" == typeof __require && __require, t = 0; t < h.length; t++) u(h[t]);
          return u;
        }({ 1: [function(t, e, r) {
          "use strict";
          var c = t("./utils"), d = t("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          r.encode = function(t2) {
            for (var e2, r2, i, n, s, a, o, h = [], u = 0, l = t2.length, f = l, d2 = "string" !== c.getTypeOf(t2); u < t2.length; ) f = l - u, i = d2 ? (e2 = t2[u++], r2 = u < l ? t2[u++] : 0, u < l ? t2[u++] : 0) : (e2 = t2.charCodeAt(u++), r2 = u < l ? t2.charCodeAt(u++) : 0, u < l ? t2.charCodeAt(u++) : 0), n = e2 >> 2, s = (3 & e2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | i >> 6 : 64, o = 2 < f ? 63 & i : 64, h.push(p.charAt(n) + p.charAt(s) + p.charAt(a) + p.charAt(o));
            return h.join("");
          }, r.decode = function(t2) {
            var e2, r2, i, n, s, a, o = 0, h = 0, u = "data:";
            if (t2.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
            var l, f = 3 * (t2 = t2.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
            if (t2.charAt(t2.length - 1) === p.charAt(64) && f--, t2.charAt(t2.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
            for (l = d.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < t2.length; ) e2 = p.indexOf(t2.charAt(o++)) << 2 | (n = p.indexOf(t2.charAt(o++))) >> 4, r2 = (15 & n) << 4 | (s = p.indexOf(t2.charAt(o++))) >> 2, i = (3 & s) << 6 | (a = p.indexOf(t2.charAt(o++))), l[h++] = e2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = i);
            return l;
          };
        }, { "./support": 30, "./utils": 32 }], 2: [function(t, e, r) {
          "use strict";
          var i = t("./external"), n = t("./stream/DataWorker"), s = t("./stream/Crc32Probe"), a = t("./stream/DataLengthProbe");
          function o(t2, e2, r2, i2, n2) {
            this.compressedSize = t2, this.uncompressedSize = e2, this.crc32 = r2, this.compression = i2, this.compressedContent = n2;
          }
          o.prototype = { getContentWorker: function() {
            var t2 = new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), e2 = this;
            return t2.on("end", function() {
              if (this.streamInfo.data_length !== e2.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
            }), t2;
          }, getCompressedWorker: function() {
            return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
          } }, o.createWorkerFrom = function(t2, e2, r2) {
            return t2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(e2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", e2);
          }, e.exports = o;
        }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, e, r) {
          "use strict";
          var i = t("./stream/GenericWorker");
          r.STORE = { magic: "\0\0", compressWorker: function(t2) {
            return new i("STORE compression");
          }, uncompressWorker: function() {
            return new i("STORE decompression");
          } }, r.DEFLATE = t("./flate");
        }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, e, r) {
          "use strict";
          var i = t("./utils");
          var o = function() {
            for (var t2, e2 = [], r2 = 0; r2 < 256; r2++) {
              t2 = r2;
              for (var i2 = 0; i2 < 8; i2++) t2 = 1 & t2 ? 3988292384 ^ t2 >>> 1 : t2 >>> 1;
              e2[r2] = t2;
            }
            return e2;
          }();
          e.exports = function(t2, e2) {
            return void 0 !== t2 && t2.length ? "string" !== i.getTypeOf(t2) ? function(t3, e3, r2, i2) {
              var n = o, s = i2 + r2;
              t3 ^= -1;
              for (var a = i2; a < s; a++) t3 = t3 >>> 8 ^ n[255 & (t3 ^ e3[a])];
              return -1 ^ t3;
            }(0 | e2, t2, t2.length, 0) : function(t3, e3, r2, i2) {
              var n = o, s = i2 + r2;
              t3 ^= -1;
              for (var a = i2; a < s; a++) t3 = t3 >>> 8 ^ n[255 & (t3 ^ e3.charCodeAt(a))];
              return -1 ^ t3;
            }(0 | e2, t2, t2.length, 0) : 0;
          };
        }, { "./utils": 32 }], 5: [function(t, e, r) {
          "use strict";
          r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
        }, {}], 6: [function(t, e, r) {
          "use strict";
          var i = null;
          i = "undefined" != typeof Promise ? Promise : t("lie"), e.exports = { Promise: i };
        }, { lie: 37 }], 7: [function(t, e, r) {
          "use strict";
          var i = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, n = t("pako"), s = t("./utils"), a = t("./stream/GenericWorker"), o = i ? "uint8array" : "array";
          function h(t2, e2) {
            a.call(this, "FlateWorker/" + t2), this._pako = null, this._pakoAction = t2, this._pakoOptions = e2, this.meta = {};
          }
          r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(t2) {
            this.meta = t2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, t2.data), false);
          }, h.prototype.flush = function() {
            a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
          }, h.prototype.cleanUp = function() {
            a.prototype.cleanUp.call(this), this._pako = null;
          }, h.prototype._createPako = function() {
            this._pako = new n[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
            var e2 = this;
            this._pako.onData = function(t2) {
              e2.push({ data: t2, meta: e2.meta });
            };
          }, r.compressWorker = function(t2) {
            return new h("Deflate", t2);
          }, r.uncompressWorker = function() {
            return new h("Inflate", {});
          };
        }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, e, r) {
          "use strict";
          function A(t2, e2) {
            var r2, i2 = "";
            for (r2 = 0; r2 < e2; r2++) i2 += String.fromCharCode(255 & t2), t2 >>>= 8;
            return i2;
          }
          function i(t2, e2, r2, i2, n2, s2) {
            var a, o, h = t2.file, u = t2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), d = I.transformTo("string", O.utf8encode(h.name)), c = h.comment, p = I.transformTo("string", s2(c)), m = I.transformTo("string", O.utf8encode(c)), _ = d.length !== h.name.length, g = m.length !== c.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
            e2 && !r2 || (x.crc32 = t2.crc32, x.compressedSize = t2.compressedSize, x.uncompressedSize = t2.uncompressedSize);
            var S = 0;
            e2 && (S |= 8), l || !_ && !g || (S |= 2048);
            var z = 0, C = 0;
            w && (z |= 16), "UNIX" === n2 ? (C = 798, z |= function(t3, e3) {
              var r3 = t3;
              return t3 || (r3 = e3 ? 16893 : 33204), (65535 & r3) << 16;
            }(h.unixPermissions, w)) : (C = 20, z |= function(t3) {
              return 63 & (t3 || 0);
            }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + d, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
            var E = "";
            return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(i2, 4) + f + b + p };
          }
          var I = t("../utils"), n = t("../stream/GenericWorker"), O = t("../utf8"), B = t("../crc32"), R = t("../signature");
          function s(t2, e2, r2, i2) {
            n.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = e2, this.zipPlatform = r2, this.encodeFileName = i2, this.streamFiles = t2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
          }
          I.inherits(s, n), s.prototype.push = function(t2) {
            var e2 = t2.meta.percent || 0, r2 = this.entriesCount, i2 = this._sources.length;
            this.accumulate ? this.contentBuffer.push(t2) : (this.bytesWritten += t2.data.length, n.prototype.push.call(this, { data: t2.data, meta: { currentFile: this.currentFile, percent: r2 ? (e2 + 100 * (r2 - i2 - 1)) / r2 : 100 } }));
          }, s.prototype.openedSource = function(t2) {
            this.currentSourceOffset = this.bytesWritten, this.currentFile = t2.file.name;
            var e2 = this.streamFiles && !t2.file.dir;
            if (e2) {
              var r2 = i(t2, e2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              this.push({ data: r2.fileRecord, meta: { percent: 0 } });
            } else this.accumulate = true;
          }, s.prototype.closedSource = function(t2) {
            this.accumulate = false;
            var e2 = this.streamFiles && !t2.file.dir, r2 = i(t2, e2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            if (this.dirRecords.push(r2.dirRecord), e2) this.push({ data: function(t3) {
              return R.DATA_DESCRIPTOR + A(t3.crc32, 4) + A(t3.compressedSize, 4) + A(t3.uncompressedSize, 4);
            }(t2), meta: { percent: 100 } });
            else for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
            this.currentFile = null;
          }, s.prototype.flush = function() {
            for (var t2 = this.bytesWritten, e2 = 0; e2 < this.dirRecords.length; e2++) this.push({ data: this.dirRecords[e2], meta: { percent: 100 } });
            var r2 = this.bytesWritten - t2, i2 = function(t3, e3, r3, i3, n2) {
              var s2 = I.transformTo("string", n2(i3));
              return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(t3, 2) + A(t3, 2) + A(e3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
            }(this.dirRecords.length, r2, t2, this.zipComment, this.encodeFileName);
            this.push({ data: i2, meta: { percent: 100 } });
          }, s.prototype.prepareNextSource = function() {
            this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
          }, s.prototype.registerPrevious = function(t2) {
            this._sources.push(t2);
            var e2 = this;
            return t2.on("data", function(t3) {
              e2.processChunk(t3);
            }), t2.on("end", function() {
              e2.closedSource(e2.previous.streamInfo), e2._sources.length ? e2.prepareNextSource() : e2.end();
            }), t2.on("error", function(t3) {
              e2.error(t3);
            }), this;
          }, s.prototype.resume = function() {
            return !!n.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
          }, s.prototype.error = function(t2) {
            var e2 = this._sources;
            if (!n.prototype.error.call(this, t2)) return false;
            for (var r2 = 0; r2 < e2.length; r2++) try {
              e2[r2].error(t2);
            } catch (t3) {
            }
            return true;
          }, s.prototype.lock = function() {
            n.prototype.lock.call(this);
            for (var t2 = this._sources, e2 = 0; e2 < t2.length; e2++) t2[e2].lock();
          }, e.exports = s;
        }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, e, r) {
          "use strict";
          var u = t("../compressions"), i = t("./ZipFileWorker");
          r.generateWorker = function(t2, a, e2) {
            var o = new i(a.streamFiles, e2, a.platform, a.encodeFileName), h = 0;
            try {
              t2.forEach(function(t3, e3) {
                h++;
                var r2 = function(t4, e4) {
                  var r3 = t4 || e4, i3 = u[r3];
                  if (!i3) throw new Error(r3 + " is not a valid compression method !");
                  return i3;
                }(e3.options.compression, a.compression), i2 = e3.options.compressionOptions || a.compressionOptions || {}, n = e3.dir, s = e3.date;
                e3._compressWorker(r2, i2).withStreamInfo("file", { name: t3, dir: n, date: s, comment: e3.comment || "", unixPermissions: e3.unixPermissions, dosPermissions: e3.dosPermissions }).pipe(o);
              }), o.entriesCount = h;
            } catch (t3) {
              o.error(t3);
            }
            return o;
          };
        }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, e, r) {
          "use strict";
          function i() {
            if (!(this instanceof i)) return new i();
            if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
            this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
              var t2 = new i();
              for (var e2 in this) "function" != typeof this[e2] && (t2[e2] = this[e2]);
              return t2;
            };
          }
          (i.prototype = t("./object")).loadAsync = t("./load"), i.support = t("./support"), i.defaults = t("./defaults"), i.version = "3.9.1", i.loadAsync = function(t2, e2) {
            return new i().loadAsync(t2, e2);
          }, i.external = t("./external"), e.exports = i;
        }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, e, r) {
          "use strict";
          var u = t("./utils"), n = t("./external"), i = t("./utf8"), s = t("./zipEntries"), a = t("./stream/Crc32Probe"), l = t("./nodejsUtils");
          function f(i2) {
            return new n.Promise(function(t2, e2) {
              var r2 = i2.decompressed.getContentWorker().pipe(new a());
              r2.on("error", function(t3) {
                e2(t3);
              }).on("end", function() {
                r2.streamInfo.crc32 !== i2.decompressed.crc32 ? e2(new Error("Corrupted zip : CRC32 mismatch")) : t2();
              }).resume();
            });
          }
          e.exports = function(t2, o) {
            var h = this;
            return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: i.utf8decode }), l.isNode && l.isStream(t2) ? n.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", t2, true, o.optimizedBinaryString, o.base64).then(function(t3) {
              var e2 = new s(o);
              return e2.load(t3), e2;
            }).then(function(t3) {
              var e2 = [n.Promise.resolve(t3)], r2 = t3.files;
              if (o.checkCRC32) for (var i2 = 0; i2 < r2.length; i2++) e2.push(f(r2[i2]));
              return n.Promise.all(e2);
            }).then(function(t3) {
              for (var e2 = t3.shift(), r2 = e2.files, i2 = 0; i2 < r2.length; i2++) {
                var n2 = r2[i2], s2 = n2.fileNameStr, a2 = u.resolve(n2.fileNameStr);
                h.file(a2, n2.decompressed, { binary: true, optimizedBinaryString: true, date: n2.date, dir: n2.dir, comment: n2.fileCommentStr.length ? n2.fileCommentStr : null, unixPermissions: n2.unixPermissions, dosPermissions: n2.dosPermissions, createFolders: o.createFolders }), n2.dir || (h.file(a2).unsafeOriginalName = s2);
              }
              return e2.zipComment.length && (h.comment = e2.zipComment), h;
            });
          };
        }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, e, r) {
          "use strict";
          var i = t("../utils"), n = t("../stream/GenericWorker");
          function s(t2, e2) {
            n.call(this, "Nodejs stream input adapter for " + t2), this._upstreamEnded = false, this._bindStream(e2);
          }
          i.inherits(s, n), s.prototype._bindStream = function(t2) {
            var e2 = this;
            (this._stream = t2).pause(), t2.on("data", function(t3) {
              e2.push({ data: t3, meta: { percent: 0 } });
            }).on("error", function(t3) {
              e2.isPaused ? this.generatedError = t3 : e2.error(t3);
            }).on("end", function() {
              e2.isPaused ? e2._upstreamEnded = true : e2.end();
            });
          }, s.prototype.pause = function() {
            return !!n.prototype.pause.call(this) && (this._stream.pause(), true);
          }, s.prototype.resume = function() {
            return !!n.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
          }, e.exports = s;
        }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, e, r) {
          "use strict";
          var n = t("readable-stream").Readable;
          function i(t2, e2, r2) {
            n.call(this, e2), this._helper = t2;
            var i2 = this;
            t2.on("data", function(t3, e3) {
              i2.push(t3) || i2._helper.pause(), r2 && r2(e3);
            }).on("error", function(t3) {
              i2.emit("error", t3);
            }).on("end", function() {
              i2.push(null);
            });
          }
          t("../utils").inherits(i, n), i.prototype._read = function() {
            this._helper.resume();
          }, e.exports = i;
        }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, e, r) {
          "use strict";
          e.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(t2, e2) {
            if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(t2, e2);
            if ("number" == typeof t2) throw new Error('The "data" argument must not be a number');
            return new Buffer(t2, e2);
          }, allocBuffer: function(t2) {
            if (Buffer.alloc) return Buffer.alloc(t2);
            var e2 = new Buffer(t2);
            return e2.fill(0), e2;
          }, isBuffer: function(t2) {
            return Buffer.isBuffer(t2);
          }, isStream: function(t2) {
            return t2 && "function" == typeof t2.on && "function" == typeof t2.pause && "function" == typeof t2.resume;
          } };
        }, {}], 15: [function(t, e, r) {
          "use strict";
          function s(t2, e2, r2) {
            var i2, n2 = u.getTypeOf(e2), s2 = u.extend(r2 || {}, f);
            s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (t2 = g(t2)), s2.createFolders && (i2 = _(t2)) && b.call(this, i2, true);
            var a2 = "string" === n2 && false === s2.binary && false === s2.base64;
            r2 && void 0 !== r2.binary || (s2.binary = !a2), (e2 instanceof d && 0 === e2.uncompressedSize || s2.dir || !e2 || 0 === e2.length) && (s2.base64 = false, s2.binary = true, e2 = "", s2.compression = "STORE", n2 = "string");
            var o2 = null;
            o2 = e2 instanceof d || e2 instanceof l ? e2 : p.isNode && p.isStream(e2) ? new m(t2, e2) : u.prepareContent(t2, e2, s2.binary, s2.optimizedBinaryString, s2.base64);
            var h2 = new c(t2, o2, s2);
            this.files[t2] = h2;
          }
          var n = t("./utf8"), u = t("./utils"), l = t("./stream/GenericWorker"), a = t("./stream/StreamHelper"), f = t("./defaults"), d = t("./compressedObject"), c = t("./zipObject"), o = t("./generate"), p = t("./nodejsUtils"), m = t("./nodejs/NodejsStreamInputAdapter"), _ = function(t2) {
            "/" === t2.slice(-1) && (t2 = t2.substring(0, t2.length - 1));
            var e2 = t2.lastIndexOf("/");
            return 0 < e2 ? t2.substring(0, e2) : "";
          }, g = function(t2) {
            return "/" !== t2.slice(-1) && (t2 += "/"), t2;
          }, b = function(t2, e2) {
            return e2 = void 0 !== e2 ? e2 : f.createFolders, t2 = g(t2), this.files[t2] || s.call(this, t2, null, { dir: true, createFolders: e2 }), this.files[t2];
          };
          function h(t2) {
            return "[object RegExp]" === Object.prototype.toString.call(t2);
          }
          var i = { load: function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, forEach: function(t2) {
            var e2, r2, i2;
            for (e2 in this.files) i2 = this.files[e2], (r2 = e2.slice(this.root.length, e2.length)) && e2.slice(0, this.root.length) === this.root && t2(r2, i2);
          }, filter: function(r2) {
            var i2 = [];
            return this.forEach(function(t2, e2) {
              r2(t2, e2) && i2.push(e2);
            }), i2;
          }, file: function(t2, e2, r2) {
            if (1 !== arguments.length) return t2 = this.root + t2, s.call(this, t2, e2, r2), this;
            if (h(t2)) {
              var i2 = t2;
              return this.filter(function(t3, e3) {
                return !e3.dir && i2.test(t3);
              });
            }
            var n2 = this.files[this.root + t2];
            return n2 && !n2.dir ? n2 : null;
          }, folder: function(r2) {
            if (!r2) return this;
            if (h(r2)) return this.filter(function(t3, e3) {
              return e3.dir && r2.test(t3);
            });
            var t2 = this.root + r2, e2 = b.call(this, t2), i2 = this.clone();
            return i2.root = e2.name, i2;
          }, remove: function(r2) {
            r2 = this.root + r2;
            var t2 = this.files[r2];
            if (t2 || ("/" !== r2.slice(-1) && (r2 += "/"), t2 = this.files[r2]), t2 && !t2.dir) delete this.files[r2];
            else for (var e2 = this.filter(function(t3, e3) {
              return e3.name.slice(0, r2.length) === r2;
            }), i2 = 0; i2 < e2.length; i2++) delete this.files[e2[i2].name];
            return this;
          }, generate: function(t2) {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, generateInternalStream: function(t2) {
            var e2, r2 = {};
            try {
              if ((r2 = u.extend(t2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: n.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type) throw new Error("No output type specified.");
              u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
              var i2 = r2.comment || this.comment || "";
              e2 = o.generateWorker(this, r2, i2);
            } catch (t3) {
              (e2 = new l("error")).error(t3);
            }
            return new a(e2, r2.type || "string", r2.mimeType);
          }, generateAsync: function(t2, e2) {
            return this.generateInternalStream(t2).accumulate(e2);
          }, generateNodeStream: function(t2, e2) {
            return (t2 = t2 || {}).type || (t2.type = "nodebuffer"), this.generateInternalStream(t2).toNodejsStream(e2);
          } };
          e.exports = i;
        }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, e, r) {
          e.exports = t("stream");
        }, { stream: void 0 }], 17: [function(t, e, r) {
          "use strict";
          var i = t("./DataReader");
          function n(t2) {
            i.call(this, t2);
            for (var e2 = 0; e2 < this.data.length; e2++) t2[e2] = 255 & t2[e2];
          }
          t("../utils").inherits(n, i), n.prototype.byteAt = function(t2) {
            return this.data[this.zero + t2];
          }, n.prototype.lastIndexOfSignature = function(t2) {
            for (var e2 = t2.charCodeAt(0), r2 = t2.charCodeAt(1), i2 = t2.charCodeAt(2), n2 = t2.charCodeAt(3), s = this.length - 4; 0 <= s; --s) if (this.data[s] === e2 && this.data[s + 1] === r2 && this.data[s + 2] === i2 && this.data[s + 3] === n2) return s - this.zero;
            return -1;
          }, n.prototype.readAndCheckSignature = function(t2) {
            var e2 = t2.charCodeAt(0), r2 = t2.charCodeAt(1), i2 = t2.charCodeAt(2), n2 = t2.charCodeAt(3), s = this.readData(4);
            return e2 === s[0] && r2 === s[1] && i2 === s[2] && n2 === s[3];
          }, n.prototype.readData = function(t2) {
            if (this.checkOffset(t2), 0 === t2) return [];
            var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
            return this.index += t2, e2;
          }, e.exports = n;
        }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, e, r) {
          "use strict";
          var i = t("../utils");
          function n(t2) {
            this.data = t2, this.length = t2.length, this.index = 0, this.zero = 0;
          }
          n.prototype = { checkOffset: function(t2) {
            this.checkIndex(this.index + t2);
          }, checkIndex: function(t2) {
            if (this.length < this.zero + t2 || t2 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + t2 + "). Corrupted zip ?");
          }, setIndex: function(t2) {
            this.checkIndex(t2), this.index = t2;
          }, skip: function(t2) {
            this.setIndex(this.index + t2);
          }, byteAt: function(t2) {
          }, readInt: function(t2) {
            var e2, r2 = 0;
            for (this.checkOffset(t2), e2 = this.index + t2 - 1; e2 >= this.index; e2--) r2 = (r2 << 8) + this.byteAt(e2);
            return this.index += t2, r2;
          }, readString: function(t2) {
            return i.transformTo("string", this.readData(t2));
          }, readData: function(t2) {
          }, lastIndexOfSignature: function(t2) {
          }, readAndCheckSignature: function(t2) {
          }, readDate: function() {
            var t2 = this.readInt(4);
            return new Date(Date.UTC(1980 + (t2 >> 25 & 127), (t2 >> 21 & 15) - 1, t2 >> 16 & 31, t2 >> 11 & 31, t2 >> 5 & 63, (31 & t2) << 1));
          } }, e.exports = n;
        }, { "../utils": 32 }], 19: [function(t, e, r) {
          "use strict";
          var i = t("./Uint8ArrayReader");
          function n(t2) {
            i.call(this, t2);
          }
          t("../utils").inherits(n, i), n.prototype.readData = function(t2) {
            this.checkOffset(t2);
            var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
            return this.index += t2, e2;
          }, e.exports = n;
        }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, e, r) {
          "use strict";
          var i = t("./DataReader");
          function n(t2) {
            i.call(this, t2);
          }
          t("../utils").inherits(n, i), n.prototype.byteAt = function(t2) {
            return this.data.charCodeAt(this.zero + t2);
          }, n.prototype.lastIndexOfSignature = function(t2) {
            return this.data.lastIndexOf(t2) - this.zero;
          }, n.prototype.readAndCheckSignature = function(t2) {
            return t2 === this.readData(4);
          }, n.prototype.readData = function(t2) {
            this.checkOffset(t2);
            var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
            return this.index += t2, e2;
          }, e.exports = n;
        }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, e, r) {
          "use strict";
          var i = t("./ArrayReader");
          function n(t2) {
            i.call(this, t2);
          }
          t("../utils").inherits(n, i), n.prototype.readData = function(t2) {
            if (this.checkOffset(t2), 0 === t2) return new Uint8Array(0);
            var e2 = this.data.subarray(this.zero + this.index, this.zero + this.index + t2);
            return this.index += t2, e2;
          }, e.exports = n;
        }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, e, r) {
          "use strict";
          var i = t("../utils"), n = t("../support"), s = t("./ArrayReader"), a = t("./StringReader"), o = t("./NodeBufferReader"), h = t("./Uint8ArrayReader");
          e.exports = function(t2) {
            var e2 = i.getTypeOf(t2);
            return i.checkSupport(e2), "string" !== e2 || n.uint8array ? "nodebuffer" === e2 ? new o(t2) : n.uint8array ? new h(i.transformTo("uint8array", t2)) : new s(i.transformTo("array", t2)) : new a(t2);
          };
        }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, e, r) {
          "use strict";
          r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
        }, {}], 24: [function(t, e, r) {
          "use strict";
          var i = t("./GenericWorker"), n = t("../utils");
          function s(t2) {
            i.call(this, "ConvertWorker to " + t2), this.destType = t2;
          }
          n.inherits(s, i), s.prototype.processChunk = function(t2) {
            this.push({ data: n.transformTo(this.destType, t2.data), meta: t2.meta });
          }, e.exports = s;
        }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, e, r) {
          "use strict";
          var i = t("./GenericWorker"), n = t("../crc32");
          function s() {
            i.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
          }
          t("../utils").inherits(s, i), s.prototype.processChunk = function(t2) {
            this.streamInfo.crc32 = n(t2.data, this.streamInfo.crc32 || 0), this.push(t2);
          }, e.exports = s;
        }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, e, r) {
          "use strict";
          var i = t("../utils"), n = t("./GenericWorker");
          function s(t2) {
            n.call(this, "DataLengthProbe for " + t2), this.propName = t2, this.withStreamInfo(t2, 0);
          }
          i.inherits(s, n), s.prototype.processChunk = function(t2) {
            if (t2) {
              var e2 = this.streamInfo[this.propName] || 0;
              this.streamInfo[this.propName] = e2 + t2.data.length;
            }
            n.prototype.processChunk.call(this, t2);
          }, e.exports = s;
        }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, e, r) {
          "use strict";
          var i = t("../utils"), n = t("./GenericWorker");
          function s(t2) {
            n.call(this, "DataWorker");
            var e2 = this;
            this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, t2.then(function(t3) {
              e2.dataIsReady = true, e2.data = t3, e2.max = t3 && t3.length || 0, e2.type = i.getTypeOf(t3), e2.isPaused || e2._tickAndRepeat();
            }, function(t3) {
              e2.error(t3);
            });
          }
          i.inherits(s, n), s.prototype.cleanUp = function() {
            n.prototype.cleanUp.call(this), this.data = null;
          }, s.prototype.resume = function() {
            return !!n.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, i.delay(this._tickAndRepeat, [], this)), true);
          }, s.prototype._tickAndRepeat = function() {
            this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (i.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
          }, s.prototype._tick = function() {
            if (this.isPaused || this.isFinished) return false;
            var t2 = null, e2 = Math.min(this.max, this.index + 16384);
            if (this.index >= this.max) return this.end();
            switch (this.type) {
              case "string":
                t2 = this.data.substring(this.index, e2);
                break;
              case "uint8array":
                t2 = this.data.subarray(this.index, e2);
                break;
              case "array":
              case "nodebuffer":
                t2 = this.data.slice(this.index, e2);
            }
            return this.index = e2, this.push({ data: t2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
          }, e.exports = s;
        }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, e, r) {
          "use strict";
          function i(t2) {
            this.name = t2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
          }
          i.prototype = { push: function(t2) {
            this.emit("data", t2);
          }, end: function() {
            if (this.isFinished) return false;
            this.flush();
            try {
              this.emit("end"), this.cleanUp(), this.isFinished = true;
            } catch (t2) {
              this.emit("error", t2);
            }
            return true;
          }, error: function(t2) {
            return !this.isFinished && (this.isPaused ? this.generatedError = t2 : (this.isFinished = true, this.emit("error", t2), this.previous && this.previous.error(t2), this.cleanUp()), true);
          }, on: function(t2, e2) {
            return this._listeners[t2].push(e2), this;
          }, cleanUp: function() {
            this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
          }, emit: function(t2, e2) {
            if (this._listeners[t2]) for (var r2 = 0; r2 < this._listeners[t2].length; r2++) this._listeners[t2][r2].call(this, e2);
          }, pipe: function(t2) {
            return t2.registerPrevious(this);
          }, registerPrevious: function(t2) {
            if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
            this.streamInfo = t2.streamInfo, this.mergeStreamInfo(), this.previous = t2;
            var e2 = this;
            return t2.on("data", function(t3) {
              e2.processChunk(t3);
            }), t2.on("end", function() {
              e2.end();
            }), t2.on("error", function(t3) {
              e2.error(t3);
            }), this;
          }, pause: function() {
            return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
          }, resume: function() {
            if (!this.isPaused || this.isFinished) return false;
            var t2 = this.isPaused = false;
            return this.generatedError && (this.error(this.generatedError), t2 = true), this.previous && this.previous.resume(), !t2;
          }, flush: function() {
          }, processChunk: function(t2) {
            this.push(t2);
          }, withStreamInfo: function(t2, e2) {
            return this.extraStreamInfo[t2] = e2, this.mergeStreamInfo(), this;
          }, mergeStreamInfo: function() {
            for (var t2 in this.extraStreamInfo) this.extraStreamInfo.hasOwnProperty(t2) && (this.streamInfo[t2] = this.extraStreamInfo[t2]);
          }, lock: function() {
            if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
            this.isLocked = true, this.previous && this.previous.lock();
          }, toString: function() {
            var t2 = "Worker " + this.name;
            return this.previous ? this.previous + " -> " + t2 : t2;
          } }, e.exports = i;
        }, {}], 29: [function(t, e, r) {
          "use strict";
          var h = t("../utils"), n = t("./ConvertWorker"), s = t("./GenericWorker"), u = t("../base64"), i = t("../support"), a = t("../external"), o = null;
          if (i.nodestream) try {
            o = t("../nodejs/NodejsStreamOutputAdapter");
          } catch (t2) {
          }
          function l(t2, o2) {
            return new a.Promise(function(e2, r2) {
              var i2 = [], n2 = t2._internalType, s2 = t2._outputType, a2 = t2._mimeType;
              t2.on("data", function(t3, e3) {
                i2.push(t3), o2 && o2(e3);
              }).on("error", function(t3) {
                i2 = [], r2(t3);
              }).on("end", function() {
                try {
                  var t3 = function(t4, e3, r3) {
                    switch (t4) {
                      case "blob":
                        return h.newBlob(h.transformTo("arraybuffer", e3), r3);
                      case "base64":
                        return u.encode(e3);
                      default:
                        return h.transformTo(t4, e3);
                    }
                  }(s2, function(t4, e3) {
                    var r3, i3 = 0, n3 = null, s3 = 0;
                    for (r3 = 0; r3 < e3.length; r3++) s3 += e3[r3].length;
                    switch (t4) {
                      case "string":
                        return e3.join("");
                      case "array":
                        return Array.prototype.concat.apply([], e3);
                      case "uint8array":
                        for (n3 = new Uint8Array(s3), r3 = 0; r3 < e3.length; r3++) n3.set(e3[r3], i3), i3 += e3[r3].length;
                        return n3;
                      case "nodebuffer":
                        return Buffer.concat(e3);
                      default:
                        throw new Error("concat : unsupported type '" + t4 + "'");
                    }
                  }(n2, i2), a2);
                  e2(t3);
                } catch (t4) {
                  r2(t4);
                }
                i2 = [];
              }).resume();
            });
          }
          function f(t2, e2, r2) {
            var i2 = e2;
            switch (e2) {
              case "blob":
              case "arraybuffer":
                i2 = "uint8array";
                break;
              case "base64":
                i2 = "string";
            }
            try {
              this._internalType = i2, this._outputType = e2, this._mimeType = r2, h.checkSupport(i2), this._worker = t2.pipe(new n(i2)), t2.lock();
            } catch (t3) {
              this._worker = new s("error"), this._worker.error(t3);
            }
          }
          f.prototype = { accumulate: function(t2) {
            return l(this, t2);
          }, on: function(t2, e2) {
            var r2 = this;
            return "data" === t2 ? this._worker.on(t2, function(t3) {
              e2.call(r2, t3.data, t3.meta);
            }) : this._worker.on(t2, function() {
              h.delay(e2, arguments, r2);
            }), this;
          }, resume: function() {
            return h.delay(this._worker.resume, [], this._worker), this;
          }, pause: function() {
            return this._worker.pause(), this;
          }, toNodejsStream: function(t2) {
            if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
            return new o(this, { objectMode: "nodebuffer" !== this._outputType }, t2);
          } }, e.exports = f;
        }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, e, r) {
          "use strict";
          if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = false;
          else {
            var i = new ArrayBuffer(0);
            try {
              r.blob = 0 === new Blob([i], { type: "application/zip" }).size;
            } catch (t2) {
              try {
                var n = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                n.append(i), r.blob = 0 === n.getBlob("application/zip").size;
              } catch (t3) {
                r.blob = false;
              }
            }
          }
          try {
            r.nodestream = !!t("readable-stream").Readable;
          } catch (t2) {
            r.nodestream = false;
          }
        }, { "readable-stream": 16 }], 31: [function(t, e, s) {
          "use strict";
          for (var o = t("./utils"), h = t("./support"), r = t("./nodejsUtils"), i = t("./stream/GenericWorker"), u = new Array(256), n = 0; n < 256; n++) u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
          u[254] = u[254] = 1;
          function a() {
            i.call(this, "utf-8 decode"), this.leftOver = null;
          }
          function l() {
            i.call(this, "utf-8 encode");
          }
          s.utf8encode = function(t2) {
            return h.nodebuffer ? r.newBufferFrom(t2, "utf-8") : function(t3) {
              var e2, r2, i2, n2, s2, a2 = t3.length, o2 = 0;
              for (n2 = 0; n2 < a2; n2++) 55296 == (64512 & (r2 = t3.charCodeAt(n2))) && n2 + 1 < a2 && 56320 == (64512 & (i2 = t3.charCodeAt(n2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), n2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
              for (e2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), n2 = s2 = 0; s2 < o2; n2++) 55296 == (64512 & (r2 = t3.charCodeAt(n2))) && n2 + 1 < a2 && 56320 == (64512 & (i2 = t3.charCodeAt(n2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), n2++), r2 < 128 ? e2[s2++] = r2 : (r2 < 2048 ? e2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? e2[s2++] = 224 | r2 >>> 12 : (e2[s2++] = 240 | r2 >>> 18, e2[s2++] = 128 | r2 >>> 12 & 63), e2[s2++] = 128 | r2 >>> 6 & 63), e2[s2++] = 128 | 63 & r2);
              return e2;
            }(t2);
          }, s.utf8decode = function(t2) {
            return h.nodebuffer ? o.transformTo("nodebuffer", t2).toString("utf-8") : function(t3) {
              var e2, r2, i2, n2, s2 = t3.length, a2 = new Array(2 * s2);
              for (e2 = r2 = 0; e2 < s2; ) if ((i2 = t3[e2++]) < 128) a2[r2++] = i2;
              else if (4 < (n2 = u[i2])) a2[r2++] = 65533, e2 += n2 - 1;
              else {
                for (i2 &= 2 === n2 ? 31 : 3 === n2 ? 15 : 7; 1 < n2 && e2 < s2; ) i2 = i2 << 6 | 63 & t3[e2++], n2--;
                1 < n2 ? a2[r2++] = 65533 : i2 < 65536 ? a2[r2++] = i2 : (i2 -= 65536, a2[r2++] = 55296 | i2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & i2);
              }
              return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
            }(t2 = o.transformTo(h.uint8array ? "uint8array" : "array", t2));
          }, o.inherits(a, i), a.prototype.processChunk = function(t2) {
            var e2 = o.transformTo(h.uint8array ? "uint8array" : "array", t2.data);
            if (this.leftOver && this.leftOver.length) {
              if (h.uint8array) {
                var r2 = e2;
                (e2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), e2.set(r2, this.leftOver.length);
              } else e2 = this.leftOver.concat(e2);
              this.leftOver = null;
            }
            var i2 = function(t3, e3) {
              var r3;
              for ((e3 = e3 || t3.length) > t3.length && (e3 = t3.length), r3 = e3 - 1; 0 <= r3 && 128 == (192 & t3[r3]); ) r3--;
              return r3 < 0 ? e3 : 0 === r3 ? e3 : r3 + u[t3[r3]] > e3 ? r3 : e3;
            }(e2), n2 = e2;
            i2 !== e2.length && (h.uint8array ? (n2 = e2.subarray(0, i2), this.leftOver = e2.subarray(i2, e2.length)) : (n2 = e2.slice(0, i2), this.leftOver = e2.slice(i2, e2.length))), this.push({ data: s.utf8decode(n2), meta: t2.meta });
          }, a.prototype.flush = function() {
            this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
          }, s.Utf8DecodeWorker = a, o.inherits(l, i), l.prototype.processChunk = function(t2) {
            this.push({ data: s.utf8encode(t2.data), meta: t2.meta });
          }, s.Utf8EncodeWorker = l;
        }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, e, a) {
          "use strict";
          var o = t("./support"), h = t("./base64"), r = t("./nodejsUtils"), i = t("set-immediate-shim"), u = t("./external");
          function n(t2) {
            return t2;
          }
          function l(t2, e2) {
            for (var r2 = 0; r2 < t2.length; ++r2) e2[r2] = 255 & t2.charCodeAt(r2);
            return e2;
          }
          a.newBlob = function(e2, r2) {
            a.checkSupport("blob");
            try {
              return new Blob([e2], { type: r2 });
            } catch (t2) {
              try {
                var i2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                return i2.append(e2), i2.getBlob(r2);
              } catch (t3) {
                throw new Error("Bug : can't construct the Blob.");
              }
            }
          };
          var s = { stringifyByChunk: function(t2, e2, r2) {
            var i2 = [], n2 = 0, s2 = t2.length;
            if (s2 <= r2) return String.fromCharCode.apply(null, t2);
            for (; n2 < s2; ) "array" === e2 || "nodebuffer" === e2 ? i2.push(String.fromCharCode.apply(null, t2.slice(n2, Math.min(n2 + r2, s2)))) : i2.push(String.fromCharCode.apply(null, t2.subarray(n2, Math.min(n2 + r2, s2)))), n2 += r2;
            return i2.join("");
          }, stringifyByChar: function(t2) {
            for (var e2 = "", r2 = 0; r2 < t2.length; r2++) e2 += String.fromCharCode(t2[r2]);
            return e2;
          }, applyCanBeUsed: { uint8array: function() {
            try {
              return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
            } catch (t2) {
              return false;
            }
          }(), nodebuffer: function() {
            try {
              return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
            } catch (t2) {
              return false;
            }
          }() } };
          function f(t2) {
            var e2 = 65536, r2 = a.getTypeOf(t2), i2 = true;
            if ("uint8array" === r2 ? i2 = s.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (i2 = s.applyCanBeUsed.nodebuffer), i2) for (; 1 < e2; ) try {
              return s.stringifyByChunk(t2, r2, e2);
            } catch (t3) {
              e2 = Math.floor(e2 / 2);
            }
            return s.stringifyByChar(t2);
          }
          function d(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++) e2[r2] = t2[r2];
            return e2;
          }
          a.applyFromCharCode = f;
          var c = {};
          c.string = { string: n, array: function(t2) {
            return l(t2, new Array(t2.length));
          }, arraybuffer: function(t2) {
            return c.string.uint8array(t2).buffer;
          }, uint8array: function(t2) {
            return l(t2, new Uint8Array(t2.length));
          }, nodebuffer: function(t2) {
            return l(t2, r.allocBuffer(t2.length));
          } }, c.array = { string: f, array: n, arraybuffer: function(t2) {
            return new Uint8Array(t2).buffer;
          }, uint8array: function(t2) {
            return new Uint8Array(t2);
          }, nodebuffer: function(t2) {
            return r.newBufferFrom(t2);
          } }, c.arraybuffer = { string: function(t2) {
            return f(new Uint8Array(t2));
          }, array: function(t2) {
            return d(new Uint8Array(t2), new Array(t2.byteLength));
          }, arraybuffer: n, uint8array: function(t2) {
            return new Uint8Array(t2);
          }, nodebuffer: function(t2) {
            return r.newBufferFrom(new Uint8Array(t2));
          } }, c.uint8array = { string: f, array: function(t2) {
            return d(t2, new Array(t2.length));
          }, arraybuffer: function(t2) {
            return t2.buffer;
          }, uint8array: n, nodebuffer: function(t2) {
            return r.newBufferFrom(t2);
          } }, c.nodebuffer = { string: f, array: function(t2) {
            return d(t2, new Array(t2.length));
          }, arraybuffer: function(t2) {
            return c.nodebuffer.uint8array(t2).buffer;
          }, uint8array: function(t2) {
            return d(t2, new Uint8Array(t2.length));
          }, nodebuffer: n }, a.transformTo = function(t2, e2) {
            if (e2 = e2 || "", !t2) return e2;
            a.checkSupport(t2);
            var r2 = a.getTypeOf(e2);
            return c[r2][t2](e2);
          }, a.resolve = function(t2) {
            for (var e2 = t2.split("/"), r2 = [], i2 = 0; i2 < e2.length; i2++) {
              var n2 = e2[i2];
              "." === n2 || "" === n2 && 0 !== i2 && i2 !== e2.length - 1 || (".." === n2 ? r2.pop() : r2.push(n2));
            }
            return r2.join("/");
          }, a.getTypeOf = function(t2) {
            return "string" == typeof t2 ? "string" : "[object Array]" === Object.prototype.toString.call(t2) ? "array" : o.nodebuffer && r.isBuffer(t2) ? "nodebuffer" : o.uint8array && t2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && t2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
          }, a.checkSupport = function(t2) {
            if (!o[t2.toLowerCase()]) throw new Error(t2 + " is not supported by this platform");
          }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(t2) {
            var e2, r2, i2 = "";
            for (r2 = 0; r2 < (t2 || "").length; r2++) i2 += "\\x" + ((e2 = t2.charCodeAt(r2)) < 16 ? "0" : "") + e2.toString(16).toUpperCase();
            return i2;
          }, a.delay = function(t2, e2, r2) {
            i(function() {
              t2.apply(r2 || null, e2 || []);
            });
          }, a.inherits = function(t2, e2) {
            function r2() {
            }
            r2.prototype = e2.prototype, t2.prototype = new r2();
          }, a.extend = function() {
            var t2, e2, r2 = {};
            for (t2 = 0; t2 < arguments.length; t2++) for (e2 in arguments[t2]) arguments[t2].hasOwnProperty(e2) && void 0 === r2[e2] && (r2[e2] = arguments[t2][e2]);
            return r2;
          }, a.prepareContent = function(r2, t2, i2, n2, s2) {
            return u.Promise.resolve(t2).then(function(i3) {
              return o.blob && (i3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(i3))) && "undefined" != typeof FileReader ? new u.Promise(function(e2, r3) {
                var t3 = new FileReader();
                t3.onload = function(t4) {
                  e2(t4.target.result);
                }, t3.onerror = function(t4) {
                  r3(t4.target.error);
                }, t3.readAsArrayBuffer(i3);
              }) : i3;
            }).then(function(t3) {
              var e2 = a.getTypeOf(t3);
              return e2 ? ("arraybuffer" === e2 ? t3 = a.transformTo("uint8array", t3) : "string" === e2 && (s2 ? t3 = h.decode(t3) : i2 && true !== n2 && (t3 = function(t4) {
                return l(t4, o.uint8array ? new Uint8Array(t4.length) : new Array(t4.length));
              }(t3))), t3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
            });
          };
        }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function(t, e, r) {
          "use strict";
          var i = t("./reader/readerFor"), n = t("./utils"), s = t("./signature"), a = t("./zipEntry"), o = (t("./utf8"), t("./support"));
          function h(t2) {
            this.files = [], this.loadOptions = t2;
          }
          h.prototype = { checkSignature: function(t2) {
            if (!this.reader.readAndCheckSignature(t2)) {
              this.reader.index -= 4;
              var e2 = this.reader.readString(4);
              throw new Error("Corrupted zip or bug: unexpected signature (" + n.pretty(e2) + ", expected " + n.pretty(t2) + ")");
            }
          }, isSignature: function(t2, e2) {
            var r2 = this.reader.index;
            this.reader.setIndex(t2);
            var i2 = this.reader.readString(4) === e2;
            return this.reader.setIndex(r2), i2;
          }, readBlockEndOfCentral: function() {
            this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
            var t2 = this.reader.readData(this.zipCommentLength), e2 = o.uint8array ? "uint8array" : "array", r2 = n.transformTo(e2, t2);
            this.zipComment = this.loadOptions.decodeFileName(r2);
          }, readBlockZip64EndOfCentral: function() {
            this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
            for (var t2, e2, r2, i2 = this.zip64EndOfCentralSize - 44; 0 < i2; ) t2 = this.reader.readInt(2), e2 = this.reader.readInt(4), r2 = this.reader.readData(e2), this.zip64ExtensibleData[t2] = { id: t2, length: e2, value: r2 };
          }, readBlockZip64EndOfCentralLocator: function() {
            if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
          }, readLocalFiles: function() {
            var t2, e2;
            for (t2 = 0; t2 < this.files.length; t2++) e2 = this.files[t2], this.reader.setIndex(e2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), e2.readLocalPart(this.reader), e2.handleUTF8(), e2.processAttributes();
          }, readCentralDir: function() {
            var t2;
            for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (t2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(t2);
            if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          }, readEndOfCentral: function() {
            var t2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
            if (t2 < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
            this.reader.setIndex(t2);
            var e2 = t2;
            if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === n.MAX_VALUE_16BITS || this.diskWithCentralDirStart === n.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === n.MAX_VALUE_16BITS || this.centralDirRecords === n.MAX_VALUE_16BITS || this.centralDirSize === n.MAX_VALUE_32BITS || this.centralDirOffset === n.MAX_VALUE_32BITS) {
              if (this.zip64 = true, (t2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
              if (this.reader.setIndex(t2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
              this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
            }
            var r2 = this.centralDirOffset + this.centralDirSize;
            this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
            var i2 = e2 - r2;
            if (0 < i2) this.isSignature(e2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = i2);
            else if (i2 < 0) throw new Error("Corrupted zip: missing " + Math.abs(i2) + " bytes.");
          }, prepareReader: function(t2) {
            this.reader = i(t2);
          }, load: function(t2) {
            this.prepareReader(t2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
          } }, e.exports = h;
        }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, e, r) {
          "use strict";
          var i = t("./reader/readerFor"), s = t("./utils"), n = t("./compressedObject"), a = t("./crc32"), o = t("./utf8"), h = t("./compressions"), u = t("./support");
          function l(t2, e2) {
            this.options = t2, this.loadOptions = e2;
          }
          l.prototype = { isEncrypted: function() {
            return 1 == (1 & this.bitFlag);
          }, useUTF8: function() {
            return 2048 == (2048 & this.bitFlag);
          }, readLocalPart: function(t2) {
            var e2, r2;
            if (t2.skip(22), this.fileNameLength = t2.readInt(2), r2 = t2.readInt(2), this.fileName = t2.readData(this.fileNameLength), t2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
            if (null === (e2 = function(t3) {
              for (var e3 in h) if (h.hasOwnProperty(e3) && h[e3].magic === t3) return h[e3];
              return null;
            }(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
            this.decompressed = new n(this.compressedSize, this.uncompressedSize, this.crc32, e2, t2.readData(this.compressedSize));
          }, readCentralPart: function(t2) {
            this.versionMadeBy = t2.readInt(2), t2.skip(2), this.bitFlag = t2.readInt(2), this.compressionMethod = t2.readString(2), this.date = t2.readDate(), this.crc32 = t2.readInt(4), this.compressedSize = t2.readInt(4), this.uncompressedSize = t2.readInt(4);
            var e2 = t2.readInt(2);
            if (this.extraFieldsLength = t2.readInt(2), this.fileCommentLength = t2.readInt(2), this.diskNumberStart = t2.readInt(2), this.internalFileAttributes = t2.readInt(2), this.externalFileAttributes = t2.readInt(4), this.localHeaderOffset = t2.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
            t2.skip(e2), this.readExtraFields(t2), this.parseZIP64ExtraField(t2), this.fileComment = t2.readData(this.fileCommentLength);
          }, processAttributes: function() {
            this.unixPermissions = null, this.dosPermissions = null;
            var t2 = this.versionMadeBy >> 8;
            this.dir = !!(16 & this.externalFileAttributes), 0 == t2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == t2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
          }, parseZIP64ExtraField: function(t2) {
            if (this.extraFields[1]) {
              var e2 = i(this.extraFields[1].value);
              this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
            }
          }, readExtraFields: function(t2) {
            var e2, r2, i2, n2 = t2.index + this.extraFieldsLength;
            for (this.extraFields || (this.extraFields = {}); t2.index + 4 < n2; ) e2 = t2.readInt(2), r2 = t2.readInt(2), i2 = t2.readData(r2), this.extraFields[e2] = { id: e2, length: r2, value: i2 };
            t2.setIndex(n2);
          }, handleUTF8: function() {
            var t2 = u.uint8array ? "uint8array" : "array";
            if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
            else {
              var e2 = this.findExtraFieldUnicodePath();
              if (null !== e2) this.fileNameStr = e2;
              else {
                var r2 = s.transformTo(t2, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(r2);
              }
              var i2 = this.findExtraFieldUnicodeComment();
              if (null !== i2) this.fileCommentStr = i2;
              else {
                var n2 = s.transformTo(t2, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(n2);
              }
            }
          }, findExtraFieldUnicodePath: function() {
            var t2 = this.extraFields[28789];
            if (t2) {
              var e2 = i(t2.value);
              return 1 !== e2.readInt(1) ? null : a(this.fileName) !== e2.readInt(4) ? null : o.utf8decode(e2.readData(t2.length - 5));
            }
            return null;
          }, findExtraFieldUnicodeComment: function() {
            var t2 = this.extraFields[25461];
            if (t2) {
              var e2 = i(t2.value);
              return 1 !== e2.readInt(1) ? null : a(this.fileComment) !== e2.readInt(4) ? null : o.utf8decode(e2.readData(t2.length - 5));
            }
            return null;
          } }, e.exports = l;
        }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, e, r) {
          "use strict";
          function i(t2, e2, r2) {
            this.name = t2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = e2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
          }
          var s = t("./stream/StreamHelper"), n = t("./stream/DataWorker"), a = t("./utf8"), o = t("./compressedObject"), h = t("./stream/GenericWorker");
          i.prototype = { internalStream: function(t2) {
            var e2 = null, r2 = "string";
            try {
              if (!t2) throw new Error("No output type specified.");
              var i2 = "string" === (r2 = t2.toLowerCase()) || "text" === r2;
              "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), e2 = this._decompressWorker();
              var n2 = !this._dataBinary;
              n2 && !i2 && (e2 = e2.pipe(new a.Utf8EncodeWorker())), !n2 && i2 && (e2 = e2.pipe(new a.Utf8DecodeWorker()));
            } catch (t3) {
              (e2 = new h("error")).error(t3);
            }
            return new s(e2, r2, "");
          }, async: function(t2, e2) {
            return this.internalStream(t2).accumulate(e2);
          }, nodeStream: function(t2, e2) {
            return this.internalStream(t2 || "nodebuffer").toNodejsStream(e2);
          }, _compressWorker: function(t2, e2) {
            if (this._data instanceof o && this._data.compression.magic === t2.magic) return this._data.getCompressedWorker();
            var r2 = this._decompressWorker();
            return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, t2, e2);
          }, _decompressWorker: function() {
            return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new n(this._data);
          } };
          for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, f = 0; f < u.length; f++) i.prototype[u[f]] = l;
          e.exports = i;
        }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, l, e) {
          (function(e2) {
            "use strict";
            var r, i, t2 = e2.MutationObserver || e2.WebKitMutationObserver;
            if (t2) {
              var n = 0, s = new t2(u), a = e2.document.createTextNode("");
              s.observe(a, { characterData: true }), r = function() {
                a.data = n = ++n % 2;
              };
            } else if (e2.setImmediate || void 0 === e2.MessageChannel) r = "document" in e2 && "onreadystatechange" in e2.document.createElement("script") ? function() {
              var t3 = e2.document.createElement("script");
              t3.onreadystatechange = function() {
                u(), t3.onreadystatechange = null, t3.parentNode.removeChild(t3), t3 = null;
              }, e2.document.documentElement.appendChild(t3);
            } : function() {
              setTimeout(u, 0);
            };
            else {
              var o = new e2.MessageChannel();
              o.port1.onmessage = u, r = function() {
                o.port2.postMessage(0);
              };
            }
            var h = [];
            function u() {
              var t3, e3;
              i = true;
              for (var r2 = h.length; r2; ) {
                for (e3 = h, h = [], t3 = -1; ++t3 < r2; ) e3[t3]();
                r2 = h.length;
              }
              i = false;
            }
            l.exports = function(t3) {
              1 !== h.push(t3) || i || r();
            };
          }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, {}], 37: [function(t, e, r) {
          "use strict";
          var n = t("immediate");
          function u() {
          }
          var l = {}, s = ["REJECTED"], a = ["FULFILLED"], i = ["PENDING"];
          function o(t2) {
            if ("function" != typeof t2) throw new TypeError("resolver must be a function");
            this.state = i, this.queue = [], this.outcome = void 0, t2 !== u && c(this, t2);
          }
          function h(t2, e2, r2) {
            this.promise = t2, "function" == typeof e2 && (this.onFulfilled = e2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
          }
          function f(e2, r2, i2) {
            n(function() {
              var t2;
              try {
                t2 = r2(i2);
              } catch (t3) {
                return l.reject(e2, t3);
              }
              t2 === e2 ? l.reject(e2, new TypeError("Cannot resolve promise with itself")) : l.resolve(e2, t2);
            });
          }
          function d(t2) {
            var e2 = t2 && t2.then;
            if (t2 && ("object" == typeof t2 || "function" == typeof t2) && "function" == typeof e2) return function() {
              e2.apply(t2, arguments);
            };
          }
          function c(e2, t2) {
            var r2 = false;
            function i2(t3) {
              r2 || (r2 = true, l.reject(e2, t3));
            }
            function n2(t3) {
              r2 || (r2 = true, l.resolve(e2, t3));
            }
            var s2 = p(function() {
              t2(n2, i2);
            });
            "error" === s2.status && i2(s2.value);
          }
          function p(t2, e2) {
            var r2 = {};
            try {
              r2.value = t2(e2), r2.status = "success";
            } catch (t3) {
              r2.status = "error", r2.value = t3;
            }
            return r2;
          }
          (e.exports = o).prototype.finally = function(e2) {
            if ("function" != typeof e2) return this;
            var r2 = this.constructor;
            return this.then(function(t2) {
              return r2.resolve(e2()).then(function() {
                return t2;
              });
            }, function(t2) {
              return r2.resolve(e2()).then(function() {
                throw t2;
              });
            });
          }, o.prototype.catch = function(t2) {
            return this.then(null, t2);
          }, o.prototype.then = function(t2, e2) {
            if ("function" != typeof t2 && this.state === a || "function" != typeof e2 && this.state === s) return this;
            var r2 = new this.constructor(u);
            this.state !== i ? f(r2, this.state === a ? t2 : e2, this.outcome) : this.queue.push(new h(r2, t2, e2));
            return r2;
          }, h.prototype.callFulfilled = function(t2) {
            l.resolve(this.promise, t2);
          }, h.prototype.otherCallFulfilled = function(t2) {
            f(this.promise, this.onFulfilled, t2);
          }, h.prototype.callRejected = function(t2) {
            l.reject(this.promise, t2);
          }, h.prototype.otherCallRejected = function(t2) {
            f(this.promise, this.onRejected, t2);
          }, l.resolve = function(t2, e2) {
            var r2 = p(d, e2);
            if ("error" === r2.status) return l.reject(t2, r2.value);
            var i2 = r2.value;
            if (i2) c(t2, i2);
            else {
              t2.state = a, t2.outcome = e2;
              for (var n2 = -1, s2 = t2.queue.length; ++n2 < s2; ) t2.queue[n2].callFulfilled(e2);
            }
            return t2;
          }, l.reject = function(t2, e2) {
            t2.state = s, t2.outcome = e2;
            for (var r2 = -1, i2 = t2.queue.length; ++r2 < i2; ) t2.queue[r2].callRejected(e2);
            return t2;
          }, o.resolve = function(t2) {
            if (t2 instanceof this) return t2;
            return l.resolve(new this(u), t2);
          }, o.reject = function(t2) {
            var e2 = new this(u);
            return l.reject(e2, t2);
          }, o.all = function(t2) {
            var r2 = this;
            if ("[object Array]" !== Object.prototype.toString.call(t2)) return this.reject(new TypeError("must be an array"));
            var i2 = t2.length, n2 = false;
            if (!i2) return this.resolve([]);
            var s2 = new Array(i2), a2 = 0, e2 = -1, o2 = new this(u);
            for (; ++e2 < i2; ) h2(t2[e2], e2);
            return o2;
            function h2(t3, e3) {
              r2.resolve(t3).then(function(t4) {
                s2[e3] = t4, ++a2 !== i2 || n2 || (n2 = true, l.resolve(o2, s2));
              }, function(t4) {
                n2 || (n2 = true, l.reject(o2, t4));
              });
            }
          }, o.race = function(t2) {
            var e2 = this;
            if ("[object Array]" !== Object.prototype.toString.call(t2)) return this.reject(new TypeError("must be an array"));
            var r2 = t2.length, i2 = false;
            if (!r2) return this.resolve([]);
            var n2 = -1, s2 = new this(u);
            for (; ++n2 < r2; ) a2 = t2[n2], e2.resolve(a2).then(function(t3) {
              i2 || (i2 = true, l.resolve(s2, t3));
            }, function(t3) {
              i2 || (i2 = true, l.reject(s2, t3));
            });
            var a2;
            return s2;
          };
        }, { immediate: 36 }], 38: [function(t, e, r) {
          "use strict";
          var i = {};
          (0, t("./lib/utils/common").assign)(i, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), e.exports = i;
        }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, e, r) {
          "use strict";
          var a = t("./zlib/deflate"), o = t("./utils/common"), h = t("./utils/strings"), n = t("./zlib/messages"), s = t("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, d = 0, c = 8;
          function p(t2) {
            if (!(this instanceof p)) return new p(t2);
            this.options = o.assign({ level: f, method: c, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, t2 || {});
            var e2 = this.options;
            e2.raw && 0 < e2.windowBits ? e2.windowBits = -e2.windowBits : e2.gzip && 0 < e2.windowBits && e2.windowBits < 16 && (e2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
            var r2 = a.deflateInit2(this.strm, e2.level, e2.method, e2.windowBits, e2.memLevel, e2.strategy);
            if (r2 !== l) throw new Error(n[r2]);
            if (e2.header && a.deflateSetHeader(this.strm, e2.header), e2.dictionary) {
              var i2;
              if (i2 = "string" == typeof e2.dictionary ? h.string2buf(e2.dictionary) : "[object ArrayBuffer]" === u.call(e2.dictionary) ? new Uint8Array(e2.dictionary) : e2.dictionary, (r2 = a.deflateSetDictionary(this.strm, i2)) !== l) throw new Error(n[r2]);
              this._dict_set = true;
            }
          }
          function i(t2, e2) {
            var r2 = new p(e2);
            if (r2.push(t2, true), r2.err) throw r2.msg || n[r2.err];
            return r2.result;
          }
          p.prototype.push = function(t2, e2) {
            var r2, i2, n2 = this.strm, s2 = this.options.chunkSize;
            if (this.ended) return false;
            i2 = e2 === ~~e2 ? e2 : true === e2 ? 4 : 0, "string" == typeof t2 ? n2.input = h.string2buf(t2) : "[object ArrayBuffer]" === u.call(t2) ? n2.input = new Uint8Array(t2) : n2.input = t2, n2.next_in = 0, n2.avail_in = n2.input.length;
            do {
              if (0 === n2.avail_out && (n2.output = new o.Buf8(s2), n2.next_out = 0, n2.avail_out = s2), 1 !== (r2 = a.deflate(n2, i2)) && r2 !== l) return this.onEnd(r2), !(this.ended = true);
              0 !== n2.avail_out && (0 !== n2.avail_in || 4 !== i2 && 2 !== i2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(n2.output, n2.next_out))) : this.onData(o.shrinkBuf(n2.output, n2.next_out)));
            } while ((0 < n2.avail_in || 0 === n2.avail_out) && 1 !== r2);
            return 4 === i2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== i2 || (this.onEnd(l), !(n2.avail_out = 0));
          }, p.prototype.onData = function(t2) {
            this.chunks.push(t2);
          }, p.prototype.onEnd = function(t2) {
            t2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
          }, r.Deflate = p, r.deflate = i, r.deflateRaw = function(t2, e2) {
            return (e2 = e2 || {}).raw = true, i(t2, e2);
          }, r.gzip = function(t2, e2) {
            return (e2 = e2 || {}).gzip = true, i(t2, e2);
          };
        }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, e, r) {
          "use strict";
          var d = t("./zlib/inflate"), c = t("./utils/common"), p = t("./utils/strings"), m = t("./zlib/constants"), i = t("./zlib/messages"), n = t("./zlib/zstream"), s = t("./zlib/gzheader"), _ = Object.prototype.toString;
          function a(t2) {
            if (!(this instanceof a)) return new a(t2);
            this.options = c.assign({ chunkSize: 16384, windowBits: 0, to: "" }, t2 || {});
            var e2 = this.options;
            e2.raw && 0 <= e2.windowBits && e2.windowBits < 16 && (e2.windowBits = -e2.windowBits, 0 === e2.windowBits && (e2.windowBits = -15)), !(0 <= e2.windowBits && e2.windowBits < 16) || t2 && t2.windowBits || (e2.windowBits += 32), 15 < e2.windowBits && e2.windowBits < 48 && 0 == (15 & e2.windowBits) && (e2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new n(), this.strm.avail_out = 0;
            var r2 = d.inflateInit2(this.strm, e2.windowBits);
            if (r2 !== m.Z_OK) throw new Error(i[r2]);
            this.header = new s(), d.inflateGetHeader(this.strm, this.header);
          }
          function o(t2, e2) {
            var r2 = new a(e2);
            if (r2.push(t2, true), r2.err) throw r2.msg || i[r2.err];
            return r2.result;
          }
          a.prototype.push = function(t2, e2) {
            var r2, i2, n2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
            if (this.ended) return false;
            i2 = e2 === ~~e2 ? e2 : true === e2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof t2 ? h.input = p.binstring2buf(t2) : "[object ArrayBuffer]" === _.call(t2) ? h.input = new Uint8Array(t2) : h.input = t2, h.next_in = 0, h.avail_in = h.input.length;
            do {
              if (0 === h.avail_out && (h.output = new c.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = d.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = d.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK) return this.onEnd(r2), !(this.ended = true);
              h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || i2 !== m.Z_FINISH && i2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (n2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - n2, a2 = p.buf2string(h.output, n2), h.next_out = s2, h.avail_out = u - s2, s2 && c.arraySet(h.output, h.output, n2, s2, 0), this.onData(a2)) : this.onData(c.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
            } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
            return r2 === m.Z_STREAM_END && (i2 = m.Z_FINISH), i2 === m.Z_FINISH ? (r2 = d.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : i2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
          }, a.prototype.onData = function(t2) {
            this.chunks.push(t2);
          }, a.prototype.onEnd = function(t2) {
            t2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = c.flattenChunks(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
          }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(t2, e2) {
            return (e2 = e2 || {}).raw = true, o(t2, e2);
          }, r.ungzip = o;
        }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, e, r) {
          "use strict";
          var i = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
          r.assign = function(t2) {
            for (var e2 = Array.prototype.slice.call(arguments, 1); e2.length; ) {
              var r2 = e2.shift();
              if (r2) {
                if ("object" != typeof r2) throw new TypeError(r2 + "must be non-object");
                for (var i2 in r2) r2.hasOwnProperty(i2) && (t2[i2] = r2[i2]);
              }
            }
            return t2;
          }, r.shrinkBuf = function(t2, e2) {
            return t2.length === e2 ? t2 : t2.subarray ? t2.subarray(0, e2) : (t2.length = e2, t2);
          };
          var n = { arraySet: function(t2, e2, r2, i2, n2) {
            if (e2.subarray && t2.subarray) t2.set(e2.subarray(r2, r2 + i2), n2);
            else for (var s2 = 0; s2 < i2; s2++) t2[n2 + s2] = e2[r2 + s2];
          }, flattenChunks: function(t2) {
            var e2, r2, i2, n2, s2, a;
            for (e2 = i2 = 0, r2 = t2.length; e2 < r2; e2++) i2 += t2[e2].length;
            for (a = new Uint8Array(i2), e2 = n2 = 0, r2 = t2.length; e2 < r2; e2++) s2 = t2[e2], a.set(s2, n2), n2 += s2.length;
            return a;
          } }, s = { arraySet: function(t2, e2, r2, i2, n2) {
            for (var s2 = 0; s2 < i2; s2++) t2[n2 + s2] = e2[r2 + s2];
          }, flattenChunks: function(t2) {
            return [].concat.apply([], t2);
          } };
          r.setTyped = function(t2) {
            t2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, n)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
          }, r.setTyped(i);
        }, {}], 42: [function(t, e, r) {
          "use strict";
          var h = t("./common"), n = true, s = true;
          try {
            String.fromCharCode.apply(null, [0]);
          } catch (t2) {
            n = false;
          }
          try {
            String.fromCharCode.apply(null, new Uint8Array(1));
          } catch (t2) {
            s = false;
          }
          for (var u = new h.Buf8(256), i = 0; i < 256; i++) u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
          function l(t2, e2) {
            if (e2 < 65537 && (t2.subarray && s || !t2.subarray && n)) return String.fromCharCode.apply(null, h.shrinkBuf(t2, e2));
            for (var r2 = "", i2 = 0; i2 < e2; i2++) r2 += String.fromCharCode(t2[i2]);
            return r2;
          }
          u[254] = u[254] = 1, r.string2buf = function(t2) {
            var e2, r2, i2, n2, s2, a = t2.length, o = 0;
            for (n2 = 0; n2 < a; n2++) 55296 == (64512 & (r2 = t2.charCodeAt(n2))) && n2 + 1 < a && 56320 == (64512 & (i2 = t2.charCodeAt(n2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), n2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (e2 = new h.Buf8(o), n2 = s2 = 0; s2 < o; n2++) 55296 == (64512 & (r2 = t2.charCodeAt(n2))) && n2 + 1 < a && 56320 == (64512 & (i2 = t2.charCodeAt(n2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), n2++), r2 < 128 ? e2[s2++] = r2 : (r2 < 2048 ? e2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? e2[s2++] = 224 | r2 >>> 12 : (e2[s2++] = 240 | r2 >>> 18, e2[s2++] = 128 | r2 >>> 12 & 63), e2[s2++] = 128 | r2 >>> 6 & 63), e2[s2++] = 128 | 63 & r2);
            return e2;
          }, r.buf2binstring = function(t2) {
            return l(t2, t2.length);
          }, r.binstring2buf = function(t2) {
            for (var e2 = new h.Buf8(t2.length), r2 = 0, i2 = e2.length; r2 < i2; r2++) e2[r2] = t2.charCodeAt(r2);
            return e2;
          }, r.buf2string = function(t2, e2) {
            var r2, i2, n2, s2, a = e2 || t2.length, o = new Array(2 * a);
            for (r2 = i2 = 0; r2 < a; ) if ((n2 = t2[r2++]) < 128) o[i2++] = n2;
            else if (4 < (s2 = u[n2])) o[i2++] = 65533, r2 += s2 - 1;
            else {
              for (n2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; ) n2 = n2 << 6 | 63 & t2[r2++], s2--;
              1 < s2 ? o[i2++] = 65533 : n2 < 65536 ? o[i2++] = n2 : (n2 -= 65536, o[i2++] = 55296 | n2 >> 10 & 1023, o[i2++] = 56320 | 1023 & n2);
            }
            return l(o, i2);
          }, r.utf8border = function(t2, e2) {
            var r2;
            for ((e2 = e2 || t2.length) > t2.length && (e2 = t2.length), r2 = e2 - 1; 0 <= r2 && 128 == (192 & t2[r2]); ) r2--;
            return r2 < 0 ? e2 : 0 === r2 ? e2 : r2 + u[t2[r2]] > e2 ? r2 : e2;
          };
        }, { "./common": 41 }], 43: [function(t, e, r) {
          "use strict";
          e.exports = function(t2, e2, r2, i) {
            for (var n = 65535 & t2 | 0, s = t2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
              for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (n = n + e2[i++] | 0) | 0, --a; ) ;
              n %= 65521, s %= 65521;
            }
            return n | s << 16 | 0;
          };
        }, {}], 44: [function(t, e, r) {
          "use strict";
          e.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
        }, {}], 45: [function(t, e, r) {
          "use strict";
          var o = function() {
            for (var t2, e2 = [], r2 = 0; r2 < 256; r2++) {
              t2 = r2;
              for (var i = 0; i < 8; i++) t2 = 1 & t2 ? 3988292384 ^ t2 >>> 1 : t2 >>> 1;
              e2[r2] = t2;
            }
            return e2;
          }();
          e.exports = function(t2, e2, r2, i) {
            var n = o, s = i + r2;
            t2 ^= -1;
            for (var a = i; a < s; a++) t2 = t2 >>> 8 ^ n[255 & (t2 ^ e2[a])];
            return -1 ^ t2;
          };
        }, {}], 46: [function(t, e, r) {
          "use strict";
          var h, d = t("../utils/common"), u = t("./trees"), c = t("./adler32"), p = t("./crc32"), i = t("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, n = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
          function R(t2, e2) {
            return t2.msg = i[e2], e2;
          }
          function T(t2) {
            return (t2 << 1) - (4 < t2 ? 9 : 0);
          }
          function D(t2) {
            for (var e2 = t2.length; 0 <= --e2; ) t2[e2] = 0;
          }
          function F(t2) {
            var e2 = t2.state, r2 = e2.pending;
            r2 > t2.avail_out && (r2 = t2.avail_out), 0 !== r2 && (d.arraySet(t2.output, e2.pending_buf, e2.pending_out, r2, t2.next_out), t2.next_out += r2, e2.pending_out += r2, t2.total_out += r2, t2.avail_out -= r2, e2.pending -= r2, 0 === e2.pending && (e2.pending_out = 0));
          }
          function N(t2, e2) {
            u._tr_flush_block(t2, 0 <= t2.block_start ? t2.block_start : -1, t2.strstart - t2.block_start, e2), t2.block_start = t2.strstart, F(t2.strm);
          }
          function U(t2, e2) {
            t2.pending_buf[t2.pending++] = e2;
          }
          function P(t2, e2) {
            t2.pending_buf[t2.pending++] = e2 >>> 8 & 255, t2.pending_buf[t2.pending++] = 255 & e2;
          }
          function L(t2, e2) {
            var r2, i2, n2 = t2.max_chain_length, s2 = t2.strstart, a2 = t2.prev_length, o2 = t2.nice_match, h2 = t2.strstart > t2.w_size - z ? t2.strstart - (t2.w_size - z) : 0, u2 = t2.window, l2 = t2.w_mask, f2 = t2.prev, d2 = t2.strstart + S, c2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
            t2.prev_length >= t2.good_match && (n2 >>= 2), o2 > t2.lookahead && (o2 = t2.lookahead);
            do {
              if (u2[(r2 = e2) + a2] === p2 && u2[r2 + a2 - 1] === c2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
                s2 += 2, r2++;
                do {
                } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < d2);
                if (i2 = S - (d2 - s2), s2 = d2 - S, a2 < i2) {
                  if (t2.match_start = e2, o2 <= (a2 = i2)) break;
                  c2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
                }
              }
            } while ((e2 = f2[e2 & l2]) > h2 && 0 != --n2);
            return a2 <= t2.lookahead ? a2 : t2.lookahead;
          }
          function j(t2) {
            var e2, r2, i2, n2, s2, a2, o2, h2, u2, l2, f2 = t2.w_size;
            do {
              if (n2 = t2.window_size - t2.lookahead - t2.strstart, t2.strstart >= f2 + (f2 - z)) {
                for (d.arraySet(t2.window, t2.window, f2, f2, 0), t2.match_start -= f2, t2.strstart -= f2, t2.block_start -= f2, e2 = r2 = t2.hash_size; i2 = t2.head[--e2], t2.head[e2] = f2 <= i2 ? i2 - f2 : 0, --r2; ) ;
                for (e2 = r2 = f2; i2 = t2.prev[--e2], t2.prev[e2] = f2 <= i2 ? i2 - f2 : 0, --r2; ) ;
                n2 += f2;
              }
              if (0 === t2.strm.avail_in) break;
              if (a2 = t2.strm, o2 = t2.window, h2 = t2.strstart + t2.lookahead, u2 = n2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, d.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = c(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), t2.lookahead += r2, t2.lookahead + t2.insert >= x) for (s2 = t2.strstart - t2.insert, t2.ins_h = t2.window[s2], t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[s2 + 1]) & t2.hash_mask; t2.insert && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[s2 + x - 1]) & t2.hash_mask, t2.prev[s2 & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = s2, s2++, t2.insert--, !(t2.lookahead + t2.insert < x)); ) ;
            } while (t2.lookahead < z && 0 !== t2.strm.avail_in);
          }
          function Z(t2, e2) {
            for (var r2, i2; ; ) {
              if (t2.lookahead < z) {
                if (j(t2), t2.lookahead < z && e2 === l) return A;
                if (0 === t2.lookahead) break;
              }
              if (r2 = 0, t2.lookahead >= x && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), 0 !== r2 && t2.strstart - r2 <= t2.w_size - z && (t2.match_length = L(t2, r2)), t2.match_length >= x) if (i2 = u._tr_tally(t2, t2.strstart - t2.match_start, t2.match_length - x), t2.lookahead -= t2.match_length, t2.match_length <= t2.max_lazy_match && t2.lookahead >= x) {
                for (t2.match_length--; t2.strstart++, t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart, 0 != --t2.match_length; ) ;
                t2.strstart++;
              } else t2.strstart += t2.match_length, t2.match_length = 0, t2.ins_h = t2.window[t2.strstart], t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + 1]) & t2.hash_mask;
              else i2 = u._tr_tally(t2, 0, t2.window[t2.strstart]), t2.lookahead--, t2.strstart++;
              if (i2 && (N(t2, false), 0 === t2.strm.avail_out)) return A;
            }
            return t2.insert = t2.strstart < x - 1 ? t2.strstart : x - 1, e2 === f ? (N(t2, true), 0 === t2.strm.avail_out ? O : B) : t2.last_lit && (N(t2, false), 0 === t2.strm.avail_out) ? A : I;
          }
          function W(t2, e2) {
            for (var r2, i2, n2; ; ) {
              if (t2.lookahead < z) {
                if (j(t2), t2.lookahead < z && e2 === l) return A;
                if (0 === t2.lookahead) break;
              }
              if (r2 = 0, t2.lookahead >= x && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), t2.prev_length = t2.match_length, t2.prev_match = t2.match_start, t2.match_length = x - 1, 0 !== r2 && t2.prev_length < t2.max_lazy_match && t2.strstart - r2 <= t2.w_size - z && (t2.match_length = L(t2, r2), t2.match_length <= 5 && (1 === t2.strategy || t2.match_length === x && 4096 < t2.strstart - t2.match_start) && (t2.match_length = x - 1)), t2.prev_length >= x && t2.match_length <= t2.prev_length) {
                for (n2 = t2.strstart + t2.lookahead - x, i2 = u._tr_tally(t2, t2.strstart - 1 - t2.prev_match, t2.prev_length - x), t2.lookahead -= t2.prev_length - 1, t2.prev_length -= 2; ++t2.strstart <= n2 && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), 0 != --t2.prev_length; ) ;
                if (t2.match_available = 0, t2.match_length = x - 1, t2.strstart++, i2 && (N(t2, false), 0 === t2.strm.avail_out)) return A;
              } else if (t2.match_available) {
                if ((i2 = u._tr_tally(t2, 0, t2.window[t2.strstart - 1])) && N(t2, false), t2.strstart++, t2.lookahead--, 0 === t2.strm.avail_out) return A;
              } else t2.match_available = 1, t2.strstart++, t2.lookahead--;
            }
            return t2.match_available && (i2 = u._tr_tally(t2, 0, t2.window[t2.strstart - 1]), t2.match_available = 0), t2.insert = t2.strstart < x - 1 ? t2.strstart : x - 1, e2 === f ? (N(t2, true), 0 === t2.strm.avail_out ? O : B) : t2.last_lit && (N(t2, false), 0 === t2.strm.avail_out) ? A : I;
          }
          function M(t2, e2, r2, i2, n2) {
            this.good_length = t2, this.max_lazy = e2, this.nice_length = r2, this.max_chain = i2, this.func = n2;
          }
          function H() {
            this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new d.Buf16(2 * w), this.dyn_dtree = new d.Buf16(2 * (2 * a + 1)), this.bl_tree = new d.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new d.Buf16(k + 1), this.heap = new d.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new d.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
          }
          function G(t2) {
            var e2;
            return t2 && t2.state ? (t2.total_in = t2.total_out = 0, t2.data_type = n, (e2 = t2.state).pending = 0, e2.pending_out = 0, e2.wrap < 0 && (e2.wrap = -e2.wrap), e2.status = e2.wrap ? C : E, t2.adler = 2 === e2.wrap ? 0 : 1, e2.last_flush = l, u._tr_init(e2), m) : R(t2, _);
          }
          function K(t2) {
            var e2 = G(t2);
            return e2 === m && function(t3) {
              t3.window_size = 2 * t3.w_size, D(t3.head), t3.max_lazy_match = h[t3.level].max_lazy, t3.good_match = h[t3.level].good_length, t3.nice_match = h[t3.level].nice_length, t3.max_chain_length = h[t3.level].max_chain, t3.strstart = 0, t3.block_start = 0, t3.lookahead = 0, t3.insert = 0, t3.match_length = t3.prev_length = x - 1, t3.match_available = 0, t3.ins_h = 0;
            }(t2.state), e2;
          }
          function Y(t2, e2, r2, i2, n2, s2) {
            if (!t2) return _;
            var a2 = 1;
            if (e2 === g && (e2 = 6), i2 < 0 ? (a2 = 0, i2 = -i2) : 15 < i2 && (a2 = 2, i2 -= 16), n2 < 1 || y < n2 || r2 !== v || i2 < 8 || 15 < i2 || e2 < 0 || 9 < e2 || s2 < 0 || b < s2) return R(t2, _);
            8 === i2 && (i2 = 9);
            var o2 = new H();
            return (t2.state = o2).strm = t2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = i2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = n2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new d.Buf8(2 * o2.w_size), o2.head = new d.Buf16(o2.hash_size), o2.prev = new d.Buf16(o2.w_size), o2.lit_bufsize = 1 << n2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new d.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = e2, o2.strategy = s2, o2.method = r2, K(t2);
          }
          h = [new M(0, 0, 0, 0, function(t2, e2) {
            var r2 = 65535;
            for (r2 > t2.pending_buf_size - 5 && (r2 = t2.pending_buf_size - 5); ; ) {
              if (t2.lookahead <= 1) {
                if (j(t2), 0 === t2.lookahead && e2 === l) return A;
                if (0 === t2.lookahead) break;
              }
              t2.strstart += t2.lookahead, t2.lookahead = 0;
              var i2 = t2.block_start + r2;
              if ((0 === t2.strstart || t2.strstart >= i2) && (t2.lookahead = t2.strstart - i2, t2.strstart = i2, N(t2, false), 0 === t2.strm.avail_out)) return A;
              if (t2.strstart - t2.block_start >= t2.w_size - z && (N(t2, false), 0 === t2.strm.avail_out)) return A;
            }
            return t2.insert = 0, e2 === f ? (N(t2, true), 0 === t2.strm.avail_out ? O : B) : (t2.strstart > t2.block_start && (N(t2, false), t2.strm.avail_out), A);
          }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(t2, e2) {
            return Y(t2, e2, v, 15, 8, 0);
          }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(t2, e2) {
            return t2 && t2.state ? 2 !== t2.state.wrap ? _ : (t2.state.gzhead = e2, m) : _;
          }, r.deflate = function(t2, e2) {
            var r2, i2, n2, s2;
            if (!t2 || !t2.state || 5 < e2 || e2 < 0) return t2 ? R(t2, _) : _;
            if (i2 = t2.state, !t2.output || !t2.input && 0 !== t2.avail_in || 666 === i2.status && e2 !== f) return R(t2, 0 === t2.avail_out ? -5 : _);
            if (i2.strm = t2, r2 = i2.last_flush, i2.last_flush = e2, i2.status === C) if (2 === i2.wrap) t2.adler = 0, U(i2, 31), U(i2, 139), U(i2, 8), i2.gzhead ? (U(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), U(i2, 255 & i2.gzhead.time), U(i2, i2.gzhead.time >> 8 & 255), U(i2, i2.gzhead.time >> 16 & 255), U(i2, i2.gzhead.time >> 24 & 255), U(i2, 9 === i2.level ? 2 : 2 <= i2.strategy || i2.level < 2 ? 4 : 0), U(i2, 255 & i2.gzhead.os), i2.gzhead.extra && i2.gzhead.extra.length && (U(i2, 255 & i2.gzhead.extra.length), U(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = 69) : (U(i2, 0), U(i2, 0), U(i2, 0), U(i2, 0), U(i2, 0), U(i2, 9 === i2.level ? 2 : 2 <= i2.strategy || i2.level < 2 ? 4 : 0), U(i2, 3), i2.status = E);
            else {
              var a2 = v + (i2.w_bits - 8 << 4) << 8;
              a2 |= (2 <= i2.strategy || i2.level < 2 ? 0 : i2.level < 6 ? 1 : 6 === i2.level ? 2 : 3) << 6, 0 !== i2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, i2.status = E, P(i2, a2), 0 !== i2.strstart && (P(i2, t2.adler >>> 16), P(i2, 65535 & t2.adler)), t2.adler = 1;
            }
            if (69 === i2.status) if (i2.gzhead.extra) {
              for (n2 = i2.pending; i2.gzindex < (65535 & i2.gzhead.extra.length) && (i2.pending !== i2.pending_buf_size || (i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), F(t2), n2 = i2.pending, i2.pending !== i2.pending_buf_size)); ) U(i2, 255 & i2.gzhead.extra[i2.gzindex]), i2.gzindex++;
              i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), i2.gzindex === i2.gzhead.extra.length && (i2.gzindex = 0, i2.status = 73);
            } else i2.status = 73;
            if (73 === i2.status) if (i2.gzhead.name) {
              n2 = i2.pending;
              do {
                if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), F(t2), n2 = i2.pending, i2.pending === i2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = i2.gzindex < i2.gzhead.name.length ? 255 & i2.gzhead.name.charCodeAt(i2.gzindex++) : 0, U(i2, s2);
              } while (0 !== s2);
              i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), 0 === s2 && (i2.gzindex = 0, i2.status = 91);
            } else i2.status = 91;
            if (91 === i2.status) if (i2.gzhead.comment) {
              n2 = i2.pending;
              do {
                if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), F(t2), n2 = i2.pending, i2.pending === i2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = i2.gzindex < i2.gzhead.comment.length ? 255 & i2.gzhead.comment.charCodeAt(i2.gzindex++) : 0, U(i2, s2);
              } while (0 !== s2);
              i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), 0 === s2 && (i2.status = 103);
            } else i2.status = 103;
            if (103 === i2.status && (i2.gzhead.hcrc ? (i2.pending + 2 > i2.pending_buf_size && F(t2), i2.pending + 2 <= i2.pending_buf_size && (U(i2, 255 & t2.adler), U(i2, t2.adler >> 8 & 255), t2.adler = 0, i2.status = E)) : i2.status = E), 0 !== i2.pending) {
              if (F(t2), 0 === t2.avail_out) return i2.last_flush = -1, m;
            } else if (0 === t2.avail_in && T(e2) <= T(r2) && e2 !== f) return R(t2, -5);
            if (666 === i2.status && 0 !== t2.avail_in) return R(t2, -5);
            if (0 !== t2.avail_in || 0 !== i2.lookahead || e2 !== l && 666 !== i2.status) {
              var o2 = 2 === i2.strategy ? function(t3, e3) {
                for (var r3; ; ) {
                  if (0 === t3.lookahead && (j(t3), 0 === t3.lookahead)) {
                    if (e3 === l) return A;
                    break;
                  }
                  if (t3.match_length = 0, r3 = u._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++, r3 && (N(t3, false), 0 === t3.strm.avail_out)) return A;
                }
                return t3.insert = 0, e3 === f ? (N(t3, true), 0 === t3.strm.avail_out ? O : B) : t3.last_lit && (N(t3, false), 0 === t3.strm.avail_out) ? A : I;
              }(i2, e2) : 3 === i2.strategy ? function(t3, e3) {
                for (var r3, i3, n3, s3, a3 = t3.window; ; ) {
                  if (t3.lookahead <= S) {
                    if (j(t3), t3.lookahead <= S && e3 === l) return A;
                    if (0 === t3.lookahead) break;
                  }
                  if (t3.match_length = 0, t3.lookahead >= x && 0 < t3.strstart && (i3 = a3[n3 = t3.strstart - 1]) === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3]) {
                    s3 = t3.strstart + S;
                    do {
                    } while (i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && n3 < s3);
                    t3.match_length = S - (s3 - n3), t3.match_length > t3.lookahead && (t3.match_length = t3.lookahead);
                  }
                  if (t3.match_length >= x ? (r3 = u._tr_tally(t3, 1, t3.match_length - x), t3.lookahead -= t3.match_length, t3.strstart += t3.match_length, t3.match_length = 0) : (r3 = u._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++), r3 && (N(t3, false), 0 === t3.strm.avail_out)) return A;
                }
                return t3.insert = 0, e3 === f ? (N(t3, true), 0 === t3.strm.avail_out ? O : B) : t3.last_lit && (N(t3, false), 0 === t3.strm.avail_out) ? A : I;
              }(i2, e2) : h[i2.level].func(i2, e2);
              if (o2 !== O && o2 !== B || (i2.status = 666), o2 === A || o2 === O) return 0 === t2.avail_out && (i2.last_flush = -1), m;
              if (o2 === I && (1 === e2 ? u._tr_align(i2) : 5 !== e2 && (u._tr_stored_block(i2, 0, 0, false), 3 === e2 && (D(i2.head), 0 === i2.lookahead && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), F(t2), 0 === t2.avail_out)) return i2.last_flush = -1, m;
            }
            return e2 !== f ? m : i2.wrap <= 0 ? 1 : (2 === i2.wrap ? (U(i2, 255 & t2.adler), U(i2, t2.adler >> 8 & 255), U(i2, t2.adler >> 16 & 255), U(i2, t2.adler >> 24 & 255), U(i2, 255 & t2.total_in), U(i2, t2.total_in >> 8 & 255), U(i2, t2.total_in >> 16 & 255), U(i2, t2.total_in >> 24 & 255)) : (P(i2, t2.adler >>> 16), P(i2, 65535 & t2.adler)), F(t2), 0 < i2.wrap && (i2.wrap = -i2.wrap), 0 !== i2.pending ? m : 1);
          }, r.deflateEnd = function(t2) {
            var e2;
            return t2 && t2.state ? (e2 = t2.state.status) !== C && 69 !== e2 && 73 !== e2 && 91 !== e2 && 103 !== e2 && e2 !== E && 666 !== e2 ? R(t2, _) : (t2.state = null, e2 === E ? R(t2, -3) : m) : _;
          }, r.deflateSetDictionary = function(t2, e2) {
            var r2, i2, n2, s2, a2, o2, h2, u2, l2 = e2.length;
            if (!t2 || !t2.state) return _;
            if (2 === (s2 = (r2 = t2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead) return _;
            for (1 === s2 && (t2.adler = c(t2.adler, e2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new d.Buf8(r2.w_size), d.arraySet(u2, e2, l2 - r2.w_size, r2.w_size, 0), e2 = u2, l2 = r2.w_size), a2 = t2.avail_in, o2 = t2.next_in, h2 = t2.input, t2.avail_in = l2, t2.next_in = 0, t2.input = e2, j(r2); r2.lookahead >= x; ) {
              for (i2 = r2.strstart, n2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[i2 + x - 1]) & r2.hash_mask, r2.prev[i2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = i2, i2++, --n2; ) ;
              r2.strstart = i2, r2.lookahead = x - 1, j(r2);
            }
            return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, t2.next_in = o2, t2.input = h2, t2.avail_in = a2, r2.wrap = s2, m;
          }, r.deflateInfo = "pako deflate (from Nodeca project)";
        }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, e, r) {
          "use strict";
          e.exports = function() {
            this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
          };
        }, {}], 48: [function(t, e, r) {
          "use strict";
          e.exports = function(t2, e2) {
            var r2, i, n, s, a, o, h, u, l, f, d, c, p, m, _, g, b, v, y, w, k, x, S, z, C;
            r2 = t2.state, i = t2.next_in, z = t2.input, n = i + (t2.avail_in - 5), s = t2.next_out, C = t2.output, a = s - (e2 - t2.avail_out), o = s + (t2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, d = r2.window, c = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
            t: do {
              p < 15 && (c += z[i++] << p, p += 8, c += z[i++] << p, p += 8), v = m[c & g];
              e: for (; ; ) {
                if (c >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v;
                else {
                  if (!(16 & y)) {
                    if (0 == (64 & y)) {
                      v = m[(65535 & v) + (c & (1 << y) - 1)];
                      continue e;
                    }
                    if (32 & y) {
                      r2.mode = 12;
                      break t;
                    }
                    t2.msg = "invalid literal/length code", r2.mode = 30;
                    break t;
                  }
                  w = 65535 & v, (y &= 15) && (p < y && (c += z[i++] << p, p += 8), w += c & (1 << y) - 1, c >>>= y, p -= y), p < 15 && (c += z[i++] << p, p += 8, c += z[i++] << p, p += 8), v = _[c & b];
                  r: for (; ; ) {
                    if (c >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                      if (0 == (64 & y)) {
                        v = _[(65535 & v) + (c & (1 << y) - 1)];
                        continue r;
                      }
                      t2.msg = "invalid distance code", r2.mode = 30;
                      break t;
                    }
                    if (k = 65535 & v, p < (y &= 15) && (c += z[i++] << p, (p += 8) < y && (c += z[i++] << p, p += 8)), h < (k += c & (1 << y) - 1)) {
                      t2.msg = "invalid distance too far back", r2.mode = 30;
                      break t;
                    }
                    if (c >>>= y, p -= y, (y = s - a) < k) {
                      if (l < (y = k - y) && r2.sane) {
                        t2.msg = "invalid distance too far back", r2.mode = 30;
                        break t;
                      }
                      if (S = d, (x = 0) === f) {
                        if (x += u - y, y < w) {
                          for (w -= y; C[s++] = d[x++], --y; ) ;
                          x = s - k, S = C;
                        }
                      } else if (f < y) {
                        if (x += u + f - y, (y -= f) < w) {
                          for (w -= y; C[s++] = d[x++], --y; ) ;
                          if (x = 0, f < w) {
                            for (w -= y = f; C[s++] = d[x++], --y; ) ;
                            x = s - k, S = C;
                          }
                        }
                      } else if (x += f - y, y < w) {
                        for (w -= y; C[s++] = d[x++], --y; ) ;
                        x = s - k, S = C;
                      }
                      for (; 2 < w; ) C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                      w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                    } else {
                      for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); ) ;
                      w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                    }
                    break;
                  }
                }
                break;
              }
            } while (i < n && s < o);
            i -= w = p >> 3, c &= (1 << (p -= w << 3)) - 1, t2.next_in = i, t2.next_out = s, t2.avail_in = i < n ? n - i + 5 : 5 - (i - n), t2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = c, r2.bits = p;
          };
        }, {}], 49: [function(t, e, r) {
          "use strict";
          var I = t("../utils/common"), O = t("./adler32"), B = t("./crc32"), R = t("./inffast"), T = t("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, i = 852, n = 592;
          function L(t2) {
            return (t2 >>> 24 & 255) + (t2 >>> 8 & 65280) + ((65280 & t2) << 8) + ((255 & t2) << 24);
          }
          function s() {
            this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
          }
          function a(t2) {
            var e2;
            return t2 && t2.state ? (e2 = t2.state, t2.total_in = t2.total_out = e2.total = 0, t2.msg = "", e2.wrap && (t2.adler = 1 & e2.wrap), e2.mode = P, e2.last = 0, e2.havedict = 0, e2.dmax = 32768, e2.head = null, e2.hold = 0, e2.bits = 0, e2.lencode = e2.lendyn = new I.Buf32(i), e2.distcode = e2.distdyn = new I.Buf32(n), e2.sane = 1, e2.back = -1, N) : U;
          }
          function o(t2) {
            var e2;
            return t2 && t2.state ? ((e2 = t2.state).wsize = 0, e2.whave = 0, e2.wnext = 0, a(t2)) : U;
          }
          function h(t2, e2) {
            var r2, i2;
            return t2 && t2.state ? (i2 = t2.state, e2 < 0 ? (r2 = 0, e2 = -e2) : (r2 = 1 + (e2 >> 4), e2 < 48 && (e2 &= 15)), e2 && (e2 < 8 || 15 < e2) ? U : (null !== i2.window && i2.wbits !== e2 && (i2.window = null), i2.wrap = r2, i2.wbits = e2, o(t2))) : U;
          }
          function u(t2, e2) {
            var r2, i2;
            return t2 ? (i2 = new s(), (t2.state = i2).window = null, (r2 = h(t2, e2)) !== N && (t2.state = null), r2) : U;
          }
          var l, f, d = true;
          function j(t2) {
            if (d) {
              var e2;
              for (l = new I.Buf32(512), f = new I.Buf32(32), e2 = 0; e2 < 144; ) t2.lens[e2++] = 8;
              for (; e2 < 256; ) t2.lens[e2++] = 9;
              for (; e2 < 280; ) t2.lens[e2++] = 7;
              for (; e2 < 288; ) t2.lens[e2++] = 8;
              for (T(D, t2.lens, 0, 288, l, 0, t2.work, { bits: 9 }), e2 = 0; e2 < 32; ) t2.lens[e2++] = 5;
              T(F, t2.lens, 0, 32, f, 0, t2.work, { bits: 5 }), d = false;
            }
            t2.lencode = l, t2.lenbits = 9, t2.distcode = f, t2.distbits = 5;
          }
          function Z(t2, e2, r2, i2) {
            var n2, s2 = t2.state;
            return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), i2 >= s2.wsize ? (I.arraySet(s2.window, e2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (i2 < (n2 = s2.wsize - s2.wnext) && (n2 = i2), I.arraySet(s2.window, e2, r2 - i2, n2, s2.wnext), (i2 -= n2) ? (I.arraySet(s2.window, e2, r2 - i2, i2, 0), s2.wnext = i2, s2.whave = s2.wsize) : (s2.wnext += n2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += n2))), 0;
          }
          r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(t2) {
            return u(t2, 15);
          }, r.inflateInit2 = u, r.inflate = function(t2, e2) {
            var r2, i2, n2, s2, a2, o2, h2, u2, l2, f2, d2, c, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
            if (!t2 || !t2.state || !t2.output || !t2.input && 0 !== t2.avail_in) return U;
            12 === (r2 = t2.state).mode && (r2.mode = 13), a2 = t2.next_out, n2 = t2.output, h2 = t2.avail_out, s2 = t2.next_in, i2 = t2.input, o2 = t2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, d2 = h2, x = N;
            t: for (; ; ) switch (r2.mode) {
              case P:
                if (0 === r2.wrap) {
                  r2.mode = 13;
                  break;
                }
                for (; l2 < 16; ) {
                  if (0 === o2) break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                if (2 & r2.wrap && 35615 === u2) {
                  E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                  break;
                }
                if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                  t2.msg = "incorrect header check", r2.mode = 30;
                  break;
                }
                if (8 != (15 & u2)) {
                  t2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits) r2.wbits = k;
                else if (k > r2.wbits) {
                  t2.msg = "invalid window size", r2.mode = 30;
                  break;
                }
                r2.dmax = 1 << k, t2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                break;
              case 2:
                for (; l2 < 16; ) {
                  if (0 === o2) break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                if (r2.flags = u2, 8 != (255 & r2.flags)) {
                  t2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (57344 & r2.flags) {
                  t2.msg = "unknown header flags set", r2.mode = 30;
                  break;
                }
                r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
              case 3:
                for (; l2 < 32; ) {
                  if (0 === o2) break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
              case 4:
                for (; l2 < 16; ) {
                  if (0 === o2) break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
              case 5:
                if (1024 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (0 === o2) break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                } else r2.head && (r2.head.extra = null);
                r2.mode = 6;
              case 6:
                if (1024 & r2.flags && (o2 < (c = r2.length) && (c = o2), c && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, i2, s2, c, k)), 512 & r2.flags && (r2.check = B(r2.check, i2, c, s2)), o2 -= c, s2 += c, r2.length -= c), r2.length)) break t;
                r2.length = 0, r2.mode = 7;
              case 7:
                if (2048 & r2.flags) {
                  if (0 === o2) break t;
                  for (c = 0; k = i2[s2 + c++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && c < o2; ) ;
                  if (512 & r2.flags && (r2.check = B(r2.check, i2, c, s2)), o2 -= c, s2 += c, k) break t;
                } else r2.head && (r2.head.name = null);
                r2.length = 0, r2.mode = 8;
              case 8:
                if (4096 & r2.flags) {
                  if (0 === o2) break t;
                  for (c = 0; k = i2[s2 + c++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && c < o2; ) ;
                  if (512 & r2.flags && (r2.check = B(r2.check, i2, c, s2)), o2 -= c, s2 += c, k) break t;
                } else r2.head && (r2.head.comment = null);
                r2.mode = 9;
              case 9:
                if (512 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (0 === o2) break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (65535 & r2.check)) {
                    t2.msg = "header crc mismatch", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), t2.adler = r2.check = 0, r2.mode = 12;
                break;
              case 10:
                for (; l2 < 32; ) {
                  if (0 === o2) break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                t2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
              case 11:
                if (0 === r2.havedict) return t2.next_out = a2, t2.avail_out = h2, t2.next_in = s2, t2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                t2.adler = r2.check = 1, r2.mode = 12;
              case 12:
                if (5 === e2 || 6 === e2) break t;
              case 13:
                if (r2.last) {
                  u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                  break;
                }
                for (; l2 < 3; ) {
                  if (0 === o2) break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                  case 0:
                    r2.mode = 14;
                    break;
                  case 1:
                    if (j(r2), r2.mode = 20, 6 !== e2) break;
                    u2 >>>= 2, l2 -= 2;
                    break t;
                  case 2:
                    r2.mode = 17;
                    break;
                  case 3:
                    t2.msg = "invalid block type", r2.mode = 30;
                }
                u2 >>>= 2, l2 -= 2;
                break;
              case 14:
                for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                  if (0 === o2) break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                  t2.msg = "invalid stored block lengths", r2.mode = 30;
                  break;
                }
                if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === e2) break t;
              case 15:
                r2.mode = 16;
              case 16:
                if (c = r2.length) {
                  if (o2 < c && (c = o2), h2 < c && (c = h2), 0 === c) break t;
                  I.arraySet(n2, i2, s2, c, a2), o2 -= c, s2 += c, h2 -= c, a2 += c, r2.length -= c;
                  break;
                }
                r2.mode = 12;
                break;
              case 17:
                for (; l2 < 14; ) {
                  if (0 === o2) break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                  t2.msg = "too many length or distance symbols", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 18;
              case 18:
                for (; r2.have < r2.ncode; ) {
                  for (; l2 < 3; ) {
                    if (0 === o2) break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                }
                for (; r2.have < 19; ) r2.lens[A[r2.have++]] = 0;
                if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  t2.msg = "invalid code lengths set", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 19;
              case 19:
                for (; r2.have < r2.nlen + r2.ndist; ) {
                  for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2) break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  if (b < 16) u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                  else {
                    if (16 === b) {
                      for (z = _ + 2; l2 < z; ) {
                        if (0 === o2) break t;
                        o2--, u2 += i2[s2++] << l2, l2 += 8;
                      }
                      if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                        t2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      k = r2.lens[r2.have - 1], c = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                    } else if (17 === b) {
                      for (z = _ + 3; l2 < z; ) {
                        if (0 === o2) break t;
                        o2--, u2 += i2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, c = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                    } else {
                      for (z = _ + 7; l2 < z; ) {
                        if (0 === o2) break t;
                        o2--, u2 += i2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, c = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                    }
                    if (r2.have + c > r2.nlen + r2.ndist) {
                      t2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    for (; c--; ) r2.lens[r2.have++] = k;
                  }
                }
                if (30 === r2.mode) break;
                if (0 === r2.lens[256]) {
                  t2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                  break;
                }
                if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  t2.msg = "invalid literal/lengths set", r2.mode = 30;
                  break;
                }
                if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                  t2.msg = "invalid distances set", r2.mode = 30;
                  break;
                }
                if (r2.mode = 20, 6 === e2) break t;
              case 20:
                r2.mode = 21;
              case 21:
                if (6 <= o2 && 258 <= h2) {
                  t2.next_out = a2, t2.avail_out = h2, t2.next_in = s2, t2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(t2, d2), a2 = t2.next_out, n2 = t2.output, h2 = t2.avail_out, s2 = t2.next_in, i2 = t2.input, o2 = t2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                  break;
                }
                for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                if (g && 0 == (240 & g)) {
                  for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (0 === o2) break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                  r2.mode = 26;
                  break;
                }
                if (32 & g) {
                  r2.back = -1, r2.mode = 12;
                  break;
                }
                if (64 & g) {
                  t2.msg = "invalid literal/length code", r2.mode = 30;
                  break;
                }
                r2.extra = 15 & g, r2.mode = 22;
              case 22:
                if (r2.extra) {
                  for (z = r2.extra; l2 < z; ) {
                    if (0 === o2) break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                r2.was = r2.length, r2.mode = 23;
              case 23:
                for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break t;
                  o2--, u2 += i2[s2++] << l2, l2 += 8;
                }
                if (0 == (240 & g)) {
                  for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (0 === o2) break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                  t2.msg = "invalid distance code", r2.mode = 30;
                  break;
                }
                r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
              case 24:
                if (r2.extra) {
                  for (z = r2.extra; l2 < z; ) {
                    if (0 === o2) break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                if (r2.offset > r2.dmax) {
                  t2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                r2.mode = 25;
              case 25:
                if (0 === h2) break t;
                if (c = d2 - h2, r2.offset > c) {
                  if ((c = r2.offset - c) > r2.whave && r2.sane) {
                    t2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  p = c > r2.wnext ? (c -= r2.wnext, r2.wsize - c) : r2.wnext - c, c > r2.length && (c = r2.length), m = r2.window;
                } else m = n2, p = a2 - r2.offset, c = r2.length;
                for (h2 < c && (c = h2), h2 -= c, r2.length -= c; n2[a2++] = m[p++], --c; ) ;
                0 === r2.length && (r2.mode = 21);
                break;
              case 26:
                if (0 === h2) break t;
                n2[a2++] = r2.length, h2--, r2.mode = 21;
                break;
              case 27:
                if (r2.wrap) {
                  for (; l2 < 32; ) {
                    if (0 === o2) break t;
                    o2--, u2 |= i2[s2++] << l2, l2 += 8;
                  }
                  if (d2 -= h2, t2.total_out += d2, r2.total += d2, d2 && (t2.adler = r2.check = r2.flags ? B(r2.check, n2, d2, a2 - d2) : O(r2.check, n2, d2, a2 - d2)), d2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                    t2.msg = "incorrect data check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 28;
              case 28:
                if (r2.wrap && r2.flags) {
                  for (; l2 < 32; ) {
                    if (0 === o2) break t;
                    o2--, u2 += i2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (4294967295 & r2.total)) {
                    t2.msg = "incorrect length check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 29;
              case 29:
                x = 1;
                break t;
              case 30:
                x = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return U;
            }
            return t2.next_out = a2, t2.avail_out = h2, t2.next_in = s2, t2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || d2 !== t2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== e2)) && Z(t2, t2.output, t2.next_out, d2 - t2.avail_out) ? (r2.mode = 31, -4) : (f2 -= t2.avail_in, d2 -= t2.avail_out, t2.total_in += f2, t2.total_out += d2, r2.total += d2, r2.wrap && d2 && (t2.adler = r2.check = r2.flags ? B(r2.check, n2, d2, t2.next_out - d2) : O(r2.check, n2, d2, t2.next_out - d2)), t2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === d2 || 4 === e2) && x === N && (x = -5), x);
          }, r.inflateEnd = function(t2) {
            if (!t2 || !t2.state) return U;
            var e2 = t2.state;
            return e2.window && (e2.window = null), t2.state = null, N;
          }, r.inflateGetHeader = function(t2, e2) {
            var r2;
            return t2 && t2.state ? 0 == (2 & (r2 = t2.state).wrap) ? U : ((r2.head = e2).done = false, N) : U;
          }, r.inflateSetDictionary = function(t2, e2) {
            var r2, i2 = e2.length;
            return t2 && t2.state ? 0 !== (r2 = t2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, e2, i2, 0) !== r2.check ? -3 : Z(t2, e2, i2, i2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
          }, r.inflateInfo = "pako inflate (from Nodeca project)";
        }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, e, r) {
          "use strict";
          var D = t("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
          e.exports = function(t2, e2, r2, i, n, s, a, o) {
            var h, u, l, f, d, c, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
            for (b = 0; b <= 15; b++) O[b] = 0;
            for (v = 0; v < i; v++) O[e2[r2 + v]]++;
            for (k = g, w = 15; 1 <= w && 0 === O[w]; w--) ;
            if (w < k && (k = w), 0 === w) return n[s++] = 20971520, n[s++] = 20971520, o.bits = 1, 0;
            for (y = 1; y < w && 0 === O[y]; y++) ;
            for (k < y && (k = y), b = z = 1; b <= 15; b++) if (z <<= 1, (z -= O[b]) < 0) return -1;
            if (0 < z && (0 === t2 || 1 !== w)) return -1;
            for (B[1] = 0, b = 1; b < 15; b++) B[b + 1] = B[b] + O[b];
            for (v = 0; v < i; v++) 0 !== e2[r2 + v] && (a[B[e2[r2 + v]]++] = v);
            if (c = 0 === t2 ? (A = R = a, 19) : 1 === t2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, d = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === t2 && 852 < C || 2 === t2 && 592 < C) return 1;
            for (; ; ) {
              for (p = b - S, _ = a[v] < c ? (m = 0, a[v]) : a[v] > c ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; n[d + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; ) ;
              for (h = 1 << b - 1; E & h; ) h >>= 1;
              if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
                if (b === w) break;
                b = e2[r2 + a[v]];
              }
              if (k < b && (E & f) !== l) {
                for (0 === S && (S = k), d += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); ) x++, z <<= 1;
                if (C += 1 << x, 1 === t2 && 852 < C || 2 === t2 && 592 < C) return 1;
                n[l = E & f] = k << 24 | x << 16 | d - s | 0;
              }
            }
            return 0 !== E && (n[d + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
          };
        }, { "../utils/common": 41 }], 51: [function(t, e, r) {
          "use strict";
          e.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
        }, {}], 52: [function(t, e, r) {
          "use strict";
          var n = t("../utils/common"), o = 0, h = 1;
          function i(t2) {
            for (var e2 = t2.length; 0 <= --e2; ) t2[e2] = 0;
          }
          var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, d = 19, _ = 2 * l + 1, g = 15, c = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
          i(z);
          var C = new Array(2 * f);
          i(C);
          var E = new Array(512);
          i(E);
          var A = new Array(256);
          i(A);
          var I = new Array(a);
          i(I);
          var O, B, R, T = new Array(f);
          function D(t2, e2, r2, i2, n2) {
            this.static_tree = t2, this.extra_bits = e2, this.extra_base = r2, this.elems = i2, this.max_length = n2, this.has_stree = t2 && t2.length;
          }
          function F(t2, e2) {
            this.dyn_tree = t2, this.max_code = 0, this.stat_desc = e2;
          }
          function N(t2) {
            return t2 < 256 ? E[t2] : E[256 + (t2 >>> 7)];
          }
          function U(t2, e2) {
            t2.pending_buf[t2.pending++] = 255 & e2, t2.pending_buf[t2.pending++] = e2 >>> 8 & 255;
          }
          function P(t2, e2, r2) {
            t2.bi_valid > c - r2 ? (t2.bi_buf |= e2 << t2.bi_valid & 65535, U(t2, t2.bi_buf), t2.bi_buf = e2 >> c - t2.bi_valid, t2.bi_valid += r2 - c) : (t2.bi_buf |= e2 << t2.bi_valid & 65535, t2.bi_valid += r2);
          }
          function L(t2, e2, r2) {
            P(t2, r2[2 * e2], r2[2 * e2 + 1]);
          }
          function j(t2, e2) {
            for (var r2 = 0; r2 |= 1 & t2, t2 >>>= 1, r2 <<= 1, 0 < --e2; ) ;
            return r2 >>> 1;
          }
          function Z(t2, e2, r2) {
            var i2, n2, s2 = new Array(g + 1), a2 = 0;
            for (i2 = 1; i2 <= g; i2++) s2[i2] = a2 = a2 + r2[i2 - 1] << 1;
            for (n2 = 0; n2 <= e2; n2++) {
              var o2 = t2[2 * n2 + 1];
              0 !== o2 && (t2[2 * n2] = j(s2[o2]++, o2));
            }
          }
          function W(t2) {
            var e2;
            for (e2 = 0; e2 < l; e2++) t2.dyn_ltree[2 * e2] = 0;
            for (e2 = 0; e2 < f; e2++) t2.dyn_dtree[2 * e2] = 0;
            for (e2 = 0; e2 < d; e2++) t2.bl_tree[2 * e2] = 0;
            t2.dyn_ltree[2 * m] = 1, t2.opt_len = t2.static_len = 0, t2.last_lit = t2.matches = 0;
          }
          function M(t2) {
            8 < t2.bi_valid ? U(t2, t2.bi_buf) : 0 < t2.bi_valid && (t2.pending_buf[t2.pending++] = t2.bi_buf), t2.bi_buf = 0, t2.bi_valid = 0;
          }
          function H(t2, e2, r2, i2) {
            var n2 = 2 * e2, s2 = 2 * r2;
            return t2[n2] < t2[s2] || t2[n2] === t2[s2] && i2[e2] <= i2[r2];
          }
          function G(t2, e2, r2) {
            for (var i2 = t2.heap[r2], n2 = r2 << 1; n2 <= t2.heap_len && (n2 < t2.heap_len && H(e2, t2.heap[n2 + 1], t2.heap[n2], t2.depth) && n2++, !H(e2, i2, t2.heap[n2], t2.depth)); ) t2.heap[r2] = t2.heap[n2], r2 = n2, n2 <<= 1;
            t2.heap[r2] = i2;
          }
          function K(t2, e2, r2) {
            var i2, n2, s2, a2, o2 = 0;
            if (0 !== t2.last_lit) for (; i2 = t2.pending_buf[t2.d_buf + 2 * o2] << 8 | t2.pending_buf[t2.d_buf + 2 * o2 + 1], n2 = t2.pending_buf[t2.l_buf + o2], o2++, 0 === i2 ? L(t2, n2, e2) : (L(t2, (s2 = A[n2]) + u + 1, e2), 0 !== (a2 = w[s2]) && P(t2, n2 -= I[s2], a2), L(t2, s2 = N(--i2), r2), 0 !== (a2 = k[s2]) && P(t2, i2 -= T[s2], a2)), o2 < t2.last_lit; ) ;
            L(t2, m, e2);
          }
          function Y(t2, e2) {
            var r2, i2, n2, s2 = e2.dyn_tree, a2 = e2.stat_desc.static_tree, o2 = e2.stat_desc.has_stree, h2 = e2.stat_desc.elems, u2 = -1;
            for (t2.heap_len = 0, t2.heap_max = _, r2 = 0; r2 < h2; r2++) 0 !== s2[2 * r2] ? (t2.heap[++t2.heap_len] = u2 = r2, t2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
            for (; t2.heap_len < 2; ) s2[2 * (n2 = t2.heap[++t2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, t2.depth[n2] = 0, t2.opt_len--, o2 && (t2.static_len -= a2[2 * n2 + 1]);
            for (e2.max_code = u2, r2 = t2.heap_len >> 1; 1 <= r2; r2--) G(t2, s2, r2);
            for (n2 = h2; r2 = t2.heap[1], t2.heap[1] = t2.heap[t2.heap_len--], G(t2, s2, 1), i2 = t2.heap[1], t2.heap[--t2.heap_max] = r2, t2.heap[--t2.heap_max] = i2, s2[2 * n2] = s2[2 * r2] + s2[2 * i2], t2.depth[n2] = (t2.depth[r2] >= t2.depth[i2] ? t2.depth[r2] : t2.depth[i2]) + 1, s2[2 * r2 + 1] = s2[2 * i2 + 1] = n2, t2.heap[1] = n2++, G(t2, s2, 1), 2 <= t2.heap_len; ) ;
            t2.heap[--t2.heap_max] = t2.heap[1], function(t3, e3) {
              var r3, i3, n3, s3, a3, o3, h3 = e3.dyn_tree, u3 = e3.max_code, l2 = e3.stat_desc.static_tree, f2 = e3.stat_desc.has_stree, d2 = e3.stat_desc.extra_bits, c2 = e3.stat_desc.extra_base, p2 = e3.stat_desc.max_length, m2 = 0;
              for (s3 = 0; s3 <= g; s3++) t3.bl_count[s3] = 0;
              for (h3[2 * t3.heap[t3.heap_max] + 1] = 0, r3 = t3.heap_max + 1; r3 < _; r3++) p2 < (s3 = h3[2 * h3[2 * (i3 = t3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * i3 + 1] = s3, u3 < i3 || (t3.bl_count[s3]++, a3 = 0, c2 <= i3 && (a3 = d2[i3 - c2]), o3 = h3[2 * i3], t3.opt_len += o3 * (s3 + a3), f2 && (t3.static_len += o3 * (l2[2 * i3 + 1] + a3)));
              if (0 !== m2) {
                do {
                  for (s3 = p2 - 1; 0 === t3.bl_count[s3]; ) s3--;
                  t3.bl_count[s3]--, t3.bl_count[s3 + 1] += 2, t3.bl_count[p2]--, m2 -= 2;
                } while (0 < m2);
                for (s3 = p2; 0 !== s3; s3--) for (i3 = t3.bl_count[s3]; 0 !== i3; ) u3 < (n3 = t3.heap[--r3]) || (h3[2 * n3 + 1] !== s3 && (t3.opt_len += (s3 - h3[2 * n3 + 1]) * h3[2 * n3], h3[2 * n3 + 1] = s3), i3--);
              }
            }(t2, e2), Z(s2, u2, t2.bl_count);
          }
          function X(t2, e2, r2) {
            var i2, n2, s2 = -1, a2 = e2[1], o2 = 0, h2 = 7, u2 = 4;
            for (0 === a2 && (h2 = 138, u2 = 3), e2[2 * (r2 + 1) + 1] = 65535, i2 = 0; i2 <= r2; i2++) n2 = a2, a2 = e2[2 * (i2 + 1) + 1], ++o2 < h2 && n2 === a2 || (o2 < u2 ? t2.bl_tree[2 * n2] += o2 : 0 !== n2 ? (n2 !== s2 && t2.bl_tree[2 * n2]++, t2.bl_tree[2 * b]++) : o2 <= 10 ? t2.bl_tree[2 * v]++ : t2.bl_tree[2 * y]++, s2 = n2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : n2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
          }
          function V(t2, e2, r2) {
            var i2, n2, s2 = -1, a2 = e2[1], o2 = 0, h2 = 7, u2 = 4;
            for (0 === a2 && (h2 = 138, u2 = 3), i2 = 0; i2 <= r2; i2++) if (n2 = a2, a2 = e2[2 * (i2 + 1) + 1], !(++o2 < h2 && n2 === a2)) {
              if (o2 < u2) for (; L(t2, n2, t2.bl_tree), 0 != --o2; ) ;
              else 0 !== n2 ? (n2 !== s2 && (L(t2, n2, t2.bl_tree), o2--), L(t2, b, t2.bl_tree), P(t2, o2 - 3, 2)) : o2 <= 10 ? (L(t2, v, t2.bl_tree), P(t2, o2 - 3, 3)) : (L(t2, y, t2.bl_tree), P(t2, o2 - 11, 7));
              s2 = n2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : n2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
          }
          i(T);
          var q = false;
          function J(t2, e2, r2, i2) {
            P(t2, (s << 1) + (i2 ? 1 : 0), 3), function(t3, e3, r3, i3) {
              M(t3), i3 && (U(t3, r3), U(t3, ~r3)), n.arraySet(t3.pending_buf, t3.window, e3, r3, t3.pending), t3.pending += r3;
            }(t2, e2, r2, true);
          }
          r._tr_init = function(t2) {
            q || (function() {
              var t3, e2, r2, i2, n2, s2 = new Array(g + 1);
              for (i2 = r2 = 0; i2 < a - 1; i2++) for (I[i2] = r2, t3 = 0; t3 < 1 << w[i2]; t3++) A[r2++] = i2;
              for (A[r2 - 1] = i2, i2 = n2 = 0; i2 < 16; i2++) for (T[i2] = n2, t3 = 0; t3 < 1 << k[i2]; t3++) E[n2++] = i2;
              for (n2 >>= 7; i2 < f; i2++) for (T[i2] = n2 << 7, t3 = 0; t3 < 1 << k[i2] - 7; t3++) E[256 + n2++] = i2;
              for (e2 = 0; e2 <= g; e2++) s2[e2] = 0;
              for (t3 = 0; t3 <= 143; ) z[2 * t3 + 1] = 8, t3++, s2[8]++;
              for (; t3 <= 255; ) z[2 * t3 + 1] = 9, t3++, s2[9]++;
              for (; t3 <= 279; ) z[2 * t3 + 1] = 7, t3++, s2[7]++;
              for (; t3 <= 287; ) z[2 * t3 + 1] = 8, t3++, s2[8]++;
              for (Z(z, l + 1, s2), t3 = 0; t3 < f; t3++) C[2 * t3 + 1] = 5, C[2 * t3] = j(t3, 5);
              O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, d, p);
            }(), q = true), t2.l_desc = new F(t2.dyn_ltree, O), t2.d_desc = new F(t2.dyn_dtree, B), t2.bl_desc = new F(t2.bl_tree, R), t2.bi_buf = 0, t2.bi_valid = 0, W(t2);
          }, r._tr_stored_block = J, r._tr_flush_block = function(t2, e2, r2, i2) {
            var n2, s2, a2 = 0;
            0 < t2.level ? (2 === t2.strm.data_type && (t2.strm.data_type = function(t3) {
              var e3, r3 = 4093624447;
              for (e3 = 0; e3 <= 31; e3++, r3 >>>= 1) if (1 & r3 && 0 !== t3.dyn_ltree[2 * e3]) return o;
              if (0 !== t3.dyn_ltree[18] || 0 !== t3.dyn_ltree[20] || 0 !== t3.dyn_ltree[26]) return h;
              for (e3 = 32; e3 < u; e3++) if (0 !== t3.dyn_ltree[2 * e3]) return h;
              return o;
            }(t2)), Y(t2, t2.l_desc), Y(t2, t2.d_desc), a2 = function(t3) {
              var e3;
              for (X(t3, t3.dyn_ltree, t3.l_desc.max_code), X(t3, t3.dyn_dtree, t3.d_desc.max_code), Y(t3, t3.bl_desc), e3 = d - 1; 3 <= e3 && 0 === t3.bl_tree[2 * S[e3] + 1]; e3--) ;
              return t3.opt_len += 3 * (e3 + 1) + 5 + 5 + 4, e3;
            }(t2), n2 = t2.opt_len + 3 + 7 >>> 3, (s2 = t2.static_len + 3 + 7 >>> 3) <= n2 && (n2 = s2)) : n2 = s2 = r2 + 5, r2 + 4 <= n2 && -1 !== e2 ? J(t2, e2, r2, i2) : 4 === t2.strategy || s2 === n2 ? (P(t2, 2 + (i2 ? 1 : 0), 3), K(t2, z, C)) : (P(t2, 4 + (i2 ? 1 : 0), 3), function(t3, e3, r3, i3) {
              var n3;
              for (P(t3, e3 - 257, 5), P(t3, r3 - 1, 5), P(t3, i3 - 4, 4), n3 = 0; n3 < i3; n3++) P(t3, t3.bl_tree[2 * S[n3] + 1], 3);
              V(t3, t3.dyn_ltree, e3 - 1), V(t3, t3.dyn_dtree, r3 - 1);
            }(t2, t2.l_desc.max_code + 1, t2.d_desc.max_code + 1, a2 + 1), K(t2, t2.dyn_ltree, t2.dyn_dtree)), W(t2), i2 && M(t2);
          }, r._tr_tally = function(t2, e2, r2) {
            return t2.pending_buf[t2.d_buf + 2 * t2.last_lit] = e2 >>> 8 & 255, t2.pending_buf[t2.d_buf + 2 * t2.last_lit + 1] = 255 & e2, t2.pending_buf[t2.l_buf + t2.last_lit] = 255 & r2, t2.last_lit++, 0 === e2 ? t2.dyn_ltree[2 * r2]++ : (t2.matches++, e2--, t2.dyn_ltree[2 * (A[r2] + u + 1)]++, t2.dyn_dtree[2 * N(e2)]++), t2.last_lit === t2.lit_bufsize - 1;
          }, r._tr_align = function(t2) {
            P(t2, 2, 3), L(t2, m, z), function(t3) {
              16 === t3.bi_valid ? (U(t3, t3.bi_buf), t3.bi_buf = 0, t3.bi_valid = 0) : 8 <= t3.bi_valid && (t3.pending_buf[t3.pending++] = 255 & t3.bi_buf, t3.bi_buf >>= 8, t3.bi_valid -= 8);
            }(t2);
          };
        }, { "../utils/common": 41 }], 53: [function(t, e, r) {
          "use strict";
          e.exports = function() {
            this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
          };
        }, {}], 54: [function(t, e, r) {
          "use strict";
          e.exports = "function" == typeof setImmediate ? setImmediate : function() {
            var t2 = [].slice.apply(arguments);
            t2.splice(1, 0, 0), setTimeout.apply(null, t2);
          };
        }, {}] }, {}, [10])(10);
      });
    }
  });

  // src/utils/page-context.ts
  var sandboxWin = window;
  var pageWin = typeof unsafeWindow !== "undefined" && unsafeWindow ? unsafeWindow : sandboxWin;
  var pageWindow = pageWin;
  var isIsolatedContext = pageWin !== sandboxWin;
  function shareGlobal(name, value) {
    try {
      pageWin[name] = value;
    } catch {
    }
    if (isIsolatedContext) {
      try {
        sandboxWin[name] = value;
      } catch {
      }
    }
  }
  function readSharedGlobal(name) {
    if (isIsolatedContext) {
      const sandboxValue = sandboxWin[name];
      if (sandboxValue !== void 0) return sandboxValue;
    }
    return pageWin[name];
  }

  // src/core/state.ts
  var NativeWS = pageWindow.WebSocket;
  var NativeWorker = pageWindow.Worker;
  var sockets = [];
  var quinoaWS = null;
  function setQWS(ws, why) {
    if (!quinoaWS) {
      quinoaWS = ws;
      shareGlobal("quinoaWS", ws);
      try {
        console.log("[QuinoaWS] selected ->", why);
      } catch {
      }
    }
  }
  var workerFound = false;
  var Workers = typeof Set !== "undefined" ? /* @__PURE__ */ new Set() : {
    _a: [],
    add(w) {
      this._a.push(w);
    },
    delete(w) {
      const i = this._a.indexOf(w);
      if (i >= 0) this._a.splice(i, 1);
    },
    forEach(fn) {
      for (let i = 0; i < this._a.length; i++) fn(this._a[i]);
    }
  };
  function label(rs) {
    return ["CONNECTING", "OPEN", "CLOSING", "CLOSED"][rs ?? -1] || "none";
  }

  // src/core/parse.ts
  async function parseWSData(d) {
    try {
      if (typeof d === "string") return JSON.parse(d);
      if (d instanceof Blob) return JSON.parse(await d.text());
      if (d instanceof ArrayBuffer) return JSON.parse(new TextDecoder().decode(d));
    } catch {
    }
    return null;
  }

  // src/store/jotai.ts
  var _store = null;
  var _captureInProgress = false;
  var _captureError = null;
  var _lastCapturedVia = null;
  var getAtomCache = () => pageWindow.jotaiAtomCache?.cache;
  function findStoreViaFiber() {
    const hook = pageWindow.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook?.renderers?.size) return null;
    for (const [rid] of hook.renderers) {
      const roots = hook.getFiberRoots?.(rid);
      if (!roots) continue;
      for (const root of roots) {
        const seen = /* @__PURE__ */ new Set();
        const stack = [root.current];
        while (stack.length) {
          const f = stack.pop();
          if (!f || seen.has(f)) continue;
          seen.add(f);
          const v = f?.pendingProps?.value;
          if (v && typeof v.get === "function" && typeof v.set === "function" && typeof v.sub === "function") {
            _lastCapturedVia = "fiber";
            return v;
          }
          if (f.child) stack.push(f.child);
          if (f.sibling) stack.push(f.sibling);
          if (f.alternate) stack.push(f.alternate);
        }
      }
    }
    return null;
  }
  async function captureViaWriteOnce(timeoutMs = 5e3) {
    const cache2 = getAtomCache();
    if (!cache2) {
      console.warn("[jotai-bridge] jotaiAtomCache.cache introuvable");
      throw new Error("jotaiAtomCache.cache introuvable");
    }
    let capturedGet = null;
    let capturedSet = null;
    const patched = [];
    const restorePatched = () => {
      for (const a of patched) {
        try {
          if (a.__origWrite) {
            a.write = a.__origWrite;
            delete a.__origWrite;
          }
        } catch {
        }
      }
    };
    for (const atom of cache2.values()) {
      if (!atom || typeof atom.write !== "function" || atom.__origWrite) continue;
      const orig = atom.write;
      atom.__origWrite = orig;
      atom.write = function(get, set2, ...args) {
        if (!capturedSet) {
          capturedGet = get;
          capturedSet = set2;
          restorePatched();
        }
        return orig.call(this, get, set2, ...args);
      };
      patched.push(atom);
    }
    const wait = (ms) => new Promise((r) => setTimeout(r, ms));
    const t0 = Date.now();
    try {
      pageWindow.dispatchEvent?.(new pageWindow.Event("visibilitychange"));
    } catch {
    }
    while (!capturedSet && Date.now() - t0 < timeoutMs) {
      await wait(50);
    }
    if (!capturedSet) {
      restorePatched();
      _lastCapturedVia = "polyfill";
      console.warn("[jotai-bridge] write-once: timeout \u2192 polyfill");
      return {
        get: () => {
          throw new Error("Store non captur\xE9: get indisponible");
        },
        set: () => {
          throw new Error("Store non captur\xE9: set indisponible");
        },
        sub: () => () => {
        },
        __polyfill: true
      };
    }
    _lastCapturedVia = "write";
    return {
      get: (a) => capturedGet(a),
      set: (a, v) => capturedSet(a, v),
      sub: (a, cb) => {
        let last;
        try {
          last = capturedGet(a);
        } catch {
        }
        const id = setInterval(() => {
          let curr;
          try {
            curr = capturedGet(a);
          } catch {
            return;
          }
          if (curr !== last) {
            last = curr;
            try {
              cb();
            } catch {
            }
          }
        }, 100);
        return () => clearInterval(id);
      }
    };
  }
  async function ensureStore() {
    if (_store && !_store.__polyfill) return _store;
    if (_captureInProgress) {
      const t0 = Date.now();
      const maxWait = 5500;
      while (!_store && Date.now() - t0 < maxWait) {
        await new Promise((r) => setTimeout(r, 25));
      }
      if (_store && !_store.__polyfill) return _store;
    }
    _captureInProgress = true;
    try {
      const viaFiber = findStoreViaFiber();
      if (viaFiber) {
        _store = viaFiber;
        return _store;
      }
      const viaWrite = await captureViaWriteOnce();
      _store = viaWrite;
      return _store;
    } catch (e) {
      _captureError = e;
      throw e;
    } finally {
      _captureInProgress = false;
    }
  }
  function isStoreCaptured() {
    return !!_store && !_store.__polyfill;
  }
  function getCapturedInfo() {
    return { via: _lastCapturedVia, polyfill: !!_store?.__polyfill, error: _captureError };
  }
  async function jGet(atom) {
    const s = await ensureStore();
    return s.get(atom);
  }
  async function jSet(atom, value) {
    const s = await ensureStore();
    await s.set(atom, value);
  }
  async function jSub(atom, cb) {
    const s = await ensureStore();
    return s.sub(atom, cb);
  }
  function findAtomsByLabel(regex) {
    const cache2 = getAtomCache();
    if (!cache2) return [];
    const out = [];
    for (const a of cache2.values()) {
      const label2 = a?.debugLabel || a?.label || "";
      if (regex.test(String(label2))) out.push(a);
    }
    return out;
  }
  function getAtomByLabel(label2) {
    const escape = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return findAtomsByLabel(new RegExp("^" + escape(label2) + "$"))[0] || null;
  }

  // src/store/api.ts
  async function ensureStore2() {
    try {
      await ensureStore();
    } catch {
    }
  }
  async function select(label2, fallback) {
    await ensureStore2();
    const atom = getAtomByLabel(label2);
    if (!atom) return fallback;
    try {
      return await jGet(atom);
    } catch {
      return fallback;
    }
  }
  async function subscribe(label2, cb) {
    await ensureStore2();
    const atom = getAtomByLabel(label2);
    if (!atom) return () => {
    };
    const unsub = await jSub(atom, async () => {
      try {
        cb(await jGet(atom));
      } catch {
      }
    });
    return unsub;
  }
  async function subscribeImmediate(label2, cb) {
    const first = await select(label2);
    if (first !== void 0) cb(first);
    return subscribe(label2, cb);
  }
  async function set(label2, value) {
    await ensureStore2();
    const atom = getAtomByLabel(label2);
    if (!atom) return;
    await jSet(atom, value);
  }
  var Store = { ensure: ensureStore2, select, subscribe, subscribeImmediate, set };

  // src/store/hub.ts
  function toPathArray(path) {
    if (!path) return [];
    return Array.isArray(path) ? path.slice() : path.split(".").map((k) => k.match(/^\d+$/) ? Number(k) : k);
  }
  function getAtPath(root, path) {
    const segs = toPathArray(path);
    let cur = root;
    for (const s of segs) {
      if (cur == null) return void 0;
      cur = cur[s];
    }
    return cur;
  }
  function setAtPath(root, path, nextValue) {
    const segs = toPathArray(path);
    if (!segs.length) return nextValue;
    const clone = Array.isArray(root) ? root.slice() : { ...root ?? {} };
    let cur = clone;
    for (let i = 0; i < segs.length - 1; i++) {
      const key2 = segs[i];
      const src = cur[key2];
      const obj = typeof src === "object" && src !== null ? Array.isArray(src) ? src.slice() : { ...src } : {};
      cur[key2] = obj;
      cur = obj;
    }
    cur[segs[segs.length - 1]] = nextValue;
    return clone;
  }
  var eq = {
    shallow(a, b) {
      if (Object.is(a, b)) return true;
      if (!a || !b || typeof a !== "object" || typeof b !== "object") return false;
      const ka = Object.keys(a);
      const kb = Object.keys(b);
      if (ka.length !== kb.length) return false;
      for (const k of ka) if (!Object.is(a[k], b[k])) return false;
      return true;
    },
    idSet(a, b) {
      if (a === b) return true;
      if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) return false;
      const sa = new Set(a);
      for (const id of b) if (!sa.has(id)) return false;
      return true;
    }
  };
  function makeView(sourceLabel, opts = {}) {
    const { path, write = "replace" } = opts;
    async function get() {
      const src = await Store.select(sourceLabel);
      return path ? getAtPath(src, path) : src;
    }
    async function set2(next) {
      if (typeof write === "function") {
        const prev2 = await Store.select(sourceLabel);
        const raw2 = write(next, prev2);
        return Store.set(sourceLabel, raw2);
      }
      const prev = await Store.select(sourceLabel);
      const raw = path ? setAtPath(prev, path, next) : next;
      if (write === "merge-shallow" && !path && prev && typeof prev === "object" && typeof next === "object") {
        return Store.set(sourceLabel, { ...prev, ...next });
      }
      return Store.set(sourceLabel, raw);
    }
    async function update(fn) {
      const prev = await get();
      const next = fn(prev);
      await set2(next);
      return next;
    }
    async function onChange(cb, isEqual = Object.is) {
      let prev;
      return Store.subscribe(sourceLabel, (src) => {
        const v = path ? getAtPath(src, path) : src;
        if (typeof prev === "undefined" || !isEqual(prev, v)) {
          const p = prev;
          prev = v;
          cb(v, p);
        }
      });
    }
    async function onChangeNow(cb, isEqual = Object.is) {
      let prev;
      return Store.subscribeImmediate(sourceLabel, (src) => {
        const v = path ? getAtPath(src, path) : src;
        if (typeof prev === "undefined" || !isEqual(prev, v)) {
          const p = prev;
          prev = v;
          cb(v, p);
        }
      });
    }
    function asSignature(opts2) {
      return makeSignatureChannel(sourceLabel, path, opts2);
    }
    return { label: sourceLabel + (path ? ":" + toPathArray(path).join(".") : ""), get, set: set2, update, onChange, onChangeNow, asSignature };
  }
  function stablePick(obj, fields) {
    const out = {};
    for (const f of fields) {
      const v = getAtPath(obj, f.includes(".") ? f : [f]);
      out[f] = v;
    }
    try {
      return JSON.stringify(out);
    } catch {
      return String(out);
    }
  }
  function makeSignatureChannel(sourceLabel, path, opts) {
    const mode = opts.mode ?? "auto";
    function computeSig(whole) {
      const base = whole;
      const value = path ? getAtPath(base, path) : base;
      const sig = /* @__PURE__ */ new Map();
      if (value == null) return { sig, keys: [] };
      if ((mode === "array" || mode === "auto" && Array.isArray(value)) && Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const key2 = opts.key ? opts.key(item, i, whole) : i;
          const s = opts.sig ? opts.sig(item, i, whole) : opts.fields ? stablePick(item, opts.fields) : (() => {
            try {
              return JSON.stringify(item);
            } catch {
              return String(item);
            }
          })();
          sig.set(key2, s);
        }
      } else {
        for (const [k, item] of Object.entries(value)) {
          const key2 = opts.key ? opts.key(item, k, whole) : k;
          const s = opts.sig ? opts.sig(item, k, whole) : opts.fields ? stablePick(item, opts.fields) : (() => {
            try {
              return JSON.stringify(item);
            } catch {
              return String(item);
            }
          })();
          sig.set(key2, s);
        }
      }
      return { sig, keys: Array.from(sig.keys()) };
    }
    function mapEqual(a, b) {
      if (a === b) return true;
      if (!a || !b || a.size !== b.size) return false;
      for (const [k, v] of a) if (b.get(k) !== v) return false;
      return true;
    }
    async function sub(cb) {
      let prevSig = null;
      return Store.subscribeImmediate(sourceLabel, (src) => {
        const whole = path ? getAtPath(src, path) : src;
        const { sig } = computeSig(whole);
        if (!mapEqual(prevSig, sig)) {
          const allKeys = /* @__PURE__ */ new Set([
            ...prevSig ? Array.from(prevSig.keys()) : [],
            ...Array.from(sig.keys())
          ]);
          const changed = [];
          for (const k of allKeys) if ((prevSig?.get(k) ?? "__NONE__") !== (sig.get(k) ?? "__NONE__")) changed.push(k);
          prevSig = sig;
          cb({ value: whole, changedKeys: changed });
        }
      });
    }
    async function subKey(key2, cb) {
      let last = "__INIT__";
      return sub(({ value, changedKeys }) => {
        if (changedKeys.includes(key2)) cb({ value });
      });
    }
    async function subKeys(keys, cb) {
      const wanted = new Set(keys);
      return sub(({ value, changedKeys }) => {
        const hit = changedKeys.filter((k) => wanted.has(k));
        if (hit.length) cb({ value, changedKeys: hit });
      });
    }
    return { sub, subKey, subKeys };
  }
  var HubEq = eq;
  function makeAtom(label2) {
    return makeView(label2);
  }

  // src/store/atoms.ts
  var position = makeAtom("positionAtom");
  var state = makeAtom("stateAtom");
  var map = makeAtom("mapAtom");
  var player = makeAtom("playerAtom");
  var action = makeAtom("actionAtom");
  var myData = makeAtom("myDataAtom");
  var myInventory = makeAtom("myInventoryAtom");
  var gardensWithBackfills = makeAtom("gardensWithBackfillsAtom");
  var myCropInventory = makeAtom("myCropInventoryAtom");
  var mySeedInventory = makeAtom("mySeedInventoryAtom");
  var myToolInventory = makeAtom("myToolInventoryAtom");
  var myEggInventory = makeAtom("myEggInventoryAtom");
  var myDecorInventory = makeAtom("myDecorInventoryAtom");
  var myPetInfos = makeAtom("myPetInfosAtom");
  var myPetSlotInfos = makeAtom("myPetSlotInfosAtom");
  var totalPetSellPrice = makeAtom("totalPetSellPriceAtom");
  var expandedPetSlotId = makeAtom("expandedPetSlotIdAtom");
  var myCropItemsToSell = makeAtom("myCropItemsToSellAtom");
  var myPetHutchPetItems = makeAtom("myPetHutchPetItemsAtom");
  var isMyInventoryAtMaxLength = makeAtom("isMyInventoryAtMaxLengthAtom");
  var myNumPetHutchItems = makeAtom("myNumPetHutchItemsAtom");
  var shops = makeAtom("shopsAtom");
  var myShopPurchases = makeAtom("myShopPurchasesAtom");
  var numPlayers = makeAtom("numPlayersAtom");
  var totalCropSellPrice = makeAtom("totalCropSellPriceAtom");
  var myValidatedSelectedItemIndex = makeAtom("myValidatedSelectedItemIndexAtom");
  var setSelectedIndexToEnd = makeAtom("setSelectedIndexToEndAtom");
  var mySelectedItemName = makeAtom("mySelectedItemNameAtom");
  var myPossiblyNoLongerValidSelectedItemIndex = makeAtom("myPossiblyNoLongerValidSelectedItemIndexAtom");
  var myCurrentGardenObject = makeAtom("myCurrentGardenObjectAtom");
  var myCurrentSortedGrowSlotIndices = makeAtom("myCurrentSortedGrowSlotIndicesAtom");
  var myCurrentGrowSlotIndex = makeAtom("myCurrentGrowSlotIndexAtom");
  var myOwnCurrentGardenObject = makeAtom("myOwnCurrentGardenObjectAtom");
  var isCurrentGrowSlotMature = makeAtom("isCurrentGrowSlotMatureAtom");
  var myOwnCurrentDirtTileIndex = makeAtom("myOwnCurrentDirtTileIndexAtom");
  var mySelectedItemRotation = makeAtom("mySelectedItemRotationAtom");
  var weather = makeAtom("weatherAtom");
  var activeModal = makeAtom("activeModalAtom");
  var avatarTriggerAnimationAtom = makeAtom("avatarTriggerAnimationAtom");
  var friendBonusMultiplier = makeAtom("friendBonusMultiplierAtom");
  var garden = makeView("myDataAtom", { path: "garden" });
  var gardenTileObjects = makeView("myDataAtom", { path: "garden.tileObjects" });
  var favoriteIds = makeView("myInventoryAtom", { path: "favoritedItemIds" });
  var playerId = makeView("playerAtom", { path: "id" });
  var playerDatabaseUserId = makeView("playerAtom", { path: "databaseUserId" });
  var myOwnCurrentGardenObjectType = makeView("myOwnCurrentGardenObjectAtom", { path: "objectType" });
  var stateChild = makeView("stateAtom", { path: "child" });
  var stateChildData = makeView("stateAtom", { path: "child.data" });
  var stateShops = makeView("stateAtom", { path: "child.data.shops" });
  var stateUserSlots = makeView("stateAtom", { path: "child.data.userSlots" });
  var statePlayers = makeView("stateAtom", { path: "data.players" });
  var myActivityLog = makeView("myDataAtom", { path: "activityLogs" });
  var seedShop = makeView("shopsAtom", { path: "seed" });
  var toolShop = makeView("shopsAtom", { path: "tool" });
  var eggShop = makeView("shopsAtom", { path: "egg" });
  var decorShop = makeView("shopsAtom", { path: "decor" });
  function slotSig(o) {
    if (!o) return "\u2205";
    return [
      o.objectType ?? o.type ?? "",
      o.species ?? o.seedSpecies ?? o.plantSpecies ?? o.eggId ?? o.decorId ?? "",
      o.plantedAt ?? o.startTime ?? 0,
      o.maturedAt ?? o.endTime ?? 0
    ].join("|");
  }
  var GardenSlotsSig = gardenTileObjects.asSignature({
    mode: "record",
    key: (_item, key2) => Number(key2),
    sig: (item) => slotSig(item)
  });
  function activePetSig(p) {
    const s = p?.slot ?? {};
    const muts = Array.isArray(s.mutations) ? s.mutations.slice().sort().join(",") : "";
    const ab = Array.isArray(s.abilities) ? s.abilities.slice().sort().join(",") : "";
    const name = s.name ?? "";
    const species = s.petSpecies ?? "";
    const xp = Number.isFinite(s.xp) ? Math.round(s.xp) : 0;
    const hunger = Number.isFinite(s.hunger) ? Math.round(s.hunger * 1e3) : 0;
    const scale = Number.isFinite(s.targetScale) ? Math.round(s.targetScale * 1e3) : 0;
    const x = Number.isFinite(p?.position?.x) ? Math.round(p.position.x) : 0;
    const y = Number.isFinite(p?.position?.y) ? Math.round(p.position.y) : 0;
    return `${species}|${name}|xp:${xp}|hg:${hunger}|sc:${scale}|m:${muts}|a:${ab}|pos:${x},${y}`;
  }
  function activePetStableSig(p) {
    const s = p?.slot ?? {};
    const muts = Array.isArray(s.mutations) ? s.mutations.slice().sort().join(",") : "";
    const ab = Array.isArray(s.abilities) ? s.abilities.slice().sort().join(",") : "";
    const name = s.name ?? "";
    const species = s.petSpecies ?? "";
    const scale = Number.isFinite(s.targetScale) ? Math.round(s.targetScale * 1e3) : 0;
    return `${species}|${name}|sc:${scale}|m:${muts}|a:${ab}`;
  }
  var PetsByIdSig = myPetInfos.asSignature({
    mode: "array",
    key: (p) => String(p?.slot?.id ?? ""),
    sig: (p) => activePetSig(p)
  });
  var PetsByIdStableSig = myPetInfos.asSignature({
    mode: "array",
    key: (p) => String(p?.slot?.id ?? ""),
    sig: (p) => activePetStableSig(p)
  });
  var FavoriteIdsSig = favoriteIds.asSignature({
    mode: "array",
    key: (id) => String(id),
    sig: () => "1"
  });
  var Atoms = {
    ui: { activeModal },
    server: { numPlayers, friendBonusMultiplier },
    player: {
      position,
      avatarTriggerAnimationAtom,
      player,
      action,
      playerId
    },
    garden: {
      myOwnCurrentGardenObject,
      isCurrentGrowSlotMature,
      myOwnCurrentGardenObjectType,
      myOwnCurrentDirtTileIndex,
      myCurrentGrowSlotIndex
    },
    root: { state, map },
    data: {
      myData,
      garden,
      gardensWithBackfills,
      gardenTileObjects,
      myCurrentGardenObject,
      myCurrentSortedGrowSlotIndices,
      myCurrentGrowSlotIndex,
      weather
    },
    inventory: {
      myInventory,
      myCropInventory,
      mySeedInventory,
      myToolInventory,
      myEggInventory,
      myDecorInventory,
      favoriteIds,
      mySelectedItemName,
      mySelectedItemRotation,
      myPossiblyNoLongerValidSelectedItemIndex,
      myValidatedSelectedItemIndex,
      setSelectedIndexToEnd,
      myCropItemsToSell
    },
    pets: {
      myPetInfos,
      myPetSlotInfos,
      totalPetSellPrice,
      expandedPetSlotId
    },
    shop: {
      shops,
      myShopPurchases,
      totalCropSellPrice,
      seedShop,
      toolShop,
      eggShop,
      decorShop
    }
  };
  function onFavoriteIds(cb) {
    return favoriteIds.onChange((next) => cb(Array.isArray(next) ? next : []), HubEq.idSet);
  }
  async function onFavoriteIdsNow(cb) {
    cb(Array.isArray(await favoriteIds.get()) ? await favoriteIds.get() : []);
    return onFavoriteIds(cb);
  }
  function activePetsStructuralEq(a, b) {
    const snap = (st) => {
      const m = /* @__PURE__ */ new Map();
      const arr = Array.isArray(st) ? st : [];
      for (const it of arr) {
        const id = String(it?.slot?.id ?? "");
        if (id) m.set(id, activePetStableSig(it));
      }
      return m;
    };
    const A = snap(a);
    const B = snap(b);
    if (A.size !== B.size) return false;
    for (const [k, v] of A) if (B.get(k) !== v) return false;
    return true;
  }
  async function onActivePetsStructuralChangeNow(cb) {
    cb(await myPetInfos.get());
    return myPetInfos.onChange(cb, activePetsStructuralEq);
  }
  async function getFavoriteIdSet() {
    const arr = await favoriteIds.get();
    return new Set(Array.isArray(arr) ? arr : []);
  }

  // src/data/hardcoded-data.clean.js
  var rarity = {
    Common: "Common",
    Uncommon: "Uncommon",
    Rare: "Rare",
    Legendary: "Legendary",
    Mythic: "Mythical",
    Divine: "Divine",
    Celestial: "Celestial"
  };
  var harvestType = {
    Single: "Single",
    Multiple: "Multiple"
  };
  var tileRefsMap = {
    Dirt1: 6,
    Dirt2: 7,
    Dirt3: 8,
    Bush1: 28,
    Bush2: 38,
    BushHomer: 48,
    Sky0: 24,
    Sky1: 25,
    Sky2: 26,
    Sky3: 27,
    Sky4: 35,
    Sky5: 36,
    Sky6: 37,
    Sky7: 45,
    Sky8: 46,
    Sky9: 47
  };
  var tileRefsPlants = {
    DirtPatch: 1,
    SproutFlower: 2,
    SproutVegetable: 3,
    SproutFruit: 4,
    SproutVine: 5,
    StemFlower: 6,
    Trellis: 7,
    Daffodil: 11,
    Tulip: 12,
    Sunflower: 13,
    Lily: 14,
    Starweaver: 15,
    Chrysanthemum: 16,
    AloePlant: 17,
    Aloe: 18,
    Blueberry: 21,
    Banana: 22,
    Strawberry: 23,
    Mango: 24,
    Grape: 25,
    Watermelon: 26,
    Lemon: 27,
    Apple: 28,
    Pear: 29,
    Pineapple: 30,
    Pepper: 31,
    Tomato: 32,
    BabyCarrot: 33,
    Carrot: 34,
    Pumpkin: 35,
    Corn: 36,
    FavaBean: 37,
    Cacao: 38,
    PalmTreeTop: 39,
    BushyTree: 40,
    Coconut: 41,
    MushroomPlant: 42,
    PassionFruit: 43,
    DragonFruit: 44,
    Lychee: 45,
    Mushroom: 46,
    BurrosTail: 47,
    Echeveria: 49,
    Delphinium: 50,
    DawnCelestialCrop: 51,
    MoonCelestialCrop: 52,
    Camellia: 57,
    Hedge: 58,
    FlowerBush: 59,
    Squash: 60
  };
  var tileRefsTallPlants = {
    Bamboo: 1,
    PalmTree: 2,
    DawnCelestialPlatform: 3,
    DawnCelestialPlant: 4,
    DawnCelestialPlantActive: 5,
    DawnCelestialPlatformTopmostLayer: 6,
    Cactus: 7,
    Tree: 8,
    MoonCelestialPlatform: 9,
    MoonCelestialPlant: 10,
    MoonCelestialPlantActive: 11,
    StarweaverPlatform: 13,
    StarweaverPlant: 14,
    CacaoTree: 15
  };
  var tileRefsSeeds = {
    Daffodil: 1,
    Tulip: 2,
    Sunflower: 3,
    Starweaver: 6,
    DawnCelestial: 7,
    MoonCelestial: 8,
    Blueberry: 11,
    Banana: 12,
    Strawberry: 13,
    Mango: 14,
    Grape: 15,
    Watermelon: 16,
    Lemon: 17,
    Apple: 18,
    Pear: 19,
    Lily: 20,
    Pepper: 21,
    Tomato: 22,
    Carrot: 23,
    Pumpkin: 25,
    Corn: 26,
    Peach: 27,
    FavaBean: 28,
    Cacao: 29,
    Delphinium: 30,
    Coconut: 31,
    Mushroom: 32,
    PassionFruit: 33,
    DragonFruit: 34,
    Lychee: 35,
    BurrosTail: 37,
    Aloe: 39,
    Echeveria: 40,
    Bamboo: 41,
    Cactus: 42,
    Camellia: 48,
    Chrysanthemum: 49,
    Squash: 50
  };
  var tileRefsItems = {
    Coin: 1,
    Shovel: 2,
    PlanterPot: 6,
    InventoryBag: 7,
    WateringCan: 9,
    MoneyBag: 11,
    RainbowPotion: 14,
    GoldPotion: 15,
    WetPotion: 16,
    ChilledPotion: 17,
    FrozenPotion: 18,
    DawnlitPotion: 19,
    AmberlitPotion: 20,
    JournalStamp: 22,
    Donut: 23,
    ToolsRestocked: 24,
    SeedsRestocked: 25,
    EggsRestocked: 26,
    DecorRestocked: 27,
    Leaderboard: 28,
    Stats: 29,
    ActivityLog: 30,
    ChatBubble: 39,
    ArrowKeys: 41,
    Touchpad: 42
  };
  var tileRefsAnimations = {
    Rain: 10,
    Frost: 20,
    Sunny: 30,
    AmberMoon: 40,
    Dawn: 50,
    MoonCelestialActivationTile: 91,
    DawnCelestialActivationTile: 92
  };
  var tileRefsPets = {
    Bee: 1,
    Chicken: 2,
    Bunny: 3,
    Turtle: 4,
    Capybara: 5,
    Cow: 6,
    Pig: 7,
    Butterfly: 8,
    Snail: 9,
    Worm: 10,
    CommonEgg: 11,
    UncommonEgg: 12,
    RareEgg: 13,
    LegendaryEgg: 14,
    MythicalEgg: 15,
    DivineEgg: 16,
    CelestialEgg: 17,
    Squirrel: 18,
    Goat: 19,
    Dragonfly: 20,
    Turkey: 29,
    Peacock: 30
  };
  var tileRefsMutations = {
    Wet: 1,
    Chilled: 2,
    Frozen: 3,
    Puddle: 5,
    Dawnlit: 11,
    Amberlit: 12,
    Dawncharged: 13,
    Ambercharged: 14
  };
  var tileRefsMutationLabels = {
    Wet: "Wet",
    Chilled: "Chilled",
    Frozen: "Frozen",
    Puddle: "Puddle",
    Dawnlit: "Dawnlit",
    Amberlit: "Amberlit",
    Dawncharged: "Dawnbound",
    Ambercharged: "Amberbound"
  };
  var tileRefsDecor = {
    WoodPedestal: 4,
    StonePedestal: 6,
    MarblePedestal: 8,
    SmallRock: 11,
    WoodBench: 13,
    WoodBenchBackwards: 14,
    StoneBench: 15,
    StoneBucketPedestal: 16,
    MarbleBench: 17,
    MarbleBenchBackwards: 18,
    MediumRock: 21,
    WoodLampPost: 23,
    WoodBenchSideways: 24,
    StoneLampPost: 25,
    StoneBenchSideways: 26,
    StoneColumn: 26,
    MarbleLampPost: 27,
    MarbleBenchSideways: 28,
    HayBale: 29,
    PetHutch: 30,
    LargeRock: 31,
    WoodArch: 33,
    WoodBucketPedestal: 34,
    WoodBridge: 34,
    StoneArch: 35,
    StoneBridge: 36,
    MarbleArch: 37,
    MarbleBridge: 38,
    HayBaleSideways: 39,
    MiniFairyForge: 40,
    WoodArchSide: 43,
    WoodBridgeSideways: 44,
    StoneArchSideways: 45,
    StoneBridgeSideways: 46,
    MarbleArchSideways: 47,
    MarbleBridgeSideways: 48,
    StrawScarecrow: 49,
    MiniFairyCottage: 50,
    WoodOwl: 53,
    Birdhouse: 54,
    StoneGnome: 55,
    StoneBirdBath: 56,
    MarbleBlobling: 57,
    MarbleBucketPedestal: 58,
    MarbleFountain: 58,
    Cauldron: 59,
    MiniFairyKeep: 60,
    WoodStool: 63,
    WoodWindmill: 64,
    StoneGardenBox: 66,
    MarbleColumn: 68,
    MiniWizardTower: 68,
    SmallGravestone: 69,
    SmallGravestoneSideways: 70,
    WoodenWindmill: 73,
    WoodGardenBox: 74,
    MarbleGardenBox: 78,
    MediumGravestone: 79,
    MediumGravestoneSideways: 80,
    LargeGravestone: 89,
    LargeGravestoneSideways: 90
  };
  var plantCatalog = {
    Carrot: {
      seed: {
        tileRef: tileRefsSeeds.Carrot,
        name: "Carrot Seed",
        coinPrice: 10,
        creditPrice: 7,
        rarity: rarity.Common
      },
      plant: {
        tileRef: tileRefsPlants.BabyCarrot,
        name: "Carrot Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.7
      },
      crop: {
        tileRef: tileRefsPlants.Carrot,
        name: "Carrot",
        baseSellPrice: 20,
        baseWeight: 0.1,
        baseTileScale: 0.6,
        maxScale: 3
      }
    },
    Strawberry: {
      seed: {
        tileRef: tileRefsSeeds.Strawberry,
        name: "Strawberry Seed",
        coinPrice: 50,
        creditPrice: 21,
        rarity: rarity.Common
      },
      plant: {
        tileRef: tileRefsPlants.SproutFruit,
        name: "Strawberry Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.2, y: -0.1, rotation: 0 },
          { x: 0.175, y: -0.2, rotation: 0 },
          { x: -0.18, y: 0.22, rotation: 0 },
          { x: 0.2, y: 0.2, rotation: 0 },
          { x: 0.01, y: 0.01, rotation: 0 }
        ],
        secondsToMature: 70,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.Strawberry,
        name: "Strawberry",
        baseSellPrice: 14,
        baseWeight: 0.05,
        baseTileScale: 0.25,
        maxScale: 2
      }
    },
    Aloe: {
      seed: {
        tileRef: tileRefsSeeds.Aloe,
        name: "Aloe Seed",
        coinPrice: 135,
        creditPrice: 18,
        rarity: rarity.Common
      },
      plant: {
        tileRef: tileRefsPlants.AloePlant,
        name: "Aloe Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.9
      },
      crop: {
        tileRef: tileRefsPlants.Aloe,
        name: "Aloe",
        baseSellPrice: 310,
        baseWeight: 1.5,
        baseTileScale: 0.7,
        maxScale: 2.5
      }
    },
    FavaBean: {
      seed: {
        tileRef: tileRefsSeeds.FavaBean,
        name: "Fava Bean",
        coinPrice: 250,
        creditPrice: 30,
        rarity: rarity.Uncommon
      },
      plant: {
        tileRef: tileRefsPlants.SproutFlower,
        name: "Fava Bean Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.1, y: 0.15, rotation: 35 },
          { x: -0.23, y: 0.22, rotation: 35 },
          { x: 0.05, y: 0.3, rotation: 35 },
          { x: 0.18, y: 0.25, rotation: 35 },
          { x: 0.22, y: -0.02, rotation: 35 },
          { x: 0.1, y: -0.15, rotation: 35 },
          { x: -0.1, y: -0.17, rotation: 35 },
          { x: -0.25, y: -0.11, rotation: 35 }
        ],
        secondsToMature: 900,
        baseTileScale: 1.1,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.FavaBean,
        name: "Fava Bean Pod",
        baseSellPrice: 30,
        baseWeight: 0.03,
        baseTileScale: 0.3,
        maxScale: 3
      }
    },
    Delphinium: {
      seed: {
        tileRef: tileRefsSeeds.Delphinium,
        name: "Delphinium Seed",
        coinPrice: 300,
        creditPrice: 12,
        rarity: rarity.Uncommon
      },
      plant: {
        tileRef: tileRefsPlants.Delphinium,
        name: "Delphinium Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.8,
        tileTransformOrigin: "bottom",
        nudgeY: -0.43,
        nudgeYMultiplier: 0.05
      },
      crop: {
        tileRef: tileRefsPlants.Delphinium,
        name: "Delphinium",
        baseSellPrice: 530,
        baseWeight: 0.02,
        baseTileScale: 0.8,
        maxScale: 3
      }
    },
    Blueberry: {
      seed: {
        tileRef: tileRefsSeeds.Blueberry,
        name: "Blueberry Seed",
        coinPrice: 400,
        creditPrice: 49,
        rarity: rarity.Uncommon
      },
      plant: {
        tileRef: tileRefsPlants.SproutFruit,
        name: "Blueberry Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.2, y: -0.1, rotation: 0 },
          { x: 0.175, y: -0.2, rotation: 0 },
          { x: -0.18, y: 0.22, rotation: 0 },
          { x: 0.2, y: 0.2, rotation: 0 },
          { x: 0.01, y: 0.01, rotation: 0 }
        ],
        secondsToMature: 105,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.Blueberry,
        name: "Blueberry",
        baseSellPrice: 23,
        baseWeight: 0.01,
        baseTileScale: 0.25,
        maxScale: 2
      }
    },
    Apple: {
      seed: {
        tileRef: tileRefsSeeds.Apple,
        name: "Apple Seed",
        coinPrice: 500,
        creditPrice: 67,
        rarity: rarity.Uncommon,
        unavailableSurfaces: ["discord"]
      },
      plant: {
        tileRef: tileRefsTallPlants.Tree,
        name: "Apple Tree",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.35, y: -2.4, rotation: 0 },
          { x: -0.5, y: -2, rotation: 0 },
          { x: 0.1, y: -2.2, rotation: 0 },
          { x: -0.2, y: -1.65, rotation: 0 },
          { x: 0.55, y: -1.9, rotation: 0 },
          { x: 0.3, y: -1.7, rotation: 0 },
          { x: 0.4, y: 0.1, rotation: 0 }
        ],
        secondsToMature: 360 * 60,
        baseTileScale: 3,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.25
      },
      crop: {
        tileRef: tileRefsPlants.Apple,
        name: "Apple",
        baseSellPrice: 73,
        baseWeight: 0.18,
        baseTileScale: 0.5,
        maxScale: 2
      }
    },
    OrangeTulip: {
      seed: {
        tileRef: tileRefsSeeds.Tulip,
        name: "Tulip Seed",
        coinPrice: 600,
        creditPrice: 14,
        rarity: rarity.Uncommon
      },
      plant: {
        tileRef: tileRefsPlants.Tulip,
        name: "Tulip Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.5
      },
      crop: {
        tileRef: tileRefsPlants.Tulip,
        name: "Tulip",
        baseSellPrice: 767,
        baseWeight: 0.01,
        baseTileScale: 0.5,
        maxScale: 3
      }
    },
    Tomato: {
      seed: {
        tileRef: tileRefsSeeds.Tomato,
        name: "Tomato Seed",
        coinPrice: 800,
        creditPrice: 79,
        rarity: rarity.Uncommon
      },
      plant: {
        tileRef: tileRefsPlants.SproutVine,
        name: "Tomato Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.3, y: -0.3, rotation: 0 },
          { x: 0.3, y: 0.3, rotation: 0 }
        ],
        secondsToMature: 1100,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: false
      },
      crop: {
        tileRef: tileRefsPlants.Tomato,
        name: "Tomato",
        baseSellPrice: 27,
        baseWeight: 0.3,
        baseTileScale: 0.33,
        maxScale: 2
      }
    },
    Daffodil: {
      seed: {
        tileRef: tileRefsSeeds.Daffodil,
        name: "Daffodil Seed",
        coinPrice: 1e3,
        creditPrice: 19,
        rarity: rarity.Rare
      },
      plant: {
        tileRef: tileRefsPlants.Daffodil,
        name: "Daffodil Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.5
      },
      crop: {
        tileRef: tileRefsPlants.Daffodil,
        name: "Daffodil",
        baseSellPrice: 1090,
        baseWeight: 0.01,
        baseTileScale: 0.5,
        maxScale: 3
      }
    },
    Corn: {
      seed: {
        tileRef: tileRefsSeeds.Corn,
        name: "Corn Kernel",
        coinPrice: 1300,
        creditPrice: 135,
        rarity: rarity.Rare
      },
      plant: {
        tileRef: tileRefsPlants.SproutVegetable,
        name: "Corn Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: 0, y: -0.1, rotation: 0 }],
        secondsToMature: 130,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: false
      },
      crop: {
        tileRef: tileRefsPlants.Corn,
        name: "Corn",
        baseSellPrice: 36,
        baseWeight: 1.2,
        baseTileScale: 0.7,
        maxScale: 2
      }
    },
    Watermelon: {
      seed: {
        tileRef: tileRefsSeeds.Watermelon,
        name: "Watermelon Seed",
        coinPrice: 2500,
        creditPrice: 195,
        rarity: rarity.Rare
      },
      plant: {
        tileRef: tileRefsPlants.Watermelon,
        name: "Watermelon Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.8
      },
      crop: {
        tileRef: tileRefsPlants.Watermelon,
        name: "Watermelon",
        baseSellPrice: 2708,
        baseWeight: 4.5,
        baseTileScale: 0.8,
        maxScale: 3
      }
    },
    Pumpkin: {
      seed: {
        tileRef: tileRefsSeeds.Pumpkin,
        name: "Pumpkin Seed",
        coinPrice: 3e3,
        creditPrice: 210,
        rarity: rarity.Rare
      },
      plant: {
        tileRef: tileRefsPlants.Pumpkin,
        name: "Pumpkin Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.8
      },
      crop: {
        tileRef: tileRefsPlants.Pumpkin,
        name: "Pumpkin",
        baseSellPrice: 3700,
        baseWeight: 6,
        baseTileScale: 0.8,
        maxScale: 3
      }
    },
    Echeveria: {
      seed: {
        tileRef: tileRefsSeeds.Echeveria,
        name: "Echeveria Cutting",
        coinPrice: 4200,
        creditPrice: 113,
        rarity: rarity.Rare
      },
      plant: {
        tileRef: tileRefsPlants.Echeveria,
        name: "Echeveria Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.8
      },
      crop: {
        tileRef: tileRefsPlants.Echeveria,
        name: "Echeveria",
        baseSellPrice: 4600,
        baseWeight: 0.8,
        baseTileScale: 0.8,
        maxScale: 2.75
      }
    },
    Coconut: {
      seed: {
        tileRef: tileRefsSeeds.Coconut,
        name: "Coconut Seed",
        coinPrice: 6e3,
        creditPrice: 235,
        rarity: rarity.Legendary
      },
      plant: {
        tileRef: tileRefsTallPlants.PalmTree,
        name: "Coconut Tree",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.2, y: -2.6, rotation: 0 },
          { x: -0.3, y: -2.4, rotation: 0 },
          { x: 0.2, y: -2.5, rotation: 0 },
          { x: -0.25, y: -2.1, rotation: 0 },
          { x: 0, y: -2.3, rotation: 0 },
          { x: 0.3, y: -2.2, rotation: 0 },
          { x: 0.05, y: -2, rotation: 0 }
        ],
        secondsToMature: 720 * 60,
        baseTileScale: 3,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.35
      },
      crop: {
        tileRef: tileRefsPlants.Coconut,
        name: "Coconut",
        baseSellPrice: 302,
        baseWeight: 5,
        baseTileScale: 0.25,
        maxScale: 3
      }
    },
    Banana: {
      seed: {
        tileRef: tileRefsSeeds.Banana,
        name: "Banana Seed",
        coinPrice: 7500,
        creditPrice: 199,
        rarity: rarity.Legendary,
        getCanSpawnInGuild: (guildId) => {
          const last = guildId.slice(-1);
          const r = parseInt(last, 10);
          return !isNaN(r) && r % 2 === 0;
        },
        unavailableSurfaces: ["web"]
      },
      plant: {
        tileRef: tileRefsTallPlants.PalmTree,
        name: "Banana Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.3, y: -1.7, rotation: 10 },
          { x: -0.2, y: -1.7, rotation: -10 },
          { x: -0.1, y: -1.7, rotation: -30 },
          { x: 0, y: -1.7, rotation: -50 },
          { x: 0.1, y: -1.7, rotation: -70 }
        ],
        secondsToMature: 14400,
        baseTileScale: 2.5,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        nudgeY: -0.4
      },
      crop: {
        tileRef: tileRefsPlants.Banana,
        name: "Banana",
        baseSellPrice: 1750,
        baseWeight: 0.12,
        baseTileScale: 0.5,
        maxScale: 1.7
      }
    },
    Lily: {
      seed: {
        tileRef: tileRefsSeeds.Lily,
        name: "Lily Seed",
        coinPrice: 2e4,
        creditPrice: 34,
        rarity: rarity.Legendary
      },
      plant: {
        tileRef: tileRefsPlants.Lily,
        name: "Lily Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.75,
        nudgeY: -0.1
      },
      crop: {
        tileRef: tileRefsPlants.Lily,
        name: "Lily",
        baseSellPrice: 20123,
        baseWeight: 0.02,
        baseTileScale: 0.5,
        maxScale: 2.75
      }
    },
    Camellia: {
      seed: {
        tileRef: tileRefsSeeds.Camellia,
        name: "Camellia Seed",
        coinPrice: 55e3,
        creditPrice: 289,
        rarity: rarity.Legendary
      },
      plant: {
        tileRef: tileRefsPlants.Hedge,
        name: "Camellia Hedge",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: 0, y: -0.9, rotation: 0 },
          { x: -0.28, y: -0.6, rotation: 0 },
          { x: 0.28, y: -0.6, rotation: 0 },
          { x: -0.35, y: -0.2, rotation: 0 },
          { x: 0.32, y: -0.2, rotation: 0 },
          { x: -0.3, y: 0.25, rotation: 0 },
          { x: 0.28, y: 0.25, rotation: 0 },
          { x: 0, y: 0, rotation: 0 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 2,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.4,
        nudgeYMultiplier: 0.5
      },
      crop: {
        tileRef: tileRefsPlants.Camellia,
        name: "Camellia",
        baseSellPrice: 4875,
        baseWeight: 0.3,
        baseTileScale: 0.4,
        maxScale: 2.5
      }
    },
    Squash: {
      seed: {
        tileRef: tileRefsSeeds.Squash,
        name: "Squash Seed",
        coinPrice: 55e3,
        creditPrice: 199,
        rarity: rarity.Legendary
      },
      plant: {
        tileRef: tileRefsPlants.SproutFlower,
        name: "Squash Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.08, y: 0.2, rotation: 35 },
          { x: 0.2, y: 0, rotation: 35 },
          { x: -0.2, y: -0.1, rotation: 35 }
        ],
        secondsToMature: 1500,
        baseTileScale: 1.2,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.Squash,
        name: "Squash",
        baseSellPrice: 3500,
        baseWeight: 0.3,
        baseTileScale: 0.4,
        maxScale: 2.5
      }
    },
    BurrosTail: {
      seed: {
        tileRef: tileRefsSeeds.BurrosTail,
        name: "Burro's Tail Cutting",
        coinPrice: 93e3,
        creditPrice: 338,
        rarity: rarity.Legendary
      },
      plant: {
        tileRef: tileRefsPlants.Trellis,
        name: "Burro's Tail Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.13, y: -0.1, rotation: 0 },
          { x: 0.17, y: 0.13, rotation: 0 }
        ],
        secondsToMature: 1800,
        baseTileScale: 0.8,
        rotateSlotOffsetsRandomly: false
      },
      crop: {
        tileRef: tileRefsPlants.BurrosTail,
        name: "Burro's Tail",
        baseSellPrice: 6e3,
        baseWeight: 0.4,
        baseTileScale: 0.4,
        maxScale: 2.5
      }
    },
    Mushroom: {
      seed: {
        tileRef: tileRefsSeeds.Mushroom,
        name: "Mushroom Spore",
        coinPrice: 15e4,
        creditPrice: 249,
        rarity: rarity.Mythic
      },
      plant: {
        tileRef: tileRefsPlants.MushroomPlant,
        name: "Mushroom Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.8
      },
      crop: {
        tileRef: tileRefsPlants.Mushroom,
        name: "Mushroom",
        baseSellPrice: 16e4,
        baseWeight: 25,
        baseTileScale: 0.65,
        maxScale: 3.5
      }
    },
    Cactus: {
      seed: {
        tileRef: tileRefsSeeds.Cactus,
        name: "Cactus Seed",
        coinPrice: 25e4,
        creditPrice: 250,
        rarity: rarity.Mythic
      },
      plant: {
        tileRef: tileRefsTallPlants.Cactus,
        name: "Cactus Plant",
        harvestType: harvestType.Single,
        baseTileScale: 2.5,
        tileTransformOrigin: "bottom",
        nudgeY: -0.4,
        nudgeYMultiplier: 0.3
      },
      crop: {
        tileRef: tileRefsTallPlants.Cactus,
        name: "Cactus",
        baseSellPrice: 261e3,
        baseWeight: 1500,
        baseTileScale: 2.5,
        maxScale: 1.8
      }
    },
    Bamboo: {
      seed: {
        tileRef: tileRefsSeeds.Bamboo,
        name: "Bamboo Seed",
        coinPrice: 4e5,
        creditPrice: 300,
        rarity: rarity.Mythic
      },
      plant: {
        tileRef: tileRefsTallPlants.Bamboo,
        name: "Bamboo Plant",
        harvestType: harvestType.Single,
        baseTileScale: 2.5,
        tileTransformOrigin: "bottom",
        nudgeY: -0.45,
        nudgeYMultiplier: 0.3
      },
      crop: {
        tileRef: tileRefsTallPlants.Bamboo,
        name: "Bamboo Shoot",
        baseSellPrice: 5e5,
        baseWeight: 1,
        baseTileScale: 2.5,
        maxScale: 2
      }
    },
    Chrysanthemum: {
      seed: {
        tileRef: tileRefsSeeds.Chrysanthemum,
        name: "Chrysanthemum Seed",
        coinPrice: 67e4,
        creditPrice: 567,
        rarity: rarity.Mythic
      },
      plant: {
        tileRef: tileRefsPlants.FlowerBush,
        name: "Chrysanthemum Bush",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: 0, y: 0, rotation: 0 },
          { x: -0.28, y: 0.22, rotation: 0 },
          { x: 0.28, y: 0.22, rotation: 0 },
          { x: 0, y: 0.33, rotation: 0 },
          { x: -0.25, y: -0.2, rotation: 0 },
          { x: 0.25, y: -0.2, rotation: 0 },
          { x: 0, y: -0.28, rotation: 0 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom"
      },
      crop: {
        tileRef: tileRefsPlants.Chrysanthemum,
        name: "Chrysanthemum",
        baseSellPrice: 18e3,
        baseWeight: 0.01,
        baseTileScale: 0.3,
        maxScale: 2.75
      }
    },
    Grape: {
      seed: {
        tileRef: tileRefsSeeds.Grape,
        name: "Grape Seed",
        coinPrice: 85e4,
        creditPrice: 599,
        rarity: rarity.Mythic,
        getCanSpawnInGuild: (guildId) => guildId.endsWith("1"),
        unavailableSurfaces: ["web"]
      },
      plant: {
        tileRef: tileRefsPlants.SproutVine,
        name: "Grape Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: 0, y: 0, rotation: 0 }],
        secondsToMature: 1440 * 60,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.Grape,
        name: "Grape",
        baseSellPrice: 12500,
        baseWeight: 3,
        baseTileScale: 0.5,
        maxScale: 2
      }
    },
    Pepper: {
      seed: {
        tileRef: tileRefsSeeds.Pepper,
        name: "Pepper Seed",
        coinPrice: 1e6,
        creditPrice: 629,
        rarity: rarity.Divine
      },
      plant: {
        tileRef: tileRefsPlants.SproutVine,
        name: "Pepper Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.02, y: 0.219, rotation: 0 },
          { x: 0.172, y: 0.172, rotation: 0 },
          { x: -0.172, y: 0.137, rotation: 0 },
          { x: 0.168, y: -0.035, rotation: 0 },
          { x: -0.082, y: -0.047, rotation: 0 },
          { x: -0.207, y: -0.074, rotation: 0 },
          { x: 0.18, y: -0.176, rotation: 0 },
          { x: -0.273, y: -0.195, rotation: 0 },
          { x: -0.074, y: -0.25, rotation: 0 }
        ],
        secondsToMature: 560,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.Pepper,
        name: "Pepper",
        baseSellPrice: 7220,
        baseWeight: 0.5,
        baseTileScale: 0.3,
        maxScale: 2
      }
    },
    Lemon: {
      seed: {
        tileRef: tileRefsSeeds.Lemon,
        name: "Lemon Seed",
        coinPrice: 2e6,
        creditPrice: 500,
        rarity: rarity.Divine,
        getCanSpawnInGuild: (guildId) => guildId.endsWith("2"),
        unavailableSurfaces: ["web"]
      },
      plant: {
        tileRef: tileRefsTallPlants.Tree,
        name: "Lemon Tree",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.5, y: -1.5, rotation: 0 },
          { x: 0.4, y: -1.6, rotation: 0 },
          { x: -0.3, y: -1.18, rotation: 0 },
          { x: 0.2, y: -1.2, rotation: 0 },
          { x: 0.01, y: -1.5, rotation: 0 },
          { x: -0.05, y: -1.8, rotation: 0 }
        ],
        secondsToMature: 720 * 60,
        baseTileScale: 2.3,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.25
      },
      crop: {
        tileRef: tileRefsPlants.Lemon,
        name: "Lemon",
        baseSellPrice: 1e4,
        baseWeight: 0.5,
        baseTileScale: 0.25,
        maxScale: 3
      }
    },
    PassionFruit: {
      seed: {
        tileRef: tileRefsSeeds.PassionFruit,
        name: "Passion Fruit Seed",
        coinPrice: 275e4,
        creditPrice: 679,
        rarity: rarity.Divine
      },
      plant: {
        tileRef: tileRefsPlants.SproutVine,
        name: "Passion Fruit Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.3, y: -0.3, rotation: 0 },
          { x: 0.3, y: 0.3, rotation: 0 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 1.1,
        rotateSlotOffsetsRandomly: false
      },
      crop: {
        tileRef: tileRefsPlants.PassionFruit,
        name: "Passion Fruit",
        baseSellPrice: 24500,
        baseWeight: 9.5,
        baseTileScale: 0.35,
        maxScale: 2
      }
    },
    DragonFruit: {
      seed: {
        tileRef: tileRefsSeeds.DragonFruit,
        name: "Dragon Fruit Seed",
        coinPrice: 5e6,
        creditPrice: 715,
        rarity: rarity.Divine
      },
      plant: {
        tileRef: tileRefsPlants.PalmTreeTop,
        name: "Dragon Fruit Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.3, y: -0.4, rotation: 0 },
          { x: -0.4, y: -0.05, rotation: 0 },
          { x: 0.36, y: -0.3, rotation: 0 },
          { x: -0.25, y: 0.3, rotation: 0 },
          { x: 0, y: -0.1, rotation: 0 },
          { x: 0.4, y: 0.1, rotation: 0 },
          { x: 0.1, y: 0.2, rotation: 0 }
        ],
        secondsToMature: 600,
        baseTileScale: 1.6,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.DragonFruit,
        name: "Dragon Fruit",
        baseSellPrice: 24500,
        baseWeight: 8.4,
        baseTileScale: 0.4,
        maxScale: 2
      }
    },
    Cacao: {
      seed: {
        tileRef: tileRefsSeeds.Cacao,
        name: "Cacao Bean",
        coinPrice: 1e7,
        creditPrice: 750,
        rarity: rarity.Divine
      },
      plant: {
        tileRef: tileRefsTallPlants.CacaoTree,
        name: "Cacao Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: 0.28, y: -1.17, rotation: 20 },
          { x: -0.3, y: -1.07, rotation: 20 },
          { x: -0.05, y: -1.42, rotation: 20 },
          { x: 0.45, y: -1.67, rotation: 20 },
          { x: -0.5, y: -1.57, rotation: 20 },
          { x: -0.05, y: -1.87, rotation: 20 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 2.8,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.32
      },
      crop: {
        tileRef: tileRefsPlants.Cacao,
        name: "Cacao Fruit",
        baseSellPrice: 7e4,
        baseWeight: 0.5,
        baseTileScale: 0.4,
        maxScale: 2.5
      }
    },
    Lychee: {
      seed: {
        tileRef: tileRefsSeeds.Lychee,
        name: "Lychee Pit",
        coinPrice: 25e6,
        creditPrice: 819,
        rarity: rarity.Divine,
        getCanSpawnInGuild: (guildId) => guildId.endsWith("2"),
        unavailableSurfaces: ["web"]
      },
      plant: {
        tileRef: tileRefsPlants.BushyTree,
        name: "Lychee Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.4, y: -0.1, rotation: 0 },
          { x: 0.3, y: -0.2, rotation: 0 },
          { x: -0.3, y: 0.22, rotation: 0 },
          { x: 0.2, y: 0.2, rotation: 0 },
          { x: 0.01, y: -0.1, rotation: 0 },
          { x: -0.2, y: -0.3, rotation: 0 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 1.2,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.Lychee,
        name: "Lychee Fruit",
        baseSellPrice: 5e4,
        baseWeight: 9,
        baseTileScale: 0.2,
        maxScale: 2
      }
    },
    Sunflower: {
      seed: {
        tileRef: tileRefsSeeds.Sunflower,
        name: "Sunflower Seed",
        coinPrice: 1e8,
        creditPrice: 900,
        rarity: rarity.Divine
      },
      plant: {
        tileRef: tileRefsPlants.StemFlower,
        name: "Sunflower Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: 0.01, y: -0.6, rotation: 0 }],
        secondsToMature: 1440 * 60,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        baseTileScale: 0.8,
        nudgeY: -0.35
      },
      crop: {
        tileRef: tileRefsPlants.Sunflower,
        name: "Sunflower",
        baseSellPrice: 75e4,
        baseWeight: 10,
        baseTileScale: 0.5,
        maxScale: 2.5
      }
    },
    Starweaver: {
      seed: {
        tileRef: tileRefsSeeds.Starweaver,
        name: "Starweaver Pod",
        coinPrice: 1e9,
        creditPrice: 1e3,
        rarity: rarity.Celestial
      },
      plant: {
        tileRef: tileRefsTallPlants.StarweaverPlant,
        name: "Starweaver Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: 0, y: -0.918, rotation: 0 }],
        secondsToMature: 1440 * 60,
        baseTileScale: 1.5,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        nudgeY: -0.27,
        immatureTileRef: tileRefsTallPlants.StarweaverPlatform,
        isFixedScale: true,
        growingAnimationTiles: { frames: 10, row: 8, fps: 20, nudgeY: -0.2 }
      },
      crop: {
        tileRef: tileRefsPlants.Starweaver,
        name: "Starweaver Fruit",
        baseSellPrice: 1e7,
        baseWeight: 10,
        baseTileScale: 0.6,
        maxScale: 2
      }
    },
    DawnCelestial: {
      seed: {
        tileRef: tileRefsSeeds.DawnCelestial,
        name: "Dawnbinder Pod",
        coinPrice: 1e10,
        creditPrice: 1129,
        rarity: rarity.Celestial
      },
      plant: {
        tileRef: tileRefsTallPlants.DawnCelestialPlant,
        name: "Dawnbinder",
        harvestType: harvestType.Multiple,
        secondsToMature: 1440 * 60,
        slotOffsets: [{ x: -0.015, y: -0.95, rotation: 0 }],
        baseTileScale: 2.3,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        nudgeY: -0.2,
        abilities: ["DawnKisser"],
        activeState: {
          tileRef: tileRefsTallPlants.DawnCelestialPlantActive,
          activeAnimationTiles: { frames: 10, row: 6, fps: 20, nudgeY: -0.1 }
        },
        topmostLayerTileRef: tileRefsTallPlants.DawnCelestialPlatformTopmostLayer,
        immatureTileRef: tileRefsTallPlants.DawnCelestialPlatform,
        isFixedScale: true,
        growingAnimationTiles: { frames: 10, row: 8, fps: 20, nudgeY: -0.2 }
      },
      crop: {
        tileRef: tileRefsPlants.DawnCelestialCrop,
        name: "Dawnbinder Bulb",
        baseSellPrice: 11e6,
        baseWeight: 6,
        baseTileScale: 0.4,
        maxScale: 2.5,
        transformOrigin: "top"
      }
    },
    MoonCelestial: {
      seed: {
        tileRef: tileRefsSeeds.MoonCelestial,
        name: "Moonbinder Pod",
        coinPrice: 5e10,
        creditPrice: 1249,
        rarity: rarity.Celestial
      },
      plant: {
        tileRef: tileRefsTallPlants.MoonCelestialPlant,
        name: "Moonbinder",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: 0.01, y: -1.81, rotation: 0 },
          { x: -0.26, y: -0.82, rotation: -20 },
          { x: 0.23, y: -1, rotation: 20 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 2.5,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        nudgeY: -0.2,
        abilities: ["MoonKisser"],
        activeState: {
          tileRef: tileRefsTallPlants.MoonCelestialPlantActive,
          activeAnimationTiles: { frames: 10, row: 6, fps: 20, nudgeY: -0.1 }
        },
        immatureTileRef: tileRefsTallPlants.MoonCelestialPlatform,
        isFixedScale: true,
        growingAnimationTiles: { frames: 10, row: 8, fps: 20, nudgeY: -0.2 }
      },
      crop: {
        tileRef: tileRefsPlants.MoonCelestialCrop,
        name: "Moonbinder Bulb",
        baseSellPrice: 11e6,
        baseWeight: 2,
        baseTileScale: 0.4,
        maxScale: 2,
        transformOrigin: "bottom"
      }
    }
  };
  var mutationCatalog = {
    Gold: { name: "Gold", baseChance: 0.01, coinMultiplier: 25 },
    Rainbow: { name: "Rainbow", baseChance: 1e-3, coinMultiplier: 50 },
    Wet: { name: "Wet", baseChance: 0, coinMultiplier: 2, tileRef: tileRefsMutations.Wet },
    Chilled: { name: "Chilled", baseChance: 0, coinMultiplier: 2, tileRef: tileRefsMutations.Chilled },
    Frozen: { name: "Frozen", baseChance: 0, coinMultiplier: 10, tileRef: tileRefsMutations.Frozen },
    Dawnlit: { name: "Dawnlit", baseChance: 0, coinMultiplier: 2, tileRef: tileRefsMutations.Dawnlit },
    Amberlit: { name: "Amberlit", baseChance: 0, coinMultiplier: 5, tileRef: tileRefsMutations.Amberlit },
    Dawncharged: { name: "Dawnbound", baseChance: 0, coinMultiplier: 3, tileRef: tileRefsMutations.Dawncharged },
    Ambercharged: { name: "Amberbound", baseChance: 0, coinMultiplier: 6, tileRef: tileRefsMutations.Ambercharged }
  };
  var eggCatalog = {
    CommonEgg: { tileRef: tileRefsPets.CommonEgg, name: "Common Egg", coinPrice: 1e5, creditPrice: 19, rarity: rarity.Common, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 600, faunaSpawnWeights: { Worm: 60, Snail: 35, Bee: 5 } },
    UncommonEgg: { tileRef: tileRefsPets.UncommonEgg, name: "Uncommon Egg", coinPrice: 1e6, creditPrice: 48, rarity: rarity.Uncommon, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 3600, faunaSpawnWeights: { Chicken: 65, Bunny: 25, Dragonfly: 10 } },
    RareEgg: { tileRef: tileRefsPets.RareEgg, name: "Rare Egg", coinPrice: 1e7, creditPrice: 99, rarity: rarity.Rare, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 21600, faunaSpawnWeights: { Pig: 90, Cow: 10 } },
    LegendaryEgg: { tileRef: tileRefsPets.LegendaryEgg, name: "Legendary Egg", coinPrice: 1e8, creditPrice: 249, rarity: rarity.Legendary, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 43200, faunaSpawnWeights: { Squirrel: 60, Turtle: 30, Goat: 10 } },
    MythicalEgg: { tileRef: tileRefsPets.MythicalEgg, name: "Mythical Egg", coinPrice: 1e9, creditPrice: 599, rarity: rarity.Mythic, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 86400, faunaSpawnWeights: { Butterfly: 75, Capybara: 5, Peacock: 20 } }
  };
  var petCatalog = {
    Worm: {
      tileRef: tileRefsPets.Worm,
      name: "Worm",
      description: "",
      coinsToFullyReplenishHunger: 500,
      innateAbilityWeights: { SeedFinderI: 50, ProduceEater: 50 },
      baseTileScale: 0.6,
      maxScale: 2,
      maturitySellPrice: 5e3,
      matureWeight: 0.1,
      moveProbability: 0.1,
      hoursToMature: 12,
      rarity: rarity.Common,
      tileTransformOrigin: "bottom",
      nudgeY: -0.25,
      diet: ["Carrot", "Strawberry", "Aloe", "Tomato", "Apple"]
    },
    Snail: {
      tileRef: tileRefsPets.Snail,
      name: "Snail",
      description: "",
      coinsToFullyReplenishHunger: 1e3,
      innateAbilityWeights: { CoinFinderI: 100 },
      baseTileScale: 0.6,
      maxScale: 2,
      maturitySellPrice: 1e4,
      matureWeight: 0.15,
      moveProbability: 0.01,
      hoursToMature: 12,
      rarity: rarity.Common,
      tileTransformOrigin: "bottom",
      nudgeY: -0.25,
      diet: ["Blueberry", "Tomato", "Corn", "Daffodil", "Chrysanthemum"]
    },
    Bee: {
      tileRef: tileRefsPets.Bee,
      name: "Bee",
      coinsToFullyReplenishHunger: 1500,
      innateAbilityWeights: { ProduceScaleBoost: 50, ProduceMutationBoost: 50 },
      baseTileScale: 0.6,
      maxScale: 2.5,
      maturitySellPrice: 3e4,
      matureWeight: 0.2,
      moveProbability: 0.5,
      hoursToMature: 12,
      rarity: rarity.Common,
      diet: ["Strawberry", "Blueberry", "Daffodil", "Lily", "Chrysanthemum"]
    },
    Chicken: {
      tileRef: tileRefsPets.Chicken,
      name: "Chicken",
      coinsToFullyReplenishHunger: 3e3,
      innateAbilityWeights: { EggGrowthBoost: 80, PetRefund: 20 },
      baseTileScale: 0.8,
      maxScale: 2,
      maturitySellPrice: 5e4,
      matureWeight: 3,
      moveProbability: 0.2,
      hoursToMature: 24,
      rarity: rarity.Uncommon,
      tileTransformOrigin: "bottom",
      nudgeY: -0.2,
      diet: ["Aloe", "Corn", "Watermelon", "Pumpkin"]
    },
    Bunny: {
      tileRef: tileRefsPets.Bunny,
      name: "Bunny",
      coinsToFullyReplenishHunger: 750,
      innateAbilityWeights: { CoinFinderII: 60, SellBoostI: 40 },
      baseTileScale: 0.7,
      maxScale: 2,
      maturitySellPrice: 75e3,
      matureWeight: 2,
      moveProbability: 0.3,
      hoursToMature: 24,
      rarity: rarity.Uncommon,
      tileTransformOrigin: "bottom",
      nudgeY: -0.2,
      diet: ["Carrot", "Strawberry", "Blueberry", "OrangeTulip", "Apple"]
    },
    Dragonfly: {
      tileRef: tileRefsPets.Dragonfly,
      name: "Dragonfly",
      coinsToFullyReplenishHunger: 250,
      innateAbilityWeights: { HungerRestore: 70, PetMutationBoost: 30 },
      baseTileScale: 0.6,
      maxScale: 2.5,
      maturitySellPrice: 15e4,
      matureWeight: 0.2,
      moveProbability: 0.7,
      hoursToMature: 24,
      rarity: rarity.Uncommon,
      tileTransformOrigin: "center",
      diet: ["Apple", "OrangeTulip", "Echeveria"]
    },
    Pig: {
      tileRef: tileRefsPets.Pig,
      name: "Pig",
      coinsToFullyReplenishHunger: 5e4,
      innateAbilityWeights: { SellBoostII: 30, PetAgeBoost: 30, PetHatchSizeBoost: 30 },
      baseTileScale: 1,
      maxScale: 2.5,
      maturitySellPrice: 5e5,
      matureWeight: 200,
      moveProbability: 0.2,
      hoursToMature: 72,
      rarity: rarity.Rare,
      tileTransformOrigin: "bottom",
      nudgeY: -0.15,
      diet: ["Watermelon", "Pumpkin", "Mushroom", "Bamboo"]
    },
    Cow: {
      tileRef: tileRefsPets.Cow,
      name: "Cow",
      coinsToFullyReplenishHunger: 25e3,
      innateAbilityWeights: { SeedFinderII: 30, HungerBoost: 30, PlantGrowthBoost: 30 },
      baseTileScale: 1.1,
      maxScale: 2.5,
      maturitySellPrice: 1e6,
      matureWeight: 600,
      moveProbability: 0.1,
      hoursToMature: 72,
      rarity: rarity.Rare,
      tileTransformOrigin: "bottom",
      nudgeY: -0.15,
      diet: ["Coconut", "Banana", "BurrosTail", "Mushroom"]
    },
    Turkey: {
      tileRef: tileRefsPets.Turkey,
      name: "Turkey",
      coinsToFullyReplenishHunger: 500,
      innateAbilityWeights: { RainDance: 60, EggGrowthBoostII_NEW: 35, DoubleHatch: 5 },
      baseTileScale: 1,
      maxScale: 2.5,
      maturitySellPrice: 3e6,
      matureWeight: 10,
      moveProbability: 0.25,
      hoursToMature: 72,
      rarity: rarity.Rare,
      tileTransformOrigin: "bottom",
      nudgeY: -0.15,
      diet: ["FavaBean", "Corn", "Squash"]
    },
    Squirrel: {
      tileRef: tileRefsPets.Squirrel,
      name: "Squirrel",
      coinsToFullyReplenishHunger: 15e3,
      innateAbilityWeights: { CoinFinderIII: 70, SellBoostIII: 20, PetMutationBoostII: 10 },
      baseTileScale: 0.6,
      maxScale: 2,
      maturitySellPrice: 5e6,
      matureWeight: 0.5,
      moveProbability: 0.4,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      tileTransformOrigin: "bottom",
      nudgeY: -0.1,
      diet: ["Pumpkin", "Banana", "Grape"]
    },
    Turtle: {
      tileRef: tileRefsPets.Turtle,
      name: "Turtle",
      coinsToFullyReplenishHunger: 1e5,
      innateAbilityWeights: { HungerRestoreII: 25, HungerBoostII: 25, PlantGrowthBoostII: 25, EggGrowthBoostII: 25 },
      baseTileScale: 1,
      maxScale: 2.5,
      maturitySellPrice: 1e7,
      matureWeight: 150,
      moveProbability: 0.05,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      tileTransformOrigin: "bottom",
      nudgeY: -0.15,
      diet: ["Watermelon", "BurrosTail", "Bamboo", "Pepper"]
    },
    Goat: {
      tileRef: tileRefsPets.Goat,
      name: "Goat",
      coinsToFullyReplenishHunger: 2e4,
      innateAbilityWeights: { PetHatchSizeBoostII: 10, PetAgeBoostII: 40, PetXpBoost: 40 },
      baseTileScale: 1,
      maxScale: 2,
      maturitySellPrice: 2e7,
      matureWeight: 100,
      moveProbability: 0.2,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      tileTransformOrigin: "bottom",
      nudgeY: -0.1,
      diet: ["Pumpkin", "Coconut", "Pepper", "Camellia", "PassionFruit"]
    },
    Butterfly: {
      tileRef: tileRefsPets.Butterfly,
      name: "Butterfly",
      coinsToFullyReplenishHunger: 25e3,
      innateAbilityWeights: { ProduceScaleBoostII: 40, ProduceMutationBoostII: 40, SeedFinderIII: 20 },
      baseTileScale: 0.6,
      maxScale: 2.5,
      maturitySellPrice: 5e7,
      matureWeight: 0.2,
      moveProbability: 0.6,
      hoursToMature: 144,
      rarity: rarity.Mythic,
      tileTransformOrigin: "center",
      diet: ["Daffodil", "Lily", "Grape", "Lemon", "Sunflower"]
    },
    Capybara: {
      tileRef: tileRefsPets.Capybara,
      name: "Capybara",
      coinsToFullyReplenishHunger: 15e4,
      innateAbilityWeights: { DoubleHarvest: 50, ProduceRefund: 50 },
      baseTileScale: 1,
      maxScale: 2.5,
      maturitySellPrice: 2e8,
      matureWeight: 50,
      moveProbability: 0.2,
      hoursToMature: 144,
      rarity: rarity.Mythic,
      tileTransformOrigin: "bottom",
      nudgeY: -0.1,
      diet: ["Lemon", "PassionFruit", "DragonFruit", "Lychee"]
    },
    Peacock: {
      tileRef: tileRefsPets.Peacock,
      name: "Peacock",
      coinsToFullyReplenishHunger: 1e5,
      innateAbilityWeights: { SellBoostIV: 40, PetXpBoostII: 50, PetRefundII: 10 },
      baseTileScale: 1.2,
      maxScale: 2.5,
      maturitySellPrice: 1e8,
      matureWeight: 5,
      moveProbability: 0.2,
      hoursToMature: 144,
      rarity: rarity.Mythic,
      tileTransformOrigin: "bottom",
      nudgeY: -0.1,
      diet: ["Cactus", "Sunflower", "Lychee"]
    }
  };
  var petAbilities = {
    ProduceScaleBoost: {
      name: "Crop Size Boost I",
      description: "Increases the scale of garden crops",
      trigger: "continuous",
      baseProbability: 0.3,
      baseParameters: { scaleIncreasePercentage: 6 }
    },
    ProduceScaleBoostII: {
      name: "Crop Size Boost II",
      description: "Increases the scale of garden crops",
      trigger: "continuous",
      baseProbability: 0.4,
      baseParameters: { scaleIncreasePercentage: 10 }
    },
    DoubleHarvest: {
      name: "Double Harvest",
      description: "Chance to duplicate harvested crops",
      trigger: "harvest",
      baseProbability: 5,
      baseParameters: {}
    },
    DoubleHatch: {
      name: "Double Hatch",
      description: "Chance to hatch an extra pet from eggs",
      trigger: "hatchEgg",
      baseProbability: 3,
      baseParameters: {}
    },
    ProduceEater: {
      name: "Crop Eater",
      description: "Harvests non-mutated crops and sells them",
      trigger: "continuous",
      baseProbability: 60,
      baseParameters: { cropSellPriceIncreasePercentage: 150 }
    },
    SellBoostI: {
      name: "Sell Boost I",
      description: "Receive bonus coins when selling crops",
      trigger: "sellAllCrops",
      baseProbability: 10,
      baseParameters: { cropSellPriceIncreasePercentage: 20 }
    },
    SellBoostII: {
      name: "Sell Boost II",
      description: "Receive bonus coins when selling crops",
      trigger: "sellAllCrops",
      baseProbability: 12,
      baseParameters: { cropSellPriceIncreasePercentage: 30 }
    },
    SellBoostIII: {
      name: "Sell Boost III",
      description: "Receive bonus coins when selling crops",
      trigger: "sellAllCrops",
      baseProbability: 14,
      baseParameters: { cropSellPriceIncreasePercentage: 40 }
    },
    SellBoostIV: {
      name: "Sell Boost IV",
      description: "Receive bonus coins when selling crops",
      trigger: "sellAllCrops",
      baseProbability: 16,
      baseParameters: { cropSellPriceIncreasePercentage: 50 }
    },
    ProduceRefund: {
      name: "Crop Refund",
      description: "Chance to get crops back when selling",
      trigger: "sellAllCrops",
      baseProbability: 20,
      baseParameters: {}
    },
    PlantGrowthBoost: {
      name: "Plant Growth Boost I",
      description: "Reduces the time for plants to grow",
      trigger: "continuous",
      baseProbability: 24,
      baseParameters: { plantGrowthReductionMinutes: 3 }
    },
    PlantGrowthBoostII: {
      name: "Plant Growth Boost II",
      description: "Reduces the time for plants to grow",
      trigger: "continuous",
      baseProbability: 27,
      baseParameters: { plantGrowthReductionMinutes: 5 }
    },
    ProduceMutationBoost: {
      name: "Crop Mutation Boost I",
      description: "Increases the chance of garden crops gaining mutations",
      trigger: "continuous",
      baseParameters: { mutationChanceIncreasePercentage: 10 }
    },
    ProduceMutationBoostII: {
      name: "Crop Mutation Boost II",
      description: "Increases the chance of garden crops gaining mutations",
      trigger: "continuous",
      baseParameters: { mutationChanceIncreasePercentage: 15 }
    },
    PetMutationBoost: {
      name: "Pet Mutation Boost I",
      description: "Increases the chance of hatched pets gaining mutations",
      trigger: "hatchEgg",
      baseParameters: { mutationChanceIncreasePercentage: 7 }
    },
    PetMutationBoostII: {
      name: "Pet Mutation Boost II",
      description: "Increases the chance of hatched pets gaining mutations",
      trigger: "hatchEgg",
      baseParameters: { mutationChanceIncreasePercentage: 10 }
    },
    GoldGranter: {
      name: "Gold Granter",
      description: "Grants the Gold mutation to a garden crop",
      trigger: "continuous",
      baseProbability: 0.72,
      baseParameters: { grantedMutations: ["Gold"] }
    },
    RainbowGranter: {
      name: "Rainbow Granter",
      description: "Grants the Rainbow mutation to a garden crop",
      trigger: "continuous",
      baseProbability: 0.72,
      baseParameters: { grantedMutations: ["Rainbow"] }
    },
    RainDance: {
      name: "Rain Dance",
      description: "Grants the Wet mutation to a garden crop",
      trigger: "continuous",
      baseProbability: 10,
      baseParameters: { grantedMutations: ["Wet"] }
    },
    EggGrowthBoost: {
      name: "Egg Growth Boost I",
      description: "Reduces the time for eggs to hatch",
      trigger: "continuous",
      baseProbability: 21,
      baseParameters: { eggGrowthTimeReductionMinutes: 7 }
    },
    // utilis par la dinde: EggGrowthBoostII_NEW
    EggGrowthBoostII_NEW: {
      name: "Egg Growth Boost II",
      description: "Reduces the time for eggs to hatch",
      trigger: "continuous",
      baseProbability: 24,
      baseParameters: { eggGrowthTimeReductionMinutes: 9 }
    },
    // ancien EggGrowthBoostIII remplac par ce bloc
    EggGrowthBoostII: {
      name: "Egg Growth Boost III",
      description: "Reduces the time for eggs to hatch",
      trigger: "continuous",
      baseProbability: 27,
      baseParameters: { eggGrowthTimeReductionMinutes: 11 }
    },
    PetAgeBoost: {
      name: "Hatch XP Boost I",
      description: "Hatched pets start with bonus XP",
      trigger: "hatchEgg",
      baseProbability: 50,
      baseParameters: { bonusXp: 8e3 }
    },
    PetAgeBoostII: {
      name: "Hatch XP Boost II",
      description: "Hatched pets start with bonus XP",
      trigger: "hatchEgg",
      baseProbability: 60,
      baseParameters: { bonusXp: 12e3 }
    },
    PetHatchSizeBoost: {
      name: "Max Strength Boost I",
      description: "Increases the maximum strength of hatched pets",
      trigger: "hatchEgg",
      baseProbability: 12,
      baseParameters: { maxStrengthIncreasePercentage: 2.4 }
    },
    PetHatchSizeBoostII: {
      name: "Max Strength Boost II",
      description: "Increases the maximum strength of hatched pets",
      trigger: "hatchEgg",
      baseProbability: 14,
      baseParameters: { maxStrengthIncreasePercentage: 3.5 }
    },
    PetXpBoost: {
      name: "XP Boost I",
      description: "Gives bonus XP to active pets",
      trigger: "continuous",
      baseProbability: 30,
      baseParameters: { bonusXp: 300 }
    },
    PetXpBoostII: {
      name: "XP Boost II",
      description: "Gives bonus XP to active pets",
      trigger: "continuous",
      baseProbability: 35,
      baseParameters: { bonusXp: 400 }
    },
    HungerRestore: {
      name: "Hunger Restore I",
      description: "Restores the hunger of a random active pet",
      trigger: "continuous",
      baseProbability: 12,
      baseParameters: { hungerRestorePercentage: 30 }
    },
    HungerRestoreII: {
      name: "Hunger Restore II",
      description: "Restores the hunger of a random active pet",
      trigger: "continuous",
      baseProbability: 14,
      baseParameters: { hungerRestorePercentage: 35 }
    },
    HungerBoost: {
      name: "Hunger Boost I",
      description: "Reduces the hunger depletion rate of active pets",
      trigger: "continuous",
      baseParameters: { hungerDepletionRateDecreasePercentage: 12 }
    },
    HungerBoostII: {
      name: "Hunger Boost II",
      description: "Reduces the hunger depletion rate of active pets",
      trigger: "continuous",
      baseParameters: { hungerDepletionRateDecreasePercentage: 16 }
    },
    PetRefund: {
      name: "Pet Refund I",
      description: "Chance to receive the pet back as an egg when sold",
      trigger: "sellPet",
      baseProbability: 5,
      baseParameters: {}
    },
    PetRefundII: {
      name: "Pet Refund II",
      description: "Chance to receive the pet back as an egg when sold",
      trigger: "sellPet",
      baseProbability: 7,
      baseParameters: {}
    },
    Copycat: {
      name: "Copycat",
      description: "Chance to copy the ability of another active pet",
      trigger: "continuous",
      baseProbability: 1,
      baseParameters: {}
    },
    CoinFinderI: {
      name: "Coin Finder I",
      description: "Finds coins in your garden",
      trigger: "continuous",
      baseProbability: 35,
      baseParameters: { baseMaxCoinsFindable: 12e4 }
    },
    CoinFinderII: {
      name: "Coin Finder II",
      description: "Finds coins in your garden",
      trigger: "continuous",
      baseProbability: 13,
      baseParameters: { baseMaxCoinsFindable: 12e5 }
    },
    CoinFinderIII: {
      name: "Coin Finder III",
      description: "Finds coins in your garden",
      trigger: "continuous",
      baseProbability: 6,
      baseParameters: { baseMaxCoinsFindable: 1e7 }
    },
    SeedFinderI: {
      name: "Seed Finder I",
      description: "Finds common and uncommon seeds in your garden",
      trigger: "continuous",
      baseProbability: 40,
      baseParameters: {}
    },
    SeedFinderII: {
      name: "Seed Finder II",
      description: "Finds rare and legendary seeds in your garden",
      trigger: "continuous",
      baseProbability: 20,
      baseParameters: {}
    },
    SeedFinderIII: {
      name: "Seed Finder III",
      description: "Finds mythical seeds in your garden",
      trigger: "continuous",
      baseProbability: 10,
      baseParameters: {}
    },
    SeedFinderIV: {
      name: "Seed Finder IV",
      description: "Finds divine and celestial seeds in your garden",
      trigger: "continuous",
      baseProbability: 0.01,
      baseParameters: {}
    },
    MoonKisser: {
      name: "Moon Kisser",
      description: "Empowers amber moon crops with special mutations",
      trigger: "continuous",
      baseParameters: {}
    },
    DawnKisser: {
      name: "Dawn Kisser",
      description: "Empowers dawn crops with special mutations",
      trigger: "continuous",
      baseParameters: {}
    }
  };
  var toolCatalog = {
    WateringCan: {
      tileRef: tileRefsItems.WateringCan,
      name: "Watering Can",
      coinPrice: 5e3,
      creditPrice: 2,
      rarity: rarity.Common,
      description: "Speeds up growth of plant by 5 minutes. SINGLE USE.",
      isOneTimePurchase: false,
      baseTileScale: 0.6,
      maxInventoryQuantity: 99
    },
    PlanterPot: {
      tileRef: tileRefsItems.PlanterPot,
      name: "Planter Pot",
      coinPrice: 25e3,
      creditPrice: 5,
      rarity: rarity.Common,
      description: "Extract a plant to your inventory (can be replanted). SINGLE USE.",
      isOneTimePurchase: false,
      baseTileScale: 0.8
    },
    Shovel: {
      tileRef: tileRefsItems.Shovel,
      name: "Garden Shovel",
      coinPrice: 1e6,
      creditPrice: 100,
      rarity: rarity.Uncommon,
      description: "Remove plants from your garden. UNLIMITED USES.",
      isOneTimePurchase: true,
      baseTileScale: 0.7
    },
    RainbowPotion: {
      tileRef: tileRefsItems.RainbowPotion,
      name: "Rainbow Potion",
      coinPrice: 1 / 0,
      creditPrice: 1 / 0,
      rarity: rarity.Celestial,
      description: "Adds the Rainbow mutation to a crop in your garden. SINGLE USE.",
      isOneTimePurchase: true,
      baseTileScale: 1
    }
  };
  var decorCatalog = {
    // Rochers
    SmallRock: {
      tileRef: tileRefsDecor.SmallRock,
      name: "Small Garden Rock",
      coinPrice: 1e3,
      creditPrice: 2,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    MediumRock: {
      tileRef: tileRefsDecor.MediumRock,
      name: "Medium Garden Rock",
      coinPrice: 2500,
      creditPrice: 5,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    LargeRock: {
      tileRef: tileRefsDecor.LargeRock,
      name: "Large Garden Rock",
      coinPrice: 5e3,
      creditPrice: 10,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    // Bois
    WoodBench: {
      tileRef: tileRefsDecor.WoodBench,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.WoodBenchSideways, flipH: true, baseTileScale: 1.46, nudgeY: -0.3 },
        180: { tileRef: tileRefsDecor.WoodBenchBackwards },
        270: { tileRef: tileRefsDecor.WoodBenchSideways, baseTileScale: 1.46, nudgeY: -0.3 }
      },
      name: "Wood Bench",
      coinPrice: 1e4,
      creditPrice: 15,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.3,
      avatarNudgeY: -0.18
    },
    WoodArch: {
      tileRef: tileRefsDecor.WoodArch,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.WoodArchSide, flipH: true, baseTileScale: 2.1, nudgeY: -0.48 },
        180: { tileRef: tileRefsDecor.WoodArch, flipH: true },
        270: { tileRef: tileRefsDecor.WoodArchSide, baseTileScale: 2.1, nudgeY: -0.48 }
      },
      name: "Wood Arch",
      coinPrice: 2e4,
      creditPrice: 25,
      rarity: rarity.Common,
      baseTileScale: 1.53,
      isOneTimePurchase: false,
      nudgeY: -0.5
    },
    WoodBridge: {
      tileRef: tileRefsDecor.WoodBridge,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.WoodBridgeSideways, flipH: true, baseTileScale: 1.7, nudgeY: -0.28 },
        180: { tileRef: tileRefsDecor.WoodBridge, flipH: true },
        270: { tileRef: tileRefsDecor.WoodBridgeSideways, baseTileScale: 1.7, nudgeY: -0.28 }
      },
      name: "Wood Bridge",
      coinPrice: 4e4,
      creditPrice: 35,
      rarity: rarity.Common,
      baseTileScale: 1.22,
      isOneTimePurchase: false,
      nudgeY: -0.35,
      avatarNudgeY: -0.44
    },
    WoodLampPost: {
      tileRef: tileRefsDecor.WoodLampPost,
      name: "Wood Lamp Post",
      coinPrice: 8e4,
      creditPrice: 49,
      rarity: rarity.Common,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.6
    },
    WoodOwl: {
      tileRef: tileRefsDecor.WoodOwl,
      name: "Wood Owl",
      coinPrice: 9e4,
      creditPrice: 59,
      rarity: rarity.Common,
      baseTileScale: 1.3,
      isOneTimePurchase: false,
      nudgeY: -0.4
    },
    WoodBirdhouse: {
      tileRef: tileRefsDecor.Birdhouse,
      name: "Wood Birdhouse",
      coinPrice: 1e5,
      creditPrice: 69,
      rarity: rarity.Common,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.6
    },
    WoodWindmill: {
      tileRef: tileRefsDecor.WoodWindmill,
      name: "Wood Windmill",
      coinPrice: 5e5,
      creditPrice: 74,
      rarity: rarity.Common,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.47
    },
    // Pierre
    StoneBench: {
      tileRef: tileRefsDecor.StoneBench,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.StoneBenchSideways, flipH: true, baseTileScale: 1.47, nudgeY: -0.3 },
        180: { tileRef: tileRefsDecor.StoneBench, flipH: true },
        270: { tileRef: tileRefsDecor.StoneBenchSideways, baseTileScale: 1.47, nudgeY: -0.3 }
      },
      name: "Stone Bench",
      coinPrice: 1e6,
      creditPrice: 75,
      rarity: rarity.Uncommon,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.3,
      avatarNudgeY: -0.18
    },
    StoneArch: {
      tileRef: tileRefsDecor.StoneArch,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.StoneArchSideways, flipH: true, baseTileScale: 2.1, nudgeY: -0.44 },
        180: { tileRef: tileRefsDecor.StoneArch, flipH: true },
        270: { tileRef: tileRefsDecor.StoneArchSideways, baseTileScale: 2.1, nudgeY: -0.44 }
      },
      name: "Stone Arch",
      coinPrice: 4e6,
      creditPrice: 124,
      rarity: rarity.Uncommon,
      baseTileScale: 1.53,
      isOneTimePurchase: false,
      nudgeY: -0.5
    },
    StoneBridge: {
      tileRef: tileRefsDecor.StoneBridge,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.StoneBridgeSideways, flipH: true, baseTileScale: 1.7, nudgeY: -0.28 },
        180: { tileRef: tileRefsDecor.StoneBridge, flipH: true },
        270: { tileRef: tileRefsDecor.StoneBridgeSideways, baseTileScale: 1.7, nudgeY: -0.28 }
      },
      name: "Stone Bridge",
      coinPrice: 5e6,
      creditPrice: 179,
      rarity: rarity.Uncommon,
      baseTileScale: 1.22,
      isOneTimePurchase: false,
      nudgeY: -0.35,
      avatarNudgeY: -0.44
    },
    StoneLampPost: {
      tileRef: tileRefsDecor.StoneLampPost,
      name: "Stone Lamp Post",
      coinPrice: 8e6,
      creditPrice: 199,
      rarity: rarity.Uncommon,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.6
    },
    StoneGnome: {
      tileRef: tileRefsDecor.StoneGnome,
      name: "Stone Gnome",
      coinPrice: 9e6,
      creditPrice: 219,
      rarity: rarity.Uncommon,
      baseTileScale: 1.3,
      isOneTimePurchase: false,
      nudgeY: -0.4
    },
    StoneBirdbath: {
      tileRef: tileRefsDecor.StoneBirdBath,
      name: "Stone Birdbath",
      coinPrice: 1e7,
      creditPrice: 249,
      rarity: rarity.Uncommon,
      baseTileScale: 1.2,
      isOneTimePurchase: false,
      nudgeY: -0.46
    },
    // Marbre
    MarbleBench: {
      tileRef: tileRefsDecor.MarbleBench,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.MarbleBenchSideways, flipH: true, baseTileScale: 1.55, nudgeY: -0.35 },
        180: { tileRef: tileRefsDecor.MarbleBenchBackwards },
        270: { tileRef: tileRefsDecor.MarbleBenchSideways, baseTileScale: 1.55, nudgeY: -0.35 }
      },
      name: "Marble Bench",
      coinPrice: 75e6,
      creditPrice: 349,
      rarity: rarity.Rare,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.3,
      avatarNudgeY: -0.18
    },
    MarbleArch: {
      tileRef: tileRefsDecor.MarbleArch,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.MarbleArchSideways, flipH: true, baseTileScale: 2.38, nudgeY: -0.57 },
        180: { tileRef: tileRefsDecor.MarbleArch, flipH: true },
        270: { tileRef: tileRefsDecor.MarbleArchSideways, baseTileScale: 2.38, nudgeY: -0.57 }
      },
      name: "Marble Arch",
      coinPrice: 1e8,
      creditPrice: 399,
      rarity: rarity.Rare,
      baseTileScale: 1.53,
      isOneTimePurchase: false,
      nudgeY: -0.5
    },
    MarbleBridge: {
      tileRef: tileRefsDecor.MarbleBridge,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.MarbleBridgeSideways, flipH: true, baseTileScale: 1.7, nudgeY: -0.28 },
        180: { tileRef: tileRefsDecor.MarbleBridge, flipH: true },
        270: { tileRef: tileRefsDecor.MarbleBridgeSideways, baseTileScale: 1.7, nudgeY: -0.28 }
      },
      name: "Marble Bridge",
      coinPrice: 15e7,
      creditPrice: 429,
      rarity: rarity.Rare,
      baseTileScale: 1.22,
      isOneTimePurchase: false,
      nudgeY: -0.35,
      avatarNudgeY: -0.44
    },
    MarbleLampPost: {
      tileRef: tileRefsDecor.MarbleLampPost,
      name: "Marble Lamp Post",
      coinPrice: 2e8,
      creditPrice: 449,
      rarity: rarity.Rare,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.6
    },
    MarbleBlobling: {
      tileRef: tileRefsDecor.MarbleBlobling,
      name: "Marble Blobling",
      coinPrice: 3e8,
      creditPrice: 499,
      rarity: rarity.Rare,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.56
    },
    MarbleFountain: {
      tileRef: tileRefsDecor.MarbleFountain,
      name: "Marble Fountain",
      coinPrice: 45e8,
      creditPrice: 449,
      rarity: rarity.Rare,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.3
    },
    // Spciaux
    MiniFairyCottage: {
      tileRef: tileRefsDecor.MiniFairyCottage,
      name: "Mini Fairy Cottage",
      coinPrice: 5e8,
      creditPrice: 549,
      rarity: rarity.Rare,
      baseTileScale: 1.1,
      isOneTimePurchase: false,
      nudgeY: -0.37
    },
    Cauldron: {
      tileRef: tileRefsDecor.Cauldron,
      name: "Cauldron",
      coinPrice: 666e6,
      creditPrice: 666,
      rarity: rarity.Legendary,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.25,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    },
    StrawScarecrow: {
      tileRef: tileRefsDecor.StrawScarecrow,
      name: "Straw Scarecrow",
      coinPrice: 1e9,
      creditPrice: 599,
      rarity: rarity.Legendary,
      baseTileScale: 1.8,
      isOneTimePurchase: false,
      nudgeY: -0.65
    },
    MiniFairyForge: {
      tileRef: tileRefsDecor.MiniFairyForge,
      name: "Mini Fairy Forge",
      coinPrice: 5e9,
      creditPrice: 979,
      rarity: rarity.Legendary,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.3
    },
    MiniFairyKeep: {
      tileRef: tileRefsDecor.MiniFairyKeep,
      name: "Mini Fairy Keep",
      coinPrice: 25e9,
      creditPrice: 1249,
      rarity: rarity.Mythic,
      baseTileScale: 1.05,
      isOneTimePurchase: false,
      nudgeY: -0.33
    },
    PetHutch: {
      tileRef: tileRefsDecor.PetHutch,
      name: "Pet Hutch",
      coinPrice: 8e10,
      creditPrice: 499,
      rarity: rarity.Divine,
      baseTileScale: 2.1,
      isOneTimePurchase: true,
      nudgeY: -0.45
    },
    MiniWizardTower: {
      tileRef: tileRefsDecor.MiniWizardTower,
      name: "Mini Wizard Tower",
      coinPrice: 75e9,
      creditPrice: 1379,
      rarity: rarity.Mythic,
      baseTileScale: 1.8,
      isOneTimePurchase: false,
      nudgeY: -0.59
    },
    // Saisonniers (Halloween)
    HayBale: {
      tileRef: tileRefsDecor.HayBale,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.HayBaleSideways, flipH: true },
        180: { tileRef: tileRefsDecor.HayBale, flipH: true },
        270: { tileRef: tileRefsDecor.HayBaleSideways }
      },
      name: "Hay Bale",
      coinPrice: 7e3,
      creditPrice: 12,
      rarity: rarity.Common,
      baseTileScale: 1.8,
      isOneTimePurchase: false,
      nudgeY: -0.42,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    },
    SmallGravestone: {
      tileRef: tileRefsDecor.SmallGravestone,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.SmallGravestoneSideways, flipH: true, baseTileScale: 1.12, nudgeY: -0.32 },
        180: { tileRef: tileRefsDecor.SmallGravestone, flipH: true },
        270: { tileRef: tileRefsDecor.SmallGravestoneSideways, baseTileScale: 1.12, nudgeY: -0.32 }
      },
      name: "Small Gravestone",
      coinPrice: 8e3,
      creditPrice: 12,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.38,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    },
    MediumGravestone: {
      tileRef: tileRefsDecor.MediumGravestone,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.MediumGravestoneSideways, flipH: true, baseTileScale: 1.32, nudgeY: -0.33 },
        180: { tileRef: tileRefsDecor.MediumGravestone, flipH: true },
        270: { tileRef: tileRefsDecor.MediumGravestoneSideways, baseTileScale: 1.32, nudgeY: -0.33 }
      },
      name: "Medium Gravestone",
      coinPrice: 5e5,
      creditPrice: 72,
      rarity: rarity.Uncommon,
      baseTileScale: 1.2,
      isOneTimePurchase: false,
      nudgeY: -0.45,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    },
    LargeGravestone: {
      tileRef: tileRefsDecor.LargeGravestone,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.LargeGravestoneSideways, flipH: true, baseTileScale: 1.5, nudgeY: -0.39 },
        180: { tileRef: tileRefsDecor.LargeGravestone, flipH: true },
        270: { tileRef: tileRefsDecor.LargeGravestoneSideways, baseTileScale: 1.5, nudgeY: -0.39 }
      },
      name: "Large Gravestone",
      coinPrice: 5e7,
      creditPrice: 299,
      rarity: rarity.Rare,
      baseTileScale: 1.4,
      isOneTimePurchase: false,
      nudgeY: -0.51,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    }
  };
  var weatherCatalog = {
    Rain: {
      atomValue: "Rain",
      description: "Gives the Wet mutation to mature garden crops",
      type: "weather",
      cycle: { kind: "weather", startWindowMin: 20, startWindowMax: 35, durationMinutes: 5 },
      weightInCycle: 0.75,
      // 75% des events mto
      appliesRandomCropPercent: 30,
      // ~30% des cultures applicables
      conditions: { requiresMature: true, requiresNoExistingModifier: true },
      mutations: [
        { name: "Wet", multiplier: 2 },
        { name: "Frozen", multiplier: 10, conditional: "applies if crop already has Chilled" }
      ],
      stacking: {
        compatible: ["Golden", "Rainbow", "Giant"],
        incompatible: ["Wet", "Chilled", "Frozen"]
      },
      screenEffect: "Rain on screen",
      notes: ["Primary vs Snow (75%)", "Affecte une culture applicable au hasard"]
    },
    Frost: {
      atomValue: "Frost",
      description: "Gives the Frozen mutation to mature garden crops",
      type: "weather",
      displayName: "Snow",
      cycle: { kind: "weather", startWindowMin: 20, startWindowMax: 35, durationMinutes: 5 },
      weightInCycle: 0.25,
      // 25% des events mto
      appliesRandomCropPercent: 30,
      conditions: { requiresMature: true, requiresNoExistingModifier: true },
      mutations: [
        { name: "Chilled", multiplier: 2 },
        { name: "Frozen", multiplier: 10, conditional: "applies if crop already has Wet" }
      ],
      stacking: {
        compatible: ["Golden", "Rainbow", "Giant"],
        incompatible: ["Wet", "Chilled", "Frozen"]
      },
      screenEffect: "Snow on screen",
      notes: ["Secondary vs Rain (25%)", "Frozen recommand\xE9 pour champignon/cactus/bambou"]
    },
    Sunny: {
      atomValue: null,
      description: "No special effects",
      type: "base",
      cycle: { kind: "base" },
      appliesRandomCropPercent: 0,
      conditions: { requiresMature: false, requiresNoExistingModifier: false },
      mutations: [],
      stacking: {
        compatible: ["Golden", "Rainbow", "Giant"],
        incompatible: []
      },
      screenEffect: "Blue skies",
      notes: ["\xC9tat par d\xE9faut, aucun effet"]
    },
    AmberMoon: {
      atomValue: "Amber Moon",
      description: "Gives the Amberglow mutation to mature garden crops",
      type: "lunar",
      displayName: "Harvest Moon",
      cycle: { kind: "lunar", periodMinutes: 240, durationMinutes: 10 },
      weightInCycle: 0.33,
      // 33% des events lunaires
      appliesRandomCropPercent: 30,
      conditions: { requiresMature: true, requiresNoExistingModifier: true },
      mutations: [
        { name: "Amberglow", multiplier: 5 }
      ],
      stacking: { compatible: ["Gold", "Rainbow"], incompatible: ["Dawnlit", "Amberlit"] },
      screenEffect: "Nightfall glow (orange)",
      notes: ["1 fois / 4h", "Ne se cumule pas avec Dawnlit"]
    },
    Dawn: {
      atomValue: "Dawn",
      description: "Gives the Dawnlit mutation to mature garden crops",
      type: "lunar",
      cycle: { kind: "lunar", periodMinutes: 240, durationMinutes: 10 },
      weightInCycle: 0.67,
      // 67% des events lunaires
      appliesRandomCropPercent: 30,
      conditions: { requiresMature: true, requiresNoExistingModifier: true },
      mutations: [
        { name: "Dawnlit", multiplier: 2 }
      ],
      stacking: { compatible: ["Gold", "Rainbow"], incompatible: ["Amberlit", "Dawnlit"] },
      screenEffect: "Sunrise glow (purple)",
      notes: ["1 fois / 4h", "Ne se cumule pas avec Amberglow"]
    }
  };
  var coin = {
    img64: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQfpCR4CFRRuokQwAAAr0ElEQVR42u29eZRlV3Xm+dvn3HvfHENGRE5KSSkJISGExCAJlQFDmRmDmAzGVcY2dIMBYSiXMXZjTA1tL1tgMxZVBparbJahbKAAA2JqxCAJAZKQUGpINKZSyiEyY3zzu8M5u/8490WE2pRRpjIlcOdeK9bKjOHFu/s7Z4/f3gEn5ISckBNyQk7ICTkhJ+SEnJATckJOyAk5ISfkfyPySL+Bo5HXv/7l3H3Pfl78vF/iKRddyGPOOYeoWkF0hBePxFWWl7rccO2NfOfKa7jsvR/lwgvP47rrdj3Sb/1fhrz7fe/i37z6Em697Tsc3P9DDh28AdUFVJU/+N2/sCuHlpLhMK8Mu8uV/mChMvSDys037Y4BUXV0+zdy3/3f4sD+6/nIh/4cVeXfvuz5j/Rj/UT5mbwhl/3n13Ldrd/kta/8Pc7YeTZnnr0DqZ/Nj3ZdNd2q2s3VevWxszOt7Z3F+Vnj3emTE5NbTWwjKFTxaJRIVtDv9YZ76s3mvYV3C/Pzh3Y3qlv3/cE7Ll/85N9cXLTnlauvuoHDyx3mZqd40av+/SP92MDPGCDvf9/bSLOMFz3/+TzmjNP50Ef/Z/S8X/zFUydmaxfUpipPN9Y8oZrEp6DDmcgOK34wT9G+H1O0UT8E70BBo5hoZhYak6jEeK169a0VzarzWbf4UZFxlZfq96+9fvmO57+0Obxn1yG+9oUb2bJtkpf/n+96RHXwMwHI/J4r+dJXvs0zf+lCdp71PG784eUnnTQ79a/rVX1+HPELkc13SDWNJO7hWQaWMTrE9ZYZ3X831VEfozlePMYLXgxs24LZth0vCcZXgAgpHOnhDqQNNfHJi7nZdP3IVj5/eNF/7TGPn9q7fE+fd7/7f/Hc55/HL73k7f//A+SvP/zHDAYZL37xszj5zGdx561fOmtmeuIV1Ur1lRXJHyP5fOTSO8hGd2DrGZW5OdREiMlAPVLkjPbtx66uEnmHN4rxgBryiSbxztMgqiMIKinic4pDh9BDSwgViso0mpzi1W77cS5znx4Us5/YdtYP79xz41ZOe8Jv8/tvfC5/8Vdf/5cPyAff+05+49d/hR/ffhdPfurL+fFNXzx98+zMbzVr0atjWd3pR/dSdG7BD/ciro3RFK3WSE45HanVQTwqiqgnX1qiOLifiivwKKIgClkcE+84FTs1g2LxCCoe0+tQ3LuHOBuFz2FRU0OTk3DJ6Xeksum/zHebnzx7tr10xU1tpuo5Fzz7Tx423diHG4wD917D5OQUJ22Z4sDhzqa6WXrd3OzE+xrVwctltHsqX7wKXbkak95D5PtE3hGpQT1ovYJpVAGDigEMBoPvdLFFgaggIiCCqoCNMc0WWAE83gjGGHQwQEYjDB6MYrzD5Avg7p0R7T6nFfkL2/3o3nOf8Ud7i8PP4rK3v4Bd993H7bcv/csB5A2veglf++YnyLOCsx/3LA7cv/sZp5w898GJqrzR5rvn3NLX8MvXYNN9GBlg8RgsXhSkADyFjYiaE2AtECHE4WOYIsMMowZBEBWsGrwKMjkBcYSoARQjoN5R9HpY9SgSwBWDkGGLtomLxdMj235Be/5ZdIfbbnZuf/a63/tXPOMxp/G3n7nhuOopejjA+PZX/56nP/dXmd9zDYcWVlqV6vWv27q58fbYHdhSrNxI1rmBpDhE4hVUcAogoGAkKNMCvjfErw7wLibtZ2TdlLwzRJdXkE4XfAQWbOSpJAbT8Gi8THTSLFKJAo6imHqNPKnih4pRD7jy91lUADoY19vS0NGf2Vp27p5V3jHxw70HDjb+LfPX7mTrRe88bro67j5kee+P+NJnv8XLXv109ty5f+fO07b9SaXqX2VGt1m38E3M6G5QjxGPqBLMkQ+OgAhxFt/zpCuOfkfpDwyml5OPBqjLsfjyA0TAGUUFrAoeg6/XkU0TVE/aRP3UOarbGkRVT3HwXlhaxAYEEBQAL4ITwahDiCi0xSCf+kZ3OP22fHTnTTcvvYBTJ67iCS/9x58/QD76gXcyN7ONZ73gYlZWhhdNN2sfaMTDi133u7iVq4myZawWKBFeBDUFogWGBM2EUSejO58xmi+g5xHnkMgjFSWJPUlUYK1DbPAFiENFUQS8QdRQOHAF5EVEahvI9CYmzthMY7PFZ4tYV2A0uHfRAKYXg6hHsIiPQQ09P3XjwX719a24ff0737uL5zw54VV/tOfnB5D/+oF3ko4y/t3bL6M7f9MzkkT/W2wOnV0sXwGr1xG5UXkLXFAgwUmTWQYLjv59I7LFEUVeEBlLpeZI6gNsZYhGikGDU6ZUIoLo2CVqeeI9wXMoqAUXURQRI2fwSZXqzCSN7U2iGqg42HBLRT3eaHn3ALX0sqkf7Tucv2br1pkfzV38SX73khrv/+LomOrtuDj1A3u+x/z8Eq+79I/Ze8e3Xzg9HX8k0v2Pyhe+gmlfS+SDzXamCOErBusiskVlefeQ1Ts7+LYnMY7mxID6dJ+4NcRWMowpiNRhANSEkFYFRfDiAY8oqBicmHDaseH7bQFxRpx4Ii0ouj1Gq32MWOJaBWwAV8bgShFuLRaDI7J+a2Lt2bvu7HyndvDLq7/yrk+w7/KPceMBf8x0d8xvyPXfvZw779rHS178ZAbD/F83a/o3ke49JTv0DUznVmLN8RLjRRHJEI1gYGnvGdG+L0WHGdUoJ5nIsI2UyI4QcYhG5YfiUXIjuDhG4hiTRMRJeE0zHBF5JVeHcx4tPHiP8R7FYFTCrREfHHiWMDJKNNOkddIcWosQr1gffJngEQ05jOIppMFqr/qFu64r3nTqjsb+VsUy+fLP/WwC8s7f/23+5D0foXPoB3R6+UUz0/W/Tdh3dnb4cmz3NmJNUaAwQbHWK+mKsHR7m/SQwwhUmhmN1ggTD1FxiAogeAEwEFuo1zBb54i3b8U2W1CpYeIYshF67z7MaICaHHWgmafIMnyek2cO1+4RpTkGRU0wbR6L94JpNameshVTjzE+nHoVDe5JFRXFG493LZb3T3z2+u/Nv6Fel4VsVPC8y67/2QNkYf/3KFJlablz+s4dm/++Hh2+MFu8HOneRKIjVKs441BJsUXM4IBn8ccDXGdEtZJRn8qJajmIw/pwIr0RfGSQeo1kokncqEO1ip+ZId5xMhonIWJVj/EF+f37kaUljLj1qE0NWqki27aQ9YeM9u6H/Qcw/S6G0mdgQjLZqFM5dQumlgCKlxAvGAXw+NIMar/C/bv1b793XfutExNROy2EV37o2oesw2PmQ+687ZuoKsur3Ykzdm55Xy0aPDdf/jKmey2xL0AUZwTEY/OI3n0Zi7f1kL7SbGS0pofE1RQxOUiBE8VFlmiiSW3LHNW5TUStOiQxIlCoYJqTSJygCEYVNcGBF90u1juEEMYKinpFJyZJtm2nctJ24rkZClXy/gDjHK68MTbNcWlGXK8hsQ1HVkL8IYQqgMERxSMiy/lulEzffSC+sh677FfOn+MzN8w/8oD894+8myi2fPQfrjS//PTzfr9Vc5cW3W+La3+H2BUIcQDDZJg8on33iNUf94lSpTHVpTaVIUkWnCiKNwbfrFPdupna5hlso4pGBm8EUER8SB6TJJRSBChvgzEG3+tisxwRRUUQ8agUeCJsYyqUVFotku1bMa06WacHoxQjIXpzeU6e5yT1GiaKUNZwAZEQNJgC27Bih+6Jtp8Vb/jAwpUXn5PoS5+wjX+86dAjC8jnv/h5Tt1e48JzT3vOpsnoPWZ4a71Y+hqx64ZISELiZV1E996UlR/3iHKlMTWiMtlDI1eWMDwuNsSzc9S3bSFu1dHI4oXwGmUSNzYhDo+daCI2ZPOCRSxoPoJ+HxlHTIRipPOCaTaQShJKJWKJpieJWy3c8ipmGEJxb4Qiy/GFI6nVMNYEzAGV0qdh8FZoRCJ+OT//WedP3Pmyxzd3v++K+9m1v/fIAfK5v/8g9VrEcnu0dWaq9uHYHzgrP/xl4vQgkQ9mQI0n8obefsfS7h5RCo2pEfFUHyOCojhxSFKltnUb8dw0xDacxPL3hFB0rOCgIK8OaTaQSg0hBoLZEhTX7YIW4fu9IGJQr5DE2EYNlfDKaiJMPUbU4bp9XJZjFCIVijRDBZJGPZQBkJB4GkU0xqgSJRF+qNW0456w64C76sLTpuZ/82mn87ffve+o9GkeChivveQSilw45YyLadX0txIZPsWtXIukd5VZsysz4ITREiz9uI8ZQW2qQzLVxuAxqjg8vlmldso2kplJxIS3FW7W+CPU1UPCpzijiHNopwveoRpyEFSQSgtfbwQYNZhAEKwWuG4bzV3ISUUR7yGKMDObsNtPwsdNIm8xCtY7sqVlsnYv5DlGEUKwYDS8Lx/lTJyUMFlLz5ypuv+8p51NLrTb/PmLtz38gLzmLS/hqU87l3tv//r5rUb0RhneStG+Ees9qKWwBi8W34elH7fxvYxaY0R1wqFGcMaTWY9p1Zncvo2oVceVd8L8MwFgabmwHly/j+bBX1Bae4kibLNVluj/Pw+bpvjBsLx9Y5AtptkimqhTn5smJUI11F2Nc2QLi2iaw9rhCOV8RfHiiCci6pti6pF7wemT5v945e+9iAMrw4cfkHQofOYzt9iZyYk3VmT5FL/8PSK/gBEQDB4BZ+ncPSRbcNSSnMbEALEZiuDE45oVGtu3YOtV/PiJ1wzV/x4Mo2BQZJTh+wOUMtGTkC9EjSY+rqCUURYg3mALj+92QAu8hMwcjTC1BlKLSDY18M0JchehWIwq0huSL6+GW6XlURFAQulGIkdza42GyeyUHb3lE3/5+fOedu7JfPhXzz5inR61D/ncp97HBU98DGedNXfBVKvyp9q7ua6rP0DIoKwziViy+YLV3UMMSmvTAFsdhWhKFFOt0jhpG7bZWHPcyD+fHAWoQpgrKKrgjcFONEHKxxEQY/DDFB0Ny1xDygQvBAOm1YQ4KfGPQhPLjfDDAZGpMVjqYo1iRYm8J3OOqNnExBEipeEsTaggWBMxms+xuZvCRLz768tfO3nS+CeebLnmnsGD1utR3xBVZcvOZ0ijZv+N8UuzxcouREeEwoQNZYeB0L1riKQZtYkUU8vwodEKsaW6eTNRo4GqrgFh9J//veUlAMBLiHfoDWA0WgNSRcFaTGsCby1aNmtVyoQiG+L7fUKReFwlBmlO4pIq8USCaTXIUwPehpA9zShWe2uRXjB1Uv5fsQ3BbqoSqTBjePmlT51+4nnb65yzKTsivR4VIF/5woc57/zHs/uWb5xZrdZfooN7sOk9iOQYD6IelYTeoZzhUkZSLag2+kjZ5/DGEm2aI9rULE2QIB5M+bAq/5zRYu17XOlZbZbhugPwsgaKF4NtNKAaMm7YELGVHUPyEAR44xD1mKSBqTXQKKM+O0WRR6hacitYD361hy+Ktd8vKhi1wadEnsoMYBxNI5unav517/razXZ//8h6gEcFSJYOOOOsC5idajw3YnSq79wKdFEpCKVviw6F3n0DxCvRZIbEKUZ98CvNOpW5aZwtHeuawkqV6U+p6ZRXRMYtWzzSWYUiBxTjS7JDkmAarUALCj8RSiEo2u+jWYaKQTQQJjAGmZzEGaE6EeErVfI8RjREWEWW4gY9dPwWNOQlHvDiiSfBRmDEMB3nL3zzBdOPO2NCef2TjjMgp57+aHbd9INaox5dQnafMNobohyxZahqGS4OyZZHJBVPVM+D08WjcURtbhqJTSAlBD09AIEHV2CTtRuFKDIaoKMB40gLFVQE22rhbRzCYV37KjbPKXrdAL6atTdhG3Wo1DGxEE81GaWGyJeKV4fv9kB1w00MH6gS1yOohHyoGcVbJ1rTL3/VRWdwxxEk7kcHyPZtTNbix1mTPbEY3Ir6dnjYMnHQ3NM+mKLqqTZHRBQYFQojRFNNomYDLSk7x0rUeVynhyrB5pf2Xao1qNcDUOLXIiPrPb7XgaIogwkbfiaKsY0W3ljqrQTnLHiD8SGQyIcpOL92cjaeJWsN0oxQHLFJmEzcL/3fX71x+qUXNI8fILfv/hZTm1vUYvvMyHc2af9ORFJELRI622S9gmzJE8dCXBthNFB0fBKRTE+iNpxI8yDvwoMRQaHbhTwtS/Xl56ME25oszVboIq5FXMMBftgvs4r1H5LWBEUcETcsXiNcEZX1AfBpjktzynAC0fVAxFpBaqX5QpmI/fmzE5subFZrXPa8ieMDyC233sH7/+vllXqjcoGm85hsqTQdpnxzMcMlhwwLKjWPRHkoBhqwzTpRrbqWS+gxvCEAJh2i/QG2LJUjHjUm+JGkslYuGT+2KTJ8ZxW8Xw/fBKRWR+sVpCKYuEKRJes3wXk0zdGy/77RnyCKrQESqgL1KGlMxebi33jyyXQGDy7aOmJALrrgbH752Y/fHCV6vg7vx7q0pGo6hAJfCKNFR6wFca3ASXCkag3VyRZEprTbsgbMMRPNKLptTBHCXG9CNm0qNbTZwCMYNbDmMxR6XchKZZXhN0mEbdUhNpg4Jits2TEsfVMWIq01kzWORUSJY4Mpk9TEJrSs+YVL/+GOSiVOjj0gr/+tl5MN2uTDztn47hYd7QvRiQZAMOBGjqxThL51nEOoWCGVCrZew5WFh+PCrhDF9wf40WiNfSIKGIttTeCNKRUoZU4CZCP8oIdRR4jzgnZts4lUYiQCX1jK/iGioTxf/royQRz//mC2DMEwWmMx1p413ayePLLVYw/IFVdcxc6TT+HUHaeeEWu/6fPDZTIXTpzD4no5OsqRqsNIHpwnEbZehzjecCuUY+rVAS+WOM3QbjucXh+tJXK23kKrNVTLUkrp3I1XXKcLrgggqS1D5gbabGCsg6I8VOKC3r1DBKwPeXoIIsrSvFEUGwqQRokqsu2k6er2k2dqxx6QP3zHWzDN8+n1Bqdq0UHdiEDDCcwRVCkGOXhHlIRStYiCEaJaNfBuN2BwjF1IWQbxuF4XimKtMoyAxBGm0cCVlWQpzaYAbjDAp+kaWS4gGG6VSrQhSAihuqp/oAMc/1PDPfIlPVWAuvGRjvo7tlTyYw/Is575VL7x7S/F1Wr8WM2XEJeWX/GggdExGhSIeGxcJnuqEFlsrbJmqsbX/FibrbGCdTQKhGr8mJEKxmBbE7goKksu65Vbk+ehf+JLsyXhtEutiZrqGqueMhFV1fBcbHydMtJz4zqXRYAq3rYSzp31bR7XOsaAXHf9DyHvxbVatIliFaN5mYOVVDcPfgTGgJScK/BIbJEkClCMMzOOucVae22T5/hOF7xfP7yA1BtorR4I3GVREMA6j3a7ZaZfOm80MCqdZexutGxQiTGoeeBxEg3P5gtZP3QIiQj1xMw8bVsf544xIHv33s89d91dK9JBTYt+SVQuM1UUHGghWKOIKRgXQ0wcIdaslUQ2RInHXBSw6qHXQ4v1HgaA2ISo2QpRH77kPXqs+pCTjEalckMw4DJP0S8wAqbs1Kh6xIwR2vgAAmpwWRhvWAfWMizyCbmsEk3O/nR1HxEg1biGxdaLPK8bl2744TGzQ/BFuCEYt3Y6JbKoHZOaj5/o2m1VSFPcYFD6FV0bO4jqDSSO1g6FBiIJ4hxFr/uAQ1L0RvhBRmxC/Wucp9g4Ck8i8k/egMu05AU7VARnDKlS275FokrlpxcajwgQg8NoYdSn1vuipG7KevcNAqXfeDB5qX6DMVKSmMvXGd+UY47Ohg68K9DOKupcGe6WiqrV0PpkiITEhVoUBusd2uvgc8/Y6KSHh/i8T5RkBD6KosZAHGF0XPGl/Hc4kG5oylKMR9Tiy76NFGW7+FgCIlraJJysRTDA2MhK2W8YH5xAcjbh8z9JfccYkHGzKFB/FN/vo1n+AKw0irATE2FWUSnbBeGGSzrC9wYhWnIwPLAK6jBxgRLY9CKCSZK19y/jFxdwuScfFqiasp0A3uWIel+oPKio8ogAKYoC770TEbfOMA8fHsAIJtbStNp187SBFLBBN8fNh2j5Dy1yXL+LKUlzWlYNTL0OlQpSRoahfxPMFu1V8AVFN2ewb5XYCBIHb2y8xcYGkyTr/HrRMkgAN3S4tMBgELUYdXifYY0fHlqWInsQXv2IAHHqsXG1H0VxXzf86DiiUANSCc4yhIhlvOL9+gmVB9eAOloZeyoRxXqH67TX+iRrtf4khmYDH7ryqBmzKoFBG9Kc0b4ubqlLJfGIDaZNVJBaBYnHvkDXngc15N0CMi0rxyFfz3xBFEV9/cCwGOU//amPqJ310pddQqW1c1CpHeq51Wjtzq5FTgbimpArqLdlpCVo4cB5JDJstKKix9Zsbcxx8IoF3KCPH44wEwkgwUQZi5lo4VbaiMsCMaJ8EC1S3FKf3u2L2Dyj0spDkRLwxhM3GsGPEG69L8EQZ0lXCqQwa0A5lzMqHKm3q1++9p/GAD9JjuiGdLp9vvzV7xft7mBJbaW0qxsOH0qlHuPH6JRqKooiJFI/rRP4UEVDJLpW0/WKLQpcv7f2dVEJfN96Fa1VymDEY8ueh4iS7TnM8K5FksiTVDIoWZUkim02Az9r3GUMWScuh9FKgfUh3/KiFOpIHX44crvzeBM/3HeMAfnmN7/La1/764Xzsou4ihKVii+zcoGoGSOxRYsyGBbweYEWRbj2PjjSjVHXMcNjLQPXUomCRdFeF81TfHnSxQtEFUxrgnFvJESLMVLE9O5ZxHT7VGseseNxN2BqAuq1EEZL6eQBEU+26nG98ZwjiDhGRUHqoyKpTexdco0H9QxHBMjTnnIW3UNXkiTNu72tezW2VISusy/qFqlHuCJMIamA5A43TNeIAevMjWMLyJjCZspet5Y2QoZDfD/0/MNMSDlV1ZwIVKByIMcbKBYLhvtH2KSgUvc4E4Z2vI2JzjgDaTZDxZcQLoeBHs9wIUdTE0jdZaI8ylKyXNpLqV060H1wXvOIAPnIx6+lvTpg4fDqbjFTK74cL1g3WIpJoDpVJSsSVAN1X7yn6A3CzTBjJ3h8oqyfKN7huj2sC2ZmnDOZagXqzbKSWyCpo39XG4Ye01KiJMyqqBd0ZhPJKTswzUlQwYgrY2aPH0QMFoch9wBiB16F4agH4u7sDPO7O+32sQfkox/9KMY0qda37lXZtE/jMY1nvYKqpqA2VyMjQdWUIa/iBgNI8xAmmhCjPVyAGBTt9WCYhpqTKY2sFcxkC2cDS7F334jevMdWCmqNESojRB3exlROPw3bbCHNCTSulJVdxahhuOgoOg4kzE5aFfLcMchzUu+vf/dX7+rNNB4cJ/GIO4ZfuvxbnHzmqxc8je8Rby2nX9fLIiqOymSEbVTICln7FTpMwy0Zf69uSCyPswiKyTJ8r896kB6+IvU6WqmTHoblu4c4IqqTKUncw5siPN/sDNWTd4RoqlZBm40Q0AA+i+nuHyJZWPMxLt8M0wEDhxuZxnV//Wun8YdfWj0+gMSRRVc/QFpEV0q0o1BixrUsU0YcUnG0NlfJsjDqHJy5Uqx2oXDrFBqjDw8kJZNduz3Uu7KCUBY+K1XIWqze2qcY5FQn+lRrgQ7rEdJKleScMzHNBnjFx4q0JlCpIBgGy0q6mIetK86iCKl19IYdMrUH2pm5tptb3vLU49DCBXjt7/wRBw52yYrou0Qzd2vZmtRyFEDV4MXRmKtiajVyFyqeAhS9AXmnt8bSeCCf8AH6e+gIbPiQsuDoRgNcOlpvIosh7zqWb1oiW1Aa1ZzG5ApYB76CqqWyYzvRqdtD08mETqNpNiCp4TOhfX8fRqY0weGV+3lKLx3ivHzvQLd2b7fv+eDVx4nkAHDw0DLbznjmfXk08XVNNpfkABP6H1KOBNSVxo4muY+wPilbqp7R4iqaFuWsnoRcWcsMUc0aifmo7k5ZNhdVhALBbfiSoi7FdbuIEyDGrzqWvnEngzsXiZOCxnSKJiM8DtQTVRMqs5MYK6jxqAHjYiSqYJoNeocLigMZVmPA422BeBj2enRVXQf7pQu3L2Wbph9cyHvUgDzp6a9hOP9ZUlf7jEvOWIUKxpfUGh3nH0p9dgI70aRwimhYn+EHfdJDi5AHWqkXWa+OEjYpGH90EbGUHY7gNWI8wVkX4fxSyRU6bdSNyBaHHPrqbvq7DhBFXWpzbUwywvgEoxafWKpbZ4Of6A2w42fzgLWobdHd00MLyCOPl+Avh5rT7nfJNL695+0VC3249JMPfgXHUY0jbJ7qsXX2VFaGj5qfqnfOs9n+xxrfRoxsoMQIYgxJtcqw10OcxxgNu01GKRInmHp9fahGQjgajElolR4pKuvNL1u+bqDAhUFNU4bgSrqsHLrybordS9SMozE7JG50sN5jfQVnDfHWKezsVCBFRHEwU5hQr3OGxR8dIrt5OexTMR6rwV8uDZdZ6nfpFrW/vvRXVz//2as3cc2eBz9zeFQ35NLf/UtqNctpMzelGk99zFd3dJ2RtT7zuNzqxWGbMfWT5shig/FK7EG9o7ewQL64isnHIzWhLerL3snR1biCUrTcoSJSYCTHUIAB72MG9zgOf/le3J3LVGopjbkhcTXHeov1MU4Uu7lFZW4KZ8NWIHpdfJHiLCARg70dutfdhxTBMiQl0S4tMla6q6Rq9q3m0d99+B9meNb500f8BEcl286+hKVexL7+6VeOkpO+kEdb1zNjxq5EUXFUpxvUt81SWEuBDbcnzxkemKe3/xA6cBiXrG3e8XK00dfYWZeO3IPxMaaIKFYci7t6LN7Ug46n0chpznYx9Q4qjkITBlGEzE1Q3RLorlLygTUd4kdDjBrckmPhqjtIlnPCqJgQ+VA+Wumt0s0cQ2c//farq7tvOez4wBduO6IneEgLzGan6mT5zVkv3fLeSXvK07RYPkUlH3c6Sx15MEJtdhIjMJpfJM5zrHd4yXGLq6y2U6qzc9RmJjGJx0tGoJod2XnRtfTfB7Pnq+R96B7o0r9vSNER4jijOtel2shD9dWHpTVpxVDdeTLJRAN8XnYCAyDioGj3sdEsy9fcjr+7jcXgpcAJxF4YpgOW+ytkGt+7VLQ+9hdPd35/R/jKXUem04c0Fv3Lz7kALSbYefJlB7udX7CRdp4p2jchuolKYDYUHmtVTBKRDsL2BAsY8dhcyVaGjFZT1EfYqIbEZo3FvMZ01AdSbkJhj3JGJISxqEVyQ7astO8dsHRnl/7+ISbz1Bue5qY+SaMNpkA1CTeyElN97Jk0zjs3rAUcDh7QUMMYJBN6t7fpXXsQyS3eKpF6IKIg59DqIZazXAda+8s3vWjxs5/8TsL7v71yxDp9yOW9A7d8HNTRGTUmtkRX/4+a2/2ySLshBAUoN/mMaZpGIV1dZXhwAZMWhBzFYxQKJwyyGLUtqpNNqtMVkkYFm4AkYd79ARTRsbMpwOXg+hmjlYLBUkG2UqBpTiyepO5JGg5bzVA7BCkwPjDbi6kpGuc9muiMUyCqwEobv/duoiIHMcGnaET/fsfCLR3MwJStJ1nb2Xiw3+Pw8v2sUP3WPb3Wq+q2ONzpFvzJFasPPyAA2YEv0lu5hYXl/rlz9T3/s8nd50ZOy4qrR/yGqjBgvCfv9ukfWkT6KeujnMGxaiakI0tWGFxksNUKUk0wlQQTWYyWddZc8alSDB3ZMMcPQQuPkYIkcSS1nKRaYBKHmrBIU8XjBFRiktnNJE96AmbrJlQM1gvkI7K9d2P73RCd+YjsgGdxV5uiH4qplXJCNbeGbtph78ICvVyWFlP51WYkV1Bt8Ft/d3Q7T47Jao2TpjPe/bGYS5695/BAW3cmZM+saDZRTlCUlNINPRABW0lIGjXE5bgsB2cCR1hyiFJs1RNXIDIeshztpriVEflSn2ypR7rYJ1/p4zojSDNir8TVgkoroz45ojoxwNaGaJLibI6Kx5ZLlk2tRrJ1lsqpW7E7diAmLvdjaVgXmGWhy6iG9IBn8ZYu9Mp6g67PivRdxsHleYZ5rsuu8Z43ffa0v3nUXI8v37zAvUd+OY7dDQG455r/yFU/+jG/8caXsvfbl79ma3X5Q7FdbHgpG0Ciaw2ptWUuClJA0WmTLi4E+qcatBykHDeazIYmvPcG9UnZMi5NmPGI8RgZhTDAx6EXQyh2hvl3iyQxyWSLZNMk1COKyBLtOA0zOR3WQIkLowSdIe7efaT39Fi5rYP2xhNZBqsWZ5RMPfNLB1jut+mY5v+az+uvq+BXVlZG/IdvHCUaHMP1TB/462/zoudsRZcGRI3n3WL8gdRTPDWWNJaSwPRAHmxwy2oFU6uQNBtIpYL34J1HfKinSlk9deIDoNZjTIGJHGIcxriwmU5yDDbMnKuUiwQUrMHUayQzm6hunSHa1MRXbDBHTvGxRSabgC1buBbJY/q7Fli+aQE/NGWaWvJ6jcPhmV89zEK/S0+aN8yntTdtqkf7t05GvOFTR78JCI5Dz27fd9/BameZ79w2jJ5z1vzvb50a/XGtOgxcfB+H0Wjc2gkes+dVJICQe4r+CNftUQwGuKKAPDS5xlHVWo6ipty9WNJwjMEZQSJBKpaoXiepNzCNGpLEZW1rTPGMUDW4WoXotJ2YpA5E5L2C1avvZnTt/ZA5nA1jDbacgcmBpfYiS6sLrEpjz6Kf/PVWlF7zm3/3HF746E9w+Z0PTX/HhXPwg8+8gqw/4AffX4ie/fTWG0/dXryrWS1mA0U/DfE9Zi2RHFef1t+ShPJ44fBphg5T/ChHsxx1DjcerlFFxIRhS2vROMFWK9hqgqnESBQWkHlYW9VnSvC8hL2mhTHYHduJpjYzvG/A4lV3kN+1jHVhOYj1ptwi53F4FlfbHOos0CfZt5xW3nD29ujyz9+sbJuO+b8+f+Ah6+64kUC++VfPZHGhyyv/+Fpu+PCzX7Hz1OT9k7Pt7UYyFIu34aRaJ2sktkDVVBRX5hTjZlb5or4EQXXtVihgTGAUrk1FbXxADX7EGV8O49iSHFfuWxRDUd1EZzli9bp9xIeHiAncTOMjYh8c3cA4DrcP02mv0qG+72AxcelbXz77hde+dw+TCbz/6u4x0dtxZeW877dPww0ifu/jX+Wbf/bqF55xevTBLVvdaZVGQWEUVUusRWnz7QaytAs7rsotJWwk1+lP3hS0XrZfF0Noe4+NnDfjGdwQJUkhDBc8q/f2SA8pJq2EZJUwluCJcEZI3YjDq4dZHPQZkdy9nCdvftOv7/zqb//5HYg6PvL9o9v887ADAvCel+1kuZ3ytrdexPdvWHza9un8o6eexNmTm6tINUNNXo4kl6PSKv+0176RhirrDdh/+jBjc7RenJTyE1rW1QwGyWPSFUdnX598f4FLATVlxTZwqsJfWnB08h7zK0v0hhkdJq7tSvOt2xuD73/h5pSKZPy37/8cLFLeKP/P7lVe8OQpfrRrxKO2Ve47tL92fbrsz3Gd/skWJY4bWFMpVzqNz2/Yv+7NWt9qnYIqY4oPa9uD1rYIPaC0sgEQU3Yts4j0sKNzZ5/27X3cYYvNKoAJ61/Hq8qN4PAcHvQ5uHKYflr4Hq1Pz49al05VRrt+cKBCwxR88OqjX+X3iAECcMUtHX7nknP40g2bedrZvf33Ha59xWWulS5m52SLw9hlijWWyErYmVjybNcVrOv+Qca7ssZ1LF37QChBFIyEeUAKKNqO4f05q3cM6N6TUSwKprAgShY5BF8u5bd4I2RpysLqIZY6y/RcvLjqGn96KK+/a6YRHXzN3z2OXZ9f5j995eBx0dVxN1kb5T0v+Ve87XOP5x/ffCt3HDaVJ+zIXzFb6f5BNeLceqTUJoR4LiLeFBM3E2wMxhblVtH1ARkJzOdydpyydWtQ1fB3wVIl73qyZUe6kpN1cnToUR8R/u4IgAfjyr9bFdjqhfcs91dY7C7Tc84PqXy7l9k/e8Nn2t/40Cu2sXUq4ePf3MuX7jl+OnpYARnLR37tPGwc8eInncb39hx41GxifnfaDF+ZaDprxGMiIa4oUUOgFWPrCVHFYGNFIh8iMEz4sx+FwaeefOTJh0o+zCkGOZoqkgnGRWVCF3Yy6lqdIHT0DTDSnPZoldXeKqtpQarRXSMXfeS+YeV/nNFMl+5ZrTBTVd78uYXjrptHBBCAP3/BHFdeu8C/f83F/NW1K/YNF80+ecLkb2xI8fyG5jOiWs5eFIhYDLaMuXwZIpd/1ghKRXvwWs7M25BZi5azhCEkNj5EV4jiREldRn8wYKXfoZcNSVXuHzr7qWXf+tjFO/zt373XUU+ESz91/P/U0SMOCMB/+uVH8aiTJ2gPPOdsa3LF/VHy1M3pkxpV+c2mFM+tUeyMyIi8X1tOoJTb38o9vWFoxq8tzh+bL9ZIa2EYJySFDucKhvmI1XTA6mhENy+K3MW7cxd/uuMrn33rzRfd9qEnXqt33HWIR+9o8Tuf7zysOnlEAdkon7r0KfRSx5mbLE/77GPl68+75Ywojl5YldELWjZ7YhWdsSaYHkGx43E0wjrxMKdRJn2E8oyX8q8kFEqeZfSzNu1sQDfXfOTi/ZmPrumrubyb8a1Xbl06+NWlLewbVWjE8M7PHd3e3X8xgAC84wVn86eXvYgPvvcqzm0Jj56r8OkfHWpsaZpzJmv2KVX6T6nFeoZI5fSKoR6TxRaPiGHMh/SuwLmMzOcMc8/ISTHKtMjzYj4Xs7ejXDc01euGQ66/5R53/3Of4PNDqwVLgxabJzxv++z+R1QHP1OAbJRXzMGnvvjv+O8f/DpTNcMvnLWdX/svX49+8eyZqa3TU6dFpDMu7509UbOn1WJJvHeoqqiqepTM4zv9fB7i26i3Dh/sFweV+v4//dSe4Ydfs4VRKiwsjZieqvKH//jQFugfS/mZBWSjvOWiiMFIufDMKQ71LTMTLTbVPJvjLpP0iHxOPVEadc9qFw63oRDI4ohRNMPhPGFfJyXKCtRYXnPx6fyHy3fx8WuPXcnjWMnPBSA/Td4MfAvYAiTAWcAB4NOP9Bs7ISfkhJyQE3JCTsgJOSEn5ISckJ8D+X8B7L1HlK7Vi1oAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjUtMDktMzBUMDI6MjE6MDgrMDA6MDAu0X64AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDI1LTA5LTMwVDAyOjIxOjA4KzAwOjAwX4zGBAAAACh0RVh0ZGF0ZTp0aW1lc3RhbXAAMjAyNS0wOS0zMFQwMjoyMToyMCswMDowMHlTrsEAAAAASUVORK5CYII="
  };

  // src/utils/friendSettingsSchema.ts
  var FRIEND_SETTINGS_PATH = "friends.settings";
  var DEFAULT_FRIEND_SETTINGS = {
    showOnlineFriendsOnly: false,
    autoAcceptIncomingRequests: false,
    hideRoomFromPublicList: false,
    showGarden: true,
    showInventory: true,
    showCoins: true,
    showActivityLog: true,
    showJournal: true,
    showStats: true
  };

  // src/utils/localStorage.ts
  var ARIES_STORAGE_KEY = "aries_mod";
  var ARIES_STORAGE_VERSION = 1;
  var DEFAULT_ARIES_STORAGE = {
    version: ARIES_STORAGE_VERSION,
    friends: {
      settings: DEFAULT_FRIEND_SETTINGS
    }
  };
  var LEGACY_STATIC_KEYS = [
    "aries_storage",
    "qws:stats:v1",
    "mg.customRooms",
    "qws:pets:overrides:v1",
    "qws:pets:ui:v1",
    "qws:pets:teams:v1",
    "qws:pets:teamSearch:v1",
    "qws:petAlerts:v1",
    "qws:pets:abilityLogs:v1",
    "qws:shop:notifs:v1",
    "qws:shop:notifs:rules.v1",
    "qws:weather:notifs:v1",
    "qws:notifier:loopDefaults.v1",
    "qws:player:ghostMode",
    "qws:ghost:delayMs",
    "qws:autoReco:onNewSession",
    "qws:autoReco:delayMs",
    "qws:locker:restrictions.v1",
    "garden.locker.state.v2",
    "qws:editor:saved-gardens",
    "qws:editor:enabled",
    "qws:activityLogs:history:v1",
    "qws:activityLog:filter",
    "qws:alerts:audio:settings:v1",
    "qws:alerts:audio:library:v1",
    "soundEffectsVolumeAtom",
    "qws:pos",
    "qws:collapsed",
    "qws:hidden",
    "mg-mod.inventory.sortKey",
    "mg-mod.inventory.sortDirection",
    "mg-mod.inventory.showValues"
  ];
  var LEGACY_PREFIXES = [
    "qws:keybind:",
    "qws:keybind-hold:",
    "qws:hk:petteam:use:",
    "qws:win:",
    "menu:"
  ];
  var STATIC_LEGACY_KEYS = [
    {
      legacyKey: "qws:stats:v1",
      apply: (raw, r) => {
        const flat = unwrapNestedSnapshot(parseSafe(raw));
        r.stats = flat;
      }
    },
    { legacyKey: "mg.customRooms", apply: (raw, r) => r.room = mergeSection(r.room, { customRooms: parseSafe(raw) }) },
    { legacyKey: "qws:pets:overrides:v1", apply: (raw, r) => r.pets = mergeSection(r.pets, { overrides: parseSafe(raw) }) },
    { legacyKey: "qws:pets:ui:v1", apply: (raw, r) => r.pets = mergeSection(r.pets, { ui: parseSafe(raw) }) },
    { legacyKey: "qws:pets:teams:v1", apply: (raw, r) => r.pets = mergeSection(r.pets, { teams: parseSafe(raw) }) },
    {
      legacyKey: "qws:pets:teamSearch:v1",
      apply: (raw, r) => r.pets = mergeSection(r.pets, { teamSearch: parseSafe(raw) })
    },
    { legacyKey: "qws:petAlerts:v1", apply: (raw, r) => r.pets = mergeSection(r.pets, { alerts: parseSafe(raw) }) },
    {
      legacyKey: "qws:pets:abilityLogs:v1",
      apply: (raw, r) => r.pets = mergeSection(r.pets, { abilityLogs: parseSafe(raw) })
    },
    { legacyKey: "qws:shop:notifs:v1", apply: (raw, r) => r.notifier = mergeSection(r.notifier, { prefs: parseSafe(raw) }) },
    {
      legacyKey: "qws:shop:notifs:rules.v1",
      apply: (raw, r) => r.notifier = mergeSection(r.notifier, { rules: parseSafe(raw) })
    },
    {
      legacyKey: "qws:weather:notifs:v1",
      apply: (raw, r) => r.notifier = mergeSection(r.notifier, { weatherPrefs: parseSafe(raw) })
    },
    {
      legacyKey: "qws:notifier:loopDefaults.v1",
      apply: (raw, r) => r.notifier = mergeSection(r.notifier, { loopDefaults: parseSafe(raw) })
    },
    { legacyKey: "qws:player:ghostMode", apply: (raw, r) => r.misc = mergeSection(r.misc, { ghostMode: parseSafe(raw) }) },
    { legacyKey: "qws:ghost:delayMs", apply: (raw, r) => r.misc = mergeSection(r.misc, { ghostDelayMs: parseSafe(raw) }) },
    {
      legacyKey: "qws:autoReco:onNewSession",
      apply: (raw, r) => r.misc = mergeSection(r.misc, { autoRecoEnabled: parseSafe(raw) })
    },
    {
      legacyKey: "qws:autoReco:delayMs",
      apply: (raw, r) => r.misc = mergeSection(r.misc, { autoRecoDelayMs: parseSafe(raw) })
    },
    {
      legacyKey: "qws:locker:restrictions.v1",
      apply: (raw, r) => r.locker = mergeSection(r.locker, { restrictions: parseSafe(raw) })
    },
    { legacyKey: "garden.locker.state.v2", apply: (raw, r) => r.locker = mergeSection(r.locker, { state: parseSafe(raw) }) },
    {
      legacyKey: "qws:editor:saved-gardens",
      apply: (raw, r) => r.editor = mergeSection(r.editor, { savedGardens: parseSafe(raw) })
    },
    {
      legacyKey: "qws:editor:enabled",
      apply: (raw, r) => r.editor = mergeSection(r.editor, { enabled: parseSafe(raw) })
    },
    {
      legacyKey: "qws:activityLogs:history:v1",
      apply: (raw, r) => r.activityLog = mergeSection(r.activityLog, { history: parseSafe(raw) })
    },
    { legacyKey: "qws:activityLog:filter", apply: (raw, r) => r.activityLog = mergeSection(r.activityLog, { filter: parseSafe(raw) }) },
    {
      legacyKey: "qws:alerts:audio:settings:v1",
      apply: (raw, r) => r.audio = mergeSection(r.audio, { settings: parseSafe(raw) })
    },
    {
      legacyKey: "qws:alerts:audio:library:v1",
      apply: (raw, r) => r.audio = mergeSection(r.audio, { library: parseSafe(raw) })
    },
    {
      legacyKey: "soundEffectsVolumeAtom",
      apply: (raw, r) => r.audio = mergeSection(r.audio, { sfxVolumeAtom: parseSafe(raw) })
    },
    { legacyKey: "qws:pos", apply: (raw, r) => r.hud = mergeSection(r.hud, { pos: parseSafe(raw) }) },
    { legacyKey: "qws:collapsed", apply: (raw, r) => r.hud = mergeSection(r.hud, { collapsed: parseSafe(raw) }) },
    { legacyKey: "qws:hidden", apply: (raw, r) => r.hud = mergeSection(r.hud, { hidden: parseSafe(raw) }) },
    {
      legacyKey: "mg-mod.inventory.sortKey",
      apply: (raw, r) => r.inventory = mergeSection(r.inventory, { sortKey: parseSafe(raw) })
    },
    {
      legacyKey: "mg-mod.inventory.sortDirection",
      apply: (raw, r) => r.inventory = mergeSection(r.inventory, { sortDirection: parseSafe(raw) })
    },
    {
      legacyKey: "mg-mod.inventory.showValues",
      apply: (raw, r) => r.inventory = mergeSection(r.inventory, { showValues: parseSafe(raw) })
    }
  ];
  function getHostStorage() {
    if (typeof window === "undefined") return null;
    try {
      if (typeof window.localStorage === "undefined") return null;
      return window.localStorage;
    } catch {
      return null;
    }
  }
  function parseSafe(raw) {
    try {
      return JSON.parse(raw);
    } catch {
      return raw;
    }
  }
  function mergeSection(existing, next) {
    const base = { ...existing ?? {} };
    for (const [k, v] of Object.entries(next)) {
      if (base[k] === void 0) {
        base[k] = v;
      }
    }
    return base;
  }
  function collectByPrefix(storage, prefix, transform) {
    const out = {};
    for (let i = 0; i < storage.length; i++) {
      const key2 = storage.key(i);
      if (!key2 || !key2.startsWith(prefix)) continue;
      const raw = storage.getItem(key2);
      if (raw == null) continue;
      if (transform) {
        const entry = transform(key2, raw);
        if (entry) out[entry[0]] = entry[1];
      } else {
        out[key2.slice(prefix.length)] = parseSafe(raw);
      }
    }
    return out;
  }
  function unwrapNestedSnapshot(raw) {
    let cur = raw;
    let guard = 0;
    while (guard++ < 10 && cur && typeof cur === "object" && "snapshot" in cur && typeof cur.snapshot === "object") {
      cur = cur.snapshot;
    }
    return cur ?? raw;
  }
  function coerceLegacyAggregate(raw) {
    const out = { ...DEFAULT_ARIES_STORAGE };
    if (!raw || typeof raw !== "object") return out;
    const data = raw;
    if (typeof data.version === "number") out.version = data.version;
    if (typeof data.migratedAt === "number") out.migratedAt = data.migratedAt;
    if ("stats" in data) out.stats = unwrapNestedSnapshot(data.stats);
    if ("customRooms" in data) out.room = mergeSection(out.room, { customRooms: data.customRooms });
    if ("pets" in data && typeof data.pets === "object") {
      out.pets = mergeSection(out.pets, data.pets);
    }
    if ("petsOverrides" in data) out.pets = mergeSection(out.pets, { overrides: data.petsOverrides });
    if ("petsUI" in data) out.pets = mergeSection(out.pets, { ui: data.petsUI });
    if ("petTeams" in data) out.pets = mergeSection(out.pets, { teams: data.petTeams });
    if ("petTeamSearch" in data) out.pets = mergeSection(out.pets, { teamSearch: data.petTeamSearch });
    if ("petTeamHotkeys" in data) out.pets = mergeSection(out.pets, { hotkeys: data.petTeamHotkeys });
    if ("petAlerts" in data) out.pets = mergeSection(out.pets, { alerts: data.petAlerts });
    if ("notifier" in data && typeof data.notifier === "object") {
      out.notifier = mergeSection(out.notifier, data.notifier);
    }
    if ("notifierPrefs" in data) out.notifier = mergeSection(out.notifier, { prefs: data.notifierPrefs });
    if ("notifierRules" in data) out.notifier = mergeSection(out.notifier, { rules: data.notifierRules });
    if ("weatherNotifierPrefs" in data) out.notifier = mergeSection(out.notifier, { weatherPrefs: data.weatherNotifierPrefs });
    if ("notifierLoopDefaults" in data) out.notifier = mergeSection(out.notifier, { loopDefaults: data.notifierLoopDefaults });
    if ("misc" in data && typeof data.misc === "object") {
      out.misc = mergeSection(out.misc, data.misc);
    }
    if ("ghostMode" in data) out.misc = mergeSection(out.misc, { ghostMode: data.ghostMode });
    if ("ghostDelayMs" in data) out.misc = mergeSection(out.misc, { ghostDelayMs: data.ghostDelayMs });
    if ("autoRecoEnabled" in data) out.misc = mergeSection(out.misc, { autoRecoEnabled: data.autoRecoEnabled });
    if ("autoRecoDelayMs" in data) out.misc = mergeSection(out.misc, { autoRecoDelayMs: data.autoRecoDelayMs });
    if ("locker" in data && typeof data.locker === "object") {
      out.locker = mergeSection(out.locker, data.locker);
    }
    if ("lockerRestrictions" in data) out.locker = mergeSection(out.locker, { restrictions: data.lockerRestrictions });
    if ("lockerState" in data) out.locker = mergeSection(out.locker, { state: data.lockerState });
    if ("keybinds" in data && typeof data.keybinds === "object") {
      out.keybinds = mergeSection(out.keybinds, data.keybinds);
    }
    if ("editorSavedGardens" in data) out.editor = mergeSection(out.editor, { savedGardens: data.editorSavedGardens });
    if ("editor" in data && typeof data.editor === "object") {
      out.editor = mergeSection(out.editor, data.editor);
    }
    if ("activityLog" in data && typeof data.activityLog === "object") {
      out.activityLog = mergeSection(out.activityLog, data.activityLog);
    }
    if ("activityLogHistory" in data) out.activityLog = mergeSection(out.activityLog, { history: data.activityLogHistory });
    if ("activityLogFilter" in data) out.activityLog = mergeSection(out.activityLog, { filter: data.activityLogFilter });
    if ("hud" in data && typeof data.hud === "object") {
      out.hud = mergeSection(out.hud, data.hud);
    }
    if ("menu" in data && typeof data.menu === "object") {
      out.menu = mergeSection(out.menu, data.menu);
    }
    if ("inventory" in data && typeof data.inventory === "object") {
      out.inventory = mergeSection(out.inventory, data.inventory);
    }
    if ("audio" in data && typeof data.audio === "object") {
      out.audio = mergeSection(out.audio, data.audio);
    }
    if ("audioSettings" in data) out.audio = mergeSection(out.audio, { settings: data.audioSettings });
    if ("audioLibrary" in data) out.audio = mergeSection(out.audio, { library: data.audioLibrary });
    if ("soundEffectsVolumeAtom" in data) out.audio = mergeSection(out.audio, { sfxVolumeAtom: data.soundEffectsVolumeAtom });
    if ("friends" in data && typeof data.friends === "object") {
      out.friends = {
        ...out.friends ?? {},
        ...data.friends
      };
    }
    return out;
  }
  function loadAriesStorage() {
    const storage = getHostStorage();
    if (!storage) return { ...DEFAULT_ARIES_STORAGE };
    const raw = storage.getItem(ARIES_STORAGE_KEY);
    if (raw) {
      const parsed = parseSafe(raw);
      if (parsed && typeof parsed === "object") {
        return coerceLegacyAggregate(parsed);
      }
    }
    return { ...DEFAULT_ARIES_STORAGE };
  }
  function persistAriesStorage(data) {
    const storage = getHostStorage();
    if (!storage) return;
    try {
      storage.setItem(ARIES_STORAGE_KEY, JSON.stringify(data));
    } catch {
    }
  }
  function getValueAtPath(obj, path) {
    let cur = obj;
    for (const segment of path) {
      if (!cur || typeof cur !== "object") return void 0;
      cur = cur[segment];
    }
    return cur;
  }
  function setValueAtPath(obj, path, value) {
    if (!path.length) return;
    let cur = obj;
    for (let i = 0; i < path.length - 1; i++) {
      const key2 = path[i];
      if (!cur[key2] || typeof cur[key2] !== "object") {
        cur[key2] = {};
      }
      cur = cur[key2];
    }
    const last = path[path.length - 1];
    if (value === void 0) {
      if (cur && typeof cur === "object") {
        delete cur[last];
      }
    } else {
      cur[last] = value;
    }
  }
  function hasLegacyData(storage) {
    for (const key2 of LEGACY_STATIC_KEYS) {
      if (storage.getItem(key2) != null) return true;
    }
    for (let i = 0; i < storage.length; i++) {
      const key2 = storage.key(i) || "";
      if (LEGACY_PREFIXES.some((p) => key2.startsWith(p))) return true;
    }
    return false;
  }
  function cleanupLegacyData(storage) {
    for (const key2 of LEGACY_STATIC_KEYS) {
      try {
        storage.removeItem(key2);
      } catch {
      }
    }
    for (let i = storage.length - 1; i >= 0; i--) {
      const key2 = storage.key(i);
      if (!key2) continue;
      if (LEGACY_PREFIXES.some((p) => key2.startsWith(p))) {
        try {
          storage.removeItem(key2);
        } catch {
        }
      }
    }
  }
  function migrateLocalStorageToAries() {
    const storage = getHostStorage();
    if (!storage) return loadAriesStorage();
    const current = loadAriesStorage();
    const shouldMigrate = hasLegacyData(storage);
    const result = { ...DEFAULT_ARIES_STORAGE, ...current };
    if (!shouldMigrate) {
      return result;
    }
    for (const entry of STATIC_LEGACY_KEYS) {
      const { legacyKey, apply } = entry;
      const raw = storage.getItem(legacyKey);
      if (raw == null) continue;
      apply(raw, result);
    }
    const bindings = collectByPrefix(storage, "qws:keybind:", (key2, raw) => [
      key2.replace("qws:keybind:", ""),
      raw
    ]);
    const holds = collectByPrefix(storage, "qws:keybind-hold:", (key2, raw) => [
      key2.replace("qws:keybind-hold:", ""),
      raw === "1" || raw === "true"
    ]);
    if ((Object.keys(bindings).length || Object.keys(holds).length) && !result.keybinds) {
      result.keybinds = {};
    }
    if (Object.keys(bindings).length) {
      result.keybinds = {
        ...result.keybinds ?? {},
        bindings: { ...result.keybinds?.bindings ?? {}, ...bindings }
      };
    }
    if (Object.keys(holds).length) {
      result.keybinds = {
        ...result.keybinds ?? {},
        hold: { ...result.keybinds?.hold ?? {}, ...holds }
      };
    }
    const teamHotkeys = collectByPrefix(storage, "qws:hk:petteam:use:", (key2, raw) => [
      key2.replace("qws:hk:petteam:use:", ""),
      raw
    ]);
    if (Object.keys(teamHotkeys).length) {
      result.pets = {
        ...result.pets ?? {},
        hotkeys: { ...result.pets?.hotkeys ?? {}, ...teamHotkeys }
      };
    }
    const hudWindows = collectByPrefix(storage, "qws:win:", (key2, raw) => {
      const match = key2.match(/^qws:win:(.+):pos$/);
      if (!match || !match[1]) return null;
      return [match[1], parseSafe(raw)];
    });
    if (Object.keys(hudWindows).length) {
      result.hud = {
        ...result.hud ?? {},
        windows: { ...result.hud?.windows ?? {}, ...hudWindows }
      };
    }
    const menuTabs = collectByPrefix(storage, "menu:", (key2, raw) => {
      const match = key2.match(/^menu:(.+):activeTab$/);
      if (!match || !match[1]) return null;
      return [match[1], parseSafe(raw)];
    });
    if (Object.keys(menuTabs).length) {
      const activeTabs = {};
      for (const [k, v] of Object.entries(menuTabs)) {
        if (typeof v === "string") activeTabs[k] = v;
      }
      if (Object.keys(activeTabs).length) {
        result.menu = {
          ...result.menu ?? {},
          activeTabs: { ...result.menu?.activeTabs ?? {}, ...activeTabs }
        };
      }
    }
    if (result.stats && typeof result.stats === "object") {
      const flat = unwrapNestedSnapshot(result.stats);
      result.stats = flat;
    }
    result.version = ARIES_STORAGE_VERSION;
    if (!result.migratedAt) result.migratedAt = Date.now();
    persistAriesStorage(result);
    cleanupLegacyData(storage);
    return result;
  }
  function getAriesStorage() {
    return loadAriesStorage();
  }
  function saveAriesStorage(data) {
    persistAriesStorage(data);
  }
  function updateAriesStorage(mutator) {
    const current = loadAriesStorage();
    mutator(current);
    current.version = ARIES_STORAGE_VERSION;
    persistAriesStorage(current);
    return current;
  }
  function readAriesPath(path, fallback) {
    const parts = path.split(".").filter(Boolean);
    const value = getValueAtPath(loadAriesStorage(), parts);
    if (value === void 0) return fallback;
    return value;
  }
  function writeAriesPath(path, value) {
    return updateAriesStorage((state2) => {
      setValueAtPath(state2, path.split(".").filter(Boolean), value);
    });
  }
  function updateAriesPath(path, updater) {
    return updateAriesStorage((state2) => {
      const parts = path.split(".").filter(Boolean);
      const currentValue = getValueAtPath(state2, parts);
      const next = updater(currentValue);
      setValueAtPath(state2, parts, next);
    });
  }

  // src/services/locker.ts
  var VISUAL_MUTATIONS = /* @__PURE__ */ new Set(["Gold", "Rainbow"]);
  var LOCKER_NO_WEATHER_TAG = "NoWeatherEffect";
  var normalizeMutationTag = (value) => {
    const raw = typeof value === "string" ? value : value == null ? "" : String(value);
    const trimmed = raw.trim();
    if (!trimmed) return "";
    const collapsed = trimmed.toLowerCase().replace(/[\s_-]+/g, "");
    switch (collapsed) {
      case "gold":
        return "Gold";
      case "rainbow":
        return "Rainbow";
      case "wet":
        return "Wet";
      case "chilled":
        return "Chilled";
      case "frozen":
        return "Frozen";
      case "dawn":
      case "dawnlit":
      case "dawnlight":
        return "Dawnlit";
      case "dawnbound":
      case "dawncharged":
      case "dawnradiant":
        return "Dawnbound";
      case "amberlit":
      case "amberlight":
      case "amberglow":
      case "ambershine":
        return "Amberlit";
      case "amberbound":
      case "ambercharged":
      case "amberradiant":
        return "Amberbound";
      default:
        return trimmed;
    }
  };
  var canonicalizeWeatherTag = (value) => {
    if (value === LOCKER_NO_WEATHER_TAG) return LOCKER_NO_WEATHER_TAG;
    const normalized = normalizeMutationTag(value);
    return normalized || null;
  };
  var normalizeMutationsList = (raw) => {
    if (!Array.isArray(raw)) return [];
    const out = [];
    for (let i = 0; i < raw.length; i++) {
      const normalized = normalizeMutationTag(raw[i]);
      if (normalized) out.push(normalized);
    }
    return out;
  };
  var normalizeSpeciesKey = (value) => value.toLowerCase().replace(/['`]/g, "").replace(/\s+/g, "").replace(/-/g, "").replace(/(seed|plant|baby|fruit|crop)$/i, "");
  var MAX_SCALE_BY_SPECIES = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const register = (key2, value) => {
      if (typeof key2 !== "string") return;
      const normalized = normalizeSpeciesKey(key2.trim());
      if (!normalized || map2.has(normalized)) return;
      map2.set(normalized, value);
    };
    for (const [species, entry] of Object.entries(plantCatalog)) {
      const maxScale = Number(entry?.crop?.maxScale);
      if (!Number.isFinite(maxScale) || maxScale <= 0) continue;
      register(species, maxScale);
      register(entry?.seed?.name, maxScale);
      register(entry?.plant?.name, maxScale);
      register(entry?.crop?.name, maxScale);
    }
    return map2;
  })();
  var emptySlotInfo = () => ({
    isPlant: false,
    originalIndex: null,
    orderedIndex: null,
    totalSlots: 0,
    availableSlotCount: 0,
    slot: null,
    seedKey: null,
    sizePercent: null,
    mutations: []
  });
  var now = () => typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now();
  var shallowEqualStrings = (a, b) => {
    if (a === b) return true;
    if (!a || !b) return (a?.length ?? 0) === (b?.length ?? 0);
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  };
  var slotInfosEqual = (a, b) => a.isPlant === b.isPlant && a.originalIndex === b.originalIndex && a.orderedIndex === b.orderedIndex && a.totalSlots === b.totalSlots && a.availableSlotCount === b.availableSlotCount && a.slot === b.slot && a.seedKey === b.seedKey && a.sizePercent === b.sizePercent && shallowEqualStrings(a.mutations, b.mutations);
  var isPlantObject = (o) => !!o && o.objectType === "plant";
  var slotSignature = (slot) => {
    if (!slot) return "\u2205";
    const species = slot.species ?? "";
    const start = Number.isFinite(slot.startTime) ? slot.startTime : 0;
    const end = Number.isFinite(slot.endTime) ? slot.endTime : 0;
    const target = Number.isFinite(slot.targetScale) ? slot.targetScale : 0;
    const muts = Array.isArray(slot.mutations) ? slot.mutations.join(",") : "";
    return `${species}|${start}|${end}|${target}|${muts}`;
  };
  var gardenObjectSignature = (obj) => {
    if (!obj) return "\u2205";
    if (!isPlantObject(obj)) {
      if (!obj || typeof obj !== "object") return String(obj);
      const entries = Object.keys(obj).sort().map((key2) => `${key2}:${JSON.stringify(obj[key2])}`);
      return `other|${entries.join(";")}`;
    }
    const base = `${obj.objectType}|${obj.species ?? ""}|${obj.plantedAt ?? 0}|${obj.maturedAt ?? 0}`;
    const slots = Array.isArray(obj.slots) ? obj.slots.map((slot) => slotSignature(slot)).join("||") : "";
    return `${base}|slots:${slots}`;
  };
  var arraySignature = (arr) => Array.isArray(arr) ? arr.join(",") : "\u2205";
  var defaultOrder = (n) => Array.from({ length: n }, (_, i) => i);
  var clamp = (n, min, max) => Math.max(min, Math.min(max, n));
  var extractSeedKey = (obj) => {
    if (!obj || typeof obj !== "object") return null;
    if (typeof obj.seedKey === "string") {
      return obj.seedKey;
    }
    if (typeof obj.species === "string" && obj.species) {
      return obj.species;
    }
    const asAny = obj;
    const fallbacks = ["seedSpecies", "plantSpecies", "cropSpecies", "speciesId"];
    for (const key2 of fallbacks) {
      const value = asAny[key2];
      if (typeof value === "string" && value) return value;
    }
    return null;
  };
  var clampPercent = (value, min, max) => Math.max(min, Math.min(max, value));
  var lookupMaxScale = (species) => {
    if (typeof species !== "string") return null;
    const normalized = normalizeSpeciesKey(species.trim());
    if (!normalized) return null;
    const found = MAX_SCALE_BY_SPECIES.get(normalized);
    if (typeof found === "number" && Number.isFinite(found) && found > 0) {
      return found;
    }
    return null;
  };
  var getMaxScaleForSlot = (slot) => {
    if (!slot || typeof slot !== "object") return null;
    const candidates = /* @__PURE__ */ new Set();
    const fromSeedKey = extractSeedKey(slot);
    if (fromSeedKey) candidates.add(fromSeedKey);
    const fields = [
      "species",
      "seedSpecies",
      "plantSpecies",
      "cropSpecies",
      "baseSpecies",
      "seedKey"
    ];
    for (const field of fields) {
      const value = slot[field];
      if (typeof value === "string" && value) {
        candidates.add(value);
      }
    }
    for (const cand of candidates) {
      const max = lookupMaxScale(cand);
      if (typeof max === "number" && Number.isFinite(max) && max > 0) {
        return max;
      }
    }
    return null;
  };
  var extractSizePercent = (slot) => {
    if (!slot || typeof slot !== "object") return 100;
    const direct = Number(slot.sizePercent ?? slot.sizePct ?? slot.size ?? slot.percent ?? slot.progressPercent);
    if (Number.isFinite(direct)) {
      return clampPercent(Math.round(direct), 0, 100);
    }
    const scale = Number(slot.targetScale ?? slot.scale);
    if (Number.isFinite(scale)) {
      const maxScale = getMaxScaleForSlot(slot);
      if (typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > 1) {
        const clamped = Math.max(1, Math.min(maxScale, scale));
        const pct2 = 50 + (clamped - 1) / (maxScale - 1) * 50;
        return clampPercent(Math.round(pct2), 50, 100);
      }
      if (scale > 1 && scale <= 2) {
        const pct2 = 50 + (scale - 1) / 1 * 50;
        return clampPercent(Math.round(pct2), 50, 100);
      }
      const pct = Math.round(scale * 100);
      return clampPercent(pct, 0, 100);
    }
    return 100;
  };
  function startLockerSlotWatcherViaGardenObject() {
    if (typeof window === "undefined") {
      return {
        get: () => emptySlotInfo(),
        onChange: () => () => {
        },
        stop() {
        },
        recompute() {
        }
      };
    }
    let cur = null;
    let sortedIdx = null;
    let sortedIdxSig = arraySignature(sortedIdx);
    let selectedIdx = null;
    let lastInfo = emptySlotInfo();
    let curSig = gardenObjectSignature(cur);
    const listeners5 = /* @__PURE__ */ new Set();
    const notify2 = () => {
      for (const fn of listeners5) {
        try {
          fn(lastInfo);
        } catch {
        }
      }
    };
    let scheduled = false;
    const scheduleRecomputeAndNotify = () => {
      recomputeAndNotify();
      if (scheduled) return;
      scheduled = true;
      const run = () => {
        scheduled = false;
        recomputeAndNotify();
      };
      if (typeof globalThis !== "undefined" && typeof globalThis.queueMicrotask === "function") {
        globalThis.queueMicrotask(run);
      } else if (typeof Promise !== "undefined") {
        Promise.resolve().then(run);
      } else if (typeof window !== "undefined" && typeof window.setTimeout === "function") {
        window.setTimeout(run, 0);
      } else {
        run();
      }
    };
    function getOrder(slotCount) {
      if (!slotCount) return [];
      if (Array.isArray(sortedIdx) && sortedIdx.length === slotCount) {
        return sortedIdx.slice();
      }
      return defaultOrder(slotCount);
    }
    function selectedOrderedPosition(order, slotCount) {
      if (!slotCount || !order.length) return 0;
      const raw = Number.isFinite(selectedIdx) ? selectedIdx : 0;
      const clampedRaw = clamp(raw, 0, slotCount - 1);
      const pos = order.indexOf(clampedRaw);
      return pos >= 0 ? pos : 0;
    }
    function sanitizeMutations2(raw) {
      return normalizeMutationsList(raw);
    }
    function computeSlotInfo() {
      const seedKey = extractSeedKey(cur);
      if (!isPlantObject(cur)) {
        return {
          isPlant: false,
          originalIndex: null,
          orderedIndex: null,
          totalSlots: 0,
          availableSlotCount: 0,
          slot: null,
          seedKey,
          sizePercent: null,
          mutations: []
        };
      }
      const slots = Array.isArray(cur.slots) ? cur.slots : [];
      const slotCount = slots.length;
      if (!slotCount) {
        return {
          isPlant: true,
          originalIndex: null,
          orderedIndex: null,
          totalSlots: 0,
          availableSlotCount: 0,
          slot: null,
          seedKey,
          sizePercent: null,
          mutations: []
        };
      }
      const order = getOrder(slotCount);
      const availableIndices = [];
      for (const idx of order) {
        if (Number.isInteger(idx) && idx >= 0 && idx < slotCount) {
          if (slots[idx] != null) availableIndices.push(idx);
        }
      }
      const availableCount = availableIndices.length;
      if (!availableCount) {
        return {
          isPlant: true,
          originalIndex: null,
          orderedIndex: null,
          totalSlots: slotCount,
          availableSlotCount: 0,
          slot: null,
          seedKey,
          sizePercent: null,
          mutations: []
        };
      }
      const pos = selectedOrderedPosition(order, slotCount);
      const clampedPos = clamp(pos, 0, availableCount - 1);
      const originalIndex = availableIndices[clampedPos] ?? null;
      const slot = typeof originalIndex === "number" ? slots[originalIndex] ?? null : null;
      const sizePercent = slot ? extractSizePercent(slot) : null;
      const mutations = slot ? sanitizeMutations2(slot.mutations) : [];
      return {
        isPlant: true,
        originalIndex: typeof originalIndex === "number" ? originalIndex : null,
        orderedIndex: clampedPos,
        totalSlots: slotCount,
        availableSlotCount: availableCount,
        slot: slot ?? null,
        seedKey,
        sizePercent,
        mutations
      };
    }
    function mutationsEqual(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }
    function infosEqual(a, b) {
      return a.isPlant === b.isPlant && a.originalIndex === b.originalIndex && a.orderedIndex === b.orderedIndex && a.totalSlots === b.totalSlots && a.availableSlotCount === b.availableSlotCount && a.slot === b.slot && a.seedKey === b.seedKey && a.sizePercent === b.sizePercent && mutationsEqual(a.mutations, b.mutations);
    }
    function recomputeAndNotify() {
      const next = computeSlotInfo();
      if (!infosEqual(next, lastInfo)) {
        lastInfo = next;
        notify2();
      }
    }
    (async () => {
      try {
        selectedIdx = await myCurrentGrowSlotIndex.get();
      } catch {
      }
      try {
        const v = await myCurrentSortedGrowSlotIndices.get();
        sortedIdx = Array.isArray(v) ? v.slice() : null;
        sortedIdxSig = arraySignature(sortedIdx);
      } catch {
      }
      try {
        cur = await myCurrentGardenObject.get();
        curSig = gardenObjectSignature(cur);
      } catch {
      }
      const refreshSorted = (v) => {
        const next = Array.isArray(v) ? v.slice() : null;
        const sig = arraySignature(next);
        if (sig === sortedIdxSig) return false;
        sortedIdx = next;
        sortedIdxSig = sig;
        return true;
      };
      const refreshGarden = (v) => {
        const sig = gardenObjectSignature(v ?? null);
        if (sig === curSig) return false;
        cur = v;
        curSig = sig;
        return true;
      };
      let awaitIndexBeforeRecompute = false;
      let awaitIndexTimer = null;
      const clearAwaitIndexTimer = () => {
        if (awaitIndexTimer == null) return;
        if (typeof globalThis !== "undefined") {
          const clearer = globalThis.clearTimeout;
          if (typeof clearer === "function") {
            clearer.call(globalThis, awaitIndexTimer);
          }
        }
        awaitIndexTimer = null;
      };
      const deferUntilIndexChanges = () => {
        awaitIndexBeforeRecompute = true;
        if (awaitIndexTimer != null) return;
        const run = () => {
          awaitIndexTimer = null;
          if (!awaitIndexBeforeRecompute) return;
          awaitIndexBeforeRecompute = false;
          scheduleRecomputeAndNotify();
        };
        if (typeof globalThis !== "undefined") {
          const setter = globalThis.setTimeout;
          if (typeof setter === "function") {
            awaitIndexTimer = setter.call(globalThis, run, 0);
            return;
          }
        }
        run();
      };
      myCurrentSortedGrowSlotIndices.onChange((v) => {
        const changed = refreshSorted(v);
        if (!changed) return;
        deferUntilIndexChanges();
      });
      myCurrentGardenObject.onChange((v) => {
        const changed = refreshGarden(v);
        if (!changed) return;
        deferUntilIndexChanges();
      });
      myCurrentGrowSlotIndex.onChange((idx) => {
        selectedIdx = Number.isFinite(idx) ? idx : 0;
        void (async () => {
          try {
            refreshSorted(await myCurrentSortedGrowSlotIndices.get());
          } catch {
          }
          try {
            refreshGarden(await myCurrentGardenObject.get());
          } catch {
          }
          if (awaitIndexBeforeRecompute) {
            awaitIndexBeforeRecompute = false;
            clearAwaitIndexTimer();
          }
          scheduleRecomputeAndNotify();
        })();
      });
      recomputeAndNotify();
    })();
    return {
      get() {
        return lastInfo;
      },
      onChange(cb) {
        listeners5.add(cb);
        return () => listeners5.delete(cb);
      },
      stop() {
        listeners5.clear();
      },
      recompute() {
        recomputeAndNotify();
      }
    };
  }
  function defaultSettings() {
    return {
      minScalePct: 50,
      maxScalePct: 100,
      scaleLockMode: "RANGE",
      lockMode: "LOCK",
      minInventory: 91,
      avoidNormal: false,
      includeNormal: true,
      visualMutations: [],
      weatherMode: "ANY",
      weatherSelected: [],
      weatherRecipes: []
    };
  }
  function defaultState() {
    return {
      enabled: false,
      settings: defaultSettings(),
      overrides: {}
    };
  }
  var ARIES_LOCKER_STATE_PATH = "locker.state";
  var clampNumber = (value, min, max) => Math.max(min, Math.min(max, value));
  function sanitizeSettings(raw) {
    const base = defaultSettings();
    base.lockMode = raw?.lockMode === "ALLOW" ? "ALLOW" : "LOCK";
    const rawMode = raw?.scaleLockMode;
    const scaleMode = rawMode === "MINIMUM" ? "MINIMUM" : rawMode === "MAXIMUM" ? "MAXIMUM" : rawMode === "NONE" ? "NONE" : "RANGE";
    base.scaleLockMode = scaleMode;
    const minScaleRaw = Number(raw?.minScalePct);
    let minScale = Number.isFinite(minScaleRaw) ? clampNumber(Math.round(minScaleRaw), 50, 100) : 50;
    const maxScaleRaw = Number(raw?.maxScalePct);
    let maxScale = Number.isFinite(maxScaleRaw) ? clampNumber(Math.round(maxScaleRaw), 50, 100) : 100;
    if (scaleMode === "RANGE") {
      maxScale = clampNumber(maxScale, 51, 100);
      if (maxScale <= minScale) {
        if (minScale >= 99) {
          minScale = 99;
          maxScale = 100;
        } else {
          maxScale = clampNumber(minScale + 1, 51, 100);
        }
      }
    } else if (scaleMode === "MAXIMUM") {
      maxScale = clampNumber(maxScale, 50, 100);
    } else if (scaleMode === "MINIMUM") {
      minScale = clampNumber(minScale, 50, 100);
    }
    base.minScalePct = minScale;
    base.maxScalePct = maxScale;
    const minInv = Number(raw?.minInventory);
    base.minInventory = Number.isFinite(minInv) ? clampNumber(Math.round(minInv), 0, 999) : 91;
    if (typeof raw?.avoidNormal === "boolean") {
      base.avoidNormal = raw.avoidNormal;
    } else {
      base.avoidNormal = raw?.includeNormal === false;
    }
    base.includeNormal = !base.avoidNormal;
    base.visualMutations = Array.isArray(raw?.visualMutations) ? Array.from(new Set(raw.visualMutations.filter((m) => VISUAL_MUTATIONS.has(m)))) : [];
    const mode = raw?.weatherMode;
    base.weatherMode = mode === "ALL" || mode === "RECIPES" ? mode : "ANY";
    base.weatherSelected = Array.isArray(raw?.weatherSelected) ? Array.from(new Set(raw.weatherSelected.map((m) => String(m || "")).filter(Boolean))) : [];
    base.weatherRecipes = Array.isArray(raw?.weatherRecipes) ? raw.weatherRecipes.map(
      (recipe) => Array.isArray(recipe) ? Array.from(new Set(recipe.map((m) => String(m || "")).filter(Boolean))) : []
    ).filter((arr) => arr.length > 0) : [];
    return base;
  }
  function sanitizeState(raw) {
    const state2 = defaultState();
    if (!raw || typeof raw !== "object") return state2;
    state2.enabled = raw.enabled === true;
    state2.settings = sanitizeSettings(raw.settings);
    state2.overrides = {};
    if (raw.overrides && typeof raw.overrides === "object") {
      for (const [key2, value] of Object.entries(raw.overrides)) {
        if (!key2) continue;
        state2.overrides[key2] = {
          enabled: value?.enabled === true,
          settings: sanitizeSettings(value?.settings)
        };
      }
    }
    return state2;
  }
  function cloneSettings(settings) {
    return {
      minScalePct: settings.minScalePct,
      maxScalePct: settings.maxScalePct,
      scaleLockMode: settings.scaleLockMode,
      lockMode: settings.lockMode === "ALLOW" ? "ALLOW" : "LOCK",
      minInventory: settings.minInventory,
      avoidNormal: settings.avoidNormal,
      includeNormal: settings.includeNormal,
      visualMutations: settings.visualMutations.slice(),
      weatherMode: settings.weatherMode,
      weatherSelected: settings.weatherSelected.slice(),
      weatherRecipes: settings.weatherRecipes.map((recipe) => recipe.slice())
    };
  }
  function cloneState(state2) {
    const overrides = {};
    for (const [key2, value] of Object.entries(state2.overrides)) {
      overrides[key2] = { enabled: value.enabled, settings: cloneSettings(value.settings) };
    }
    return {
      enabled: state2.enabled,
      settings: cloneSettings(state2.settings),
      overrides
    };
  }
  function cloneSlotInfo(info) {
    return {
      isPlant: info.isPlant,
      originalIndex: info.originalIndex,
      orderedIndex: info.orderedIndex,
      totalSlots: info.totalSlots,
      availableSlotCount: info.availableSlotCount,
      slot: info.slot,
      seedKey: info.seedKey,
      sizePercent: info.sizePercent,
      mutations: info.mutations.slice()
    };
  }
  function mutationsToArrays(raw) {
    const normalized = normalizeMutationsList(raw);
    let hasGold = false;
    let hasRainbow = false;
    const weather2 = [];
    for (let i = 0; i < normalized.length; i++) {
      const tag = String(normalized[i] || "");
      if (!tag) continue;
      if (tag === "Gold") {
        hasGold = true;
      } else if (tag === "Rainbow") {
        hasRainbow = true;
      } else {
        weather2.push(tag);
      }
    }
    return { hasGold, hasRainbow, weather: weather2 };
  }
  var LockerService = class {
    constructor() {
      __publicField(this, "state", defaultState());
      __publicField(this, "listeners", /* @__PURE__ */ new Set());
      __publicField(this, "slotInfoListeners", /* @__PURE__ */ new Set());
      __publicField(this, "slotWatcher", null);
      __publicField(this, "slotWatcherUnsub", null);
      __publicField(this, "currentSlotInfo", emptySlotInfo());
      __publicField(this, "currentSlotHarvestAllowed", null);
      __publicField(this, "lastSlotChangeDetectedAt", null);
      this.load();
      this.updateSlotWatcher();
    }
    load() {
      if (typeof window === "undefined") {
        this.state = defaultState();
        return;
      }
      try {
        const parsed = readAriesPath(ARIES_LOCKER_STATE_PATH);
        this.state = sanitizeState(parsed);
      } catch {
        this.state = defaultState();
      }
    }
    save() {
      if (typeof window === "undefined") return;
      try {
        writeAriesPath(ARIES_LOCKER_STATE_PATH, this.state);
      } catch {
      }
    }
    emit() {
      if (!this.listeners.size) return;
      const snapshot = this.getState();
      const event = { type: "locker-state-changed", state: snapshot };
      for (const listener of this.listeners) {
        try {
          listener(event);
        } catch {
        }
      }
    }
    setState(next) {
      this.state = next;
      this.updateSlotWatcher();
      this.save();
      this.emit();
      this.requestSlotWatcherRecompute();
      this.reapplyCurrentSlotInfo();
    }
    updateSlotWatcher() {
      const shouldWatch = this.state.enabled;
      if (shouldWatch) {
        if (!this.slotWatcher) {
          this.slotWatcher = startLockerSlotWatcherViaGardenObject();
        }
        if (this.slotWatcher && !this.slotWatcherUnsub) {
          try {
            this.slotWatcherUnsub = this.slotWatcher.onChange((info) => this.handleSlotInfo(info));
          } catch {
            this.slotWatcherUnsub = null;
          }
        }
        try {
          const info = this.slotWatcher ? this.slotWatcher.get() : emptySlotInfo();
          this.handleSlotInfo(info, { silent: true });
        } catch {
          this.handleSlotInfo(emptySlotInfo(), { silent: true });
        }
        return;
      }
      this.detachSlotWatcher();
    }
    getState() {
      return cloneState(this.state);
    }
    setGlobalState(next) {
      const current = this.state;
      const sanitized = sanitizeSettings(next.settings);
      const updated = {
        enabled: !!next.enabled,
        settings: sanitized,
        overrides: { ...current.overrides }
      };
      this.setState(updated);
    }
    setOverride(seedKey, override) {
      if (!seedKey) return;
      const sanitized = {
        enabled: !!override?.enabled,
        settings: sanitizeSettings(override?.settings)
      };
      const overrides = { ...this.state.overrides, [seedKey]: sanitized };
      this.setState({ ...this.state, overrides });
    }
    removeOverride(seedKey) {
      if (!seedKey) return;
      if (!(seedKey in this.state.overrides)) return;
      const overrides = { ...this.state.overrides };
      delete overrides[seedKey];
      this.setState({ ...this.state, overrides });
    }
    subscribe(listener) {
      this.listeners.add(listener);
      return () => this.listeners.delete(listener);
    }
    onSlotInfoChange(listener) {
      this.slotInfoListeners.add(listener);
      return () => this.slotInfoListeners.delete(listener);
    }
    getCurrentSlotSnapshot() {
      return {
        info: cloneSlotInfo(this.currentSlotInfo),
        harvestAllowed: this.currentSlotHarvestAllowed,
        detectedAt: this.lastSlotChangeDetectedAt
      };
    }
    requestSlotWatcherRecompute() {
      if (!this.slotWatcher) return;
      try {
        this.slotWatcher.recompute();
      } catch {
      }
    }
    detachSlotWatcher() {
      if (this.slotWatcherUnsub) {
        try {
          this.slotWatcherUnsub();
        } catch {
        }
        this.slotWatcherUnsub = null;
      }
      if (this.slotWatcher) {
        try {
          this.slotWatcher.stop();
        } catch {
        }
        this.slotWatcher = null;
      }
      this.handleSlotInfo(emptySlotInfo(), { silent: true });
    }
    handleSlotInfo(info, opts = {}) {
      const { silent = false } = opts;
      const prevInfo = this.currentSlotInfo;
      const prevHarvestAllowed = this.currentSlotHarvestAllowed;
      const normalizedMutations = normalizeMutationsList(info.mutations);
      const nextInfo = { ...info, mutations: normalizedMutations };
      let computedSizePercent = null;
      let harvestAllowed = null;
      let displaySizePercent = null;
      if (nextInfo.isPlant && nextInfo.slot) {
        if (typeof nextInfo.sizePercent === "number" && Number.isFinite(nextInfo.sizePercent)) {
          computedSizePercent = nextInfo.sizePercent;
        } else {
          computedSizePercent = extractSizePercent(nextInfo.slot);
        }
        try {
          const assessment = this.assessHarvest({
            seedKey: nextInfo.seedKey ?? null,
            sizePercent: computedSizePercent ?? 0,
            mutations: normalizedMutations
          });
          harvestAllowed = assessment.allowed;
        } catch {
          harvestAllowed = null;
        }
      } else {
        computedSizePercent = typeof nextInfo.sizePercent === "number" && Number.isFinite(nextInfo.sizePercent) ? nextInfo.sizePercent : null;
        harvestAllowed = null;
      }
      if (typeof computedSizePercent === "number") {
        displaySizePercent = Math.max(50, Math.min(100, computedSizePercent));
      }
      this.currentSlotInfo = nextInfo;
      this.currentSlotHarvestAllowed = harvestAllowed;
      if (!silent) {
        if (nextInfo.isPlant) {
          if (nextInfo.slot) {
            console.log("[Locker] Slot selection", {
              seedKey: nextInfo.seedKey ?? null,
              slotIndex: nextInfo.originalIndex,
              orderedIndex: nextInfo.orderedIndex,
              sizePercent: computedSizePercent,
              displaySizePercent,
              harvestAllowed,
              mutations: normalizedMutations,
              slot: nextInfo.slot
            });
          } else {
            console.log("[Locker] Slot selection", {
              isPlant: true,
              slotIndex: nextInfo.originalIndex,
              orderedIndex: nextInfo.orderedIndex,
              totalSlots: nextInfo.totalSlots,
              availableSlotCount: nextInfo.availableSlotCount,
              seedKey: nextInfo.seedKey ?? null,
              displaySizePercent,
              slot: nextInfo.slot
            });
          }
        } else {
          console.log("[Locker] Slot selection", { isPlant: false, slot: nextInfo.slot });
        }
        const infoChanged = !slotInfosEqual(prevInfo, nextInfo) || (prevHarvestAllowed ?? null) !== (harvestAllowed ?? null);
        if (infoChanged) {
          this.lastSlotChangeDetectedAt = now();
        }
      }
      this.emitSlotInfoChange();
    }
    reapplyCurrentSlotInfo() {
      try {
        const info = this.slotWatcher ? this.slotWatcher.get() : emptySlotInfo();
        this.handleSlotInfo(info, { silent: true });
      } catch {
        this.handleSlotInfo(emptySlotInfo(), { silent: true });
      }
    }
    recomputeCurrentSlot() {
      this.requestSlotWatcherRecompute();
      this.reapplyCurrentSlotInfo();
    }
    effectiveSettings(seedKey) {
      if (!this.state.enabled) {
        return { enabled: false, settings: this.state.settings };
      }
      if (seedKey) {
        const override = this.state.overrides[seedKey];
        if (override?.enabled) {
          return { enabled: true, settings: override.settings };
        }
      }
      return { enabled: true, settings: this.state.settings };
    }
    assessHarvest(args) {
      const effective = this.effectiveSettings(args.seedKey);
      const filters = this.evaluateLockFilters(effective.settings, args);
      const lockMode = effective.settings.lockMode === "ALLOW" ? "ALLOW" : "LOCK";
      if (!effective.enabled) {
        return { effective, filters, lockMode, allowed: true };
      }
      const blocked = lockMode === "ALLOW" ? filters.size.hasCriteria && !filters.size.matched || filters.color.hasCriteria && !filters.color.matched || filters.weather.hasCriteria && !filters.weather.matched : filters.matchAny;
      return { effective, filters, lockMode, allowed: !blocked };
    }
    evaluateLockFilters(settings, args) {
      const size = { hasCriteria: false, matched: false };
      const color = { hasCriteria: false, matched: false };
      const weatherInfo = { hasCriteria: false, matched: false };
      const scaleMode = settings.scaleLockMode === "MAXIMUM" ? "MAXIMUM" : settings.scaleLockMode === "MINIMUM" ? "MINIMUM" : settings.scaleLockMode === "NONE" ? "NONE" : "RANGE";
      const minScale = clampNumber(Math.round(settings.minScalePct ?? 50), 50, 100);
      const maxScaleBase = clampNumber(Math.round(settings.maxScalePct ?? 100), 50, 100);
      const epsilon = 1e-4;
      let sizeMin = null;
      let sizeMax = null;
      if (scaleMode === "RANGE") {
        size.hasCriteria = true;
        const maxScaleRaw = clampNumber(maxScaleBase, 51, 100);
        const maxScale = maxScaleRaw <= minScale ? Math.min(100, Math.max(51, minScale + 1)) : maxScaleRaw;
        sizeMin = minScale;
        sizeMax = maxScale;
        const inRange = args.sizePercent + epsilon >= minScale && args.sizePercent - epsilon <= maxScale;
        size.matched = inRange;
      } else if (scaleMode === "MINIMUM") {
        size.hasCriteria = true;
        sizeMin = minScale;
        size.matched = args.sizePercent + epsilon >= minScale;
      } else if (scaleMode === "MAXIMUM") {
        size.hasCriteria = true;
        const maxScale = clampNumber(maxScaleBase, 50, 100);
        sizeMax = maxScale;
        size.matched = args.sizePercent - epsilon <= maxScale;
      }
      const { hasGold, hasRainbow, weather: weather2 } = mutationsToArrays(args.mutations);
      const isNormal = !hasGold && !hasRainbow;
      const avoidGold = settings.visualMutations.includes("Gold");
      const avoidRainbow = settings.visualMutations.includes("Rainbow");
      const colorFilters = [
        settings.avoidNormal ? "normal" : null,
        avoidGold ? "gold" : null,
        avoidRainbow ? "rainbow" : null
      ].filter(Boolean);
      if (colorFilters.length) {
        color.hasCriteria = true;
        const matches = settings.avoidNormal && isNormal || avoidGold && hasGold || avoidRainbow && hasRainbow;
        color.matched = matches;
      }
      const selected = settings.weatherSelected ?? [];
      const mode = settings.weatherMode ?? "ANY";
      if (mode === "RECIPES") {
        const recipes = settings.weatherRecipes ?? [];
        if (recipes.length) {
          weatherInfo.hasCriteria = true;
          let recipeMatch = false;
          for (const recipe of recipes) {
            if (!Array.isArray(recipe) || recipe.length === 0) continue;
            let matches = true;
            for (let j = 0; j < recipe.length; j++) {
              const rawTag = recipe[j];
              const normalizedRequired = canonicalizeWeatherTag(rawTag);
              if (!normalizedRequired) {
                matches = false;
                break;
              }
              if (normalizedRequired === LOCKER_NO_WEATHER_TAG) {
                if (weather2.length !== 0) {
                  matches = false;
                  break;
                }
                continue;
              }
              if (!weather2.includes(normalizedRequired)) {
                matches = false;
                break;
              }
            }
            if (matches) {
              recipeMatch = true;
              break;
            }
          }
          weatherInfo.matched = recipeMatch;
        }
        const matchAny2 = size.matched || color.matched || weatherInfo.matched;
        return { size, color, weather: weatherInfo, matchAny: matchAny2, sizeMin, sizeMax, scaleMode };
      }
      if (selected.length) {
        weatherInfo.hasCriteria = true;
        if (mode === "ALL") {
          let allMatch = true;
          for (let i = 0; i < selected.length; i++) {
            const requiredRaw = selected[i];
            const normalizedRequired = canonicalizeWeatherTag(requiredRaw);
            if (!normalizedRequired) {
              allMatch = false;
              break;
            }
            if (normalizedRequired === LOCKER_NO_WEATHER_TAG) {
              if (weather2.length !== 0) {
                allMatch = false;
                break;
              }
              continue;
            }
            if (!weather2.includes(normalizedRequired)) {
              allMatch = false;
              break;
            }
          }
          weatherInfo.matched = allMatch;
        } else {
          let anyMatch = false;
          for (let i = 0; i < selected.length; i++) {
            const requiredRaw = selected[i];
            const normalizedRequired = canonicalizeWeatherTag(requiredRaw);
            if (!normalizedRequired) {
              continue;
            }
            if (normalizedRequired === LOCKER_NO_WEATHER_TAG) {
              if (weather2.length === 0) {
                anyMatch = true;
                break;
              }
              continue;
            }
            if (weather2.includes(normalizedRequired)) {
              anyMatch = true;
              break;
            }
          }
          weatherInfo.matched = anyMatch;
        }
      }
      const matchAny = size.matched || color.matched || weatherInfo.matched;
      return { size, color, weather: weatherInfo, matchAny, sizeMin, sizeMax, scaleMode };
    }
    emitSlotInfoChange() {
      if (!this.slotInfoListeners.size) {
        return;
      }
      const snapshot = {
        type: "locker-slot-info-changed",
        info: cloneSlotInfo(this.currentSlotInfo),
        harvestAllowed: this.currentSlotHarvestAllowed,
        detectedAt: this.lastSlotChangeDetectedAt
      };
      for (const listener of this.slotInfoListeners) {
        try {
          listener(snapshot);
        } catch {
        }
      }
    }
    allowsHarvest(args) {
      return this.assessHarvest(args).allowed;
    }
  };
  var lockerService = new LockerService();

  // src/services/stats.ts
  var GARDEN_INT_KEYS = {
    totalPlanted: true,
    totalHarvested: true,
    totalDestroyed: true,
    watercanUsed: true,
    waterTimeSavedMs: true
  };
  var SHOP_INT_KEYS = {
    seedsBought: true,
    decorBought: true,
    eggsBought: true,
    toolsBought: true,
    cropsSoldCount: true,
    cropsSoldValue: false,
    petsSoldCount: true,
    petsSoldValue: false
  };
  var ABILITY_INT_KEYS = {
    triggers: true,
    totalValue: false
  };
  var WEATHER_INT_KEYS = {
    triggers: true
  };
  var memoryStore = null;
  var listeners = /* @__PURE__ */ new Set();
  var isRecord = (value) => typeof value === "object" && value !== null;
  var toNumber = (value, fallback = 0) => {
    const num = Number(value);
    if (!Number.isFinite(num)) return fallback;
    return num;
  };
  var toPositiveNumber = (value, fallback = 0) => {
    const num = toNumber(value, fallback);
    return Math.max(0, num);
  };
  var toPositiveInt = (value, fallback = 0) => {
    const num = toPositiveNumber(value, fallback);
    return Math.floor(num);
  };
  var toPositiveTimestamp = (value, fallback) => {
    const num = Number(value);
    if (!Number.isFinite(num) || num <= 0) return fallback;
    return Math.floor(num);
  };
  var cloneStats = (stats) => ({
    createdAt: stats.createdAt,
    garden: { ...stats.garden },
    shops: { ...stats.shops },
    pets: {
      hatchedByType: Object.fromEntries(
        Object.entries(stats.pets.hatchedByType).map(([key2, counts]) => [key2, { ...counts }])
      )
    },
    abilities: Object.fromEntries(
      Object.entries(stats.abilities).map(([key2, value]) => [key2, { ...value }])
    ),
    weather: Object.fromEntries(
      Object.entries(stats.weather).map(([key2, value]) => [key2, { ...value }])
    )
  });
  var unwrapMaybeNestedSnapshot = (raw) => {
    let cur = raw;
    let guard = 0;
    while (guard++ < 10 && isRecord(cur) && "snapshot" in cur && isRecord(cur.snapshot)) {
      cur = cur.snapshot;
    }
    return cur;
  };
  function createDefaultStats(createdAt = Date.now()) {
    const hatchedByType = {};
    for (const species of Object.keys(petCatalog)) {
      hatchedByType[species.toLowerCase()] = { normal: 0, gold: 0, rainbow: 0 };
    }
    const abilities = {};
    for (const abilityId of Object.keys(petAbilities)) {
      abilities[abilityId] = { triggers: 0, totalValue: 0 };
    }
    const weather2 = {};
    for (const key2 of Object.keys(weatherCatalog)) {
      weather2[key2.toLowerCase()] = { triggers: 0 };
    }
    return {
      createdAt,
      garden: {
        totalPlanted: 0,
        totalHarvested: 0,
        totalDestroyed: 0,
        watercanUsed: 0,
        waterTimeSavedMs: 0
      },
      shops: {
        seedsBought: 0,
        decorBought: 0,
        eggsBought: 0,
        toolsBought: 0,
        cropsSoldCount: 0,
        cropsSoldValue: 0,
        petsSoldCount: 0,
        petsSoldValue: 0
      },
      pets: { hatchedByType },
      abilities,
      weather: weather2
    };
  }
  function normalizeHatchedCounts(value, fallback) {
    if (!isRecord(value)) return { ...fallback };
    return {
      normal: toPositiveInt(value.normal, fallback.normal),
      gold: toPositiveInt(value.gold, fallback.gold),
      rainbow: toPositiveInt(value.rainbow, fallback.rainbow)
    };
  }
  function normalizeStats(raw) {
    const fallbackCreatedAt = Date.now();
    const base = createDefaultStats(fallbackCreatedAt);
    if (!isRecord(raw)) return base;
    if (Object.prototype.hasOwnProperty.call(raw, "createdAt")) {
      base.createdAt = toPositiveTimestamp(raw.createdAt, fallbackCreatedAt);
    }
    if (isRecord(raw.garden)) {
      base.garden = {
        totalPlanted: toPositiveInt(raw.garden.totalPlanted, base.garden.totalPlanted),
        totalHarvested: toPositiveInt(raw.garden.totalHarvested, base.garden.totalHarvested),
        totalDestroyed: toPositiveInt(raw.garden.totalDestroyed, base.garden.totalDestroyed),
        watercanUsed: toPositiveInt(raw.garden.watercanUsed, base.garden.watercanUsed),
        waterTimeSavedMs: toPositiveInt(raw.garden.waterTimeSavedMs, base.garden.waterTimeSavedMs)
      };
    }
    if (isRecord(raw.shops)) {
      base.shops = {
        seedsBought: toPositiveInt(raw.shops.seedsBought, base.shops.seedsBought),
        decorBought: toPositiveInt(raw.shops.decorBought, base.shops.decorBought),
        eggsBought: toPositiveInt(raw.shops.eggsBought, base.shops.eggsBought),
        toolsBought: toPositiveInt(raw.shops.toolsBought, base.shops.toolsBought),
        cropsSoldCount: toPositiveInt(raw.shops.cropsSoldCount, base.shops.cropsSoldCount),
        cropsSoldValue: toPositiveNumber(raw.shops.cropsSoldValue, base.shops.cropsSoldValue),
        petsSoldCount: toPositiveInt(raw.shops.petsSoldCount, base.shops.petsSoldCount),
        petsSoldValue: toPositiveNumber(raw.shops.petsSoldValue, base.shops.petsSoldValue)
      };
    }
    if (isRecord(raw.pets) && isRecord(raw.pets.hatchedByType)) {
      for (const [key2, counts] of Object.entries(raw.pets.hatchedByType)) {
        if (typeof key2 !== "string") continue;
        const normalizedKey = key2.toLowerCase();
        const fallback = base.pets.hatchedByType[normalizedKey] ?? { normal: 0, gold: 0, rainbow: 0 };
        base.pets.hatchedByType[normalizedKey] = normalizeHatchedCounts(counts, fallback);
      }
    }
    if (isRecord(raw.abilities)) {
      for (const [key2, value] of Object.entries(raw.abilities)) {
        if (typeof key2 !== "string" || !isRecord(value)) continue;
        base.abilities[key2] = {
          triggers: toPositiveInt(value.triggers, base.abilities[key2]?.triggers ?? 0),
          totalValue: toPositiveNumber(value.totalValue, base.abilities[key2]?.totalValue ?? 0)
        };
      }
    }
    if (isRecord(raw.weather)) {
      for (const [key2, value] of Object.entries(raw.weather)) {
        if (typeof key2 !== "string" || !isRecord(value)) continue;
        const normalizedKey = key2.toLowerCase();
        const fallback = base.weather[normalizedKey] ?? { triggers: 0 };
        base.weather[normalizedKey] = {
          triggers: toPositiveInt(value.triggers, fallback.triggers)
        };
      }
    }
    return base;
  }
  function readFromStorage() {
    if (memoryStore) return cloneStats(memoryStore);
    const rawWrapped = readAriesPath("stats");
    const raw = unwrapMaybeNestedSnapshot(rawWrapped);
    if (!raw) {
      const fresh = createDefaultStats();
      memoryStore = cloneStats(fresh);
      writeAriesPath("stats", memoryStore);
      return fresh;
    }
    const normalized = normalizeStats(raw);
    memoryStore = cloneStats(normalized);
    if (rawWrapped !== raw) {
      writeAriesPath("stats", memoryStore);
    }
    return normalized;
  }
  function emitUpdate(stats) {
    const snapshot = cloneStats(stats);
    for (const listener of listeners) {
      try {
        listener(snapshot);
      } catch (error) {
        console.error("[StatsService] Listener error", error);
      }
    }
  }
  function writeToStorage(stats) {
    const snapshot = cloneStats(stats);
    memoryStore = snapshot;
    writeAriesPath("stats", snapshot);
    return snapshot;
  }
  function adjustValue(current, delta, integer) {
    const a = Number(current);
    const b = Number(delta);
    const sum = Number.isFinite(a) ? a : 0;
    const next = sum + (Number.isFinite(b) ? b : 0);
    const clamped = Math.max(0, next);
    return integer ? Math.floor(clamped) : clamped;
  }
  function updateStats(mutator) {
    const current = readFromStorage();
    const before = JSON.stringify(current);
    const draft = cloneStats(current);
    mutator(draft);
    const after = JSON.stringify(draft);
    if (before === after) return current;
    const stored = writeToStorage(draft);
    emitUpdate(stored);
    return stored;
  }
  function requireAbilityEntry(stats, abilityId) {
    if (!stats.abilities[abilityId]) {
      stats.abilities[abilityId] = { triggers: 0, totalValue: 0 };
    }
    return stats.abilities[abilityId];
  }
  function requireWeatherEntry(stats, weatherId) {
    const key2 = weatherId.toLowerCase();
    if (!stats.weather[key2]) {
      stats.weather[key2] = { triggers: 0 };
    }
    return stats.weather[key2];
  }
  function requirePetEntry(stats, species) {
    const key2 = species.toLowerCase();
    if (!stats.pets.hatchedByType[key2]) {
      stats.pets.hatchedByType[key2] = { normal: 0, gold: 0, rainbow: 0 };
    }
    return stats.pets.hatchedByType[key2];
  }
  var StatsService = {
    storageKey: "stats",
    getSnapshot() {
      return readFromStorage();
    },
    setSnapshot(snapshot) {
      const normalized = normalizeStats(unwrapMaybeNestedSnapshot(snapshot));
      const stored = writeToStorage(normalized);
      emitUpdate(stored);
      return stored;
    },
    reset() {
      const fresh = createDefaultStats();
      const stored = writeToStorage(fresh);
      emitUpdate(stored);
      return stored;
    },
    update(mutator) {
      return updateStats(mutator);
    },
    incrementGardenStat(key2, amount = 1) {
      return updateStats((draft) => {
        draft.garden[key2] = adjustValue(draft.garden[key2], amount, GARDEN_INT_KEYS[key2]);
      });
    },
    incrementShopStat(key2, amount = 1) {
      return updateStats((draft) => {
        draft.shops[key2] = adjustValue(draft.shops[key2], amount, SHOP_INT_KEYS[key2]);
      });
    },
    incrementPetHatched(species, rarityKey = "normal", amount = 1) {
      return updateStats((draft) => {
        const entry = requirePetEntry(draft, species);
        entry[rarityKey] = adjustValue(entry[rarityKey], amount, true);
      });
    },
    incrementAbilityStat(abilityId, key2, amount = 1) {
      return updateStats((draft) => {
        const entry = requireAbilityEntry(draft, abilityId);
        entry[key2] = adjustValue(entry[key2], amount, ABILITY_INT_KEYS[key2]);
      });
    },
    incrementWeatherStat(weatherId, key2 = "triggers", amount = 1) {
      return updateStats((draft) => {
        const entry = requireWeatherEntry(draft, weatherId);
        entry[key2] = adjustValue(entry[key2], amount, WEATHER_INT_KEYS[key2]);
      });
    },
    subscribe(listener) {
      listeners.add(listener);
      return () => {
        listeners.delete(listener);
      };
    }
  };
  var StatsDefaults = {
    rarityOrder: [
      rarity.Common,
      rarity.Uncommon,
      rarity.Rare,
      rarity.Legendary,
      rarity.Mythic,
      rarity.Divine,
      rarity.Celestial
    ],
    createEmpty() {
      return createDefaultStats();
    }
  };

  // src/services/lockerRestrictions.ts
  var ARIES_LOCKER_RESTRICTIONS_PATH = "locker.restrictions";
  var clampPercent2 = (value) => Math.max(0, Math.min(50, Math.round(value)));
  var roundToStep = (value, step) => Math.round(value / step) * step;
  var DEFAULT_STATE = {
    minRequiredPlayers: 1,
    eggLocks: {},
    decorPickupLocked: false
  };
  var FRIEND_BONUS_STEP = 10;
  var FRIEND_BONUS_MAX = 50;
  var sanitizePercent = (value) => {
    const clamped = clampPercent2(value);
    return Math.max(0, Math.min(FRIEND_BONUS_MAX, roundToStep(clamped, FRIEND_BONUS_STEP)));
  };
  var sanitizePlayers = (value) => {
    if (!Number.isFinite(value)) return 1;
    return Math.max(1, Math.min(6, Math.round(value)));
  };
  var sanitizeEggLocks = (raw) => {
    const out = {};
    if (!raw || typeof raw !== "object") return out;
    for (const [key2, value] of Object.entries(raw)) {
      if (!key2) continue;
      out[key2] = value === true;
    }
    return out;
  };
  function friendBonusPercentFromMultiplier(raw) {
    const n = Number(raw);
    if (!Number.isFinite(n)) return null;
    if (n <= 0) return 0;
    if (n > 0 && n <= 2) {
      return clampPercent2(Math.round((n - 1) * 100));
    }
    const clamped = Math.max(1, Math.min(6, Math.round(n)));
    return clampPercent2((clamped - 1) * 10);
  }
  function friendBonusPercentFromPlayers(raw) {
    const n = Number(raw);
    if (!Number.isFinite(n)) return null;
    const clamped = Math.max(1, Math.min(6, Math.round(n)));
    return clampPercent2((clamped - 1) * 10);
  }
  function percentToRequiredFriendCount(percent) {
    const pct = sanitizePercent(percent);
    return Math.max(1, Math.min(6, Math.round(pct / 10) + 1));
  }
  var requiredPercentFromPlayers = (players) => sanitizePercent((sanitizePlayers(players) - 1) * 10);
  var LockerRestrictionsService = class {
    constructor() {
      __publicField(this, "state", { ...DEFAULT_STATE });
      __publicField(this, "listeners", /* @__PURE__ */ new Set());
      this.load();
    }
    load() {
      if (typeof window === "undefined") {
        this.state = { ...DEFAULT_STATE };
        return;
      }
      try {
        const parsed = readAriesPath(ARIES_LOCKER_RESTRICTIONS_PATH) ?? {};
        const players = sanitizePlayers(Number(parsed?.minRequiredPlayers ?? parsed?.minFriendBonusPct));
        const eggLocks = sanitizeEggLocks(parsed?.eggLocks);
        const decorPickupLocked = parsed?.decorPickupLocked === true;
        this.state = { minRequiredPlayers: players, eggLocks, decorPickupLocked };
      } catch {
        this.state = { ...DEFAULT_STATE };
      }
    }
    save() {
      if (typeof window === "undefined") return;
      try {
        writeAriesPath(ARIES_LOCKER_RESTRICTIONS_PATH, this.state);
      } catch {
      }
    }
    emit() {
      for (const listener of this.listeners) {
        try {
          listener(this.getState());
        } catch {
        }
      }
    }
    getState() {
      return { ...this.state };
    }
    setMinRequiredPlayers(value) {
      const players = sanitizePlayers(value);
      if (players === this.state.minRequiredPlayers) return;
      this.state = { ...this.state, minRequiredPlayers: players };
      this.save();
      this.emit();
    }
    setEggLock(eggId, locked) {
      if (!eggId) return;
      const nextLocks = { ...this.state.eggLocks, [eggId]: !!locked };
      this.state = { ...this.state, eggLocks: nextLocks };
      this.save();
      this.emit();
    }
    setDecorPickupLocked(locked) {
      if (!!locked === this.state.decorPickupLocked) return;
      this.state = { ...this.state, decorPickupLocked: !!locked };
      this.save();
      this.emit();
    }
    isEggLocked(eggId) {
      if (!eggId) return false;
      return this.state.eggLocks?.[eggId] === true;
    }
    allowsCropSale(currentFriendBonusPercent) {
      const required = requiredPercentFromPlayers(this.state.minRequiredPlayers);
      if (required <= 0) return true;
      if (!Number.isFinite(currentFriendBonusPercent)) return false;
      const current = clampPercent2(Number(currentFriendBonusPercent));
      return current + 1e-4 >= required;
    }
    getRequiredPercent() {
      return requiredPercentFromPlayers(this.state.minRequiredPlayers);
    }
    isDecorPickupLocked() {
      return this.state.decorPickupLocked === true;
    }
    subscribe(listener) {
      this.listeners.add(listener);
      return () => this.listeners.delete(listener);
    }
  };
  var lockerRestrictionsService = new LockerRestrictionsService();

  // src/ui/toast.ts
  async function sendToast(toast2) {
    const sendAtom = getAtomByLabel("sendQuinoaToastAtom");
    if (sendAtom) {
      await jSet(sendAtom, toast2);
      return;
    }
    const listAtom = getAtomByLabel("quinoaToastsAtom");
    if (!listAtom) throw new Error("Aucun atom de toast trouv\xE9");
    const prev = await jGet(listAtom).catch(() => []);
    const t = { isClosable: true, duration: 1e4, ...toast2 };
    if ("toastType" in t && t.toastType === "board") {
      t.id = t.id ?? (t.isStackable ? `quinoa-stackable-${Date.now()}-${Math.random()}` : "quinoa-game-toast");
    } else {
      t.id = t.id ?? "quinoa-game-toast";
    }
    await jSet(listAtom, [...prev, t]);
  }
  async function toastSimple(title, description, variant = "info", duration = 3500) {
    await sendToast({ title, description, variant, duration });
  }

  // src/utils/api.ts
  function detectEnvironment() {
    const isInIframe = (() => {
      try {
        return window.top !== window.self;
      } catch {
        return true;
      }
    })();
    const refHost = safeHost(document.referrer);
    const parentLooksDiscord = isInIframe && !!refHost && /(^|\.)discord(app)?\.com$/i.test(refHost);
    const host = location.hostname;
    const surface = parentLooksDiscord ? "discord" : "web";
    const platform = /Android|iPhone|iPad|Mobile/i.test(navigator.userAgent) ? "mobile" : "desktop";
    return {
      surface,
      host,
      origin: location.origin,
      isInIframe,
      platform
    };
  }
  function isDiscordSurface() {
    return detectEnvironment().surface === "discord";
  }
  function buildRoomApiUrl(roomIdOrCode, endpoint = "info") {
    return `${location.origin}/api/rooms/${encodeURIComponent(roomIdOrCode)}/${endpoint}`;
  }
  async function httpGetWithFetch(url, headers, timeoutMs = 1e4) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const res = await fetch(url, {
        method: "GET",
        credentials: "include",
        headers,
        signal: controller.signal
      });
      const body = await res.text();
      return { status: res.status, ok: res.ok, body };
    } finally {
      clearTimeout(timeout);
    }
  }
  function httpGetWithGM(url, headers, timeoutMs = 1e4) {
    return new Promise((resolve2, reject) => {
      if (typeof GM_xmlhttpRequest !== "function") {
        reject(new Error("GM_xmlhttpRequest is not available"));
        return;
      }
      GM_xmlhttpRequest({
        method: "GET",
        url,
        headers,
        timeout: timeoutMs,
        onload: (response) => resolve2({
          status: response.status,
          ok: response.status >= 200 && response.status < 300,
          body: response.responseText
        }),
        onerror: (error) => reject(error),
        ontimeout: () => reject(new Error("GM_xmlhttpRequest timed out"))
      });
    });
  }
  async function requestRoomEndpoint(roomIdOrCode, options = {}) {
    const endpoint = options.endpoint ?? "info";
    const url = buildRoomApiUrl(roomIdOrCode, endpoint);
    const headers = {};
    if (options.jwt) {
      headers["Authorization"] = `Bearer ${options.jwt}`;
    }
    let rawResponse;
    if (options.preferGM && typeof GM_xmlhttpRequest === "function") {
      rawResponse = await httpGetWithGM(url, headers, options.timeoutMs);
    } else {
      try {
        rawResponse = await httpGetWithFetch(url, headers, options.timeoutMs);
      } catch (error) {
        if (typeof GM_xmlhttpRequest === "function") {
          rawResponse = await httpGetWithGM(url, headers, options.timeoutMs);
        } else {
          throw error;
        }
      }
    }
    let parsed;
    try {
      parsed = JSON.parse(rawResponse.body);
    } catch {
    }
    return { url, ...rawResponse, parsed };
  }
  function safeHost(url) {
    if (!url) return null;
    try {
      return new URL(url).hostname;
    } catch {
      return null;
    }
  }
  function buildSoftJoinUrl(roomCode) {
    const merged = new URLSearchParams(location.search);
    const url = new URL(location.href);
    url.pathname = `/r/${encodeURIComponent(roomCode)}`;
    url.search = merged.toString();
    return url.toString();
  }
  function buildHardJoinUrl(roomCode) {
    return buildSoftJoinUrl(roomCode);
  }
  function joinRoom(roomCode, options = {}) {
    const env = detectEnvironment();
    const isDiscord = env.surface === "discord";
    const preferSoft = options.preferSoft ?? !isDiscord;
    const hardIfSoftFails = options.hardIfSoftFails ?? true;
    if (isDiscord) {
      if (options.siteFallbackOnDiscord) {
        const fallback = `https://magiccircle.gg/r/${encodeURIComponent(roomCode)}`;
        if (options.openInNewTab) {
          window.open(fallback, "_blank", "noopener,noreferrer");
        } else {
          location.assign(fallback);
        }
        return {
          ok: true,
          mode: "site-fallback",
          url: fallback,
          message: "Discord activity does not support room switching by code, redirecting to the official site."
        };
      }
      return {
        ok: false,
        mode: "discord-unsupported",
        message: "Discord activity does not support joining a room by code. Open the website or use an activity invite."
      };
    }
    const softUrl = buildSoftJoinUrl(roomCode);
    if (preferSoft) {
      try {
        const url = new URL(softUrl);
        if (url.origin === location.origin) {
          history.replaceState({}, "", url.pathname + (url.search || "") + (url.hash || ""));
          window.dispatchEvent(new PopStateEvent("popstate", { state: {} }));
          console.log("[joinRoom] soft \u2192", url.toString());
          return { ok: true, mode: "soft", url: url.toString() };
        }
      } catch {
      }
      if (!hardIfSoftFails) {
        return {
          ok: false,
          mode: "noop",
          url: softUrl,
          message: "Soft navigation failed because the origins differ."
        };
      }
    }
    const hardUrl = buildHardJoinUrl(roomCode);
    console.log("[joinRoom] hard \u2192", hardUrl);
    location.assign(hardUrl);
    return { ok: true, mode: "hard", url: hardUrl };
  }

  // src/core/webSocketBridge.ts
  function postAllToWorkers(msg) {
    if (Workers.forEach) Workers.forEach((w) => {
      try {
        w.postMessage(msg);
      } catch {
      }
    });
    else for (const w of Workers._a) {
      try {
        w.postMessage(msg);
      } catch {
      }
    }
  }
  function getPageWS() {
    if (quinoaWS && quinoaWS.readyState === NativeWS.OPEN) return quinoaWS;
    let any = null;
    if (sockets.find) any = sockets.find((s) => s.readyState === NativeWS.OPEN) || null;
    if (!any) {
      for (let i = 0; i < sockets.length; i++) if (sockets[i].readyState === NativeWS.OPEN) {
        any = sockets[i];
        break;
      }
    }
    if (any) {
      setQWS(any, "getPageWS");
      return any;
    }
    throw new Error("No page WebSocket open");
  }
  function sendToGame(payloadObj) {
    const msg = { scopePath: ["Room", "Quinoa"], ...payloadObj };
    try {
      const ws = getPageWS();
      ws.send(JSON.stringify(msg));
      return true;
    } catch {
      postAllToWorkers({ __QWS_CMD: "send", payload: JSON.stringify(msg) });
      return true;
    }
  }

  // src/services/player.ts
  function slotSig2(o) {
    if (!o) return "\u2205";
    return [
      o.objectType ?? o.type ?? "",
      o.species ?? o.seedSpecies ?? o.plantSpecies ?? o.eggId ?? o.decorId ?? "",
      o.plantedAt ?? o.startTime ?? 0,
      o.maturedAt ?? o.endTime ?? 0
    ].join("|");
  }
  function diffGarden(prev, next) {
    const p = prev?.tileObjects ?? {};
    const n = next?.tileObjects ?? {};
    const added = [];
    const updated = [];
    const removed = [];
    const changes = [];
    const seen = /* @__PURE__ */ new Set();
    for (const k of Object.keys(n)) {
      seen.add(k);
      if (!(k in p)) {
        added.push(+k);
        changes.push({ kind: "added", slot: +k, next: n[k] });
      } else if (slotSig2(p[k]) !== slotSig2(n[k])) {
        updated.push(+k);
        changes.push({ kind: "updated", slot: +k, prev: p[k], next: n[k] });
      }
    }
    for (const k of Object.keys(p)) {
      if (!seen.has(k)) {
        removed.push(+k);
        changes.push({ kind: "removed", slot: +k, prev: p[k] });
      }
    }
    return { added, updated, removed, changes };
  }
  function petSig(p) {
    const s = p?.slot ?? {};
    const muts = Array.isArray(s.mutations) ? s.mutations.slice().sort().join(",") : "";
    const ab = Array.isArray(s.abilities) ? s.abilities.slice().sort().join(",") : "";
    const name = s.name ?? "";
    const species = s.petSpecies ?? "";
    const xp = Number.isFinite(s.xp) ? Math.round(s.xp) : 0;
    const hunger = Number.isFinite(s.hunger) ? Math.round(s.hunger * 1e3) : 0;
    const scale = Number.isFinite(s.targetScale) ? Math.round(s.targetScale * 1e3) : 0;
    const x = Number.isFinite(p?.position?.x) ? Math.round(p.position.x) : 0;
    const y = Number.isFinite(p?.position?.y) ? Math.round(p.position.y) : 0;
    return `${species}|${name}|xp:${xp}|hg:${hunger}|sc:${scale}|m:${muts}|a:${ab}|pos:${x},${y}`;
  }
  function snapshotPets(state2) {
    const snap = /* @__PURE__ */ new Map();
    const arr = Array.isArray(state2) ? state2 : [];
    for (const it of arr) {
      const id = String(it?.slot?.id ?? "");
      if (!id) continue;
      snap.set(id, petSig(it));
    }
    return snap;
  }
  function diffPetsSnapshot(prev, next) {
    const added = [];
    const updated = [];
    const removed = [];
    const changes = [];
    for (const [id, sig] of next) {
      if (!prev.has(id)) {
        added.push(id);
        changes.push({ kind: "added", id });
      } else if (prev.get(id) !== sig) {
        updated.push(id);
        changes.push({ kind: "updated", id });
      }
    }
    for (const id of prev.keys()) {
      if (!next.has(id)) {
        removed.push(id);
        changes.push({ kind: "removed", id });
      }
    }
    return { added, updated, removed, changes };
  }
  function cropSig(it) {
    const muts = Array.isArray(it.mutations) ? it.mutations.slice().sort().join(",") : "";
    const scale = Number.isFinite(it.scale) ? Math.round(it.scale * 1e3) : 0;
    return `${it.species ?? ""}|${it.itemType ?? ""}|${scale}|${muts}`;
  }
  function snapshotInventory(inv) {
    const snap = /* @__PURE__ */ new Map();
    const arr = Array.isArray(inv) ? inv : [];
    for (const it of arr) {
      const id = String(it?.id ?? "");
      if (!id) continue;
      snap.set(id, cropSig(it));
    }
    return snap;
  }
  function diffCropInventorySnapshot(prev, next) {
    const added = [];
    const updated = [];
    const removed = [];
    const changes = [];
    for (const [id, sig] of next) {
      if (!prev.has(id)) {
        added.push(id);
        changes.push({ kind: "added", key: id });
      } else if (prev.get(id) !== sig) {
        updated.push(id);
        changes.push({ kind: "updated", key: id });
      }
    }
    for (const id of prev.keys()) {
      if (!next.has(id)) {
        removed.push(id);
        changes.push({ kind: "removed", key: id });
      }
    }
    return { added, updated, removed, changes };
  }
  var PlayerService = {
    /* ------------------------- Position / Dplacement ------------------------- */
    getPosition() {
      return Atoms.player.position.get();
    },
    onPosition(cb) {
      return Atoms.player.position.onChange(cb);
    },
    onPositionNow(cb) {
      return Atoms.player.position.onChangeNow(cb);
    },
    async setPosition(x, y) {
      await Atoms.player.position.set({ x, y });
    },
    async teleport(x, y) {
      try {
        await this.setPosition(x, y);
      } catch (err) {
      }
      try {
        sendToGame({ type: "Teleport", position: { x, y } });
      } catch (err) {
      }
    },
    async move(x, y) {
      try {
        await this.setPosition(x, y);
      } catch (err) {
      }
      try {
        sendToGame({ type: "PlayerPosition", position: { x, y } });
      } catch (err) {
      }
    },
    /* ------------------------------ Actions jeu ------------------------------ */
    async plantSeed(slot, species) {
      try {
        sendToGame({ type: "PlantSeed", slot, species });
      } catch (err) {
      }
    },
    async sellAllCrops() {
      try {
        sendToGame({ type: "SellAllCrops" });
      } catch (err) {
      }
    },
    async sellPet(itemId) {
      try {
        sendToGame({ type: "SellPet", itemId });
      } catch (err) {
      }
    },
    async removeGardenObject(slot, slotType) {
      try {
        sendToGame({ type: "RemoveGardenObject", slot, slotType });
      } catch (err) {
      }
    },
    async waterPlant(slot) {
      try {
        sendToGame({ type: "WaterPlant", slot });
      } catch (err) {
      }
    },
    async setSelectedItem(itemIndex) {
      try {
        sendToGame({ type: "SetSelectedItem", itemIndex });
      } catch (err) {
      }
    },
    async pickupObject() {
      try {
        sendToGame({ type: "PickupObject" });
      } catch (err) {
      }
    },
    async dropObject() {
      try {
        sendToGame({ type: "DropObject" });
      } catch (err) {
      }
    },
    async harvestCrop(slot, slotsIndex) {
      try {
        sendToGame({ type: "HarvestCrop", slot, slotsIndex });
      } catch (err) {
      }
    },
    async feedPet(petItemId, cropItemId) {
      try {
        sendToGame({ type: "FeedPet", petItemId, cropItemId });
      } catch (err) {
      }
    },
    async hatchEgg(slot) {
      try {
        sendToGame({ type: "HatchEgg", slot });
      } catch (err) {
      }
    },
    async placeDecor(tileType, localTileIndex, decorId, rotation) {
      try {
        sendToGame({ type: "PlaceDecor", tileType, localTileIndex, decorId, rotation });
      } catch (err) {
      }
    },
    async swapPet(petSlotId, petInventoryId) {
      try {
        sendToGame({ type: "SwapPet", petSlotId, petInventoryId });
      } catch (err) {
      }
    },
    async placePet(itemId, position2, tileType, localTileIndex) {
      try {
        sendToGame({ type: "PlacePet", itemId, position: position2, tileType, localTileIndex });
      } catch (err) {
      }
    },
    async retrieveItemFromStorage(itemId, storageId) {
      try {
        sendToGame({ type: "RetrieveItemFromStorage", itemId, storageId });
      } catch (err) {
      }
    },
    async putItemInStorage(itemId, storageId) {
      try {
        sendToGame({ type: "PutItemInStorage", itemId, storageId });
      } catch (err) {
      }
    },
    async petPositions(petPositions) {
      const entries = Object.entries(petPositions ?? {});
      if (!entries.length) {
        return;
      }
      const sanitized = {};
      for (const [id, pos] of entries) {
        const x = Number(pos?.x);
        const y = Number(pos?.y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        sanitized[String(id)] = { x, y };
      }
      const validCount = Object.keys(sanitized).length;
      if (!validCount) {
        return;
      }
      try {
        sendToGame({ type: "PetPositions", petPositions: sanitized });
      } catch (err) {
      }
    },
    async storePet(itemId) {
      try {
        sendToGame({ type: "StorePet", itemId });
      } catch (err) {
      }
    },
    async wish(itemId) {
      try {
        sendToGame({ type: "Wish", itemId });
      } catch (err) {
      }
    },
    async purchaseSeed(species) {
      try {
        sendToGame({ type: "PurchaseSeed", species });
      } catch (err) {
      }
    },
    async purchaseDecor(decorId) {
      try {
        sendToGame({ type: "PurchaseDecor", decorId });
      } catch (err) {
      }
    },
    async purchaseEgg(eggId) {
      try {
        sendToGame({ type: "PurchaseEgg", eggId });
      } catch (err) {
      }
    },
    async purchaseTool(toolId) {
      try {
        sendToGame({ type: "PurchaseTool", toolId });
      } catch (err) {
      }
    },
    async triggerAnimation(playerId2, animation) {
      Atoms.player.avatarTriggerAnimationAtom.set({ playerId: playerId2, animation });
    },
    /* -------------------------------- Favorites ------------------------------ */
    async toggleFavoriteItem(itemId) {
      try {
        sendToGame({ type: "ToggleFavoriteItem", itemId });
      } catch (err) {
      }
    },
    async getFavoriteIds() {
      const ids = await Atoms.inventory.favoriteIds.get();
      return Array.isArray(ids) ? ids.slice() : [];
    },
    async getFavoriteIdSet() {
      return getFavoriteIdSet();
    },
    async isFavoriteItem(itemId) {
      const set2 = await getFavoriteIdSet();
      return set2.has(itemId);
    },
    async ensureFavoriteItem(itemId, shouldBeFavorite) {
      const cur = await this.isFavoriteItem(itemId);
      if (cur !== shouldBeFavorite) {
        await this.toggleFavoriteItem(itemId);
        return shouldBeFavorite;
      }
      return cur;
    },
    async ensureFavorites(items, shouldBeFavorite) {
      const set2 = await getFavoriteIdSet();
      for (const id of items) {
        const cur = set2.has(id);
        if (cur !== shouldBeFavorite) {
          try {
            await this.toggleFavoriteItem(id);
          } catch {
          }
        }
      }
    },
    onFavoriteIdsChange(cb) {
      return onFavoriteIds((ids) => cb(Array.isArray(ids) ? ids : []));
    },
    async onFavoriteIdsChangeNow(cb) {
      return onFavoriteIdsNow((ids) => cb(Array.isArray(ids) ? ids : []));
    },
    onFavoriteSetChange(cb) {
      return onFavoriteIds((ids) => cb(new Set(Array.isArray(ids) ? ids : [])));
    },
    async onFavoriteSetChangeNow(cb) {
      const cur = await getFavoriteIdSet();
      cb(cur);
      return onFavoriteIds((ids) => cb(new Set(Array.isArray(ids) ? ids : [])));
    },
    /* --------------------------------- Garden -------------------------------- */
    async getGardenState() {
      return await Atoms.data.garden.get() ?? null;
    },
    onGardenChange(cb) {
      return Atoms.data.garden.onChange(cb);
    },
    onGardenChangeNow(cb) {
      return Atoms.data.garden.onChangeNow(cb);
    },
    onGardenDiff(cb) {
      let prev = null;
      return Atoms.data.garden.onChange((g) => {
        const d = diffGarden(prev, g);
        if (d.added.length || d.updated.length || d.removed.length || g !== prev) {
          prev = g;
          cb(g, d);
        }
      });
    },
    async onGardenDiffNow(cb) {
      let prev = await Atoms.data.garden.get() ?? null;
      cb(prev, diffGarden(null, prev));
      return Atoms.data.garden.onChange((next) => {
        const d = diffGarden(prev, next);
        if (d.added.length || d.updated.length || d.removed.length) {
          prev = next;
          cb(next, d);
        }
      });
    },
    /* ------------------------------------ Pets ------------------------------------ */
    async getPets() {
      const arr = await Atoms.pets.myPetInfos.get();
      return Array.isArray(arr) ? arr : null;
    },
    onPetsChange(cb) {
      let prev = null;
      return Atoms.pets.myPetInfos.onChange((next) => {
        if (next !== prev) {
          prev = next;
          cb(prev);
        }
      });
    },
    async onPetsChangeNow(cb) {
      let prev = await this.getPets();
      cb(prev);
      return Atoms.pets.myPetInfos.onChange((next) => {
        if (next !== prev) {
          prev = next;
          cb(prev);
        }
      });
    },
    onPetsDiff(cb) {
      let prevSnap = snapshotPets(null);
      return Atoms.pets.myPetInfos.onChange((state2) => {
        const nextSnap = snapshotPets(state2);
        const d = diffPetsSnapshot(prevSnap, nextSnap);
        if (d.added.length || d.updated.length || d.removed.length) {
          cb(state2, d);
          prevSnap = nextSnap;
        }
      });
    },
    async onPetsDiffNow(cb) {
      let cur = await this.getPets();
      let prevSnap = snapshotPets(null);
      let nextSnap = snapshotPets(cur);
      const first = diffPetsSnapshot(prevSnap, nextSnap);
      cb(cur, first);
      prevSnap = nextSnap;
      return Atoms.pets.myPetInfos.onChange((state2) => {
        nextSnap = snapshotPets(state2);
        const d = diffPetsSnapshot(prevSnap, nextSnap);
        if (d.added.length || d.updated.length || d.removed.length) {
          cb(state2, d);
          prevSnap = nextSnap;
        }
      });
    },
    /* ------------------------- Crop Inventory (crops) ------------------------- */
    async getCropInventoryState() {
      return Atoms.inventory.myCropInventory.get();
    },
    onCropInventoryChange(cb) {
      let prev = null;
      return Atoms.inventory.myCropInventory.onChange((inv) => {
        if (inv !== prev) {
          prev = inv;
          cb(inv);
        }
      });
    },
    async onCropInventoryChangeNow(cb) {
      let prev = await Atoms.inventory.myCropInventory.get();
      cb(prev);
      return Atoms.inventory.myCropInventory.onChange((inv) => {
        if (inv !== prev) {
          prev = inv;
          cb(inv);
        }
      });
    },
    onCropInventoryDiff(cb) {
      let prevSnap = snapshotInventory(null);
      return Atoms.inventory.myCropInventory.onChange((inv) => {
        const nextSnap = snapshotInventory(inv);
        const d = diffCropInventorySnapshot(prevSnap, nextSnap);
        if (d.added.length || d.updated.length || d.removed.length) {
          cb(inv, d);
          prevSnap = nextSnap;
        }
      });
    },
    async onCropInventoryDiffNow(cb) {
      let cur = await Atoms.inventory.myCropInventory.get();
      let prevSnap = snapshotInventory(null);
      let nextSnap = snapshotInventory(cur);
      const firstDiff = diffCropInventorySnapshot(prevSnap, nextSnap);
      cb(cur, firstDiff);
      prevSnap = nextSnap;
      return Atoms.inventory.myCropInventory.onChange((inv) => {
        nextSnap = snapshotInventory(inv);
        const d = diffCropInventorySnapshot(prevSnap, nextSnap);
        if (d.added.length || d.updated.length || d.removed.length) {
          cb(inv, d);
          prevSnap = nextSnap;
        }
      });
    },
    /* --------------------------- Players in room --------------------------- */
    async getNumPlayers() {
      const n = await Atoms.server.numPlayers.get();
      return typeof n === "number" ? n : 0;
    },
    onNumPlayersChange(cb) {
      let prev = void 0;
      return Atoms.server.numPlayers.onChange((n) => {
        if (n !== prev) {
          prev = n;
          cb(n);
        }
      });
    },
    async onNumPlayersChangeNow(cb) {
      let prev = await this.getNumPlayers();
      cb(prev);
      return Atoms.server.numPlayers.onChange((n) => {
        if (n !== prev) {
          prev = n;
          cb(n);
        }
      });
    }
  };

  // src/services/fakeAtoms.ts
  var _fakeRegistry = /* @__PURE__ */ new Map();
  function _atomsByExactLabel(label2) {
    try {
      return findAtomsByLabel(new RegExp("^" + label2 + "$"));
    } catch {
      return [];
    }
  }
  function _findReadKey(atom) {
    if (atom && typeof atom.read === "function") return "read";
    for (const k of Object.keys(atom || {})) {
      const v = atom[k];
      if (typeof v === "function" && k !== "write" && k !== "onMount" && k !== "toString") {
        const ar = v.length;
        if (ar === 1 || ar === 2) return k;
      }
    }
    throw new Error("Impossible de localiser la fonction read() de l'atom");
  }
  function _getState(label2) {
    return _fakeRegistry.get(label2) || null;
  }
  async function _forceRepaintViaGate(gate) {
    if (!gate?.closeAction || !gate?.openAction) return;
    await gate.closeAction();
    await new Promise((r) => setTimeout(r, 0));
    await gate.openAction();
  }
  async function _ensureFakeInstalled(config) {
    const key2 = config.label;
    const existing = _fakeRegistry.get(key2);
    if (existing?.installed) return existing;
    const atoms = _atomsByExactLabel(config.label);
    if (!atoms.length) {
      throw new Error(`${config.label} introuvable`);
    }
    const state2 = existing ?? {
      config,
      enabled: false,
      payload: null,
      patched: /* @__PURE__ */ new Map(),
      installed: false
    };
    let gateAtom = null;
    if (config.gate?.label) gateAtom = getAtomByLabel(config.gate.label);
    for (const a of atoms) {
      const readKey = _findReadKey(a);
      const orig = a[readKey];
      a[readKey] = (get) => {
        try {
          if (gateAtom) get(gateAtom);
        } catch (err) {
        }
        for (const dep of config.extraDeps || []) {
          try {
            const d = getAtomByLabel(dep);
            d && get(d);
          } catch (err) {
          }
        }
        const real = orig(get);
        if (!state2.enabled || state2.payload == null) return real;
        return config.merge ? config.merge(real, state2.payload) : state2.payload;
      };
      state2.patched.set(a, { readKey, orig });
    }
    if (gateAtom && config.gate?.autoDisableOnClose) {
      state2.unsubGate = await jSub(gateAtom, async () => {
        let v;
        try {
          v = await jGet(gateAtom);
        } catch (err) {
          v = null;
        }
        const isOpen = config.gate?.isOpen ? config.gate.isOpen(v) : !!v;
        if (!isOpen && state2.enabled) state2.enabled = false;
      });
    }
    state2.installed = true;
    _fakeRegistry.set(key2, state2);
    return state2;
  }
  async function fakeShow(config, payload, options) {
    await ensureStore();
    const st = await _ensureFakeInstalled(config);
    st.payload = payload;
    st.enabled = true;
    if (options?.merge && !config.merge) {
      config.merge = (_real, fake) => fake;
    }
    if (options?.openGate && config.gate?.openAction) await config.gate.openAction();
    if (st.autoTimer) {
      clearTimeout(st.autoTimer);
      st.autoTimer = null;
    }
    if (options?.autoRestoreMs && options.autoRestoreMs > 0) {
      st.autoTimer = setTimeout(() => {
        void fakeHide(config.label);
      }, options.autoRestoreMs);
    }
  }
  async function fakeHide(label2) {
    const st = _getState(label2);
    if (!st) return;
    st.enabled = false;
    st.payload = null;
    if (st.autoTimer) {
      clearTimeout(st.autoTimer);
      st.autoTimer = null;
    }
    await _forceRepaintViaGate(st.config.gate);
  }

  // src/services/fakeModal.ts
  async function openModal(modalId) {
    try {
      await Atoms.ui.activeModal.set(modalId);
    } catch (err) {
    }
  }
  async function closeModal(_modalId) {
    try {
      await Atoms.ui.activeModal.set(null);
    } catch (err) {
    }
  }
  function isModalOpen(value, modalId) {
    return value === modalId;
  }
  async function isModalOpenAsync(modalId) {
    try {
      const v = await Atoms.ui.activeModal.get();
      return isModalOpen(v, modalId);
    } catch (err) {
      return false;
    }
  }
  async function waitModalClosed(modalId, timeoutMs = 12e4) {
    const t0 = performance.now();
    while (performance.now() - t0 < timeoutMs) {
      try {
        const v = await Atoms.ui.activeModal.get();
        if (!isModalOpen(v, modalId)) return true;
      } catch {
        return true;
      }
      await new Promise((r) => setTimeout(r, 80));
    }
    return false;
  }
  var mergeMyData = (real, patch) => {
    const base = real && typeof real === "object" ? real : {};
    const add = patch && typeof patch === "object" ? patch : {};
    return { ...base, ...add };
  };
  var SHARED_MYDATA_PATCH = {
    label: Atoms.data.myData.label,
    merge: mergeMyData,
    gate: {
      label: Atoms.ui.activeModal.label,
      isOpen: (v) => v === "inventory" || v === "journal" || v === "stats" || v === "activityLog",
      autoDisableOnClose: true
    }
  };
  var INVENTORY_ATOM_PATCH = {
    label: Atoms.inventory.myInventory.label,
    merge: (_real, fake) => fake,
    gate: {
      label: Atoms.ui.activeModal.label,
      isOpen: (v) => v === "inventory",
      autoDisableOnClose: true
    }
  };
  var INVENTORY_MODAL_ID = "inventory";
  async function openInventoryPanel() {
    return openModal(INVENTORY_MODAL_ID);
  }
  async function closeInventoryPanel() {
    return closeModal(INVENTORY_MODAL_ID);
  }
  function isInventoryOpen(v) {
    return isModalOpen(v, INVENTORY_MODAL_ID);
  }
  async function isInventoryPanelOpen() {
    return isModalOpenAsync(INVENTORY_MODAL_ID);
  }
  async function waitInventoryPanelClosed(timeoutMs = 12e4) {
    return waitModalClosed(INVENTORY_MODAL_ID, timeoutMs);
  }
  async function fakeInventoryShow(payload, opts) {
    const shouldOpen = opts?.open !== false;
    await fakeShow(SHARED_MYDATA_PATCH, { inventory: payload }, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    await fakeShow(INVENTORY_ATOM_PATCH, payload, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    if (shouldOpen) await openInventoryPanel();
  }
  async function fakeInventoryHide() {
    await fakeHide(INVENTORY_ATOM_PATCH.label);
    await fakeHide(SHARED_MYDATA_PATCH.label);
    await closeInventoryPanel();
  }
  var JOURNAL_MODAL_ID = "journal";
  async function openJournalModal() {
    return openModal(JOURNAL_MODAL_ID);
  }
  async function isJournalModalOpen() {
    return isModalOpenAsync(JOURNAL_MODAL_ID);
  }
  async function waitJournalModalClosed(timeoutMs = 12e4) {
    return waitModalClosed(JOURNAL_MODAL_ID, timeoutMs);
  }
  async function fakeJournalShow(payload, opts) {
    const shouldOpen = opts?.open !== false;
    await fakeHide(INVENTORY_ATOM_PATCH.label);
    await fakeShow(SHARED_MYDATA_PATCH, { journal: payload ?? {} }, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    if (shouldOpen) await openJournalModal();
  }
  var STATS_MODAL_ID = "stats";
  async function openStatsModal() {
    return openModal(STATS_MODAL_ID);
  }
  async function isStatsModalOpenAsync() {
    return isModalOpenAsync(STATS_MODAL_ID);
  }
  async function waitStatsModalClosed(timeoutMs = 12e4) {
    return waitModalClosed(STATS_MODAL_ID, timeoutMs);
  }
  async function fakeStatsShow(payload, opts) {
    const shouldOpen = opts?.open !== false;
    await fakeShow(SHARED_MYDATA_PATCH, { stats: payload ?? {} }, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    if (shouldOpen) await openStatsModal();
  }
  var ACTIVITY_LOG_MODAL_ID = "activityLog";
  async function openActivityLogModal() {
    return openModal(ACTIVITY_LOG_MODAL_ID);
  }
  async function isActivityLogModalOpenAsync() {
    return isModalOpenAsync(ACTIVITY_LOG_MODAL_ID);
  }
  async function waitActivityLogModalClosed(timeoutMs = 12e4) {
    return waitModalClosed(ACTIVITY_LOG_MODAL_ID, timeoutMs);
  }
  async function fakeActivityLogShow(payload, opts) {
    const shouldOpen = opts?.open !== false;
    await fakeShow(SHARED_MYDATA_PATCH, { activityLogs: payload ?? [] }, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    if (shouldOpen) await openActivityLogModal();
  }

  // src/services/misc.ts
  var PATH_GHOST_MODE = "misc.ghostMode";
  var PATH_GHOST_DELAY = "misc.ghostDelayMs";
  var DEFAULT_DELAY_MS = 50;
  var PATH_AUTO_RECO_ENABLED = "misc.autoRecoEnabled";
  var PATH_AUTO_RECO_DELAY = "misc.autoRecoDelayMs";
  var AUTO_RECO_MIN_MS = 3e4;
  var AUTO_RECO_MAX_MS = 5 * 6e4;
  var AUTO_RECO_DEFAULT_MS = 6e4;
  var readGhostEnabled = (def = false) => {
    try {
      const stored = readAriesPath(PATH_GHOST_MODE);
      if (typeof stored === "boolean") return stored;
      if (stored === "1" || stored === 1) return true;
      if (stored === "0" || stored === 0) return false;
      return !!stored;
    } catch {
      return def;
    }
  };
  var writeGhostEnabled = (v) => {
    try {
      writeAriesPath(PATH_GHOST_MODE, !!v);
    } catch (err) {
    }
  };
  var getGhostDelayMs = () => {
    try {
      const stored = readAriesPath(PATH_GHOST_DELAY);
      const n = Math.floor(Number(stored || DEFAULT_DELAY_MS));
      return Math.max(5, n);
    } catch {
      return DEFAULT_DELAY_MS;
    }
  };
  var setGhostDelayMs = (n) => {
    const v = Math.max(5, Math.floor(n || DEFAULT_DELAY_MS));
    try {
      writeAriesPath(PATH_GHOST_DELAY, v);
    } catch (err) {
    }
  };
  var clampAutoRecoDelay = (ms) => Math.min(AUTO_RECO_MAX_MS, Math.max(AUTO_RECO_MIN_MS, Math.floor(ms || AUTO_RECO_DEFAULT_MS)));
  var readAutoRecoEnabled = (def = false) => {
    try {
      const stored = readAriesPath(PATH_AUTO_RECO_ENABLED);
      if (typeof stored === "boolean") return stored;
      if (stored === "1" || stored === 1) return true;
      if (stored === "0" || stored === 0) return false;
      return !!stored;
    } catch {
      return def;
    }
  };
  var writeAutoRecoEnabled = (on) => {
    try {
      writeAriesPath(PATH_AUTO_RECO_ENABLED, !!on);
    } catch {
    }
  };
  var getAutoRecoDelayMs = () => {
    try {
      const raw = Number(readAriesPath(PATH_AUTO_RECO_DELAY));
      if (Number.isFinite(raw)) return clampAutoRecoDelay(raw);
    } catch {
    }
    return AUTO_RECO_DEFAULT_MS;
  };
  var setAutoRecoDelayMs = (ms) => {
    const v = clampAutoRecoDelay(ms);
    try {
      writeAriesPath(PATH_AUTO_RECO_DELAY, v);
    } catch {
    }
  };
  function createGhostController() {
    let DELAY_MS = getGhostDelayMs();
    const KEYS = /* @__PURE__ */ new Set();
    const onKeyDownCapture = (e) => {
      const k = e.key.toLowerCase();
      const isMove = k === "z" || k === "q" || k === "s" || k === "d" || k === "w" || k === "a" || e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight";
      if (!isMove) return;
      e.preventDefault();
      e.stopImmediatePropagation();
      if (e.repeat) return;
      KEYS.add(k);
    };
    const onKeyUpCapture = (e) => {
      const k = e.key.toLowerCase();
      const isMove = k === "z" || k === "q" || k === "s" || k === "d" || k === "w" || k === "a" || e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight";
      if (!isMove) return;
      e.preventDefault();
      e.stopImmediatePropagation();
      KEYS.delete(k);
    };
    const onBlur = () => {
      KEYS.clear();
    };
    const onVisibility = () => {
      if (document.hidden) KEYS.clear();
    };
    function getDir() {
      let dx = 0, dy = 0;
      if (KEYS.has("z") || KEYS.has("w") || KEYS.has("arrowup")) dy -= 1;
      if (KEYS.has("s") || KEYS.has("arrowdown")) dy += 1;
      if (KEYS.has("q") || KEYS.has("a") || KEYS.has("arrowleft")) dx -= 1;
      if (KEYS.has("d") || KEYS.has("arrowright")) dx += 1;
      if (dx) dx = dx > 0 ? 1 : -1;
      if (dy) dy = dy > 0 ? 1 : -1;
      return { dx, dy };
    }
    let rafId = null;
    let lastTs = 0, accMs = 0, inMove = false;
    async function step(dx, dy) {
      let cur;
      try {
        cur = await PlayerService.getPosition();
      } catch (err) {
      }
      const cx = Math.round(cur?.x ?? 0), cy = Math.round(cur?.y ?? 0);
      try {
        await PlayerService.move(cx + dx, cy + dy);
      } catch (err) {
      }
    }
    const CAPTURE = { capture: true };
    function frame(ts) {
      if (!lastTs) lastTs = ts;
      const dt = ts - lastTs;
      lastTs = ts;
      const { dx, dy } = getDir();
      accMs += dt;
      if (dx === 0 && dy === 0) {
        accMs = Math.min(accMs, DELAY_MS * 4);
        rafId = requestAnimationFrame(frame);
        return;
      }
      if (accMs >= DELAY_MS && !inMove) {
        accMs -= DELAY_MS;
        inMove = true;
        (async () => {
          try {
            await step(dx, dy);
          } finally {
            inMove = false;
          }
        })();
      }
      accMs = Math.min(accMs, DELAY_MS * 4);
      rafId = requestAnimationFrame(frame);
    }
    return {
      start() {
        if (rafId !== null) return;
        lastTs = 0;
        accMs = 0;
        inMove = false;
        window.addEventListener("keydown", onKeyDownCapture, CAPTURE);
        window.addEventListener("keyup", onKeyUpCapture, CAPTURE);
        window.addEventListener("blur", onBlur);
        document.addEventListener("visibilitychange", onVisibility);
        rafId = requestAnimationFrame(frame);
      },
      stop() {
        if (rafId !== null) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
        KEYS.clear();
        window.removeEventListener("keydown", onKeyDownCapture, CAPTURE);
        window.removeEventListener("keyup", onKeyUpCapture, CAPTURE);
        window.removeEventListener("blur", onBlur);
        document.removeEventListener("visibilitychange", onVisibility);
      },
      setSpeed(n) {
        const v = Math.max(5, Math.floor(n || DEFAULT_DELAY_MS));
        DELAY_MS = v;
        setGhostDelayMs(v);
      },
      getSpeed() {
        return DELAY_MS;
      }
    };
  }
  var selectedMap = /* @__PURE__ */ new Map();
  var seedStockByName = /* @__PURE__ */ new Map();
  var seedSourceCache = [];
  var selectedDecorMap = /* @__PURE__ */ new Map();
  var decorStockByName = /* @__PURE__ */ new Map();
  var decorSourceCache = [];
  var _decorDeleteAbort = null;
  var _decorDeleteBusy = false;
  var _decorDeletePaused = false;
  var _decorDeletePauseResolver = null;
  var NF_US = new Intl.NumberFormat("en-US");
  var formatNum = (n) => NF_US.format(Math.max(0, Math.floor(n || 0)));
  async function clearUiSelectionAtoms() {
    try {
      await Atoms.inventory.mySelectedItemName.set(null);
    } catch {
    }
    try {
      await Atoms.inventory.myValidatedSelectedItemIndex.set(null);
    } catch {
    }
    try {
      await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(null);
    } catch {
    }
  }
  var OVERLAY_ID = "qws-seeddeleter-overlay";
  var LIST_ID = "qws-seeddeleter-list";
  var SUMMARY_ID = "qws-seeddeleter-summary";
  var OVERLAY_DECOR_ID = "qws-decordeleter-overlay";
  var LIST_DECOR_ID = "qws-decordeleter-list";
  var SUMMARY_DECOR_ID = "qws-decordeleter-summary";
  function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
  }
  function buildDisplayNameToSpeciesFromCatalog() {
    const map2 = /* @__PURE__ */ new Map();
    try {
      const cat = plantCatalog;
      for (const species of Object.keys(cat || {})) {
        const seedName = cat?.[species]?.seed?.name && String(cat?.[species]?.seed?.name) || `${species} Seed`;
        const arr = map2.get(seedName) ?? [];
        arr.push(species);
        map2.set(seedName, arr);
      }
    } catch {
    }
    return map2;
  }
  async function buildSpeciesStockFromInventory() {
    const inv = await getMySeedInventory();
    const stock = /* @__PURE__ */ new Map();
    for (const it of inv) {
      const q = Math.max(0, Math.floor(it.quantity || 0));
      if (q > 0) stock.set(it.species, (stock.get(it.species) ?? 0) + q);
    }
    return stock;
  }
  function allocateForRequestedName(requested, nameToSpecies, speciesStock) {
    let remaining = Math.max(0, Math.floor(requested.qty || 0));
    let candidates = nameToSpecies.get(requested.name) ?? [];
    if (!candidates.length && / seed$/i.test(requested.name)) {
      const fallbackSpecies = requested.name.replace(/\s+seed$/i, "");
      if (plantCatalog?.[fallbackSpecies]) candidates = [fallbackSpecies];
    }
    if (!candidates.length || remaining <= 0) return [];
    const ranked = candidates.map((sp) => ({ sp, available: speciesStock.get(sp) ?? 0 })).filter((x) => x.available > 0).sort((a, b) => b.available - a.available);
    const out = [];
    for (const { sp, available } of ranked) {
      if (remaining <= 0) break;
      const take = Math.min(available, remaining);
      if (take > 0) {
        out.push({ species: sp, qty: take });
        remaining -= take;
      }
    }
    return out;
  }
  var _seedDeleteAbort = null;
  var _seedDeleteBusy = false;
  var _seedDeletePaused = false;
  var _seedDeletePauseResolver = null;
  var DEFAULT_SEED_DELETE_DELAY_MS = 35;
  async function waitSeedPause() {
    while (_seedDeletePaused) {
      await new Promise((resolve2) => {
        _seedDeletePauseResolver = resolve2;
      });
      _seedDeletePauseResolver = null;
    }
  }
  async function deleteSelectedSeeds(opts = {}) {
    if (_seedDeleteBusy) {
      await toastSimple("Seed deleter", "Deletion already in progress.", "info");
      return;
    }
    const delayMs = Math.max(0, Math.floor(opts.delayMs ?? DEFAULT_SEED_DELETE_DELAY_MS));
    const selection = (opts.selection && Array.isArray(opts.selection) ? opts.selection : Array.from(selectedMap.values())).map((s) => ({ name: s.name, qty: Math.max(0, Math.floor(s.qty || 0)) })).filter((s) => s.qty > 0);
    if (selection.length === 0) {
      await toastSimple("Seed deleter", "No seeds selected.", "info");
      return;
    }
    const nameToSpecies = buildDisplayNameToSpeciesFromCatalog();
    const speciesStock = await buildSpeciesStockFromInventory();
    const allocatedBySpecies = /* @__PURE__ */ new Map();
    let requestedTotal = 0, cappedTotal = 0;
    for (const req of selection) {
      requestedTotal += req.qty;
      const chunks = allocateForRequestedName(req, nameToSpecies, speciesStock);
      const okForThis = chunks.reduce((a, c) => a + c.qty, 0);
      cappedTotal += okForThis;
      for (const c of chunks) {
        allocatedBySpecies.set(c.species, (allocatedBySpecies.get(c.species) ?? 0) + c.qty);
      }
    }
    if (cappedTotal <= 0) {
      await toastSimple("Seed deleter", "Nothing to delete (not in inventory).", "info");
      return;
    }
    if (cappedTotal < requestedTotal) {
      await toastSimple(
        "Seed deleter",
        `Requested ${formatNum(requestedTotal)} but only ${formatNum(cappedTotal)} available. Proceeding.`,
        "info"
      );
    }
    const tasks = Array.from(allocatedBySpecies.entries()).map(([species, qty]) => ({ species, qty: Math.max(0, Math.floor(qty || 0)) })).filter((t) => t.qty > 0);
    const total = tasks.reduce((acc, t) => acc + t.qty, 0);
    if (total <= 0) {
      await toastSimple("Seed deleter", "Nothing to delete.", "info");
      return;
    }
    _seedDeleteBusy = true;
    const abort = new AbortController();
    _seedDeleteAbort = abort;
    try {
      await toastSimple("Seed deleter", `Deleting ${formatNum(total)} seeds across ${tasks.length} species...`, "info");
      let done = 0;
      let successfulDeletes = 0;
      for (const t of tasks) {
        let remaining = t.qty;
        while (remaining > 0) {
          if (abort.signal.aborted) throw new Error("Deletion cancelled.");
          await waitDecorPause();
          await waitSeedPause();
          let attemptSucceeded = false;
          try {
            await PlayerService.wish(t.species);
            attemptSucceeded = true;
          } catch (err) {
          }
          if (attemptSucceeded) successfulDeletes += 1;
          done += 1;
          remaining -= 1;
          try {
            opts.onProgress?.({ done, total, species: t.species, remainingForSpecies: remaining });
            window.dispatchEvent(new CustomEvent("qws:seeddeleter:progress", {
              detail: { done, total, species: t.species, remainingForSpecies: remaining }
            }));
          } catch {
          }
          if (delayMs > 0 && remaining > 0) await sleep(delayMs);
        }
      }
      if (!opts.keepSelection) selectedMap.clear();
      try {
        window.dispatchEvent(new CustomEvent("qws:seeddeleter:done", { detail: { total, speciesCount: tasks.length } }));
      } catch {
      }
      if (successfulDeletes > 0) {
        await toastSimple("Seed deleter", `Deleted ${formatNum(successfulDeletes)} seeds (${tasks.length} species).`, "success");
      } else {
        await toastSimple("Seed deleter", "No seeds were deleted (requests failed).", "info");
      }
    } catch (e) {
      const msg = e?.message || "Deletion failed.";
      try {
        window.dispatchEvent(new CustomEvent("qws:seeddeleter:error", { detail: { message: msg } }));
      } catch {
      }
      await toastSimple("Seed deleter", msg, "error");
    } finally {
      _seedDeleteBusy = false;
      _seedDeletePaused = false;
      _seedDeleteAbort = null;
      _seedDeletePauseResolver?.();
      _seedDeletePauseResolver = null;
    }
  }
  function cancelSeedDeletion() {
    try {
      _seedDeletePaused = false;
      _seedDeletePauseResolver?.();
      _seedDeletePauseResolver = null;
      _seedDeleteAbort?.abort();
    } catch (err) {
    }
  }
  function isSeedDeletionRunning() {
    return _seedDeleteBusy;
  }
  function pauseSeedDeletion() {
    if (!_seedDeleteBusy || _seedDeletePaused) return;
    _seedDeletePaused = true;
    try {
      window.dispatchEvent(new CustomEvent("qws:seeddeleter:paused"));
    } catch {
    }
  }
  function resumeSeedDeletion() {
    if (!_seedDeletePaused) return;
    _seedDeletePaused = false;
    _seedDeletePauseResolver?.();
    _seedDeletePauseResolver = null;
    try {
      window.dispatchEvent(new CustomEvent("qws:seeddeleter:resumed"));
    } catch {
    }
  }
  function isSeedDeletionPaused() {
    return _seedDeletePaused;
  }
  try {
    window.addEventListener("qws:seeddeleter:apply", async (e) => {
      try {
        const selection = Array.isArray(e?.detail?.selection) ? e.detail.selection : void 0;
        await deleteSelectedSeeds({ selection, delayMs: 35, keepSelection: false });
      } catch {
      }
    });
  } catch {
  }
  function seedDisplayNameFromSpecies(species) {
    try {
      const node = plantCatalog?.[species];
      const n = node?.seed?.name;
      if (typeof n === "string" && n) return n;
    } catch {
    }
    return `${species} Seed`;
  }
  function normalizeSeedItem(x, _idx) {
    if (!x || typeof x !== "object") return null;
    const species = typeof x.species === "string" ? x.species.trim() : "";
    const itemType = x.itemType === "Seed" ? "Seed" : null;
    const quantity = Number.isFinite(x.quantity) ? Math.max(0, Math.floor(x.quantity)) : 0;
    if (!species || itemType !== "Seed" || quantity <= 0) return null;
    return { species, itemType: "Seed", quantity, id: `seed:${species}` };
  }
  async function getMySeedInventory() {
    try {
      const raw = await Atoms.inventory.mySeedInventory.get();
      if (!Array.isArray(raw)) return [];
      const out = [];
      raw.forEach((x, i) => {
        const s = normalizeSeedItem(x, i);
        if (s) out.push(s);
      });
      return out;
    } catch {
      return [];
    }
  }
  function buildInventoryShapeFrom(items) {
    return { items, favoritedItemIds: [] };
  }
  function decorDisplayNameFromId(decorId) {
    try {
      const node = decorCatalog?.[decorId];
      const n = node?.name;
      if (typeof n === "string" && n) return n;
    } catch {
    }
    return decorId || "Decor";
  }
  function normalizeDecorItem(x) {
    if (!x || typeof x !== "object") return null;
    const decorId = typeof x.decorId === "string" ? x.decorId.trim() : "";
    const itemType = x.itemType === "Decor" ? "Decor" : null;
    const quantity = Number.isFinite(x.quantity) ? Math.max(0, Math.floor(x.quantity)) : 0;
    if (!decorId || itemType !== "Decor" || quantity <= 0) return null;
    return { decorId, itemType: "Decor", quantity, id: `decor:${decorId}` };
  }
  async function getMyDecorInventory() {
    try {
      const raw = await Atoms.inventory.myDecorInventory.get();
      if (!Array.isArray(raw)) return [];
      const out = [];
      raw.forEach((x) => {
        const s = normalizeDecorItem(x);
        if (s) out.push(s);
      });
      return out;
    } catch {
      return [];
    }
  }
  function buildDecorInventoryShapeFrom(items) {
    return { items, favoritedItemIds: [] };
  }
  function setStyles(el2, styles) {
    Object.assign(el2.style, styles);
  }
  function styleOverlayBox(div, id) {
    div.id = id;
    setStyles(div, {
      position: "fixed",
      left: "12px",
      top: "12px",
      zIndex: "999999",
      display: "grid",
      gridTemplateRows: "auto auto 1px 1fr auto",
      gap: "6px",
      minWidth: "320px",
      maxWidth: "420px",
      maxHeight: "52vh",
      padding: "8px",
      border: "1px solid #39424c",
      borderRadius: "10px",
      background: "rgba(22,27,34,0.92)",
      boxShadow: "0 10px 30px rgba(0,0,0,0.35)",
      backdropFilter: "blur(2px)",
      userSelect: "none",
      fontFamily: "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial",
      fontSize: "12px",
      lineHeight: "1.25"
    });
    div.dataset["qwsSeedDeleter"] = "1";
  }
  function makeDraggable(root, handle) {
    let dragging = false;
    let ox = 0, oy = 0;
    const onDown = (e) => {
      dragging = true;
      const r = root.getBoundingClientRect();
      ox = e.clientX - r.left;
      oy = e.clientY - r.top;
      document.addEventListener("mousemove", onMove);
      document.addEventListener("mouseup", onUp, { once: true });
    };
    const onMove = (e) => {
      if (!dragging) return;
      const nx = Math.max(4, e.clientX - ox);
      const ny = Math.max(4, e.clientY - oy);
      root.style.left = `${nx}px`;
      root.style.top = `${ny}px`;
    };
    const onUp = () => {
      dragging = false;
      document.removeEventListener("mousemove", onMove);
    };
    handle.addEventListener("mousedown", onDown);
  }
  function createButton(label2, styleOverride) {
    const b = document.createElement("button");
    b.textContent = label2;
    setStyles(b, {
      padding: "4px 8px",
      borderRadius: "8px",
      border: "1px solid #4446",
      background: "#161b22",
      color: "#E7EEF7",
      cursor: "pointer",
      fontWeight: "600",
      fontSize: "12px",
      ...styleOverride
    });
    b.onmouseenter = () => b.style.borderColor = "#6aa1";
    b.onmouseleave = () => b.style.borderColor = "#4446";
    return b;
  }
  var overlayKeyGuardsOn = false;
  function isInsideOverlay(el2) {
    return !!(el2 && (el2.closest?.(`#${OVERLAY_ID}`) || el2.closest?.(`#${OVERLAY_DECOR_ID}`)));
  }
  function keyGuardCapture(e) {
    const ae = document.activeElement;
    if (!isInsideOverlay(ae)) return;
    const tag = (ae?.tagName || "").toLowerCase();
    const isEditable = tag === "input" || tag === "textarea" || ae && ae.isContentEditable;
    if (!isEditable) return;
    if (/^[0-9]$/.test(e.key)) {
      e.stopImmediatePropagation();
    }
  }
  function installOverlayKeyGuards() {
    if (overlayKeyGuardsOn) return;
    window.addEventListener("keydown", keyGuardCapture, { capture: true });
    overlayKeyGuardsOn = true;
  }
  function removeOverlayKeyGuards() {
    if (!overlayKeyGuardsOn) return;
    window.removeEventListener("keydown", keyGuardCapture, { capture: true });
    overlayKeyGuardsOn = false;
  }
  async function closeSeedInventoryPanel() {
    try {
      await fakeInventoryHide();
    } catch {
      try {
        document.dispatchEvent(new KeyboardEvent("keydown", { key: "Escape" }));
      } catch {
      }
    }
  }
  function createSeedOverlay() {
    const box = document.createElement("div");
    styleOverlayBox(box, OVERLAY_ID);
    const header = document.createElement("div");
    setStyles(header, { display: "flex", alignItems: "center", gap: "4px", cursor: "move" });
    const title = document.createElement("div");
    title.textContent = "\u{1F3AF} Selection mode";
    setStyles(title, { fontWeight: "700", fontSize: "13px" });
    const hint = document.createElement("div");
    hint.textContent = "Click seeds in inventory to toggle selection.";
    setStyles(hint, { opacity: "0.8", fontSize: "11px" });
    const hr = document.createElement("div");
    setStyles(hr, { height: "1px", background: "#2d333b" });
    const list = document.createElement("div");
    list.id = LIST_ID;
    setStyles(list, {
      minHeight: "44px",
      maxHeight: "26vh",
      overflow: "auto",
      padding: "4px",
      border: "1px dashed #39424c",
      borderRadius: "8px",
      background: "rgba(15,19,24,0.84)",
      userSelect: "text"
    });
    const actions = document.createElement("div");
    setStyles(actions, { display: "flex", justifyContent: "space-between", alignItems: "center", gap: "8px" });
    const summary = document.createElement("div");
    summary.id = SUMMARY_ID;
    setStyles(summary, { fontWeight: "600" });
    summary.textContent = "Selected: 0 species \xB7 0 seeds";
    const btnClear = createButton("Clear");
    btnClear.title = "Clear selection";
    btnClear.onclick = async () => {
      selectedMap.clear();
      refreshList();
      updateSummary();
      await clearUiSelectionAtoms();
      await repatchFakeSeedInventoryWithSelection();
    };
    _btnConfirm = createButton("Confirm", { background: "#1F2328CC" });
    _btnConfirm.disabled = true;
    _btnConfirm.onclick = async () => {
      await closeSeedInventoryPanel();
    };
    header.append(title);
    actions.append(summary, btnClear, _btnConfirm);
    box.append(header, hint, hr, list, actions);
    makeDraggable(box, header);
    return box;
  }
  function showSeedOverlay() {
    if (document.getElementById(OVERLAY_ID)) return;
    const el2 = createSeedOverlay();
    document.body.appendChild(el2);
    installOverlayKeyGuards();
    refreshList();
    updateSummary();
  }
  function hideSeedOverlay() {
    const el2 = document.getElementById(OVERLAY_ID);
    if (el2) el2.remove();
    if (!document.getElementById(OVERLAY_DECOR_ID)) removeOverlayKeyGuards();
  }
  var _btnConfirm = null;
  var unsubSelectedName = null;
  var unsubDecorSelectedName = null;
  function renderListRow(item) {
    const row = document.createElement("div");
    setStyles(row, {
      display: "grid",
      gridTemplateColumns: "1fr auto",
      alignItems: "center",
      gap: "6px",
      padding: "4px 6px",
      borderBottom: "1px dashed #2d333b"
    });
    const name = document.createElement("div");
    name.textContent = item.name;
    setStyles(name, {
      fontSize: "12px",
      fontWeight: "600",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    const controls = document.createElement("div");
    setStyles(controls, { display: "flex", alignItems: "center", gap: "6px" });
    const qty = document.createElement("input");
    qty.type = "number";
    qty.min = "1";
    qty.max = String(Math.max(1, item.maxQty));
    qty.step = "1";
    qty.value = String(item.qty);
    qty.className = "qmm-input";
    setStyles(qty, {
      width: "68px",
      height: "28px",
      border: "1px solid #4446",
      borderRadius: "8px",
      background: "rgba(15,19,24,0.90)",
      padding: "0 8px",
      fontSize: "12px"
    });
    const swallowDigits = (e) => {
      if (/^[0-9]$/.test(e.key)) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    };
    qty.addEventListener("keydown", swallowDigits);
    const updateQty = async () => {
      const v = Math.min(item.maxQty, Math.max(1, Math.floor(Number(qty.value) || 1)));
      qty.value = String(v);
      const cur = selectedMap.get(item.name);
      if (!cur) return;
      cur.qty = v;
      selectedMap.set(item.name, cur);
      updateSummary();
      await repatchFakeSeedInventoryWithSelection();
    };
    qty.onchange = () => {
      void updateQty();
    };
    qty.oninput = () => {
      void updateQty();
    };
    const remove = createButton("Remove", { background: "transparent" });
    remove.onclick = async () => {
      selectedMap.delete(item.name);
      refreshList();
      updateSummary();
      await repatchFakeSeedInventoryWithSelection();
    };
    controls.append(qty, remove);
    row.append(name, controls);
    return row;
  }
  function refreshList() {
    const list = document.getElementById(LIST_ID);
    if (!list) return;
    list.innerHTML = "";
    const entries = Array.from(selectedMap.values()).sort((a, b) => a.name.localeCompare(b.name));
    if (entries.length === 0) {
      const empty = document.createElement("div");
      empty.textContent = "No seeds selected.";
      empty.style.opacity = "0.8";
      list.appendChild(empty);
      return;
    }
    for (const it of entries) list.appendChild(renderListRow(it));
  }
  function totalSelected() {
    let species = 0, qty = 0;
    for (const it of selectedMap.values()) {
      species += 1;
      qty += it.qty;
    }
    return { species, qty };
  }
  function updateSummary() {
    const { species, qty } = totalSelected();
    const el2 = document.getElementById(SUMMARY_ID);
    if (el2) el2.textContent = `Selected: ${species} species \xB7 ${formatNum(qty)} seeds`;
    if (_btnConfirm) {
      _btnConfirm.textContent = "Confirm";
      _btnConfirm.disabled = qty <= 0;
      _btnConfirm.style.opacity = qty <= 0 ? "0.6" : "1";
      _btnConfirm.style.cursor = qty <= 0 ? "not-allowed" : "pointer";
    }
  }
  async function repatchFakeSeedInventoryWithSelection() {
    const src = Array.isArray(seedSourceCache) ? seedSourceCache : [];
    const remainingByName = /* @__PURE__ */ new Map();
    for (const s of src) {
      const disp = seedDisplayNameFromSpecies(s.species);
      const qty = Math.max(0, Math.floor(s.quantity || 0));
      remainingByName.set(disp, (remainingByName.get(disp) ?? 0) + qty);
    }
    for (const sel of selectedMap.values()) {
      const cur = remainingByName.get(sel.name) ?? 0;
      const picked = Math.max(0, Math.floor(sel.qty || 0));
      remainingByName.set(sel.name, Math.max(0, cur - picked));
    }
    const patched = [];
    for (const s of src) {
      const disp = seedDisplayNameFromSpecies(s.species);
      const remaining = remainingByName.get(disp) ?? 0;
      if (remaining <= 0) continue;
      const take = Math.min(remaining, Math.max(0, Math.floor(s.quantity || 0)));
      if (take <= 0) continue;
      patched.push({ ...s, quantity: take });
      remainingByName.set(disp, remaining - take);
    }
    try {
      await fakeInventoryShow({ items: patched, favoritedItemIds: [] }, { open: false });
    } catch {
    }
  }
  async function beginSelectedNameListener() {
    if (unsubSelectedName) return;
    const unsub = await Atoms.inventory.mySelectedItemName.onChange(async (name) => {
      const n = (name || "").trim();
      if (!n) return;
      const max = Math.max(1, seedStockByName.get(n) ?? 1);
      const existing = selectedMap.get(n);
      if (existing) {
        existing.qty = max;
        existing.maxQty = max;
        selectedMap.set(n, existing);
      } else {
        selectedMap.set(n, { name: n, qty: max, maxQty: max });
      }
      refreshList();
      updateSummary();
      await clearUiSelectionAtoms();
      await repatchFakeSeedInventoryWithSelection();
    });
    unsubSelectedName = typeof unsub === "function" ? unsub : null;
  }
  async function endSelectedNameListener() {
    const fn = unsubSelectedName;
    unsubSelectedName = null;
    try {
      await fn?.();
    } catch {
    }
  }
  async function openSeedInventoryPreview() {
    try {
      const src = await getMySeedInventory();
      if (!src.length) {
        await toastSimple("Seed inventory", "No seeds to display.", "info");
        return;
      }
      await fakeInventoryShow(buildInventoryShapeFrom(src), { open: true });
    } catch (e) {
      await toastSimple("Seed inventory", e?.message || "Failed to open seed inventory.", "error");
    }
  }
  async function openSeedSelectorFlow(setWindowVisible) {
    try {
      setWindowVisible?.(false);
      seedSourceCache = await getMySeedInventory();
      seedStockByName = /* @__PURE__ */ new Map();
      for (const s of seedSourceCache) {
        const display = seedDisplayNameFromSpecies(s.species);
        seedStockByName.set(display, Math.max(1, Math.floor(s.quantity || 0)));
      }
      selectedMap.clear();
      showSeedOverlay();
      await beginSelectedNameListener();
      await fakeInventoryShow(buildInventoryShapeFrom(seedSourceCache), { open: true });
      if (await isInventoryPanelOpen()) {
        await waitInventoryPanelClosed();
      }
    } catch (e) {
      await toastSimple("Seed inventory", e?.message || "Failed to open seed selector.", "error");
    } finally {
      await endSelectedNameListener();
      hideSeedOverlay();
      seedSourceCache = [];
      seedStockByName.clear();
      setWindowVisible?.(true);
    }
  }
  function createDecorOverlay() {
    const box = document.createElement("div");
    styleOverlayBox(box, OVERLAY_DECOR_ID);
    const header = document.createElement("div");
    setStyles(header, { display: "flex", alignItems: "center", gap: "4px", cursor: "move" });
    const title = document.createElement("div");
    title.textContent = "Decor selection";
    setStyles(title, { fontWeight: "700", fontSize: "13px" });
    const hint = document.createElement("div");
    hint.textContent = "Click decor in inventory to toggle selection.";
    setStyles(hint, { opacity: "0.8", fontSize: "11px" });
    const hr = document.createElement("div");
    setStyles(hr, { height: "1px", background: "#2d333b" });
    const list = document.createElement("div");
    list.id = LIST_DECOR_ID;
    setStyles(list, {
      minHeight: "44px",
      maxHeight: "26vh",
      overflow: "auto",
      padding: "4px",
      border: "1px dashed #39424c",
      borderRadius: "8px",
      background: "rgba(15,19,24,0.84)",
      userSelect: "text"
    });
    const actions = document.createElement("div");
    setStyles(actions, { display: "flex", justifyContent: "space-between", alignItems: "center", gap: "8px" });
    const summary = document.createElement("div");
    summary.id = SUMMARY_DECOR_ID;
    setStyles(summary, { fontWeight: "600" });
    summary.textContent = "Selected: 0 decor \xB7 0 items";
    const btnClear = createButton("Clear");
    btnClear.title = "Clear selection";
    btnClear.onclick = async () => {
      selectedDecorMap.clear();
      refreshDecorList();
      updateDecorSummary();
      await clearUiSelectionAtoms();
      await repatchFakeDecorInventoryWithSelection();
    };
    const btnConfirm = createButton("Confirm", { background: "#1F2328CC" });
    btnConfirm.disabled = true;
    btnConfirm.onclick = async () => {
      await closeSeedInventoryPanel();
    };
    header.append(title);
    actions.append(summary, btnClear, btnConfirm);
    box.append(header, hint, hr, list, actions);
    makeDraggable(box, header);
    box.__btnConfirm = btnConfirm;
    return box;
  }
  function showDecorOverlay() {
    if (document.getElementById(OVERLAY_DECOR_ID)) return;
    const el2 = createDecorOverlay();
    document.body.appendChild(el2);
    installOverlayKeyGuards();
    refreshDecorList();
    updateDecorSummary();
  }
  function hideDecorOverlay() {
    const el2 = document.getElementById(OVERLAY_DECOR_ID);
    if (el2) el2.remove();
    if (!document.getElementById(OVERLAY_ID)) removeOverlayKeyGuards();
  }
  function renderDecorListRow(item) {
    const row = document.createElement("div");
    setStyles(row, {
      display: "grid",
      gridTemplateColumns: "1fr auto",
      alignItems: "center",
      gap: "6px",
      padding: "4px 6px",
      borderBottom: "1px dashed #2d333b"
    });
    const name = document.createElement("div");
    name.textContent = item.name;
    setStyles(name, {
      fontSize: "12px",
      fontWeight: "600",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    const controls = document.createElement("div");
    setStyles(controls, { display: "flex", alignItems: "center", gap: "6px" });
    const qty = document.createElement("input");
    qty.type = "number";
    qty.min = "1";
    qty.max = String(Math.max(1, item.maxQty));
    qty.step = "1";
    qty.value = String(item.qty);
    qty.className = "qmm-input";
    setStyles(qty, {
      width: "68px",
      height: "28px",
      border: "1px solid #4446",
      borderRadius: "8px",
      background: "rgba(15,19,24,0.90)",
      padding: "0 8px",
      fontSize: "12px"
    });
    const swallowDigits = (e) => {
      if (/^[0-9]$/.test(e.key)) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    };
    qty.addEventListener("keydown", swallowDigits);
    const updateQty = async () => {
      const v = Math.min(item.maxQty, Math.max(1, Math.floor(Number(qty.value) || 1)));
      qty.value = String(v);
      const cur = selectedDecorMap.get(item.name);
      if (!cur) return;
      cur.qty = v;
      cur.maxQty = Math.max(cur.maxQty, v);
      selectedDecorMap.set(item.name, cur);
      updateDecorSummary();
      await repatchFakeDecorInventoryWithSelection();
    };
    qty.onchange = () => {
      void updateQty();
    };
    qty.oninput = () => {
      void updateQty();
    };
    const remove = createButton("Remove", { background: "transparent" });
    remove.onclick = async () => {
      selectedDecorMap.delete(item.name);
      refreshDecorList();
      updateDecorSummary();
      await repatchFakeDecorInventoryWithSelection();
    };
    controls.append(qty, remove);
    row.append(name, controls);
    return row;
  }
  function refreshDecorList() {
    const list = document.getElementById(LIST_DECOR_ID);
    if (!list) return;
    list.innerHTML = "";
    const entries = Array.from(selectedDecorMap.values()).sort((a, b) => a.name.localeCompare(b.name));
    if (entries.length === 0) {
      const empty = document.createElement("div");
      empty.textContent = "No decor selected.";
      empty.style.opacity = "0.8";
      list.appendChild(empty);
      return;
    }
    for (const it of entries) list.appendChild(renderDecorListRow(it));
  }
  function totalDecorSelected() {
    let kinds = 0, qty = 0;
    for (const it of selectedDecorMap.values()) {
      kinds += 1;
      qty += it.qty;
    }
    return { kinds, qty };
  }
  function updateDecorSummary() {
    const { kinds, qty } = totalDecorSelected();
    const el2 = document.getElementById(SUMMARY_DECOR_ID);
    if (el2) el2.textContent = `Selected: ${kinds} decor \xB7 ${formatNum(qty)} items`;
    const overlay = document.getElementById(OVERLAY_DECOR_ID);
    const btn = overlay?.__btnConfirm;
    if (btn) {
      btn.textContent = "Confirm";
      btn.disabled = qty <= 0;
      btn.style.opacity = qty <= 0 ? "0.6" : "1";
      btn.style.cursor = qty <= 0 ? "not-allowed" : "pointer";
    }
  }
  async function repatchFakeDecorInventoryWithSelection() {
    const src = Array.isArray(decorSourceCache) ? decorSourceCache : [];
    const remainingByName = /* @__PURE__ */ new Map();
    for (const s of src) {
      const disp = decorDisplayNameFromId(s.decorId);
      const qty = Math.max(0, Math.floor(s.quantity || 0));
      remainingByName.set(disp, (remainingByName.get(disp) ?? 0) + qty);
    }
    for (const sel of selectedDecorMap.values()) {
      const cur = remainingByName.get(sel.name) ?? 0;
      const picked = Math.max(0, Math.floor(sel.qty || 0));
      remainingByName.set(sel.name, Math.max(0, cur - picked));
    }
    const patched = [];
    for (const s of src) {
      const disp = decorDisplayNameFromId(s.decorId);
      const remaining = remainingByName.get(disp) ?? 0;
      if (remaining <= 0) continue;
      const take = Math.min(remaining, Math.max(0, Math.floor(s.quantity || 0)));
      if (take <= 0) continue;
      patched.push({ ...s, quantity: take });
      remainingByName.set(disp, remaining - take);
    }
    try {
      await fakeInventoryShow({ items: patched, favoritedItemIds: [] }, { open: false });
    } catch {
    }
  }
  async function beginSelectedDecorNameListener() {
    if (unsubDecorSelectedName) return;
    const unsub = await Atoms.inventory.mySelectedItemName.onChange(async (name) => {
      const n = (name || "").trim();
      if (!n) return;
      const max = Math.max(1, decorStockByName.get(n) ?? 1);
      const decorId = Array.from(decorSourceCache || []).find((d) => decorDisplayNameFromId(d.decorId) === n)?.decorId || n;
      const existing = selectedDecorMap.get(n);
      if (existing) {
        existing.qty = max;
        existing.maxQty = max;
        selectedDecorMap.set(n, existing);
      } else {
        selectedDecorMap.set(n, { name: n, qty: max, maxQty: max, decorId });
      }
      refreshDecorList();
      updateDecorSummary();
      await clearUiSelectionAtoms();
      await repatchFakeDecorInventoryWithSelection();
    });
    unsubDecorSelectedName = typeof unsub === "function" ? unsub : null;
  }
  async function endSelectedDecorNameListener() {
    const fn = unsubDecorSelectedName;
    unsubDecorSelectedName = null;
    try {
      await fn?.();
    } catch {
    }
  }
  async function findFirstEmptySlot() {
    const state2 = await PlayerService.getGardenState();
    const dirt = state2?.tileObjects || {};
    const boardwalk = state2?.boardwalkTileObjects || {};
    for (let i = 0; i < 200; i++) {
      const key2 = String(i);
      const has = Object.prototype.hasOwnProperty.call(dirt, key2) && dirt[key2] != null;
      if (!has) return { tileType: "Dirt", index: i };
    }
    for (let i = 0; i < 76; i++) {
      const key2 = String(i);
      const has = Object.prototype.hasOwnProperty.call(boardwalk, key2) && boardwalk[key2] != null;
      if (!has) return { tileType: "Boardwalk", index: i };
    }
    return null;
  }
  var DEFAULT_DECOR_DELETE_DELAY_MS = 35;
  async function waitDecorPause() {
    while (_decorDeletePaused) {
      await new Promise((resolve2) => {
        _decorDeletePauseResolver = resolve2;
      });
      _decorDeletePauseResolver = null;
    }
  }
  async function deleteSelectedDecor(opts = {}) {
    if (_decorDeleteBusy) {
      await toastSimple("Decor deleter", "Deletion already in progress.", "info");
      return;
    }
    const delayMs = Math.max(0, Math.floor(opts.delayMs ?? DEFAULT_DECOR_DELETE_DELAY_MS));
    const selection = (opts.selection && Array.isArray(opts.selection) ? opts.selection : Array.from(selectedDecorMap.values())).map((s) => ({ name: s.name, decorId: s.decorId, qty: Math.max(0, Math.floor(s.qty || 0)) })).filter((s) => s.qty > 0);
    if (!selection.length) {
      await toastSimple("Decor deleter", "No decor selected.", "info");
      return;
    }
    const stock = /* @__PURE__ */ new Map();
    (await getMyDecorInventory()).forEach((d) => {
      stock.set(d.decorId, (stock.get(d.decorId) ?? 0) + Math.max(0, Math.floor(d.quantity || 0)));
    });
    const tasks = selection.map((s) => {
      const available = stock.get(s.decorId) ?? 0;
      const qty = Math.min(s.qty, available);
      return { decorId: s.decorId, qty, name: s.name };
    }).filter((t) => t.qty > 0);
    const total = tasks.reduce((acc, t) => acc + t.qty, 0);
    if (total <= 0) {
      await toastSimple("Decor deleter", "Nothing to delete (not in inventory).", "info");
      return;
    }
    const emptySlot = await findFirstEmptySlot();
    if (!emptySlot) {
      await toastSimple("Decor deleter", "No empty slot available to delete decor (dirt 0-199, boardwalk 0-75).", "error");
      return;
    }
    _decorDeleteBusy = true;
    const abort = new AbortController();
    _decorDeleteAbort = abort;
    try {
      await toastSimple("Decor deleter", `Deleting ${formatNum(total)} decor items across ${tasks.length} types...`, "info");
      let done = 0;
      for (const t of tasks) {
        let remaining = t.qty;
        while (remaining > 0) {
          if (abort.signal.aborted) throw new Error("Deletion cancelled.");
          try {
            await PlayerService.placeDecor(emptySlot.tileType, emptySlot.index, t.decorId, 0);
          } catch {
          }
          if (delayMs > 0) await sleep(delayMs);
          try {
            await PlayerService.removeGardenObject(emptySlot.index, emptySlot.tileType);
          } catch {
          }
          if (delayMs > 0) await sleep(delayMs);
          done += 1;
          remaining -= 1;
          try {
            opts.onProgress?.({ done, total, decorId: t.decorId, remainingForDecor: remaining });
            window.dispatchEvent(new CustomEvent("qws:decordeleter:progress", {
              detail: { done, total, decorId: t.decorId, remainingForDecor: remaining }
            }));
          } catch {
          }
        }
      }
      if (!opts.keepSelection) selectedDecorMap.clear();
      try {
        window.dispatchEvent(new CustomEvent("qws:decordeleter:done", { detail: { total, decorCount: tasks.length } }));
      } catch {
      }
      await toastSimple("Decor deleter", `Deleted ${formatNum(total)} decor items (${tasks.length} types).`, "success");
    } catch (e) {
      const msg = e?.message || "Deletion failed.";
      try {
        window.dispatchEvent(new CustomEvent("qws:decordeleter:error", { detail: { message: msg } }));
      } catch {
      }
      await toastSimple("Decor deleter", msg, "error");
    } finally {
      _decorDeleteBusy = false;
      _decorDeletePaused = false;
      _decorDeleteAbort = null;
      _decorDeletePauseResolver?.();
      _decorDeletePauseResolver = null;
    }
  }
  function cancelDecorDeletion() {
    try {
      _decorDeletePaused = false;
      _decorDeletePauseResolver?.();
      _decorDeletePauseResolver = null;
      _decorDeleteAbort?.abort();
    } catch {
    }
  }
  function isDecorDeletionRunning() {
    return _decorDeleteBusy;
  }
  function pauseDecorDeletion() {
    if (!_decorDeleteBusy || _decorDeletePaused) return;
    _decorDeletePaused = true;
    try {
      window.dispatchEvent(new CustomEvent("qws:decordeleter:paused"));
    } catch {
    }
  }
  function resumeDecorDeletion() {
    if (!_decorDeletePaused) return;
    _decorDeletePaused = false;
    _decorDeletePauseResolver?.();
    _decorDeletePauseResolver = null;
    try {
      window.dispatchEvent(new CustomEvent("qws:decordeleter:resumed"));
    } catch {
    }
  }
  function isDecorDeletionPaused() {
    return _decorDeletePaused;
  }
  async function openDecorSelectorFlow(setWindowVisible) {
    try {
      setWindowVisible?.(false);
      decorSourceCache = await getMyDecorInventory();
      decorStockByName = /* @__PURE__ */ new Map();
      for (const d of decorSourceCache) {
        const display = decorDisplayNameFromId(d.decorId);
        decorStockByName.set(display, Math.max(1, Math.floor(d.quantity || 0)));
      }
      selectedDecorMap.clear();
      showDecorOverlay();
      await beginSelectedDecorNameListener();
      await fakeInventoryShow(buildDecorInventoryShapeFrom(decorSourceCache), { open: true });
      if (await isInventoryPanelOpen()) {
        await waitInventoryPanelClosed();
      }
    } catch (e) {
      await toastSimple("Decor inventory", e?.message || "Failed to open decor selector.", "error");
    } finally {
      await endSelectedDecorNameListener();
      hideDecorOverlay();
      decorSourceCache = [];
      decorStockByName.clear();
      setWindowVisible?.(true);
    }
  }
  var MiscService = {
    // ghost
    readGhostEnabled,
    writeGhostEnabled,
    getGhostDelayMs,
    setGhostDelayMs,
    createGhostController,
    readAutoRecoEnabled,
    writeAutoRecoEnabled,
    getAutoRecoDelayMs,
    setAutoRecoDelayMs,
    // seeds
    getMySeedInventory,
    openSeedInventoryPreview,
    openSeedSelectorFlow,
    //delete
    deleteSelectedSeeds,
    cancelSeedDeletion,
    isSeedDeletionRunning,
    pauseSeedDeletion,
    resumeSeedDeletion,
    isSeedDeletionPaused,
    getCurrentSeedSelection() {
      return Array.from(selectedMap.values());
    },
    clearSeedSelection() {
      selectedMap.clear();
    },
    // decor
    getMyDecorInventory,
    openDecorSelectorFlow,
    deleteSelectedDecor,
    cancelDecorDeletion,
    isDecorDeletionRunning,
    pauseDecorDeletion,
    resumeDecorDeletion,
    isDecorDeletionPaused,
    getCurrentDecorSelection() {
      return Array.from(selectedDecorMap.values());
    },
    clearDecorSelection() {
      selectedDecorMap.clear();
    }
  };

  // src/hooks/ws-hook.ts
  var wsCloseListeners = [];
  var versionReloadScheduled = false;
  var autoRecoTimer = null;
  function onWebSocketClose(cb) {
    wsCloseListeners.push(cb);
    return () => {
      const idx = wsCloseListeners.indexOf(cb);
      if (idx !== -1) wsCloseListeners.splice(idx, 1);
    };
  }
  function notifyWebSocketClose(ev, ws) {
    for (const listener of [...wsCloseListeners]) {
      try {
        listener(ev, ws);
      } catch {
      }
    }
  }
  function isVersionExpiredClose(ev) {
    return ev?.code === 4710 || /Version\s*Expired/i.test(ev?.reason || "");
  }
  function startAutoReloadOnVersionExpired() {
    onWebSocketClose((ev) => {
      if (!isVersionExpiredClose(ev)) return;
      const env = detectEnvironment();
      if (env.surface === "discord" || env.isInIframe) return;
      if (versionReloadScheduled) return;
      versionReloadScheduled = true;
      try {
        console.warn("[MagicGarden] Version expired, reloading...");
      } catch {
      }
      try {
        pageWindow.location.reload();
      } catch {
        try {
          window.location.reload();
        } catch {
        }
      }
    });
  }
  function isSupersededSessionClose(ev) {
    if (ev?.code !== 4250) return false;
    const reason = ev?.reason || "";
    return /superseded/i.test(reason) || /newer user session/i.test(reason);
  }
  function startAutoReconnectOnSuperseded() {
    onWebSocketClose((ev) => {
      if (!isSupersededSessionClose(ev)) return;
      if (!MiscService.readAutoRecoEnabled(false)) return;
      const delayMs = MiscService.getAutoRecoDelayMs();
      if (autoRecoTimer !== null) {
        clearTimeout(autoRecoTimer);
        autoRecoTimer = null;
      }
      autoRecoTimer = window.setTimeout(() => {
        autoRecoTimer = null;
        if (!MiscService.readAutoRecoEnabled(false)) return;
        try {
          const conn = pageWindow.MagicCircle_RoomConnection;
          const connect = conn?.connect;
          if (typeof connect === "function") {
            connect.call(conn);
          }
        } catch (error) {
          console.warn("[MagicGarden] Auto reco failed:", error);
        }
      }, delayMs);
    });
  }
  function installPageWebSocketHook() {
    if (!pageWindow || !NativeWS) return;
    startAutoReloadOnVersionExpired();
    startAutoReconnectOnSuperseded();
    function WrappedWebSocket(url, protocols) {
      const ws = protocols !== void 0 ? new NativeWS(url, protocols) : new NativeWS(url);
      sockets.push(ws);
      ws.addEventListener("open", () => {
        setTimeout(() => {
          if (ws.readyState === NativeWS.OPEN) setQWS(ws, "open-fallback");
        }, 800);
      });
      ws.addEventListener("message", async (ev) => {
        const j = await parseWSData(ev.data);
        if (!j) return;
        if (!hasSharedQuinoaWS() && (j.type === "Welcome" || j.type === "Config" || j.fullState || j.config)) {
          setQWS(ws, "message:" + (j.type || "state"));
        }
      });
      ws.addEventListener("close", (ev) => {
        notifyWebSocketClose(ev, ws);
      });
      return ws;
    }
    WrappedWebSocket.prototype = NativeWS.prototype;
    try {
      WrappedWebSocket.OPEN = NativeWS.OPEN;
    } catch {
    }
    try {
      WrappedWebSocket.CLOSED = NativeWS.CLOSED;
    } catch {
    }
    try {
      WrappedWebSocket.CLOSING = NativeWS.CLOSING;
    } catch {
    }
    try {
      WrappedWebSocket.CONNECTING = NativeWS.CONNECTING;
    } catch {
    }
    pageWindow.WebSocket = WrappedWebSocket;
    if (pageWindow !== window) {
      try {
        window.WebSocket = WrappedWebSocket;
      } catch {
      }
    }
    function hasSharedQuinoaWS() {
      const existing = readSharedGlobal("quinoaWS");
      return !!existing;
    }
    installHarvestCropInterceptor();
  }
  var interceptorsByType = /* @__PURE__ */ new Map();
  var interceptorStatus = readSharedGlobal(
    "__tmMessageHookInstalled"
  ) ? "installed" : "idle";
  var interceptorPoll = null;
  var interceptorTimeout = null;
  function registerMessageInterceptor(type, interceptor) {
    const list = interceptorsByType.get(type);
    if (list) {
      list.push(interceptor);
    } else {
      interceptorsByType.set(type, [interceptor]);
    }
    ensureMessageInterceptorInstalled();
    return () => {
      const current = interceptorsByType.get(type);
      if (!current) return;
      const index = current.indexOf(interceptor);
      if (index !== -1) current.splice(index, 1);
      if (current.length === 0) interceptorsByType.delete(type);
    };
  }
  function ensureMessageInterceptorInstalled() {
    if (interceptorStatus === "installed" || interceptorStatus === "installing") return;
    interceptorStatus = "installing";
    const tryInstall = () => {
      const Conn = pageWindow.MagicCircle_RoomConnection || readSharedGlobal("MagicCircle_RoomConnection");
      if (!Conn) return false;
      const original = resolveSendMessage(Conn);
      if (!original) return false;
      const wrap = function(message, ...rest) {
        let currentMessage = message;
        try {
          const type = currentMessage?.type;
          if (type && interceptorsByType.size > 0) {
            const context = { thisArg: this, args: rest };
            const result = applyInterceptors(type, currentMessage, context);
            if (result.drop) return;
            currentMessage = result.message;
          }
        } catch (error) {
          console.error("[MG-mod] Erreur dans le hook WS :", error);
        }
        return original.fn.call(this, currentMessage, ...rest);
      };
      if (original.kind === "static") {
        Conn.sendMessage = wrap;
      } else {
        Conn.prototype.sendMessage = wrap;
      }
      interceptorStatus = "installed";
      shareGlobal("__tmMessageHookInstalled", true);
      if (interceptorPoll !== null) {
        clearInterval(interceptorPoll);
        interceptorPoll = null;
      }
      if (interceptorTimeout !== null) {
        clearTimeout(interceptorTimeout);
        interceptorTimeout = null;
      }
      return true;
    };
    if (tryInstall()) return;
    interceptorPoll = window.setInterval(() => {
      if (tryInstall()) {
        if (interceptorPoll !== null) {
          clearInterval(interceptorPoll);
          interceptorPoll = null;
        }
      }
    }, 200);
    interceptorTimeout = window.setTimeout(() => {
      if (interceptorPoll !== null) {
        clearInterval(interceptorPoll);
        interceptorPoll = null;
      }
      if (interceptorStatus !== "installed") {
        interceptorStatus = "idle";
      }
      interceptorTimeout = null;
    }, 2e4);
  }
  function applyInterceptors(type, initialMessage, context) {
    const interceptors = interceptorsByType.get(type);
    if (!interceptors || interceptors.length === 0) {
      return { message: initialMessage, drop: false };
    }
    let currentMessage = initialMessage;
    for (const interceptor of [...interceptors]) {
      try {
        const result = interceptor(currentMessage, context);
        if (!result) continue;
        if (result.kind === "drop") {
          return { message: currentMessage, drop: true };
        }
        if (result.kind === "replace") {
          currentMessage = result.message;
        }
      } catch (error) {
      }
    }
    return { message: currentMessage, drop: false };
  }
  function installHarvestCropInterceptor() {
    if (readSharedGlobal("__tmHarvestHookInstalled")) return;
    let latestGardenState = null;
    let friendBonusPercent = null;
    let friendBonusFromPlayers = null;
    let latestEggId = null;
    void (async () => {
      try {
        latestGardenState = await Atoms.data.garden.get() ?? null;
      } catch {
      }
      try {
        await Atoms.data.garden.onChange((next) => {
          latestGardenState = next ?? null;
        });
      } catch {
      }
      try {
        const initialObj = await Atoms.data.myCurrentGardenObject.get();
        latestEggId = extractEggId(initialObj);
      } catch {
      }
      try {
        await Atoms.data.myCurrentGardenObject.onChange((next) => {
          latestEggId = extractEggId(next);
        });
      } catch {
      }
    })();
    void (async () => {
      try {
        const initial = await Atoms.server.friendBonusMultiplier.get();
        friendBonusPercent = friendBonusPercentFromMultiplier(initial);
      } catch {
      }
      try {
        await Atoms.server.friendBonusMultiplier.onChange((next) => {
          friendBonusPercent = friendBonusPercentFromMultiplier(next);
        });
      } catch {
      }
      try {
        const initialPlayers = await Atoms.server.numPlayers.get();
        friendBonusFromPlayers = friendBonusPercentFromPlayers(initialPlayers);
      } catch {
      }
      try {
        await Atoms.server.numPlayers.onChange((next) => {
          friendBonusFromPlayers = friendBonusPercentFromPlayers(next);
        });
      } catch {
      }
    })();
    const resolveFriendBonusPercent = () => friendBonusPercent ?? friendBonusFromPlayers ?? null;
    registerMessageInterceptor("HarvestCrop", (message) => {
      const slot = message.slot;
      const slotsIndex = message.slotsIndex;
      if (!Number.isInteger(slot) || !Number.isInteger(slotsIndex)) {
        return;
      }
      const garden2 = latestGardenState;
      const tileObjects = garden2?.tileObjects;
      const tile = tileObjects ? tileObjects[String(slot)] : void 0;
      if (!tile || typeof tile !== "object" || tile.objectType !== "plant") {
        return;
      }
      const slots = Array.isArray(tile.slots) ? tile.slots : [];
      const cropSlot = slots[slotsIndex];
      if (!cropSlot || typeof cropSlot !== "object") {
        return;
      }
      const seedKey = extractSeedKey2(tile);
      const sizePercent = extractSizePercent2(cropSlot);
      const mutations = sanitizeMutations(cropSlot?.mutations);
      const lockerEnabled = (() => {
        try {
          return lockerService.getState().enabled;
        } catch {
          return false;
        }
      })();
      if (lockerEnabled) {
        let harvestAllowed = true;
        try {
          harvestAllowed = lockerService.allowsHarvest({
            seedKey,
            sizePercent,
            mutations
          });
        } catch {
          harvestAllowed = true;
        }
        if (!harvestAllowed) {
          console.log("[HarvestCrop] Blocked by locker", {
            slot,
            slotsIndex,
            seedKey,
            sizePercent,
            mutations
          });
          return { kind: "drop" };
        }
      }
      StatsService.incrementGardenStat("totalHarvested");
      void (async () => {
        try {
          const garden3 = await Atoms.data.garden.get();
          const tileObjects2 = garden3?.tileObjects ?? null;
          const tile2 = tileObjects2 ? tileObjects2[String(slot)] : void 0;
          const cropSlot2 = Array.isArray(tile2?.slots) ? tile2.slots?.[slotsIndex] : void 0;
          console.log("[HarvestCrop]", {
            slot,
            slotsIndex,
            cropSlot: cropSlot2
          });
        } catch (error) {
          console.error("[HarvestCrop] Unable to log crop slot", error);
        }
      })();
    });
    registerMessageInterceptor("RemoveGardenObject", (message) => {
      StatsService.incrementGardenStat("totalDestroyed");
    });
    registerMessageInterceptor("WaterPlant", (message) => {
      StatsService.incrementGardenStat("watercanUsed");
      StatsService.incrementGardenStat("waterTimeSavedMs", 5 * 60 * 1e3);
    });
    registerMessageInterceptor("PlantSeed", (message) => {
      StatsService.incrementGardenStat("totalPlanted");
    });
    registerMessageInterceptor("PurchaseDecor", (message) => {
      StatsService.incrementShopStat("decorBought");
    });
    registerMessageInterceptor("PurchaseSeed", (message) => {
      StatsService.incrementShopStat("seedsBought");
    });
    registerMessageInterceptor("PurchaseEgg", (message) => {
      StatsService.incrementShopStat("eggsBought");
    });
    registerMessageInterceptor("PurchaseTool", (message) => {
      StatsService.incrementShopStat("toolsBought");
    });
    registerMessageInterceptor("PickupDecor", () => {
      const decorLocked = lockerRestrictionsService.isDecorPickupLocked();
      if (decorLocked) {
        console.log("[PickupDecor] Blocked by decor picker");
        return { kind: "drop" };
      }
    });
    registerMessageInterceptor("HatchEgg", () => {
      const locked = lockerRestrictionsService.isEggLocked(latestEggId);
      if (locked) {
        console.log("[HatchEgg] Blocked by egg locker", { eggId: latestEggId });
        void (async () => {
          try {
            await dedupeEggLockToast(latestEggId);
          } catch {
          }
        })();
        return { kind: "drop" };
      }
      void (async () => {
        const previousPets = await readInventoryPetSnapshots();
        const previousMap = buildPetMap(previousPets);
        const nextPets = await waitForInventoryPetAddition(previousMap);
        if (!nextPets) return;
        const newPets = extractNewPets(nextPets, previousMap);
        if (!newPets.length) return;
        for (const pet of newPets) {
          const rarity2 = inferPetRarity(pet.mutations);
          if (pet.species) {
            StatsService.incrementPetHatched(pet.species, rarity2);
          }
        }
      })();
    });
    registerMessageInterceptor("SellAllCrops", (message) => {
      const restrictionState = lockerRestrictionsService.getState();
      const requiredPct = lockerRestrictionsService.getRequiredPercent();
      const requiredPlayers = restrictionState.minRequiredPlayers;
      const currentBonusPct = resolveFriendBonusPercent();
      const allowed = lockerRestrictionsService.allowsCropSale(currentBonusPct);
      if (!allowed) {
        const currentPlayers = currentBonusPct != null ? percentToRequiredFriendCount(currentBonusPct) : null;
        console.log("[SellAllCrops] Blocked by friend bonus restriction", {
          requiredPct,
          requiredPlayers,
          currentBonusPct,
          currentPlayers
        });
        void (async () => {
          try {
            await toastSimple(
              "Friend bonus locker",
              `Require at least ${requiredPct}% friend bonus`,
              "error"
            );
          } catch {
          }
          void removeSellSuccessToast();
        })();
        return { kind: "drop" };
      }
      void (async () => {
        try {
          const items = await Atoms.inventory.myCropItemsToSell.get();
          const count = Array.isArray(items) ? items.length : 0;
          if (count > 0) {
            StatsService.incrementShopStat("cropsSoldCount", count);
          }
        } catch (error) {
          console.error("[SellAllCrops] Unable to read crop items", error);
        }
        try {
          const total = await Atoms.shop.totalCropSellPrice.get();
          const value = Number(total);
          if (Number.isFinite(value) && value > 0) {
            StatsService.incrementShopStat("cropsSoldValue", value);
          }
        } catch (error) {
          console.error("[SellAllCrops] Unable to read crop sell price", error);
        }
      })();
    });
    registerMessageInterceptor("SellPet", (message) => {
      StatsService.incrementShopStat("petsSoldCount");
      void (async () => {
        try {
          const total = await Atoms.pets.totalPetSellPrice.get();
          const value = Number(total);
          if (Number.isFinite(value) && value > 0) {
            StatsService.incrementShopStat("petsSoldValue", value);
          }
        } catch (error) {
          console.error("[SellPet] Unable to read pet sell price", error);
        }
      })();
    });
    shareGlobal("__tmHarvestHookInstalled", true);
  }
  function extractSeedKey2(tile) {
    if (!tile || typeof tile !== "object") return null;
    if (typeof tile.seedKey === "string" && tile.seedKey) return tile.seedKey;
    if (typeof tile.species === "string" && tile.species) return tile.species;
    const fallbacks = ["seedSpecies", "plantSpecies", "cropSpecies", "speciesId"];
    for (const key2 of fallbacks) {
      const value = tile[key2];
      if (typeof value === "string" && value) return value;
    }
    return null;
  }
  var normalizeSpeciesKey2 = (value) => value.toLowerCase().replace(/['`]/g, "").replace(/\s+/g, "").replace(/-/g, "").replace(/(seed|plant|baby|fruit|crop)$/i, "");
  var MAX_SCALE_BY_SPECIES2 = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const register = (key2, value) => {
      if (typeof key2 !== "string") return;
      const normalized = normalizeSpeciesKey2(key2.trim());
      if (!normalized || map2.has(normalized)) return;
      map2.set(normalized, value);
    };
    for (const [species, entry] of Object.entries(plantCatalog)) {
      const maxScale = Number(entry?.crop?.maxScale);
      if (!Number.isFinite(maxScale) || maxScale <= 0) continue;
      register(species, maxScale);
      register(entry?.seed?.name, maxScale);
      register(entry?.plant?.name, maxScale);
      register(entry?.crop?.name, maxScale);
    }
    return map2;
  })();
  function lookupMaxScale2(species) {
    if (typeof species !== "string") return null;
    const normalized = normalizeSpeciesKey2(species.trim());
    if (!normalized) return null;
    const found = MAX_SCALE_BY_SPECIES2.get(normalized);
    if (typeof found === "number" && Number.isFinite(found) && found > 0) {
      return found;
    }
    return null;
  }
  function getMaxScaleForSlot2(slot) {
    if (!slot || typeof slot !== "object") return null;
    const candidates = /* @__PURE__ */ new Set();
    const fromSeedKey = extractSeedKey2(slot);
    if (fromSeedKey) candidates.add(fromSeedKey);
    const fields = [
      "species",
      "seedSpecies",
      "plantSpecies",
      "cropSpecies",
      "baseSpecies",
      "seedKey"
    ];
    for (const field of fields) {
      const value = slot[field];
      if (typeof value === "string" && value) {
        candidates.add(value);
      }
    }
    for (const cand of candidates) {
      const max = lookupMaxScale2(cand);
      if (typeof max === "number" && Number.isFinite(max) && max > 0) {
        return max;
      }
    }
    return null;
  }
  function extractSizePercent2(slot) {
    if (!slot || typeof slot !== "object") return 100;
    const direct = Number(
      slot.sizePercent ?? slot.sizePct ?? slot.size ?? slot.percent ?? slot.progressPercent
    );
    if (Number.isFinite(direct)) {
      return clampPercent3(Math.round(direct), 0, 100);
    }
    const scale = Number(slot.targetScale ?? slot.scale);
    if (Number.isFinite(scale)) {
      const maxScale = getMaxScaleForSlot2(slot);
      if (typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > 1) {
        const clamped = Math.max(1, Math.min(maxScale, scale));
        const pct2 = 50 + (clamped - 1) / (maxScale - 1) * 50;
        return clampPercent3(Math.round(pct2), 50, 100);
      }
      if (scale > 1 && scale <= 2) {
        const pct2 = 50 + (scale - 1) / 1 * 50;
        return clampPercent3(Math.round(pct2), 50, 100);
      }
      const pct = Math.round(scale * 100);
      return clampPercent3(pct, 0, 100);
    }
    return 100;
  }
  function sanitizeMutations(raw) {
    if (!Array.isArray(raw)) return [];
    const out = [];
    for (let i = 0; i < raw.length; i++) {
      const value = raw[i];
      if (typeof value === "string") {
        if (value) out.push(value);
      } else if (value != null) {
        const str = String(value);
        if (str) out.push(str);
      }
    }
    return out;
  }
  function clampPercent3(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  var HATCH_EGG_TIMEOUT_MS = 5e3;
  async function readInventoryPetSnapshots() {
    try {
      const inventory = await Atoms.inventory.myInventory.get();
      return collectInventoryPets(inventory);
    } catch (error) {
      console.error("[HatchEgg] Unable to read inventory", error);
      return [];
    }
  }
  function collectInventoryPets(rawInventory) {
    const items = extractInventoryItems(rawInventory);
    const pets = [];
    for (const entry of items) {
      const pet = toInventoryPet(entry);
      if (pet) pets.push(pet);
    }
    return pets;
  }
  function extractInventoryItems(rawInventory) {
    if (!rawInventory) return [];
    if (Array.isArray(rawInventory)) return rawInventory;
    if (Array.isArray(rawInventory.items)) return rawInventory.items;
    if (Array.isArray(rawInventory.inventory)) return rawInventory.inventory;
    if (Array.isArray(rawInventory.inventory?.items)) return rawInventory.inventory.items;
    return [];
  }
  function toInventoryPet(entry) {
    if (!entry || typeof entry !== "object") return null;
    const source = entry.item && typeof entry.item === "object" ? entry.item : entry;
    if (!source || typeof source !== "object") return null;
    const type = source.itemType ?? source.data?.itemType ?? "";
    if (String(type).toLowerCase() !== "pet") return null;
    const id = source.id ?? source.data?.id;
    const species = source.petSpecies ?? source.data?.petSpecies;
    if (!id || !species) return null;
    const mutations = sanitizeMutations(source.mutations ?? source.data?.mutations);
    return {
      id: String(id),
      species: String(species),
      mutations
    };
  }
  function buildPetMap(pets) {
    const map2 = /* @__PURE__ */ new Map();
    for (const pet of pets) {
      map2.set(pet.id, pet);
    }
    return map2;
  }
  function extractNewPets(pets, previous) {
    return pets.filter((pet) => !previous.has(pet.id));
  }
  function extractEggId(obj) {
    if (!obj || typeof obj !== "object") return null;
    if (obj.objectType !== "egg") return null;
    const eggId = obj.eggId;
    return typeof eggId === "string" && eggId ? eggId : null;
  }
  async function dedupeEggLockToast(latestEggId) {
    const toastsAtom = getAtomByLabel("quinoaToastsAtom");
    const description = latestEggId ? `Hatching locked for ${latestEggId}` : "Hatching locked by egg locker";
    if (!toastsAtom) {
      await toastSimple("Egg hatch locker", description, "error");
      return;
    }
    const list = await jGet(toastsAtom).catch(() => []);
    const filtered = Array.isArray(list) ? list.filter((t) => !(t?.title === "Egg hatch locker")) : [];
    filtered.push({
      isClosable: true,
      duration: 3500,
      title: "Egg hatch locker",
      description,
      variant: "error",
      id: "quinoa-game-toast"
    });
    await jSet(toastsAtom, filtered);
  }
  function inferPetRarity(mutations) {
    if (!Array.isArray(mutations) || mutations.length === 0) {
      return "normal";
    }
    const seen = new Set(mutations.map((m) => String(m).toLowerCase()));
    if (seen.has("rainbow")) return "rainbow";
    if (seen.has("gold") || seen.has("golden")) return "gold";
    return "normal";
  }
  async function waitForInventoryPetAddition(previous, timeoutMs = HATCH_EGG_TIMEOUT_MS) {
    await delay(0);
    const initial = await readInventoryPetSnapshots();
    if (hasNewInventoryPet(initial, previous)) {
      return initial;
    }
    return new Promise(async (resolve2) => {
      let settled = false;
      let unsub = null;
      let timer = null;
      const finalize = (value) => {
        if (settled) return;
        settled = true;
        if (timer !== null) {
          clearTimeout(timer);
        }
        if (unsub) {
          try {
            unsub();
          } catch {
          }
        }
        resolve2(value);
      };
      const evaluate = (source) => {
        const pets = collectInventoryPets(source);
        if (hasNewInventoryPet(pets, previous)) {
          finalize(pets);
        }
      };
      try {
        unsub = await Atoms.inventory.myInventory.onChange((next) => {
          evaluate(next);
        });
      } catch (error) {
        console.error("[HatchEgg] Unable to observe inventory", error);
        finalize(null);
        return;
      }
      timer = setTimeout(() => {
        void (async () => {
          const latest = await readInventoryPetSnapshots();
          if (hasNewInventoryPet(latest, previous)) {
            finalize(latest);
          } else {
            finalize(null);
          }
        })();
      }, timeoutMs);
    });
  }
  function hasNewInventoryPet(pets, previous) {
    return pets.some((pet) => !previous.has(pet.id));
  }
  function delay(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  function resolveSendMessage(Conn) {
    const isFn = (value) => typeof value === "function";
    if (isFn(Conn.sendMessage)) {
      return { kind: "static", fn: Conn.sendMessage.bind(Conn) };
    }
    if (Conn.prototype && isFn(Conn.prototype.sendMessage)) {
      return { kind: "proto", fn: Conn.prototype.sendMessage };
    }
    return null;
  }
  async function removeSellSuccessToast() {
    try {
      const toastsAtom = getAtomByLabel("quinoaToastsAtom");
      if (!toastsAtom) return;
      const list = await jGet(toastsAtom).catch(() => []);
      const filtered = Array.isArray(list) ? list.filter((t) => {
        if (!t || typeof t !== "object") return true;
        if (t.variant !== "success") return true;
        const icon = t.icon;
        const isTileSell = icon?.type === "tile" && icon?.spritesheet === "items" && Number(icon?.index) === 11;
        const hasCropText = !!t?.description?.props?.values?.cropText;
        return !(isTileSell || hasCropText);
      }) : list;
      if (filtered.length !== list.length) {
        await jSet(toastsAtom, filtered);
      }
    } catch {
    }
  }

  // src/ui/menu.ts
  var Menu = class {
    constructor(opts = {}) {
      this.opts = opts;
      // NOTE: je rends root public pour pouvoir faire ui.root.appendChild(...) ct menus
      __publicField(this, "root");
      __publicField(this, "tabBar");
      __publicField(this, "views");
      __publicField(this, "tabs", /* @__PURE__ */ new Map());
      __publicField(this, "events", /* @__PURE__ */ new Map());
      __publicField(this, "currentId", null);
      __publicField(this, "lsKeyActive");
      __publicField(this, "menuId");
      __publicField(this, "_altDown", false);
      __publicField(this, "_insertDown", false);
      __publicField(this, "_hovering", false);
      __publicField(this, "_onKey", (e) => {
        if (e.code === "Insert" || e.key === "Insert") {
          this._insertDown = e.type === "keydown";
        }
        const alt = e.altKey || this._insertDown;
        if (alt !== this._altDown) {
          this._altDown = alt;
          this._updateAltCursor();
        }
      });
      __publicField(this, "_onBlur", () => {
        this._altDown = false;
        this._insertDown = false;
        this._updateAltCursor();
      });
      __publicField(this, "_onEnter", () => {
        this._hovering = true;
        this._updateAltCursor();
      });
      __publicField(this, "_onLeave", () => {
        this._hovering = false;
        this._updateAltCursor();
      });
      this.menuId = this.opts.id || "default";
      this.lsKeyActive = `menu:${this.menuId}:activeTab`;
    }
    /** Monte le menu dans un conteneur */
    mount(container) {
      this.ensureStyles();
      container.innerHTML = "";
      this.root = el("div", `qmm ${this.opts.classes || ""} ${this.opts.compact ? "qmm-compact" : ""}`);
      if (this.opts.startHidden) this.root.style.display = "none";
      this.tabBar = el("div", "qmm-tabs");
      this.views = el("div", "qmm-views");
      this.root.appendChild(this.tabBar);
      this.root.appendChild(this.views);
      container.appendChild(this.root);
      if (this.tabs.size) {
        for (const [id, def] of this.tabs) this.createTabView(id, def);
        this.restoreActive();
      }
      this.updateTabsBarVisibility();
      this.root.addEventListener("pointerenter", this._onEnter);
      this.root.addEventListener("pointerleave", this._onLeave);
      window.addEventListener("keydown", this._onKey, true);
      window.addEventListener("keyup", this._onKey, true);
      window.addEventListener("blur", this._onBlur);
      document.addEventListener("visibilitychange", this._onBlur);
      if (this.opts.startWindowHidden) this.setWindowVisible(false);
      this.emit("mounted");
    }
    /** Dmonte le menu (optionnel) */
    unmount() {
      this.root?.removeEventListener("pointerenter", this._onEnter);
      this.root?.removeEventListener("pointerleave", this._onLeave);
      window.removeEventListener("keydown", this._onKey, true);
      window.removeEventListener("keyup", this._onKey, true);
      window.removeEventListener("blur", this._onBlur);
      document.removeEventListener("visibilitychange", this._onBlur);
      if (this.root?.parentElement) this.root.parentElement.removeChild(this.root);
      this.emit("unmounted");
    }
    /** Retourne l'lment fentre englobant (barre  / ) */
    getWindowEl() {
      if (!this.root) return null;
      const sel = this.opts.windowSelector || ".qws-win";
      return this.root.closest(sel);
    }
    /** Affiche/masque la FENTRE (barre incluse) */
    setWindowVisible(visible) {
      const win = this.getWindowEl();
      if (!win) return;
      win.classList.toggle("is-hidden", !visible);
      this.emit(visible ? "window:show" : "window:hide");
    }
    /** Bascule ltat de la fentre. Retourne true si maintenant visible. */
    toggleWindow() {
      const win = this.getWindowEl();
      if (!win) return false;
      const willShow = win.classList.contains("is-hidden");
      this.setWindowVisible(willShow);
      return willShow;
    }
    /** Donne ltat courant de la fentre (true = visible) */
    isWindowVisible() {
      const win = this.getWindowEl();
      if (!win) return true;
      return !win.classList.contains("is-hidden") && getComputedStyle(win).display !== "none";
    }
    /** Affiche/masque le root */
    setVisible(visible) {
      if (!this.root) return;
      this.root.style.display = visible ? "" : "none";
      this.emit(visible ? "show" : "hide");
    }
    toggle() {
      if (!this.root) return false;
      const v = this.root.style.display === "none";
      this.setVisible(v);
      return v;
    }
    /** Ajoute un onglet (peut tre appel avant ou aprs mount) */
    addTab(id, title, render) {
      this.tabs.set(id, { title, render, badge: null });
      if (this.root) {
        this.createTabView(id, this.tabs.get(id));
        this.updateTabsBarVisibility();
      }
      return this;
    }
    /** Ajoute plusieurs onglets en une fois */
    addTabs(defs) {
      defs.forEach((d) => this.addTab(d.id, d.title, d.render));
      return this;
    }
    /** Met  jour le titre de longlet (ex: compteur, libell) */
    setTabTitle(id, title) {
      const def = this.tabs.get(id);
      if (!def) return;
      def.title = title;
      if (def.btn) {
        const label2 = def.btn.querySelector(".label");
        if (label2) label2.textContent = title;
      }
    }
    /** Ajoute/retire un badge  droite du titre (ex: 3, NEW, !) */
    setTabBadge(id, text) {
      const def = this.tabs.get(id);
      if (!def || !def.btn) return;
      if (!def.badge) {
        def.badge = document.createElement("span");
        def.badge.className = "badge";
        def.btn.appendChild(def.badge);
      }
      if (text == null || text === "") {
        def.badge.style.display = "none";
      } else {
        def.badge.textContent = text;
        def.badge.style.display = "";
      }
    }
    /** Force le re-render dun onglet (r-excute son render) */
    refreshTab(id) {
      const def = this.tabs.get(id);
      if (!def?.view) return;
      const scroller = this.findScrollableAncestor(def.view);
      const st = scroller ? scroller.scrollTop : null;
      const sl = scroller ? scroller.scrollLeft : null;
      const activeId = document.activeElement?.id || null;
      def.view.innerHTML = "";
      try {
        def.render(def.view, this);
      } catch (e) {
        def.view.textContent = String(e);
      }
      if (this.currentId === id) this.switchTo(id);
      this.emit("tab:render", id);
      if (scroller && st != null) {
        requestAnimationFrame(() => {
          try {
            scroller.scrollTop = st;
            scroller.scrollLeft = sl ?? 0;
          } catch {
          }
          if (activeId) {
            const n = document.getElementById(activeId);
            if (n && n.focus) try {
              n.focus();
            } catch {
            }
          }
        });
      }
    }
    findScrollableAncestor(start) {
      function isScrollable(el3) {
        const s = getComputedStyle(el3);
        const oy = s.overflowY || s.overflow;
        return /(auto|scroll)/.test(oy) && el3.scrollHeight > el3.clientHeight;
      }
      let el2 = start;
      while (el2) {
        if (isScrollable(el2)) return el2;
        el2 = el2.parentElement;
      }
      return document.querySelector(".qws-win");
    }
    firstTabId() {
      const it = this.tabs.keys().next();
      return it.done ? null : it.value ?? null;
    }
    _updateAltCursor() {
      if (!this.root) return;
      this.root.classList.toggle("qmm-alt-drag", this._altDown && this._hovering);
    }
    /** Rcupre la vue DOM dun onglet (pratique pour updates cibles) */
    getTabView(id) {
      return this.tabs.get(id)?.view ?? null;
    }
    /** Retire un onglet */
    removeTab(id) {
      const def = this.tabs.get(id);
      if (!def) return;
      this.tabs.delete(id);
      const btn = this.tabBar?.querySelector(`button[data-id="${cssq(id)}"]`);
      if (btn && btn.parentElement) btn.parentElement.removeChild(btn);
      if (def.view && def.view.parentElement) def.view.parentElement.removeChild(def.view);
      if (this.currentId === id) {
        const first = this.tabs.keys().next().value || null;
        this.switchTo(first);
      }
      this.updateTabsBarVisibility();
    }
    /** Active un onglet (id=null => affiche toutes les vues) */
    switchTo(id) {
      this.currentId = id;
      [...this.tabBar.children].forEach((ch) => ch.classList.toggle("active", ch.dataset.id === id || id === null));
      [...this.views.children].forEach((ch) => ch.classList.toggle("active", ch.dataset.id === id || id === null));
      this.persistActive();
      this.emit("tab:change", id);
    }
    /** vnements */
    on(event, handler) {
      if (!this.events.has(event)) this.events.set(event, /* @__PURE__ */ new Set());
      this.events.get(event).add(handler);
      return () => this.off(event, handler);
    }
    off(event, handler) {
      this.events.get(event)?.delete(handler);
    }
    emit(event, ...args) {
      this.events.get(event)?.forEach((h) => {
        try {
          h(...args);
        } catch {
        }
      });
    }
    // ---------- Helpers UI publics (rutilisables dans tes tabs) ----------
    btn(label2, onClickOrOpts) {
      const opts = typeof onClickOrOpts === "function" ? { onClick: onClickOrOpts } : { ...onClickOrOpts || {} };
      const b = el("button", "qmm-btn");
      b.type = "button";
      let iconEl = null;
      if (opts.icon) {
        iconEl = typeof opts.icon === "string" ? document.createElement("span") : opts.icon;
        if (typeof opts.icon === "string" && iconEl) {
          iconEl.textContent = opts.icon;
        }
        if (iconEl) {
          iconEl.classList.add("qmm-btn__icon");
        }
      }
      const trimmedLabel = (label2 ?? "").trim();
      const shouldRenderLabel = !iconEl || trimmedLabel.length > 0;
      const labelSpan = shouldRenderLabel ? document.createElement("span") : null;
      if (labelSpan) {
        labelSpan.className = "label";
        labelSpan.textContent = label2;
      }
      if (iconEl) {
        if (trimmedLabel.length === 0) {
          b.classList.add("qmm-btn--icon");
        }
        if (opts.iconPosition === "right") {
          iconEl.classList.add("is-right");
          if (labelSpan) b.append(labelSpan);
          b.append(iconEl);
        } else {
          iconEl.classList.add("is-left");
          b.append(iconEl);
          if (labelSpan) b.append(labelSpan);
        }
      } else {
        if (labelSpan) b.append(labelSpan);
      }
      const variant = opts.variant && opts.variant !== "default" ? opts.variant : null;
      if (variant) b.classList.add(`qmm-btn--${variant}`);
      if (opts.fullWidth) b.classList.add("qmm-btn--full");
      if (opts.size === "sm") b.classList.add("qmm-btn--sm");
      if (opts.active) b.classList.add("active");
      if (opts.tooltip || opts.title) b.title = opts.tooltip || opts.title || "";
      if (opts.ariaLabel) b.setAttribute("aria-label", opts.ariaLabel);
      if (opts.onClick) b.addEventListener("click", opts.onClick);
      if (opts.disabled) this.setButtonEnabled(b, false);
      b.setEnabled = (enabled) => this.setButtonEnabled(b, enabled);
      b.setActive = (active) => b.classList.toggle("active", !!active);
      return b;
    }
    setButtonEnabled(button, enabled) {
      button.disabled = !enabled;
      button.classList.toggle("is-disabled", !enabled);
      button.setAttribute("aria-disabled", (!enabled).toString());
    }
    flexRow(opts = {}) {
      const row = document.createElement("div");
      row.className = ["qmm-flex", opts.className || ""].filter(Boolean).join(" ").trim();
      row.style.display = "flex";
      row.style.alignItems = this.mapAlign(opts.align ?? "center");
      row.style.justifyContent = this.mapJustify(opts.justify ?? "start");
      row.style.gap = `${opts.gap ?? 8}px`;
      row.style.flexWrap = opts.wrap === false ? "nowrap" : "wrap";
      if (opts.fullWidth) row.style.width = "100%";
      return row;
    }
    formGrid(opts = {}) {
      const grid = document.createElement("div");
      grid.className = "qmm-form-grid";
      grid.style.display = "grid";
      grid.style.gridTemplateColumns = opts.columns || "max-content 1fr";
      grid.style.columnGap = `${opts.columnGap ?? 8}px`;
      grid.style.rowGap = `${opts.rowGap ?? 8}px`;
      grid.style.alignItems = opts.align ? opts.align : "center";
      return grid;
    }
    formRow(labelText, control, opts = {}) {
      const wrap = document.createElement("div");
      wrap.className = "qmm-form-row";
      wrap.style.display = "grid";
      wrap.style.gridTemplateColumns = `${opts.labelWidth || "160px"} 1fr`;
      wrap.style.columnGap = `${opts.gap ?? 10}px`;
      wrap.style.alignItems = opts.alignTop ? "start" : "center";
      if (opts.wrap) wrap.classList.add("is-wrap");
      const lab = this.label(labelText);
      lab.classList.add("qmm-form-row__label");
      lab.style.margin = "0";
      lab.style.justifySelf = "start";
      if (opts.alignTop) lab.style.alignSelf = "start";
      wrap.append(lab, control);
      return { root: wrap, label: lab };
    }
    card(title, opts = {}) {
      const root = document.createElement("div");
      root.className = "qmm-card";
      root.dataset.tone = opts.tone || "default";
      if (opts.align === "center") root.classList.add("is-center");
      if (opts.align === "stretch") root.classList.add("is-stretch");
      if (opts.padding) root.style.padding = opts.padding;
      if (opts.gap != null) root.style.gap = `${opts.gap}px`;
      if (opts.maxWidth) {
        const max = typeof opts.maxWidth === "number" ? `${opts.maxWidth}px` : opts.maxWidth;
        root.style.width = `min(${max}, 100%)`;
      }
      const header = document.createElement("div");
      header.className = "qmm-card__header";
      if (opts.compactHeader) header.classList.add("is-compact");
      const titleWrap = document.createElement("div");
      titleWrap.className = "qmm-card__title";
      titleWrap.textContent = title;
      if (opts.icon) {
        const icon = typeof opts.icon === "string" ? document.createElement("span") : opts.icon;
        if (typeof opts.icon === "string" && icon) icon.textContent = opts.icon;
        if (icon) {
          icon.classList.add("qmm-card__icon");
          header.appendChild(icon);
        }
      }
      header.appendChild(titleWrap);
      if (opts.subtitle || opts.description) {
        const sub = document.createElement("div");
        sub.className = "qmm-card__subtitle";
        sub.textContent = opts.subtitle || opts.description || "";
        header.appendChild(sub);
      }
      if (opts.actions?.length) {
        const actions = document.createElement("div");
        actions.className = "qmm-card__actions";
        opts.actions.forEach((a) => actions.appendChild(a));
        header.appendChild(actions);
      }
      const body = document.createElement("div");
      body.className = "qmm-card__body";
      root.append(header, body);
      return {
        root,
        header,
        body,
        setTitle(next) {
          titleWrap.textContent = next;
        }
      };
    }
    toggleChip(labelText, opts = {}) {
      const wrap = document.createElement("label");
      wrap.className = "qmm-chip-toggle";
      if (opts.tooltip) wrap.title = opts.tooltip;
      const input = document.createElement("input");
      input.type = opts.type || "checkbox";
      if (opts.name) input.name = opts.name;
      if (opts.value) input.value = opts.value;
      input.checked = !!opts.checked;
      const face = document.createElement("div");
      face.className = "qmm-chip-toggle__face";
      if (opts.icon) {
        const icon = typeof opts.icon === "string" ? document.createElement("span") : opts.icon;
        if (typeof opts.icon === "string" && icon) icon.textContent = opts.icon;
        if (icon) {
          icon.classList.add("qmm-chip-toggle__icon");
          face.appendChild(icon);
        }
      }
      const labelEl = document.createElement("span");
      labelEl.className = "qmm-chip-toggle__label";
      labelEl.textContent = labelText;
      face.appendChild(labelEl);
      if (opts.description) {
        const desc = document.createElement("span");
        desc.className = "qmm-chip-toggle__desc";
        desc.textContent = opts.description;
        face.appendChild(desc);
      }
      if (opts.badge) {
        const badge = document.createElement("span");
        badge.className = "qmm-chip-toggle__badge";
        badge.textContent = opts.badge;
        face.appendChild(badge);
      }
      wrap.append(input, face);
      return { root: wrap, input, label: labelEl };
    }
    select(opts = {}) {
      const sel = document.createElement("select");
      sel.className = "qmm-input qmm-select";
      if (opts.id) sel.id = opts.id;
      if (opts.width) sel.style.minWidth = opts.width;
      if (opts.placeholder) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = opts.placeholder;
        opt.disabled = true;
        opt.selected = true;
        sel.appendChild(opt);
      }
      return sel;
    }
    errorBar() {
      const el2 = document.createElement("div");
      el2.className = "qmm-error";
      el2.style.display = "none";
      return {
        el: el2,
        show(message) {
          el2.textContent = message;
          el2.style.display = "block";
        },
        clear() {
          el2.textContent = "";
          el2.style.display = "none";
        }
      };
    }
    mapAlign(al) {
      if (al === "start") return "flex-start";
      if (al === "end") return "flex-end";
      if (al === "stretch") return "stretch";
      return "center";
    }
    mapJustify(j) {
      if (j === "center") return "center";
      if (j === "end") return "flex-end";
      if (j === "between") return "space-between";
      if (j === "around") return "space-around";
      return "flex-start";
    }
    label(text) {
      const l = el("label", "qmm-label");
      l.textContent = text;
      return l;
    }
    row(...children) {
      const r = el("div", "qmm-row");
      children.forEach((c) => r.appendChild(c));
      return r;
    }
    section(title) {
      const s = el("div", "qmm-section");
      s.appendChild(el("div", "qmm-section-title", escapeHtml(title)));
      return s;
    }
    inputNumber(min = 0, max = 9999, step = 1, value = 0) {
      const wrap = el("div", "qmm-input-number");
      const i = el("input", "qmm-input qmm-input-number-input");
      i.type = "number";
      i.min = String(min);
      i.max = String(max);
      i.step = String(step);
      i.value = String(value);
      i.inputMode = "numeric";
      const spin = el("div", "qmm-spin");
      const up = el("button", "qmm-step qmm-step--up", "\u25B2");
      const down = el("button", "qmm-step qmm-step--down", "\u25BC");
      up.type = down.type = "button";
      const clamp4 = () => {
        const n = Number(i.value);
        if (Number.isFinite(n)) {
          const lo = Number(i.min), hi = Number(i.max);
          const clamped = Math.max(lo, Math.min(hi, n));
          if (clamped !== n) i.value = String(clamped);
        }
      };
      const bump = (dir) => {
        if (dir < 0) i.stepDown();
        else i.stepUp();
        clamp4();
        i.dispatchEvent(new Event("input", { bubbles: true }));
        i.dispatchEvent(new Event("change", { bubbles: true }));
      };
      const addSpin = (btn, dir) => {
        let pressTimer = null;
        let repeatTimer = null;
        let suppressNextClick = false;
        const start = (ev) => {
          suppressNextClick = false;
          pressTimer = window.setTimeout(() => {
            suppressNextClick = true;
            bump(dir);
            repeatTimer = window.setInterval(() => bump(dir), 60);
          }, 300);
          btn.setPointerCapture?.(ev.pointerId);
        };
        const stop2 = () => {
          if (pressTimer != null) {
            clearTimeout(pressTimer);
            pressTimer = null;
          }
          if (repeatTimer != null) {
            clearInterval(repeatTimer);
            repeatTimer = null;
          }
        };
        btn.addEventListener("pointerdown", start);
        ["pointerup", "pointercancel", "pointerleave", "blur"].forEach(
          (ev) => btn.addEventListener(ev, stop2)
        );
        btn.addEventListener("click", (e) => {
          if (suppressNextClick) {
            e.preventDefault();
            e.stopPropagation();
            suppressNextClick = false;
            return;
          }
          bump(dir);
        });
      };
      addSpin(up, 1);
      addSpin(down, -1);
      i.addEventListener("change", clamp4);
      spin.append(up, down);
      wrap.append(i, spin);
      i.wrap = wrap;
      return i;
    }
    inputText(placeholder = "", value = "") {
      const i = el("input", "qmm-input");
      i.type = "text";
      i.placeholder = placeholder;
      i.value = value;
      return i;
    }
    checkbox(checked = false) {
      const i = el("input", "qmm-check");
      i.type = "checkbox";
      i.checked = checked;
      return i;
    }
    radio(name, value, checked = false) {
      const i = el("input", "qmm-radio");
      i.type = "radio";
      i.name = name;
      i.value = value;
      i.checked = checked;
      return i;
    }
    slider(min = 0, max = 100, step = 1, value = 0) {
      const i = el("input", "qmm-range");
      i.type = "range";
      i.min = String(min);
      i.max = String(max);
      i.step = String(step);
      i.value = String(value);
      return i;
    }
    rangeDual(min = 0, max = 100, step = 1, valueMin = min, valueMax = max) {
      const wrap = el("div", "qmm-range-dual");
      const track = el("div", "qmm-range-dual-track");
      const fill = el("div", "qmm-range-dual-fill");
      track.appendChild(fill);
      wrap.appendChild(track);
      const createHandle = (value, extraClass) => {
        const input = this.slider(min, max, step, value);
        input.classList.add("qmm-range-dual-input", extraClass);
        wrap.appendChild(input);
        return input;
      };
      const minInput = createHandle(valueMin, "qmm-range-dual-input--min");
      const maxInput = createHandle(valueMax, "qmm-range-dual-input--max");
      const updateFill = () => {
        const minValue = Number(minInput.value);
        const maxValue = Number(maxInput.value);
        const total = max - min;
        if (!Number.isFinite(total) || total <= 0) {
          fill.style.left = "0%";
          fill.style.right = "100%";
          return;
        }
        const clampPercent4 = (value) => Math.max(0, Math.min(100, value));
        const start = (Math.min(minValue, maxValue) - min) / total * 100;
        const end = (Math.max(minValue, maxValue) - min) / total * 100;
        fill.style.left = `${clampPercent4(start)}%`;
        fill.style.right = `${clampPercent4(100 - end)}%`;
      };
      minInput.addEventListener("input", updateFill);
      maxInput.addEventListener("input", updateFill);
      const handle = {
        root: wrap,
        min: minInput,
        max: maxInput,
        setValues(minValue, maxValue) {
          minInput.value = String(minValue);
          maxInput.value = String(maxValue);
          updateFill();
        },
        refresh: updateFill
      };
      handle.refresh();
      return handle;
    }
    switch(checked = false) {
      const i = this.checkbox(checked);
      i.classList.add("qmm-switch");
      return i;
    }
    // Helpers tableau simple pour lister les items
    table(headers, opts) {
      const wrap = document.createElement("div");
      wrap.className = "qmm-table-wrap";
      if (opts?.minimal) wrap.classList.add("qmm-table-wrap--minimal");
      const scroller = document.createElement("div");
      scroller.className = "qmm-table-scroll";
      if (opts?.maxHeight) scroller.style.maxHeight = opts.maxHeight;
      wrap.appendChild(scroller);
      const t = document.createElement("table");
      t.className = "qmm-table";
      if (opts?.minimal) t.classList.add("qmm-table--minimal");
      if (opts?.compact) t.classList.add("qmm-table--compact");
      if (opts?.fixed) t.style.tableLayout = "fixed";
      const thead = document.createElement("thead");
      const trh = document.createElement("tr");
      headers.forEach((h) => {
        const th = document.createElement("th");
        if (typeof h === "string") {
          th.textContent = h;
        } else {
          th.textContent = h.label ?? "";
          if (h.align) th.classList.add(`is-${h.align}`);
          if (h.width) th.style.width = h.width;
        }
        trh.appendChild(th);
      });
      thead.appendChild(trh);
      const tbody = document.createElement("tbody");
      t.append(thead, tbody);
      scroller.appendChild(t);
      return { root: wrap, tbody };
    }
    segmented(items, selected, onChange, opts) {
      const root = document.createElement("div");
      root.className = "qmm-seg";
      if (opts?.fullWidth) root.classList.add("qmm-seg--full");
      if (opts?.id) root.id = opts.id;
      root.setAttribute("role", "radiogroup");
      if (opts?.ariaLabel) root.setAttribute("aria-label", opts.ariaLabel);
      const rail = document.createElement("div");
      rail.className = "qmm-seg__indicator";
      root.appendChild(rail);
      const reduceMotionQuery = typeof window !== "undefined" && "matchMedia" in window ? window.matchMedia("(prefers-reduced-motion: reduce)") : null;
      const canAnimateIndicator = typeof rail.animate === "function";
      if (canAnimateIndicator) {
        rail.style.transition = "none";
      }
      let indicatorMetrics = null;
      let indicatorAnimation = null;
      const applyIndicatorStyles = (left, width) => {
        rail.style.transform = `translate3d(${left}px,0,0)`;
        rail.style.width = `${width}px`;
      };
      const cancelIndicatorAnimation = () => {
        if (!indicatorAnimation) return;
        indicatorAnimation.cancel();
        indicatorAnimation = null;
      };
      let value = selected;
      const btns = [];
      const setSelected = (v, focus = false) => {
        if (v === value) {
          if (focus) {
            const alreadyActive = btns.find((b) => b.dataset.value === v);
            alreadyActive?.focus();
          }
          onChange?.(value);
          return;
        }
        value = v;
        for (const b of btns) {
          const active = b.dataset.value === v;
          b.setAttribute("aria-checked", active ? "true" : "false");
          b.tabIndex = active ? 0 : -1;
          b.classList.toggle("active", active);
          if (active && focus) b.focus();
        }
        moveIndicator(true);
        onChange?.(value);
      };
      const moveIndicator = (animate = false) => {
        const active = btns.find((b) => b.dataset.value === value);
        if (!active) return;
        const i = btns.indexOf(active);
        const n = btns.length;
        const cs = getComputedStyle(root);
        const gap = parseFloat(cs.gap || cs.columnGap || "0") || 0;
        const bL = parseFloat(cs.borderLeftWidth || "0") || 0;
        const bR = parseFloat(cs.borderRightWidth || "0") || 0;
        const rRoot = root.getBoundingClientRect();
        const rBtn = active.getBoundingClientRect();
        let left = rBtn.left - rRoot.left - bL;
        let width = rBtn.width;
        const padW = rRoot.width - bL - bR;
        if (n === 1) {
          left = 0;
          width = padW;
        } else if (i === 0) {
          const rightEdge = left + width + gap / 2;
          left = 0;
          width = rightEdge - left;
        } else if (i === n - 1) {
          left = left - gap / 2;
          width = padW - left;
        } else {
          left = left - gap / 2;
          width = width + gap;
        }
        const dpr = window.devicePixelRatio || 1;
        const snap = (x) => Math.round(x * dpr) / dpr;
        const targetLeft = snap(left);
        const targetWidth = snap(width);
        const previous = indicatorMetrics;
        indicatorMetrics = { left: targetLeft, width: targetWidth };
        const applyFinal = () => applyIndicatorStyles(targetLeft, targetWidth);
        const shouldAnimate = animate && canAnimateIndicator && !reduceMotionQuery?.matches && previous != null && previous.width > 0 && Number.isFinite(previous.width) && targetWidth > 0 && Number.isFinite(targetWidth);
        if (!shouldAnimate) {
          cancelIndicatorAnimation();
          applyFinal();
          return;
        }
        cancelIndicatorAnimation();
        applyIndicatorStyles(previous.left, previous.width);
        indicatorAnimation = rail.animate(
          [
            {
              transform: `translate3d(${previous.left}px,0,0)`,
              width: `${previous.width}px`,
              opacity: 0.92,
              offset: 0
            },
            {
              transform: `translate3d(${targetLeft}px,0,0)`,
              width: `${targetWidth}px`,
              opacity: 1,
              offset: 1
            }
          ],
          {
            duration: 260,
            easing: "cubic-bezier(.22,.7,.28,1)",
            fill: "forwards"
          }
        );
        const finalize = () => {
          applyFinal();
          indicatorAnimation = null;
        };
        indicatorAnimation.addEventListener("finish", finalize, { once: true });
        indicatorAnimation.addEventListener("cancel", finalize, { once: true });
      };
      items.forEach(({ value: v, label: label2, disabled }) => {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "qmm-seg__btn";
        b.dataset.value = String(v);
        b.setAttribute("role", "radio");
        b.setAttribute("aria-checked", v === selected ? "true" : "false");
        b.tabIndex = v === selected ? 0 : -1;
        b.disabled = !!disabled;
        const labelSpan = document.createElement("span");
        labelSpan.className = "qmm-seg__btn-label";
        labelSpan.textContent = label2;
        b.appendChild(labelSpan);
        b.addEventListener("click", () => {
          if (!b.disabled) setSelected(v, false);
        });
        b.addEventListener("keydown", (e) => {
          if (!["ArrowRight", "ArrowLeft", "Home", "End"].includes(e.key)) return;
          e.preventDefault();
          const idx = items.findIndex((it) => it.value === value);
          if (e.key === "Home") {
            setSelected(items[0].value, true);
            return;
          }
          if (e.key === "End") {
            setSelected(items[items.length - 1].value, true);
            return;
          }
          const dir = e.key === "ArrowRight" ? 1 : -1;
          let j = idx;
          for (let k = 0; k < items.length; k++) {
            j = (j + dir + items.length) % items.length;
            if (!items[j].disabled) {
              setSelected(items[j].value, true);
              break;
            }
          }
        });
        btns.push(b);
        root.appendChild(b);
      });
      const ro = window.ResizeObserver ? new ResizeObserver(() => moveIndicator(false)) : null;
      if (ro) ro.observe(root);
      window.addEventListener("resize", () => moveIndicator(false));
      queueMicrotask(() => moveIndicator(false));
      root.get = () => value;
      root.set = (v) => setSelected(v, false);
      return root;
    }
    radioGroup(name, options, selected, onChange) {
      const wrap = el("div", "qmm-radio-group");
      for (const { value, label: label2 } of options) {
        const r = this.radio(name, value, selected === value);
        const lab = document.createElement("label");
        lab.className = "qmm-radio-label";
        lab.appendChild(r);
        lab.appendChild(document.createTextNode(label2));
        r.onchange = () => {
          if (r.checked) onChange(value);
        };
        wrap.appendChild(lab);
      }
      return wrap;
    }
    /** Bind LS: sauvegarde automatique via toStr/parse */
    bindLS(key2, read, write, parse, toStr) {
      try {
        const raw = localStorage.getItem(key2);
        if (raw != null) write(parse(raw));
      } catch {
      }
      return { save: () => {
        try {
          localStorage.setItem(key2, toStr(read()));
        } catch {
        }
      } };
    }
    /* -------------------------- split2 helper -------------------------- */
    /** Cre un layout 2 colonnes (gauche/droite) en CSS Grid.
     *  leftWidth: ex "200px" | "18rem" | "minmax(160px, 30%)" */
    split2(leftWidth = "260px") {
      const root = el("div", "qmm-split");
      root.style.gridTemplateColumns = "minmax(160px, max-content) 1fr";
      const left = el("div", "qmm-split-left");
      const right = el("div", "qmm-split-right");
      root.appendChild(left);
      root.appendChild(right);
      return { root, left, right };
    }
    /* -------------------------- VTabs factory -------------------------- */
    /** Cre des tabs verticaux gnriques (liste slectionnable + filtre). */
    vtabs(options = {}) {
      return new VTabs(this, options);
    }
    hotkeyButton(initial, onChange, opts) {
      const emptyLabel = opts?.emptyLabel ?? "None";
      const listeningLabel = opts?.listeningLabel ?? "Press a key\u2026";
      const clearable = opts?.clearable ?? true;
      let hk = initial ?? null;
      let recording = false;
      if (opts?.storageKey) {
        try {
          hk = stringToHotkey(localStorage.getItem(opts.storageKey) || "") ?? initial ?? null;
        } catch {
        }
      }
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "qmm-hotkey";
      btn.setAttribute("aria-live", "polite");
      const render = () => {
        btn.classList.toggle("is-recording", recording);
        btn.classList.toggle("is-empty", !hk);
        btn.classList.toggle("is-assigned", !recording && !!hk);
        if (recording) {
          btn.textContent = listeningLabel;
          btn.title = "Listening\u2026 press a key (Esc to cancel, Backspace to clear)";
        } else if (!hk) {
          btn.textContent = emptyLabel;
          btn.title = "No key assigned";
        } else {
          btn.textContent = hotkeyToPretty(hk);
          btn.title = "Click to rebind \u2022 Right-click to clear";
        }
      };
      const applyHotkey = (value, skipRender = false) => {
        hk = value ? { ...value } : null;
        if (!skipRender) render();
      };
      btn.refreshHotkey = (value) => {
        applyHotkey(value);
      };
      const stopRecording = (commit) => {
        recording = false;
        if (!commit) {
          render();
          return;
        }
        render();
      };
      const save = () => {
        if (opts?.storageKey) {
          const str = hotkeyToString(hk);
          try {
            if (str) localStorage.setItem(opts.storageKey, str);
            else localStorage.removeItem(opts.storageKey);
          } catch {
          }
        }
        onChange?.(hk, opts?.storageKey ? hotkeyToString(hk) : void 0);
      };
      const handleKeyDown = (e) => {
        if (!recording) return;
        e.preventDefault();
        e.stopPropagation();
        if (e.key === "Escape") {
          stopRecording(false);
          window.removeEventListener("keydown", handleKeyDown, true);
          return;
        }
        if ((e.key === "Backspace" || e.key === "Delete") && clearable) {
          applyHotkey(null, true);
          save();
          stopRecording(true);
          window.removeEventListener("keydown", handleKeyDown, true);
          return;
        }
        const next = eventToHotkey(e, opts?.allowModifierOnly ?? false);
        if (!next) {
          return;
        }
        applyHotkey(next, true);
        save();
        stopRecording(true);
        window.removeEventListener("keydown", handleKeyDown, true);
      };
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        if (!recording) {
          recording = true;
          render();
          window.addEventListener("keydown", handleKeyDown, true);
          btn.focus();
        }
      });
      if (clearable) {
        btn.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          if (hk) {
            applyHotkey(null, true);
            save();
            render();
          }
        });
      }
      render();
      return btn;
    }
    // ---------- internes ----------
    createTabView(id, def) {
      const b = document.createElement("button");
      b.className = "qmm-tab";
      b.dataset.id = id;
      b.innerHTML = `<span class="label">${escapeHtml(def.title)}</span><span class="badge" style="display:none"></span>`;
      const badgeEl = b.querySelector(".badge");
      def.btn = b;
      def.badge = badgeEl;
      b.onclick = () => this.switchTo(id);
      this.tabBar.appendChild(b);
      const view = el("div", "qmm-view");
      view.dataset.id = id;
      def.view = view;
      this.views.appendChild(view);
      try {
        def.render(view, this);
      } catch (e) {
        view.textContent = String(e);
      }
      if (!this.currentId) this.switchTo(id);
    }
    persistActive() {
      if (!this.currentId) return;
      try {
        writeAriesPath(`menu.activeTabs.${this.menuId}`, this.currentId);
        try {
          localStorage.removeItem(this.lsKeyActive);
        } catch {
        }
      } catch {
      }
    }
    restoreActive() {
      let id = null;
      try {
        const stored = readAriesPath(`menu.activeTabs.${this.menuId}`);
        if (typeof stored === "string" && stored) id = stored;
      } catch {
      }
      if (!id) {
        try {
          id = localStorage.getItem(this.lsKeyActive);
        } catch {
        }
      }
      if (id && this.tabs.has(id)) this.switchTo(id);
      else if (this.tabs.size) this.switchTo(this.firstTabId());
    }
    updateTabsBarVisibility() {
      if (!this.tabBar || !this.root) return;
      const hasTabs = this.tabs.size > 0;
      if (hasTabs) {
        if (!this.tabBar.parentElement) {
          this.root.insertBefore(this.tabBar, this.views);
        }
        this.tabBar.style.display = "flex";
        this.root.classList.remove("qmm-no-tabs");
      } else {
        if (this.tabBar.parentElement) {
          this.tabBar.parentElement.removeChild(this.tabBar);
        }
        this.root.classList.add("qmm-no-tabs");
      }
    }
    ensureStyles() {
      if (document.getElementById("__qmm_css__")) return;
      const css = `
    /* ================= Modern UI for qmm ================= */
.qmm{
  --qmm-bg:        #0f1318;
  --qmm-bg-soft:   #0b0f13;
  --qmm-panel:     #111823cc;
  --qmm-border:    #ffffff22;
  --qmm-border-2:  #ffffff14;
  --qmm-accent:    #7aa2ff;
  --qmm-accent-2:  #92b2ff;
  --qmm-text:      #e7eef7;
  --qmm-text-dim:  #b9c3cf;
  --qmm-shadow:    0 6px 20px rgba(0,0,0,.35);
  --qmm-blur:      8px;

  display:flex; flex-direction:column; gap:10px; color:var(--qmm-text);
}
.qmm-compact{ gap:6px }

/* ---------- Tabs (pill + underline) ---------- */
.qmm-tabs{
  display:flex; gap:6px; flex-wrap:wrap; align-items:flex-end;
  padding:0 6px 2px 6px; position:relative; isolation:isolate;
  border-bottom:1px solid var(--qmm-border);
  background:linear-gradient(180deg, rgba(255,255,255,.04), transparent);
  border-top-left-radius:10px; border-top-right-radius:10px;
}
.qmm-no-tabs .qmm-views{ margin-top:0 }

.qmm-tab{
  flex:1 1 0; min-width:0; cursor:pointer;
  display:inline-flex; justify-content:center; align-items:center; gap:8px;
  padding:8px 12px; color:var(--qmm-text);
  background:transparent; border:1px solid transparent; border-bottom:none;
  border-top-left-radius:10px; border-top-right-radius:10px;
  position:relative; margin:0; margin-bottom:-1px;
  transition:background .18s ease, color .18s ease, box-shadow .18s ease, transform .12s ease;
}
.qmm-compact .qmm-tab{ padding:6px 10px }
.qmm-tab:hover{ background:rgba(255,255,255,.06) }
.qmm-tab:active{ transform:translateY(1px) }
.qmm-tab:focus-visible{ outline:2px solid var(--qmm-accent); outline-offset:2px; border-radius:10px }

.qmm-tab .badge{
  font-size:11px; line-height:1; padding:2px 6px; border-radius:999px;
  background:#ffffff1a; border:1px solid #ffffff22;
}

.qmm-tab.active{
  background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
  color:#fff; box-shadow:inset 0 -1px 0 #0007;
}
.qmm-tab.active::after{
  content:""; position:absolute; left:10%; right:10%; bottom:-1px; height:2px;
  background:linear-gradient(90deg, transparent, var(--qmm-accent), transparent);
  border-radius:2px; box-shadow:0 0 12px var(--qmm-accent-2);
}

/* ---------- Views panel ---------- */
.qmm-views{
  border:1px solid var(--qmm-border); border-radius:12px; padding:12px;
  background:var(--qmm-panel); backdrop-filter:blur(var(--qmm-blur));
  display:flex; flex-direction:column;
  min-width:0; min-height:0; overflow:auto; box-shadow:var(--qmm-shadow);
}
.qmm-compact .qmm-views{ padding:8px }
.qmm-tabs + .qmm-views{ margin-top:-1px }

.qmm-view{ display:none; min-width:0; min-height:0; }
.qmm-view.active{ display:block; }

/* ---------- Basic controls ---------- */
.qmm-row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:6px 0 }
.qmm-section{ margin-top:8px }
.qmm-section-title{ font-weight:650; margin:2px 0 8px 0; color:var(--qmm-text) }

.qmm-label{ opacity:.9 }
.qmm-val{ min-width:24px; text-align:center }

/* Buttons */
.qmm-btn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  padding:8px 14px;
  border-radius:10px;
  border:1px solid var(--qmm-border);
  background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
  color:var(--qmm-text);
  font-weight:600;
  font-size:13px;
  line-height:1.2;
  cursor:pointer;
  user-select:none;
  transition:background .18s ease, border-color .18s ease, transform .1s ease, box-shadow .18s ease, color .18s ease;
}
.qmm-compact .qmm-btn{ padding:6px 10px }
.qmm-btn:hover{ background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.04)); border-color:#ffffff3d }
.qmm-btn:active{ transform:translateY(1px) }
.qmm-btn:focus-visible{ outline:2px solid var(--qmm-accent); outline-offset:2px; }
.qmm-btn:disabled,
.qmm-btn.is-disabled{
  opacity:.55;
  cursor:not-allowed;
  filter:saturate(.6);
  box-shadow:none;
}
.qmm-btn--full{ width:100%; justify-content:center; }
.qmm-btn--sm{ padding:6px 10px; font-size:12px; border-radius:8px; }
.qmm-btn--icon{ padding:6px; width:34px; height:34px; border-radius:50%; gap:0; }
.qmm-btn__icon{ display:inline-flex; align-items:center; justify-content:center; font-size:1.1em; }
.qmm-btn__icon.is-right{ order:2; }
.qmm-btn__icon.is-left{ order:0; }

/* Button variants */
.qmm-btn--primary,
.qmm-btn.qmm-primary{
  background:linear-gradient(180deg, rgba(122,162,255,.38), rgba(122,162,255,.16));
  border-color:#9db7ff55;
  box-shadow:0 4px 14px rgba(122,162,255,.26);
}
.qmm-btn--primary:hover,
.qmm-btn.qmm-primary:hover{ border-color:#afc5ff77; }
.qmm-btn--secondary{
  background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.01));
}
.qmm-btn--danger,
.qmm-btn.qmm-danger{
  background:linear-gradient(180deg, rgba(255,86,86,.32), rgba(255,86,86,.14));
  border-color:#ff6a6a55;
  box-shadow:0 4px 14px rgba(255,86,86,.25);
}
.qmm-btn--ghost{ background:transparent; border-color:transparent; }
.qmm-btn--ghost:hover{ background:rgba(255,255,255,.06); border-color:#ffffff2a; }
.qmm-btn.active{
  background:#79a6ff22;
  border-color:#79a6ff66;
  box-shadow: inset 0 0 0 1px #79a6ff33;
}

.qmm-flex{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }

.qmm-form-grid{ width:100%; }

.qmm-form-row{ width:100%; }
.qmm-form-row.is-wrap{ grid-template-columns:1fr; }
.qmm-form-row__label{ font-weight:600; opacity:.9; }

.qmm-card{
  display:grid;
  gap:12px;
  border:1px solid var(--qmm-border);
  border-radius:12px;
  padding:14px;
  background:var(--qmm-panel);
  backdrop-filter:blur(var(--qmm-blur));
  box-shadow:var(--qmm-shadow);
  width:100%;
}
.qmm-card.is-center{ text-align:center; align-items:center; }
.qmm-card.is-stretch{ align-items:stretch; }
.qmm-card__header{
  display:flex;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
  justify-content:space-between;
}
.qmm-card__header.is-compact{ gap:6px; }
.qmm-card__icon{ font-size:18px; }
.qmm-card__title{ font-weight:700; font-size:14px; letter-spacing:.01em; }
.qmm-card__subtitle{ font-size:12px; opacity:.75; flex-basis:100%; }
.qmm-card__actions{ display:flex; gap:6px; margin-left:auto; }
.qmm-card__body{ display:grid; gap:10px; }
.qmm-card[data-tone="muted"]{
  background:rgba(15,17,22,.88);
  border-color:#ffffff1a;
  box-shadow:none;
}
.qmm-card[data-tone="accent"]{
  border-color:#7aa2ff99;
  box-shadow:0 10px 26px rgba(122,162,255,.25);
}

.qmm .stats-collapse-toggle{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  padding:6px 12px;
  min-height:32px;
  border-radius:999px;
  border:1px solid rgba(122,162,255,.45);
  background:linear-gradient(135deg, rgba(122,162,255,.18), rgba(33,59,121,.18));
  color:rgba(220,230,255,.92);
  font-size:12px;
  font-weight:600;
  letter-spacing:.01em;
  text-transform:uppercase;
  box-shadow:inset 0 1px 0 rgba(255,255,255,.12), 0 10px 24px rgba(9,13,27,.28);
  transition:background .26s ease, border-color .26s ease, box-shadow .26s ease, color .26s ease, transform .16s ease;
}
.qmm .stats-collapse-toggle:hover{
  background:linear-gradient(135deg, rgba(122,162,255,.28), rgba(53,94,182,.24));
  border-color:rgba(122,162,255,.62);
  color:#fff;
  box-shadow:0 14px 30px rgba(66,106,201,.32), inset 0 1px 0 rgba(255,255,255,.18);
}
.qmm .stats-collapse-toggle:active{
  transform:translateY(1px) scale(.99);
}
.qmm-card--collapsible[data-collapsed="true"] .stats-collapse-toggle{
  background:linear-gradient(135deg, rgba(122,162,255,.12), rgba(23,36,78,.12));
  border-color:rgba(122,162,255,.32);
  color:rgba(208,219,255,.82);
  box-shadow:inset 0 1px 0 rgba(255,255,255,.1), 0 6px 18px rgba(9,13,27,.22);
}
.qmm-card--collapsible[data-collapsed="false"] .stats-collapse-toggle{
  background:linear-gradient(135deg, rgba(122,162,255,.36), rgba(83,124,255,.28));
  border-color:rgba(122,162,255,.78);
  color:#fff;
  box-shadow:0 16px 32px rgba(72,112,214,.35), inset 0 1px 0 rgba(255,255,255,.22);
}
.qmm .stats-collapse-toggle__icon{
  width:16px;
  height:16px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  position:relative;
  color:inherit;
  transition:transform .24s ease;
}
.qmm .stats-collapse-toggle__icon::before{
  content:"";
  position:absolute;
  width:8px;
  height:8px;
  border-right:2px solid currentColor;
  border-bottom:2px solid currentColor;
  transform:rotate(45deg);
  transition:transform .24s ease;
}
.qmm .stats-collapse-toggle__label{
  color:inherit;
  font-size:11px;
  letter-spacing:.08em;
  font-weight:700;
}
.qmm-card--collapsible[data-collapsed="false"] .stats-collapse-toggle__icon::before{
  transform:rotate(-135deg);
}
.qmm-card--collapsible[data-collapsed="true"] .stats-collapse-toggle__icon::before{
  transform:rotate(45deg);
}

.qmm-chip-toggle{
  display:inline-flex;
  align-items:stretch;
  border-radius:999px;
  border:1px solid #ffffff1f;
  background:rgba(255,255,255,.05);
  cursor:pointer;
  transition:border-color .18s ease, background .18s ease, box-shadow .18s ease, transform .1s ease;
}
.qmm-chip-toggle input{ display:none; }
.qmm-chip-toggle__face{
  display:flex;
  align-items:center;
  gap:8px;
  padding:6px 12px;
  border-radius:999px;
}
.qmm-chip-toggle__icon{ font-size:14px; }
.qmm-chip-toggle__label{ font-weight:600; }
.qmm-chip-toggle__desc{ font-size:12px; opacity:.75; }
.qmm-chip-toggle__badge{ font-size:11px; padding:2px 6px; border-radius:999px; background:#ffffff1a; border:1px solid #ffffff22; }
.qmm-chip-toggle:hover{ border-color:#7aa2ff55; background:rgba(122,162,255,.12); }
.qmm-chip-toggle input:checked + .qmm-chip-toggle__face{
  background:linear-gradient(180deg, rgba(122,162,255,.25), rgba(122,162,255,.10));
  box-shadow:0 0 0 1px #7aa2ff55 inset, 0 6px 18px rgba(122,162,255,.22);
}

.qmm .stats-metric-grid{
  display:grid;
  gap:10px;
  grid-template-columns:repeat(auto-fit, minmax(160px, 1fr));
}
.qmm .stats-metric{
  border-radius:12px;
  padding:12px 14px;
  background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
  border:1px solid rgba(255,255,255,.08);
  box-shadow:inset 0 1px 0 rgba(255,255,255,.08);
  display:flex;
  flex-direction:column;
  gap:6px;
  transition:border-color .18s ease, background .18s ease, transform .14s ease;
}
.qmm .stats-metric:hover{
  border-color:#7aa2ff55;
  background:linear-gradient(180deg, rgba(122,162,255,.22), rgba(122,162,255,.10));
  transform:translateY(-1px);
}
.qmm .stats-metric__label{
  font-size:12px;
  letter-spacing:.02em;
  text-transform:uppercase;
  color:var(--qmm-text-dim);
}
.qmm .stats-metric__value{
  font-size:20px;
  font-weight:700;
  color:#fff;
}

.qmm .stats-list{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.qmm .stats-list__row{
  display:grid;
  align-items:center;
  gap:10px;
  padding:10px 12px;
  border-radius:10px;
  background:rgba(255,255,255,.035);
  border:1px solid rgba(255,255,255,.08);
  transition:border-color .18s ease, background .18s ease;
}
.qmm .stats-list__row:not(.stats-list__row--header):hover{
  background:rgba(122,162,255,.12);
  border-color:#7aa2ff55;
}
.qmm .stats-list__row--header{
  background:transparent;
  border:none;
  padding:0 6px 2px 6px;
  font-size:11px;
  letter-spacing:.05em;
  text-transform:uppercase;
  color:var(--qmm-text-dim);
}
.qmm .stats-list__row--header .stats-list__cell{
  font-weight:600;
}
.qmm .stats-list__header-label--gold,
.qmm .stats-list__header-label--rainbow{
  display:inline-block;
}
.qmm .stats-list__header-label--gold{
  color:#f7d774;
  background:linear-gradient(135deg,#fff5c0 0%,#f3c76a 55%,#f5b84f 100%);
  background-clip:text;
  -webkit-background-clip:text;
  -webkit-text-fill-color:transparent;
  text-shadow:0 1px 4px rgba(0,0,0,.35);
}
.qmm .stats-list__header-label--rainbow{
  color:#ffd6ff;
  background:linear-gradient(90deg,#ff6b6b 0%,#ffd86f 25%,#6bff8f 50%,#6bc7ff 75%,#b86bff 100%);
  background-clip:text;
  -webkit-background-clip:text;
  -webkit-text-fill-color:transparent;
  text-shadow:0 1px 4px rgba(0,0,0,.35);
}
.qmm .stats-list__cell{
  min-width:0;
  font-size:13px;
}
.qmm .stats-pet__species{
  display:inline-flex;
  align-items:center;
  gap:8px;
  min-width:0;
}
.qmm .stats-pet__label{
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.qmm .stats-pet__total-value{
  font-weight:700;
}
.qmm .stats-pet__sprite-icon{
  --stats-pet-sprite-size:28px;
  width:var(--stats-pet-sprite-size);
  height:var(--stats-pet-sprite-size);
  display:inline-flex;
  align-items:center;
  justify-content:center;
  border-radius:6px;
  background:rgba(255,255,255,.08);
  padding:2px;
  flex-shrink:0;
}
.qmm .stats-pet__sprite-icon img{
  width:100%;
  height:100%;
  object-fit:contain;
  image-rendering:pixelated;
}
.qmm .stats-weather__name{
  display:inline-flex;
  align-items:center;
  gap:8px;
  min-width:0;
}
.qmm .stats-weather__icon{
  width:32px;
  height:32px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  border-radius:6px;
  background:rgba(255,255,255,.08);
  overflow:hidden;
  flex-shrink:0;
}
.qmm .stats-weather__icon img{
  width:100%;
  height:100%;
  object-fit:contain;
  image-rendering:pixelated;
}
.qmm .stats-weather__label{
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.qmm .stats-list__cell--align-right{ text-align:right; }
.qmm .stats-list__cell--align-center{ text-align:center; }

.qmm .stats-pet-group{
  border:1px solid var(--stats-pet-group-border-color, rgba(255,255,255,.09));
  border-radius:12px;
  padding:10px 12px;
  background:rgba(255,255,255,.05);
  transition:border-color .18s ease, background .18s ease;
  display:flex;
  flex-direction:column;
  align-items:stretch;
  width:100%;
}
.qmm .stats-pet-group + .stats-pet-group{
  margin-top:8px;
}
.qmm .stats-pet-group__summary{
  display:flex;
  align-items:center;
  gap:6px;
  font-weight:650;
  font-size:13px;
  color:var(--qmm-text);
  margin:0;
  user-select:none;
  justify-content:center;
  text-align:center;
}
.qmm .stats-pet-group__content{
  margin-top:8px;
  display:flex;
  flex-direction:column;
  align-items:stretch;
  gap:8px;
}

.qmm-error{
  border:1px solid #ff6a6a55;
  background:rgba(120,20,20,.35);
  border-radius:10px;
  color:#ffdada;
  padding:10px;
  font-size:13px;
  line-height:1.4;
}

.qmm-select{
  background-image:linear-gradient(45deg, transparent 50%, #ffffff80 50%), linear-gradient(135deg, #ffffff80 50%, transparent 50%), linear-gradient(90deg, transparent 50%, rgba(255,255,255,.1) 50%);
  background-position:calc(100% - 18px) 50%, calc(100% - 13px) 50%, 100% 0;
  background-size:5px 5px, 5px 5px, 2.5rem 2.5rem;
  background-repeat:no-repeat;
  padding-right:34px;
}

.qmm-vlist-wrap{ display:flex; flex-direction:column; width:100%; }

/* Inputs */
.qmm-input{
  min-width:90px; background:rgba(0,0,0,.42); color:#fff;
  border:1px solid var(--qmm-border); border-radius:10px;
  padding:8px 10px; box-shadow:inset 0 1px 0 rgba(255,255,255,.06);
  transition:border-color .18s ease, background .18s ease, box-shadow .18s ease;
}
.qmm-input::placeholder{ color:#cbd6e780 }
.qmm-input:focus{ outline:none; border-color:var(--qmm-accent); background:#0f1521; box-shadow:0 0 0 2px #7aa2ff33 }

/* Number input + spinner (unchanged API) */
.qmm-input-number{ display:inline-flex; align-items:center; gap:6px }
.qmm-input-number-input{ width:70px; text-align:center; padding-right:8px }
.qmm-spin{ display:inline-flex; flex-direction:column; gap:2px }
.qmm-step{
  width:22px; height:16px; font-size:11px; line-height:1;
  display:inline-flex; align-items:center; justify-content:center;
  border-radius:6px; border:1px solid var(--qmm-border);
  background:rgba(255,255,255,.08); color:#fff; cursor:pointer; user-select:none;
  transition:background .18s ease, border-color .18s ease, transform .08s ease;
}
.qmm-step:hover{ background:#ffffff18; border-color:#ffffff40 }
.qmm-step:active{ transform:translateY(1px) }

/* Switch (checkbox) */
.qmm-switch{
  appearance:none; width:42px; height:24px; background:#6c7488aa; border-radius:999px;
  position:relative; outline:none; cursor:pointer; transition:background .18s ease, box-shadow .18s ease;
  box-shadow:inset 0 1px 0 rgba(255,255,255,.12);
}
.qmm-switch::before{
  content:""; position:absolute; top:2px; left:2px; width:20px; height:20px;
  background:#fff; border-radius:50%; transition:transform .2s ease;
  box-shadow:0 2px 8px rgba(0,0,0,.35);
}
.qmm-switch:checked{ background:linear-gradient(180deg, rgba(122,162,255,.9), rgba(122,162,255,.6)) }
.qmm-switch:checked::before{ transform:translateX(18px) }
.qmm-switch:focus-visible{ outline:2px solid var(--qmm-accent); outline-offset:2px }

/* Checkbox & radio (native inputs skinned lightly) */
.qmm-check, .qmm-radio{ transform:scale(1.1); accent-color: var(--qmm-accent) }

/* Slider */
.qmm-range{
  width:180px; appearance:none; background:transparent; height:22px;
}
.qmm-range:focus{ outline:none }
.qmm-range::-webkit-slider-runnable-track{
  height:6px; background:linear-gradient(90deg, var(--qmm-accent), #7aa2ff44);
  border-radius:999px; box-shadow:inset 0 1px 0 rgba(255,255,255,.14);
}
.qmm-range::-moz-range-track{
  height:6px; background:linear-gradient(90deg, var(--qmm-accent), #7aa2ff44);
  border-radius:999px; box-shadow:inset 0 1px 0 rgba(255,255,255,.14);
}
.qmm-range::-webkit-slider-thumb{
  appearance:none; width:16px; height:16px; border-radius:50%; margin-top:-5px;
  background:#fff; box-shadow:0 2px 10px rgba(0,0,0,.35), 0 0 0 2px #ffffff66 inset;
  transition:transform .1s ease;
}
.qmm-range:active::-webkit-slider-thumb{ transform:scale(1.04) }
.qmm-range::-moz-range-thumb{
  width:16px; height:16px; border-radius:50%; background:#fff; border:none;
  box-shadow:0 2px 10px rgba(0,0,0,.35), 0 0 0 2px #ffffff66 inset;
}

.qmm-range-dual{
  position:relative;
  width:100%;
  padding:18px 0 10px;
}
.qmm-range-dual-track{
  position:absolute;
  left:0;
  right:0;
  top:50%;
  transform:translateY(-50%);
  height:8px;
  border-radius:999px;
  background:linear-gradient(90deg, rgba(8,19,33,.8), rgba(27,43,68,.9));
  box-shadow:inset 0 1px 0 rgba(255,255,255,.08), inset 0 0 0 1px rgba(118,156,255,.08);
}
.qmm-range-dual-fill{
  position:absolute;
  top:50%;
  transform:translateY(-50%);
  height:8px;
  border-radius:999px;
  background:linear-gradient(90deg, var(--qmm-accent), #7aa2ff99);
  box-shadow:0 4px 14px rgba(37,92,255,.3);
  transition:left .12s ease, right .12s ease;
}
.qmm-range-dual-input{
  position:absolute;
  left:0;
  right:0;
  top:50%;
  transform:translateY(-50%);
  width:100%;
  height:28px;
  margin:0;
  background:transparent;
  pointer-events:none;
}
.qmm-range-dual-input::-webkit-slider-runnable-track{ background:none; }
.qmm-range-dual-input::-moz-range-track{ background:none; }
.qmm-range-dual-input::-webkit-slider-thumb{
  pointer-events:auto;
  width:18px;
  height:18px;
  border-radius:50%;
  background:linear-gradient(145deg, #fff, #dce6ff);
  border:2px solid rgba(122,162,255,.8);
  box-shadow:0 4px 12px rgba(0,0,0,.35);
  transition:transform .12s ease, box-shadow .12s ease;
}
.qmm-range-dual-input:active::-webkit-slider-thumb,
.qmm-range-dual-input:focus-visible::-webkit-slider-thumb{
  transform:scale(1.05);
  box-shadow:0 6px 16px rgba(0,0,0,.4);
}
.qmm-range-dual-input::-moz-range-thumb{
  pointer-events:auto;
  width:18px;
  height:18px;
  border-radius:50%;
  background:linear-gradient(145deg, #fff, #dce6ff);
  border:2px solid rgba(122,162,255,.8);
  box-shadow:0 4px 12px rgba(0,0,0,.35);
  transition:transform .12s ease, box-shadow .12s ease;
}
.qmm-range-dual-input:active::-moz-range-thumb,
.qmm-range-dual-input:focus-visible::-moz-range-thumb{
  transform:scale(1.05);
  box-shadow:0 6px 16px rgba(0,0,0,.4);
}
.qmm-range-dual-input--min{ z-index:2; }
.qmm-range-dual-input--max{ z-index:3; }
.qmm-range-dual-bubble{
  position:absolute;
  top:14px;
  transform:translate(-50%, -100%);
  padding:4px 8px;
  border-radius:6px;
  font-size:11px;
  line-height:1;
  font-weight:600;
  color:#dbe6ff;
  background:rgba(17,28,46,.9);
  box-shadow:0 4px 14px rgba(0,0,0,.35);
  pointer-events:none;
  transition:opacity .12s ease, transform .12s ease;
  opacity:.85;
}
.qmm-range-dual-bubble::after{
  content:"";
  position:absolute;
  left:50%;
  bottom:-4px;
  width:8px;
  height:8px;
  background:inherit;
  transform:translateX(-50%) rotate(45deg);
  border-radius:2px;
  box-shadow:0 4px 14px rgba(0,0,0,.35);
}
.qmm-range-dual-input--min:focus-visible + .qmm-range-dual-bubble--min,
.qmm-range-dual-input--max:focus-visible + .qmm-range-dual-bubble--max,
.qmm-range-dual-input--min:active + .qmm-range-dual-bubble--min,
.qmm-range-dual-input--max:active + .qmm-range-dual-bubble--max{
  opacity:1;
  transform:translate(-50%, -110%) scale(1.02);
}

/* ---------- Minimal table ---------- */
/* container */
.qmm-table-wrap--minimal{
  border:1px solid #263040; border-radius:8px; background:#0b0f14; box-shadow:none;
}
/* scroller (height cap) */
.qmm-table-scroll{
  overflow:auto; max-height:44vh; /* override via opts.maxHeight */
}

/* base */
.qmm-table--minimal{
  width:100%;
  border-collapse:collapse;
  background:transparent;
  font-size:13px; line-height:1.35; color:var(--qmm-text, #cdd6e3);
}

/* header */
.qmm-table--minimal thead th{
  position:sticky; top:0; z-index:1;
  text-align:left; font-weight:600;
  padding:8px 10px;
  color:#cbd5e1; background:#0f1318;
  border-bottom:1px solid #263040;
  text-transform:none; letter-spacing:0;
}
.qmm-table--minimal thead th.is-center { text-align: center; }
.qmm-table--minimal thead th.is-left   { text-align: left; }   /* d\xE9j\xE0 pr\xE9sent, ok */
.qmm-table--minimal thead th.is-right  { text-align: right; }
.qmm-table--minimal thead th,
.qmm-table--minimal td { vertical-align: middle; }

/* cells */
.qmm-table--minimal td{
  padding:8px 10px; border-bottom:1px solid #1f2937; vertical-align:middle;
}
.qmm-table--minimal tbody tr:hover{ background:#0f1824; }

/* compact variant */
.qmm-table--compact thead th,
.qmm-table--compact td{ padding:6px 8px; font-size:12px }

/* utils */
.qmm-table--minimal td.is-num{ text-align:right; font-variant-numeric:tabular-nums }
.qmm-table--minimal td.is-center{ text-align:center }
.qmm-ellipsis{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap }
.qmm-prewrap{ white-space:pre-wrap; word-break:break-word }


/* ---------- Split panels ---------- */
.qmm-split{
  display:grid; gap:12px;
  grid-template-columns:minmax(180px,260px) minmax(0,1fr);
  align-items:start;
}
.qmm-split-left{ display:flex; flex-direction:column; gap:10px }
.qmm-split-right{
  border:1px solid var(--qmm-border); border-radius:12px; padding:12px;
  display:flex; flex-direction:column; gap:12px;
  background:var(--qmm-panel); backdrop-filter:blur(var(--qmm-blur));
  box-shadow:var(--qmm-shadow);
}

/* ---------- VTabs (vertical list + filter) ---------- */
.qmm-vtabs{ display:flex; flex-direction:column; gap:8px; min-width:0 }
.qmm-vtabs .filter{ display:block }
.qmm-vtabs .filter input{ width:100% }

.qmm-vlist{
  flex:0 0 auto; overflow:visible;
  border:1px solid var(--qmm-border); border-radius:12px; padding:6px;
  background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
  box-shadow:inset 0 1px 0 rgba(255,255,255,.04);
}

.qmm-vtab{
  width:100%; text-align:left; cursor:pointer;
  display:grid; grid-template-columns:28px 1fr auto; align-items:center; gap:10px;
  padding:8px 10px; border-radius:10px; border:1px solid #ffffff18;
  background:rgba(255,255,255,.03); color:inherit;
  transition:background .18s ease, border-color .18s ease, transform .08s ease;
}
.qmm-vtab:hover{ background:rgba(255,255,255,.07); border-color:#ffffff34 }
.qmm-vtab:active{ transform:translateY(1px) }
.qmm-vtab.active{
  background:linear-gradient(180deg, rgba(122,162,255,.18), rgba(122,162,255,.08));
  border-color:#9db7ff55;
  box-shadow:0 1px 14px rgba(122,162,255,.18) inset;
}

.qmm-dot{ width:10px; height:10px; border-radius:50%; justify-self:center; box-shadow:0 0 0 1px #0006 inset }
.qmm-chip{ display:flex; align-items:center; gap:8px; min-width:0 }
.qmm-chip img{
  width:20px; height:20px; border-radius:50%; object-fit:cover; border:1px solid #4446;
  box-shadow:0 1px 0 rgba(255,255,255,.08) inset;
}
.qmm-chip .t{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
.qmm-tag{
  font-size:11px; line-height:1; padding:3px 7px; border-radius:999px;
  background:#ffffff14; border:1px solid #ffffff26;
}

/* ---------- Small helpers (optional) ---------- */
.qmm .qmm-card{
  border:1px solid var(--qmm-border); border-radius:12px; padding:12px;
  background:var(--qmm-panel); backdrop-filter:blur(var(--qmm-blur)); box-shadow:var(--qmm-shadow);
}
  .qmm .qmm-help{ font-size:12px; color:var(--qmm-text-dim) }
  .qmm .qmm-sep{ height:1px; background:var(--qmm-border); width:100%; opacity:.6; }

/* ta poign\xE9e, inchang\xE9 */
.qmm-grab { margin-left:auto; opacity:.8; cursor:grab; user-select:none; }
.qmm-grab:active { cursor:grabbing; }
.qmm-dragging { opacity:.6; }

/* items animables */
.qmm-team-item {
  will-change: transform;
  transition: transform 160ms ease;
}
.qmm-team-item.drag-ghost {
  opacity: .4;
}

.qmm.qmm-alt-drag { cursor: grab; }
.qmm.qmm-alt-drag:active { cursor: grabbing; }

.qws-win.is-hidden { display: none !important; }

.qmm-hotkey{
  cursor:pointer; user-select:none;
  border:1px solid var(--qmm-border); border-radius:10px;
  padding:8px 12px;
  background:linear-gradient(180deg, #ffffff10, #ffffff06);
  color:var(--qmm-text);
  box-shadow:0 1px 0 #000 inset, 0 1px 16px rgba(0,0,0,.18);
  transition:
    background .18s ease,
    border-color .18s ease,
    box-shadow .18s ease,
    transform .08s ease,
    color .18s ease;
}
.qmm-hotkey{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  white-space:nowrap;
  width: var(--qmm-hotkey-w, 180px); 
}
.qmm-hotkey:hover{ background:linear-gradient(180deg, #ffffff16, #ffffff08); border-color:#ffffff40 }
.qmm-hotkey:active{ transform:translateY(1px) }

.qmm-hotkey:focus-visible{ outline:none }

.qmm-hotkey.is-empty{
  color:var(--qmm-text-dim);
  font-style:italic;
}

.qmm-hotkey.is-assigned{
  border-color: rgba(122,162,255,.45);
  box-shadow:0 1px 0 #000 inset, 0 1px 16px rgba(0,0,0,.18), 0 0 0 2px rgba(122,162,255,.24);
}

.qmm-hotkey.is-recording{
  outline:2px solid var(--qmm-accent);
  outline-offset:2px;
  border-color: var(--qmm-accent);
  background:linear-gradient(180deg, rgba(122,162,255,.25), rgba(122,162,255,.10));
  animation: qmm-hotkey-breathe 1.2s ease-in-out infinite;
}
  
@keyframes qmm-hotkey-breathe{
  0%   { box-shadow: 0 0 0 0 rgba(122,162,255,.55), 0 1px 16px rgba(0,0,0,.25); }
  60%  { box-shadow: 0 0 0 12px rgba(122,162,255,0), 0 1px 16px rgba(0,0,0,.25); }
  100% { box-shadow: 0 0 0 0 rgba(122,162,255,0),  0 1px 16px rgba(0,0,0,.25); }
}

/* ---------- Segmented (minimal, modern) ---------- */
.qmm-seg{
  --seg-pad: 8px;
  --seg-radius: 999px;
  --seg-stroke: 1.2px;      /* \xE9paisseur du trait */
  --seg-nudge-x: 0px;       /* micro-ajustements optionnels */
  --seg-nudge-w: 0px;
  --seg-fill: rgba(122,162,255,.05);           
  --seg-stroke-color: rgba(122,162,255,.60);

  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: var(--seg-pad);
  border-radius: var(--seg-radius);
  background: var(--qmm-bg-soft);
  border: 1px solid var(--qmm-border-2);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
  overflow: hidden;
  background-clip: padding-box; /* important pour que le fond ne passe pas sous la bordure */
}

.qmm-seg--full{ display:flex; width:100% }

.qmm-seg__btn{
  position: relative;
  z-index: 1;
  appearance: none; background: transparent; border: 0; cursor: pointer;
  padding: 8px 14px;
  border-radius: 999px;
  color: var(--qmm-text-dim);
  font: inherit; line-height: 1; white-space: nowrap;
  transition: color .15s ease, transform .06s ease;
}
.qmm-seg__btn-label{
  display: inline-flex;
  align-items: center;
  justify-content: center;
  white-space: inherit;
}
.qmm-compact .qmm-seg__btn{ padding: 6px 10px }
.qmm-seg__btn:hover{ color: var(--qmm-text); }
.qmm-seg__btn.active{ color:#fff; font-weight:600; }
.qmm-seg__btn:active{ transform: translateY(1px); }
.qmm-seg__btn[disabled]{ opacity:.5; cursor:not-allowed; }

.qmm-seg__indicator{
  position: absolute;
  top: 0; left: 0;
  height: 100%;
  width: 40px;                      /* maj en JS */
  border-radius: inherit;
  background: var(--seg-fill);              /* \u2B05\uFE0F applique la couleur */
  outline: var(--seg-stroke,1.2px) solid var(--seg-stroke-color);
  outline-offset: calc(-1 * var(--seg-stroke));

  box-shadow: 0 1px 4px rgba(122,162,255,.10);
  transform-origin: left center;
  will-change: transform, width, opacity;
  transition: transform .18s cubic-bezier(.2,.8,.2,1),
              width .18s cubic-bezier(.2,.8,.2,1),
              opacity .18s ease-out;
  pointer-events: none;
}

/* Accessibilit\xE9 */
@media (prefers-reduced-motion: reduce){
  .qmm-seg__indicator, .qmm-seg__btn { transition: none; }
}  /* \u2190 manquait cette accolade */

    `;
      const st = document.createElement("style");
      st.id = "__qmm_css__";
      st.textContent = css;
      (document.documentElement || document.body).appendChild(st);
    }
  };
  var VTabs = class {
    constructor(api, opts = {}) {
      this.api = api;
      this.opts = opts;
      __publicField(this, "root");
      __publicField(this, "filterWrap", null);
      __publicField(this, "filterInput", null);
      __publicField(this, "list");
      __publicField(this, "listWrap", null);
      __publicField(this, "items", []);
      __publicField(this, "selectedId", null);
      __publicField(this, "onSelectCb");
      __publicField(this, "renderItemCustom");
      __publicField(this, "emptyText");
      this.root = el("div", "qmm-vtabs");
      this.root.style.minWidth = "0";
      this.emptyText = opts.emptyText || "Aucun \xE9l\xE9ment.";
      this.renderItemCustom = opts.renderItem;
      if (opts.filterPlaceholder) {
        this.filterWrap = el("div", "filter");
        this.filterInput = document.createElement("input");
        this.filterInput.type = "search";
        this.filterInput.placeholder = opts.filterPlaceholder;
        this.filterInput.className = "qmm-input";
        this.filterInput.oninput = () => this.renderList();
        this.filterWrap.appendChild(this.filterInput);
        this.root.appendChild(this.filterWrap);
      }
      this.list = el("div", "qmm-vlist");
      this.list.style.minWidth = "0";
      if (opts.maxHeightPx) {
        this.list.style.maxHeight = `${opts.maxHeightPx}px`;
        this.list.style.overflow = "auto";
        this.list.style.flex = "1 1 auto";
      }
      if (opts.fillAvailableHeight) {
        this.listWrap = document.createElement("div");
        this.listWrap.className = "qmm-vlist-wrap";
        Object.assign(this.listWrap.style, {
          flex: "1 1 auto",
          minHeight: "0",
          display: "flex",
          flexDirection: "column"
        });
        this.list.style.flex = "1 1 auto";
        if (!opts.maxHeightPx) this.list.style.overflow = "auto";
        this.listWrap.appendChild(this.list);
        this.root.appendChild(this.listWrap);
      } else {
        this.root.appendChild(this.list);
      }
      this.selectedId = opts.initialId ?? null;
      this.onSelectCb = opts.onSelect;
    }
    setItems(items) {
      this.items = Array.isArray(items) ? items.slice() : [];
      if (this.selectedId && !this.items.some((i) => i.id === this.selectedId)) {
        this.selectedId = this.items[0]?.id ?? null;
      }
      this.renderList();
    }
    getSelected() {
      return this.items.find((i) => i.id === this.selectedId) ?? null;
    }
    select(id) {
      this.selectedId = id;
      this.renderList();
      this.onSelectCb?.(this.selectedId, this.getSelected());
    }
    onSelect(cb) {
      this.onSelectCb = cb;
    }
    setBadge(id, text) {
      const btn = this.list.querySelector(`button[data-id="${cssq(id)}"]`);
      if (!btn) return;
      let tag = btn.querySelector(".qmm-tag");
      if (!tag && text != null) {
        tag = el("span", "qmm-tag");
        btn.appendChild(tag);
      }
      if (!tag) return;
      if (text == null || text === "") tag.style.display = "none";
      else {
        tag.textContent = text;
        tag.style.display = "";
      }
    }
    getFilter() {
      return (this.filterInput?.value || "").trim().toLowerCase();
    }
    renderList() {
      const keepScroll = this.list.scrollTop;
      this.list.innerHTML = "";
      const q = this.getFilter();
      const filtered = q ? this.items.filter((it) => (it.title || "").toLowerCase().includes(q) || (it.subtitle || "").toLowerCase().includes(q)) : this.items;
      if (!filtered.length) {
        const empty = document.createElement("div");
        empty.style.opacity = "0.75";
        empty.textContent = this.emptyText;
        this.list.appendChild(empty);
        return;
      }
      const ul = document.createElement("ul");
      ul.style.listStyle = "none";
      ul.style.margin = "0";
      ul.style.padding = "0";
      ul.style.display = "flex";
      ul.style.flexDirection = "column";
      ul.style.gap = "4px";
      for (const it of filtered) {
        const li = document.createElement("li");
        const btn = document.createElement("button");
        btn.className = "qmm-vtab";
        btn.dataset.id = it.id;
        btn.disabled = !!it.disabled;
        if (this.renderItemCustom) {
          this.renderItemCustom(it, btn);
        } else {
          const dot = el("div", "qmm-dot");
          dot.style.background = it.statusColor || "#999a";
          const chip = el("div", "qmm-chip");
          const img = document.createElement("img");
          img.src = it.avatarUrl || "";
          img.alt = it.title;
          const wrap = document.createElement("div");
          wrap.style.display = "flex";
          wrap.style.flexDirection = "column";
          wrap.style.gap = "2px";
          const t = el("div", "t");
          t.textContent = it.title;
          const sub = document.createElement("div");
          sub.textContent = it.subtitle || "";
          sub.style.opacity = "0.7";
          sub.style.fontSize = "12px";
          if (!it.subtitle) sub.style.display = "none";
          wrap.appendChild(t);
          wrap.appendChild(sub);
          chip.appendChild(img);
          chip.appendChild(wrap);
          btn.appendChild(dot);
          btn.appendChild(chip);
          if (it.badge != null) {
            const tag = el("span", "qmm-tag", escapeHtml(String(it.badge)));
            btn.appendChild(tag);
          } else {
            const spacer = document.createElement("div");
            spacer.style.width = "0";
            btn.appendChild(spacer);
          }
        }
        btn.classList.toggle("active", it.id === this.selectedId);
        btn.onclick = () => this.select(it.id);
        li.appendChild(btn);
        ul.appendChild(li);
      }
      this.list.appendChild(ul);
      this.list.scrollTop = keepScroll;
    }
  };
  function el(tag, cls, html) {
    const e = document.createElement(tag);
    if (cls) e.className = cls;
    if (html != null) e.innerHTML = html;
    return e;
  }
  function cssq(s) {
    return s.replace(/"/g, '\\"');
  }
  function escapeHtml(s) {
    return s.replace(/[&<>"']/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[m]);
  }
  var _MOD_CODES = /* @__PURE__ */ new Set([
    "ShiftLeft",
    "ShiftRight",
    "ControlLeft",
    "ControlRight",
    "AltLeft",
    "AltRight",
    "MetaLeft",
    "MetaRight"
  ]);
  function codesMatch(expected, actual) {
    if (expected === actual) return true;
    const altCodes = expected === "AltLeft" || expected === "AltRight";
    const ctrlCodes = expected === "ControlLeft" || expected === "ControlRight";
    const shiftCodes = expected === "ShiftLeft" || expected === "ShiftRight";
    const metaCodes = expected === "MetaLeft" || expected === "MetaRight";
    if (altCodes && (actual === "AltLeft" || actual === "AltRight")) return true;
    if (ctrlCodes && (actual === "ControlLeft" || actual === "ControlRight")) return true;
    if (shiftCodes && (actual === "ShiftLeft" || actual === "ShiftRight")) return true;
    if (metaCodes && (actual === "MetaLeft" || actual === "MetaRight")) return true;
    return false;
  }
  function isMac() {
    return navigator.platform?.toLowerCase().includes("mac") || /mac|iphone|ipad|ipod/i.test(navigator.userAgent);
  }
  function eventToHotkey(e, allowModifierOnly = false) {
    const isModifier = _MOD_CODES.has(e.code) || e.key === "Shift" || e.key === "Control" || e.key === "Alt" || e.key === "Meta";
    if (isModifier && !allowModifierOnly) {
      return null;
    }
    return {
      code: e.code,
      ctrl: e.ctrlKey,
      alt: e.altKey,
      shift: e.shiftKey,
      meta: e.metaKey
    };
  }
  function matchHotkey(e, h) {
    if (!h) return false;
    if (!!h.ctrl !== e.ctrlKey) return false;
    if (!!h.shift !== e.shiftKey) return false;
    if (!!h.alt !== e.altKey) return false;
    if (!!h.meta !== e.metaKey) return false;
    return codesMatch(h.code, e.code);
  }
  function hotkeyToString(hk) {
    if (!hk) return "";
    const parts = [];
    if (hk.ctrl) parts.push("Ctrl");
    if (hk.shift) parts.push("Shift");
    if (hk.alt) parts.push("Alt");
    if (hk.meta) parts.push("Meta");
    if (hk.code) parts.push(hk.code);
    return parts.join("+");
  }
  function stringToHotkey(s) {
    if (!s) return null;
    const parts = s.split("+").map((p) => p.trim()).filter(Boolean);
    if (!parts.length) return null;
    const code = canonicalizeCode(parts.pop() || "");
    const hk = { code };
    for (const p of parts) {
      const P = p.toLowerCase();
      if (P === "ctrl" || P === "control") hk.ctrl = true;
      else if (P === "shift") hk.shift = true;
      else if (P === "alt") hk.alt = true;
      else if (P === "meta" || P === "cmd" || P === "command") hk.meta = true;
    }
    return hk.code ? hk : null;
  }
  var CANONICAL_CODES = {
    space: "Space",
    enter: "Enter",
    escape: "Escape",
    tab: "Tab",
    backspace: "Backspace",
    delete: "Delete",
    insert: "Insert",
    home: "Home",
    end: "End",
    pageup: "PageUp",
    pagedown: "PageDown",
    arrowup: "ArrowUp",
    arrowdown: "ArrowDown",
    arrowleft: "ArrowLeft",
    arrowright: "ArrowRight",
    bracketleft: "BracketLeft",
    bracketright: "BracketRight",
    backslash: "Backslash",
    slash: "Slash",
    minus: "Minus",
    equal: "Equal",
    semicolon: "Semicolon",
    quote: "Quote",
    backquote: "Backquote",
    comma: "Comma",
    period: "Period",
    dot: "Period",
    capslock: "CapsLock",
    numlock: "NumLock",
    scrolllock: "ScrollLock",
    pause: "Pause",
    contextmenu: "ContextMenu",
    printscreen: "PrintScreen",
    metaleft: "MetaLeft",
    metaright: "MetaRight",
    altleft: "AltLeft",
    altright: "AltRight",
    controlleft: "ControlLeft",
    controlright: "ControlRight",
    shiftleft: "ShiftLeft",
    shiftright: "ShiftRight"
  };
  function canonicalizeCode(rawCode) {
    const trimmed = rawCode.trim();
    if (!trimmed) return "";
    const lower = trimmed.toLowerCase();
    const keyMatch = lower.match(/^key([a-z])$/);
    if (keyMatch) return `Key${keyMatch[1].toUpperCase()}`;
    const digitMatch = lower.match(/^digit([0-9])$/);
    if (digitMatch) return `Digit${digitMatch[1]}`;
    const numpadDigitMatch = lower.match(/^numpad([0-9])$/);
    if (numpadDigitMatch) return `Numpad${numpadDigitMatch[1]}`;
    if (lower.startsWith("numpad")) {
      const suffix = lower.slice(6);
      if (!suffix) return "Numpad";
      const mappedSuffix = CANONICAL_CODES[suffix] ?? capitalizeWord(suffix);
      return `Numpad${mappedSuffix}`;
    }
    const fMatch = lower.match(/^f([0-9]{1,2})$/);
    if (fMatch) return `F${fMatch[1]}`;
    const arrowMatch = lower.match(/^arrow([a-z]+)$/);
    if (arrowMatch) {
      const suffix = arrowMatch[1];
      const mappedSuffix = CANONICAL_CODES[suffix] ?? capitalizeWord(suffix);
      return `Arrow${mappedSuffix}`;
    }
    if (CANONICAL_CODES[lower]) {
      return CANONICAL_CODES[lower];
    }
    return trimmed[0].toUpperCase() + trimmed.slice(1);
  }
  function capitalizeWord(word) {
    if (!word) return "";
    return word[0].toUpperCase() + word.slice(1);
  }
  function prettyCode(code) {
    if (code === "AltLeft" || code === "AltRight") return "Alt";
    if (code === "ControlLeft" || code === "ControlRight") return "Ctrl";
    if (code === "ShiftLeft" || code === "ShiftRight") return "Shift";
    if (code === "MetaLeft" || code === "MetaRight") return isMac() ? "\u2318" : "Meta";
    if (code.startsWith("Key")) return code.slice(3);
    if (code.startsWith("Digit")) return code.slice(5);
    if (code.startsWith("Numpad")) return "Numpad " + code.slice(6);
    const arrows = { ArrowUp: "\u2191", ArrowDown: "\u2193", ArrowLeft: "\u2190", ArrowRight: "\u2192" };
    if (arrows[code]) return arrows[code];
    return code;
  }
  function hotkeyToPretty(h) {
    if (!h) return "\u2014";
    const mac = isMac();
    const mods = [];
    if (mac) {
      if (h.ctrl) mods.push("\u2303");
      if (h.alt) mods.push("\u2325");
      if (h.shift) mods.push("\u21E7");
      if (h.meta) mods.push("\u2318");
    } else {
      if (h.ctrl) mods.push("Ctrl");
      if (h.alt) mods.push("Alt");
      if (h.shift) mods.push("Shift");
      if (h.meta) mods.push("Meta");
    }
    const modifierCode = h.alt && (h.code === "AltLeft" || h.code === "AltRight") || h.ctrl && (h.code === "ControlLeft" || h.code === "ControlRight") || h.shift && (h.code === "ShiftLeft" || h.code === "ShiftRight") || h.meta && (h.code === "MetaLeft" || h.code === "MetaRight");
    const parts = mods.slice();
    const codePretty = prettyCode(h.code);
    if (!modifierCode || parts.length === 0) {
      parts.push(codePretty);
    }
    if (!parts.length) return codePretty;
    return parts.join(mac ? "" : " + ");
  }

  // src/core/ingameHotkeys.ts
  var resolveContext = (context) => {
    if (context) return context;
    const win = pageWindow ?? window;
    const doc = win.document ?? document;
    return { window: win, document: doc };
  };
  var KEYCODE_TABLE = {
    KeyA: 65,
    KeyB: 66,
    KeyC: 67,
    KeyD: 68,
    KeyE: 69,
    KeyF: 70,
    KeyG: 71,
    KeyH: 72,
    KeyI: 73,
    KeyJ: 74,
    KeyK: 75,
    KeyL: 76,
    KeyM: 77,
    KeyN: 78,
    KeyO: 79,
    KeyP: 80,
    KeyQ: 81,
    KeyR: 82,
    KeyS: 83,
    KeyT: 84,
    KeyU: 85,
    KeyV: 86,
    KeyW: 87,
    KeyX: 88,
    KeyY: 89,
    KeyZ: 90,
    Digit0: 48,
    Digit1: 49,
    Digit2: 50,
    Digit3: 51,
    Digit4: 52,
    Digit5: 53,
    Digit6: 54,
    Digit7: 55,
    Digit8: 56,
    Digit9: 57,
    Space: 32,
    Enter: 13,
    Escape: 27,
    Tab: 9,
    Backspace: 8,
    Delete: 46,
    Insert: 45,
    ArrowLeft: 37,
    ArrowUp: 38,
    ArrowRight: 39,
    ArrowDown: 40
  };
  var codeToKey = (code, shift = false) => {
    if (!code) return "";
    if (/^Key[A-Z]$/.test(code)) return shift ? code.slice(3).toUpperCase() : code.slice(3).toLowerCase();
    if (/^Digit[0-9]$/.test(code)) return code.slice(5);
    if (code === "Space") return " ";
    return code;
  };
  var isEditableTarget = (t) => {
    const el2 = t;
    if (!el2 || !el2.tagName) return false;
    const tag = el2.tagName.toLowerCase();
    if (tag === "input" || tag === "textarea") return true;
    const ce = el2.getAttribute && el2.getAttribute("contenteditable");
    return !!(ce && ce !== "false");
  };
  var normalizeCombo = (c) => {
    const parts = String(c).split("+").map((s) => s.trim()).filter(Boolean);
    const mods = [];
    let code = "";
    for (const p of parts) {
      const P = p.toLowerCase();
      if (P === "ctrl" || P === "control") mods.push("ctrl");
      else if (P === "shift") mods.push("shift");
      else if (P === "alt") mods.push("alt");
      else if (P === "meta" || P === "cmd" || P === "command" || P === "win") mods.push("meta");
      else code = p;
    }
    mods.sort((a, b) => ["ctrl", "shift", "alt", "meta"].indexOf(a) - ["ctrl", "shift", "alt", "meta"].indexOf(b));
    return (mods.length ? mods.join("+") + "+" : "") + code;
  };
  var parseCombo = (c) => {
    const parts = String(c).split("+").map((s) => s.trim()).filter(Boolean);
    const spec = {};
    for (const p of parts) {
      const P = p.toLowerCase();
      if (P === "ctrl" || P === "control") spec.ctrl = true;
      else if (P === "shift") spec.shift = true;
      else if (P === "alt") spec.alt = true;
      else if (P === "meta" || P === "cmd" || P === "command" || P === "win") spec.meta = true;
      else spec.code = p;
    }
    if (spec.code && spec.key === void 0) spec.key = codeToKey(spec.code, !!spec.shift);
    return spec;
  };
  var evToCombo = (e) => {
    const mods = [];
    if (e.ctrlKey) mods.push("ctrl");
    if (e.shiftKey) mods.push("shift");
    if (e.altKey) mods.push("alt");
    if (e.metaKey) mods.push("meta");
    mods.sort((a, b) => ["ctrl", "shift", "alt", "meta"].indexOf(a) - ["ctrl", "shift", "alt", "meta"].indexOf(b));
    return (mods.length ? mods.join("+") + "+" : "") + (e.code || "");
  };
  var REMAP_FLAG = "__inGameHotkeysRemapped__";
  var RAPID_SYN_FLAG = "__inGameHotkeysRapidSynthetic__";
  var InGameHotkeys = class {
    constructor(autoAttach = true, context) {
      __publicField(this, "win");
      __publicField(this, "doc");
      // remapper
      __publicField(this, "enabled", true);
      __publicField(this, "map", /* @__PURE__ */ new Map());
      // combo normalis -> spec destination
      __publicField(this, "blockedSet", /* @__PURE__ */ new Set());
      // combos bloqus
      __publicField(this, "eventBlockers", /* @__PURE__ */ new Set());
      __publicField(this, "attachedDocs", /* @__PURE__ */ new WeakSet());
      // docs dj hooks
      __publicField(this, "observers", []);
      __publicField(this, "handlers", /* @__PURE__ */ new Map());
      __publicField(this, "passthrough", /* @__PURE__ */ new Set(["F5", "F12"]));
      // rapid-fire manager
      __publicField(this, "sessions", /* @__PURE__ */ new Map());
      const ctx = resolveContext(context);
      this.win = ctx.window;
      this.doc = ctx.document;
      if (autoAttach) {
        this.attachDoc(this.doc);
        this.attachAllFrames();
        if (this.win.MutationObserver) {
          const mo = new this.win.MutationObserver(() => this.attachAllFrames());
          mo.observe(this.doc.documentElement || this.doc, { childList: true, subtree: true });
          this.observers.push(mo);
        }
      }
    }
    /* --------- on/off remapper --------- */
    enable(flag = true) {
      this.enabled = !!flag;
    }
    disable() {
      this.enabled = false;
    }
    isEnabled() {
      return this.enabled;
    }
    /* --------- remaps --------- */
    setMap(m) {
      this.map.clear();
      for (const [from, to] of Object.entries(m || {})) this.map.set(normalizeCombo(from), parseCombo(to));
    }
    add(from, to) {
      this.map.set(normalizeCombo(from), parseCombo(to));
    }
    remove(from) {
      this.map.delete(normalizeCombo(from));
    }
    clear() {
      this.map.clear();
    }
    current() {
      const out = {};
      for (const [k, v] of this.map.entries()) {
        const mods = [];
        if (v.ctrl) mods.push("Ctrl");
        if (v.shift) mods.push("Shift");
        if (v.alt) mods.push("Alt");
        if (v.meta) mods.push("Meta");
        out[k] = (mods.length ? mods.join("+") + "+" : "") + (v.code || "");
      }
      return out;
    }
    /* --------- blocages --------- */
    block(combo) {
      this.blockedSet.add(normalizeCombo(combo));
    }
    unblock(combo) {
      this.blockedSet.delete(normalizeCombo(combo));
    }
    blocked() {
      return Array.from(this.blockedSet);
    }
    addEventBlocker(blocker) {
      if (typeof blocker !== "function") {
        return () => {
        };
      }
      this.eventBlockers.add(blocker);
      return () => {
        this.eventBlockers.delete(blocker);
      };
    }
    /* --------- helpers de binding --------- */
    /** Dplace laction binde sur oldBase vers newPhysical et dsactive oldBase. */
    replace(oldBase, newPhysical) {
      const oldN = normalizeCombo(oldBase);
      const newN = normalizeCombo(newPhysical);
      this.blockedSet.add(oldN);
      this.map.set(newN, parseCombo(oldN));
    }
    /** change rciproquement deux touches (ne bloque pas). */
    swap(a, b) {
      const an = normalizeCombo(a), bn = normalizeCombo(b);
      this.map.set(an, parseCombo(bn));
      this.map.set(bn, parseCombo(an));
    }
    /* --------- frames & cleanup --------- */
    attachAllFrames() {
      this.doc.querySelectorAll("iframe").forEach((f) => {
        try {
          const d = f.contentDocument;
          const origin = d?.location?.origin;
          if (d && origin && origin === this.win.location.origin) this.attachDoc(d);
        } catch {
        }
      });
    }
    destroy() {
      for (const [doc, handler] of this.handlers.entries()) {
        try {
          const win = doc.defaultView || this.win;
          win.removeEventListener("keydown", handler, true);
          win.removeEventListener("keypress", handler, true);
          win.removeEventListener("keyup", handler, true);
        } catch {
        }
      }
      this.handlers.clear();
      this.attachedDocs = /* @__PURE__ */ new WeakSet();
      for (const mo of this.observers) mo.disconnect();
      this.observers = [];
      this.stopAllRapidFires();
      this.eventBlockers.clear();
    }
    /* --------- rapid-fire (API) --------- */
    startRapidFire(opts) {
      const trigger = normalizeCombo(opts.trigger);
      const emit = normalizeCombo(opts.emit ?? opts.trigger);
      const rateMs = 1e3 / Math.max(1, opts.rateHz ?? 12);
      const mode = opts.mode ?? "tap";
      const keyupDelayMs = opts.keyupDelayMs ?? 20;
      this.sessions.set(trigger, {
        trigger: parseRapid(trigger),
        emit: parseRapid(emit),
        rateMs,
        mode,
        keyupDelayMs,
        pressed: false,
        lastTarget: null,
        tickTimer: null,
        upTimer: null
      });
    }
    stopRapidFire(trigger) {
      if (!trigger) {
        this.stopAllRapidFires();
        return;
      }
      const key2 = normalizeCombo(trigger);
      const s = this.sessions.get(key2);
      if (!s) return;
      this.endSession(s);
      this.sessions.delete(key2);
    }
    stopAllRapidFires() {
      for (const s of this.sessions.values()) this.endSession(s);
      this.sessions.clear();
    }
    isRapidFireActive(trigger) {
      const s = this.sessions.get(normalizeCombo(trigger));
      return !!(s && s.pressed);
    }
    setRapidFireRate(trigger, hz) {
      const s = this.sessions.get(normalizeCombo(trigger));
      if (!s) return;
      s.rateMs = 1e3 / Math.max(1, hz);
      if (s.pressed) this.restartLoop(s);
    }
    setRapidFireMode(trigger, mode) {
      const s = this.sessions.get(normalizeCombo(trigger));
      if (!s) return;
      s.mode = mode;
    }
    listRapidFires() {
      const out = [];
      for (const [key2, s] of this.sessions.entries()) {
        out.push({
          trigger: key2,
          emit: joinRapid(s.emit),
          rateHz: Math.round(1e3 / s.rateMs),
          mode: s.mode
        });
      }
      return out;
    }
    /* ================= internes ================= */
    attachDoc(doc) {
      if (!doc || this.attachedDocs.has(doc)) return;
      const handler = this.makeHandler(doc);
      const win = doc.defaultView || this.win;
      win.addEventListener("keydown", handler, true);
      win.addEventListener("keypress", handler, true);
      win.addEventListener("keyup", handler, true);
      this.handlers.set(doc, handler);
      this.attachedDocs.add(doc);
    }
    makeHandler(doc) {
      return (evt) => {
        const e = evt;
        if (e[REMAP_FLAG]) return;
        const isRapidSynthetic = !!e[RAPID_SYN_FLAG];
        if (!isRapidSynthetic) this.handleRapidFireInput(doc, e);
        if (!isRapidSynthetic && this.eventBlockers.size) {
          for (const blocker of Array.from(this.eventBlockers)) {
            let shouldBlock = false;
            try {
              shouldBlock = blocker(e);
            } catch {
              shouldBlock = false;
            }
            if (shouldBlock) {
              e.stopImmediatePropagation();
              e.preventDefault();
              return;
            }
          }
        }
        if (!this.enabled) return;
        if (isEditableTarget(e.target)) return;
        if (this.passthrough.has(e.code)) return;
        const combo = evToCombo(e);
        if (this.blockedSet.has(combo)) {
          e.stopImmediatePropagation();
          e.preventDefault();
          return;
        }
        const spec = this.map.get(combo);
        if (!spec) return;
        e.stopImmediatePropagation();
        e.preventDefault();
        const code = spec.code || "";
        const key2 = spec.key !== void 0 ? spec.key : codeToKey(code, e.shiftKey);
        const ctrl = spec.ctrl ?? e.ctrlKey;
        const shift = spec.shift ?? e.shiftKey;
        const alt = spec.alt ?? e.altKey;
        const meta = spec.meta ?? e.metaKey;
        const kc = KEYCODE_TABLE[code] ?? (key2 && key2.length === 1 ? key2.toUpperCase().charCodeAt(0) : 0);
        const eventWindow = doc.defaultView || this.win;
        const ne = new eventWindow.KeyboardEvent(e.type, {
          bubbles: true,
          cancelable: true,
          composed: true,
          key: key2,
          code,
          ctrlKey: ctrl,
          shiftKey: shift,
          altKey: alt,
          metaKey: meta,
          repeat: e.repeat,
          location: e.location
        });
        Object.defineProperties(ne, {
          keyCode: { get: () => kc },
          which: { get: () => kc },
          charCode: { get: () => kc },
          [REMAP_FLAG]: { value: true }
        });
        const target = e.target || doc;
        target.dispatchEvent(ne);
      };
    }
    /* ---------- Rapid-fire internes ---------- */
    handleRapidFireInput(doc, e) {
      if (isEditableTarget(e.target)) return;
      if (e.type === "keydown" && !e.repeat) {
        for (const s of this.sessions.values()) {
          if (this.matches(e, s.trigger)) {
            s.pressed = true;
            s.lastTarget = e.target || doc;
            this.startLoop(doc, s);
          }
        }
      } else if (e.type === "keyup") {
        for (const s of this.sessions.values()) {
          if (this.matches(e, s.trigger)) {
            s.pressed = false;
            this.stopLoop(doc, s);
          }
        }
      }
    }
    matches(e, c) {
      return e.code === c.code && !!e.ctrlKey === !!c.ctrl && !!e.shiftKey === !!c.shift && !!e.altKey === !!c.alt && !!e.metaKey === !!c.meta;
    }
    startLoop(doc, s) {
      this.stopLoop(doc, s);
      const tick = () => {
        if (!s.pressed) return;
        this.dispatchKey(doc, s.lastTarget || doc, "keydown", s.emit, true);
        if (s.mode === "tap") {
          if (s.upTimer) this.win.clearTimeout(s.upTimer);
          s.upTimer = this.win.setTimeout(() => {
            this.dispatchKey(doc, s.lastTarget || doc, "keyup", s.emit, false);
          }, s.keyupDelayMs);
        }
      };
      tick();
      s.tickTimer = this.win.setInterval(tick, s.rateMs);
    }
    stopLoop(doc, s) {
      if (s.tickTimer) {
        this.win.clearInterval(s.tickTimer);
        s.tickTimer = null;
      }
      if (s.upTimer) {
        this.win.clearTimeout(s.upTimer);
        s.upTimer = null;
      }
      if (s.mode === "hold" && s.lastTarget) {
        this.dispatchKey(doc, s.lastTarget, "keyup", s.emit, false);
      }
    }
    restartLoop(s) {
      if (!s.pressed) return;
      const anyDoc = this.doc;
      this.startLoop(anyDoc, s);
    }
    endSession(s) {
      this.stopLoop(this.doc, s);
      s.pressed = false;
      s.lastTarget = null;
    }
    dispatchKey(doc, target, type, c, repeat) {
      const code = c.code;
      const key2 = codeToKey(code, c.shift);
      const kc = KEYCODE_TABLE[code] ?? (key2 && key2.length === 1 ? key2.toUpperCase().charCodeAt(0) : 0);
      const eventWindow = doc.defaultView || this.win;
      const ev = new eventWindow.KeyboardEvent(type, {
        bubbles: true,
        cancelable: true,
        composed: true,
        key: key2,
        code,
        ctrlKey: c.ctrl,
        shiftKey: c.shift,
        altKey: c.alt,
        metaKey: c.meta,
        repeat
      });
      Object.defineProperties(ev, {
        keyCode: { get: () => kc },
        which: { get: () => kc },
        charCode: { get: () => kc },
        [RAPID_SYN_FLAG]: { value: true }
      });
      try {
        target.dispatchEvent(ev);
      } catch {
        doc.dispatchEvent(ev);
      }
    }
  };
  function parseRapid(c) {
    const parts = String(c).split("+").map((s) => s.trim()).filter(Boolean);
    let code = "";
    let ctrl = false, shift = false, alt = false, meta = false;
    for (const p of parts) {
      const P = p.toLowerCase();
      if (P === "ctrl" || P === "control") ctrl = true;
      else if (P === "shift") shift = true;
      else if (P === "alt") alt = true;
      else if (P === "meta" || P === "cmd" || P === "command" || P === "win") meta = true;
      else code = p;
    }
    return { code, ctrl, shift, alt, meta };
  }
  function joinRapid(c) {
    const mods = [];
    if (c.ctrl) mods.push("Ctrl");
    if (c.shift) mods.push("Shift");
    if (c.alt) mods.push("Alt");
    if (c.meta) mods.push("Meta");
    mods.push(c.code);
    return mods.join("+");
  }
  var defaultContext = resolveContext();
  var inGameHotkeys = new InGameHotkeys(true, defaultContext);
  shareGlobal("inGameHotkeys", inGameHotkeys);
  try {
    window.inGameHotkeys = inGameHotkeys;
  } catch {
  }

  // src/services/keybinds.ts
  var SECTION_CONFIG = [
    {
      id: "gui",
      title: "GUI",
      icon: "\u{1F5A5}\uFE0F",
      description: "Choose how you open and move the overlay.",
      actions: [
        {
          id: "gui.toggle",
          label: "\u{1F441}\uFE0F Toggle menu visibility",
          hint: "Opens or closes the Arie's Mod overlay.",
          defaultHotkey: { alt: true, code: "KeyX" }
        },
        {
          id: "gui.drag",
          label: "\u270B Drag HUD",
          hint: "Hold to drag menus interfaces around the screen.",
          defaultHotkey: { alt: true, code: "AltLeft" },
          allowModifierOnly: true
        }
      ]
    },
    {
      id: "shops",
      title: "Shops",
      icon: "\u{1F6D2}",
      description: "Quick shortcuts to every shop tab.",
      actions: [
        {
          id: "shops.seeds",
          label: "\u{1F330} Seeds shop",
          defaultHotkey: { alt: true, code: "KeyS" }
        },
        {
          id: "shops.eggs",
          label: "\u{1F95A} Eggs shop",
          defaultHotkey: { alt: true, code: "KeyE" }
        },
        {
          id: "shops.decors",
          label: "\u{1FA91} Decors shop",
          defaultHotkey: { alt: true, code: "KeyD" }
        },
        {
          id: "shops.tools",
          label: "\u{1F9FA} Tools shop",
          defaultHotkey: { alt: true, code: "KeyT" }
        }
      ]
    },
    {
      id: "game",
      title: "Game",
      icon: "\u{1F3AE}",
      description: "Remap the in-game actions",
      actions: [
        {
          id: "game.action",
          label: "\u26A1 Action",
          defaultHotkey: { code: "Space" },
          holdDetection: {
            label: "Hold to repeat",
            defaultEnabled: false
          }
        },
        {
          id: "game.inventory",
          label: "\u{1F392} Inventory",
          defaultHotkey: { code: "KeyE" }
        },
        {
          id: "game.move-up",
          label: "\u2B06 Move up",
          defaultHotkey: { code: "KeyW" }
        },
        {
          id: "game.move-down",
          label: "\u2B07 Move down",
          defaultHotkey: { code: "KeyS" }
        },
        {
          id: "game.move-left",
          label: "\u2B05 Move left",
          defaultHotkey: { code: "KeyA" }
        },
        {
          id: "game.move-right",
          label: "\u27A1 Move right",
          defaultHotkey: { code: "KeyD" }
        }
      ]
    },
    {
      id: "sell",
      title: "Sell",
      icon: "\u{1F4B0}",
      description: "Streamline selling actions.",
      actions: [
        {
          id: "sell.sell-all",
          label: "\u{1F33E} All crops",
          hint: "Trigger the sell-all flow for harvested crops.",
          defaultHotkey: null
        },
        {
          id: "sell.sell-all-pets",
          label: "\u{1F43E} All pets",
          hint: "Sell every non-favorited pet in your inventory.",
          defaultHotkey: null
        }
      ]
    },
    {
      id: "editor",
      title: "Editor",
      icon: "\u{1F4DD}",
      description: "Shortcuts for placing/removing items and toggling editor overlays.",
      actions: [
        {
          id: "editor.place-remove",
          label: "Place / Remove item",
          hint: "Place selected item on empty tile, or remove the item under your feet.",
          defaultHotkey: { code: "Space" }
        },
        {
          id: "editor.toggle-overlays",
          label: "Toggle editor overlays",
          hint: "Show or hide the editor panels.",
          defaultHotkey: { code: "KeyU" }
        },
        {
          id: "editor.delete-inventory",
          label: "Remove selected item from inventory",
          hint: "Remove the currently selected inventory item.",
          defaultHotkey: { code: "Delete" }
        }
      ]
    }
  ];
  var KEYBINDS_BINDINGS_PATH = "keybinds.bindings";
  var KEYBINDS_HOLD_PATH = "keybinds.hold";
  var ARIES_ROOT_KEY = "aries_mod";
  var STORED_NONE = "__none__";
  var actionMap = /* @__PURE__ */ new Map();
  var defaultMap = /* @__PURE__ */ new Map();
  var cache = /* @__PURE__ */ new Map();
  var listeners2 = /* @__PURE__ */ new Map();
  var holdDefaultMap = /* @__PURE__ */ new Map();
  var holdCache = /* @__PURE__ */ new Map();
  var holdListeners = /* @__PURE__ */ new Map();
  var keybindSections = SECTION_CONFIG.map((section) => {
    const actions = section.actions.map((action2) => {
      const normalized = {
        id: action2.id,
        sectionId: section.id,
        label: action2.label,
        hint: action2.hint,
        allowModifierOnly: action2.allowModifierOnly,
        defaultHotkey: cloneHotkey(action2.defaultHotkey),
        holdDetection: action2.holdDetection ? {
          label: action2.holdDetection.label,
          description: action2.holdDetection.description,
          defaultEnabled: action2.holdDetection.defaultEnabled
        } : void 0
      };
      actionMap.set(normalized.id, normalized);
      defaultMap.set(normalized.id, cloneHotkey(action2.defaultHotkey));
      if (action2.holdDetection) {
        holdDefaultMap.set(normalized.id, !!action2.holdDetection.defaultEnabled);
      }
      return normalized;
    });
    return {
      id: section.id,
      title: section.title,
      description: section.description,
      icon: section.icon,
      actions
    };
  });
  var PET_SECTION_ID = "pets";
  var PET_TEAM_ACTION_PREFIX = "pets.team.";
  var PET_TEAM_NEXT_ID = "pets.team.next";
  var PET_TEAM_PREV_ID = "pets.team.prev";
  var petSection = {
    id: PET_SECTION_ID,
    title: "Pets",
    icon: "\u{1F437}",
    description: "Assign shortcuts to your pet teams and cycle through them instantly.",
    actions: []
  };
  keybindSections.push(petSection);
  var petActionIds = /* @__PURE__ */ new Set();
  function getPetTeamActionId(teamId) {
    return `${PET_TEAM_ACTION_PREFIX}${teamId}`;
  }
  function disposePetAction(id) {
    actionMap.delete(id);
    defaultMap.delete(id);
    cache.delete(id);
    listeners2.delete(id);
    holdDefaultMap.delete(id);
    holdCache.delete(id);
    holdListeners.delete(id);
  }
  function registerPetAction(action2, defaultHotkey) {
    const normalized = {
      id: action2.id,
      sectionId: PET_SECTION_ID,
      label: action2.label,
      hint: action2.hint,
      allowModifierOnly: action2.allowModifierOnly,
      defaultHotkey: cloneHotkey(defaultHotkey),
      holdDetection: action2.holdDetection ? {
        label: action2.holdDetection.label,
        description: action2.holdDetection.description,
        defaultEnabled: action2.holdDetection.defaultEnabled
      } : void 0
    };
    actionMap.set(normalized.id, normalized);
    defaultMap.set(normalized.id, cloneHotkey(defaultHotkey));
    petActionIds.add(normalized.id);
    petSection.actions.push(normalized);
  }
  function updatePetKeybinds(teams) {
    for (const id of petActionIds) {
      disposePetAction(id);
    }
    petActionIds.clear();
    petSection.actions = [];
    registerPetAction(
      {
        id: PET_TEAM_PREV_ID,
        sectionId: PET_SECTION_ID,
        label: "\u25C0\uFE0F Previous team",
        defaultHotkey: null
      },
      null
    );
    registerPetAction(
      {
        id: PET_TEAM_NEXT_ID,
        sectionId: PET_SECTION_ID,
        label: "\u25B6\uFE0F Next team",
        defaultHotkey: null
      },
      null
    );
    teams.forEach((team, index) => {
      const name = String(team?.name || "").trim();
      const labelName = name.length ? name : `Team ${index + 1}`;
      registerPetAction(
        {
          id: getPetTeamActionId(team.id),
          sectionId: PET_SECTION_ID,
          label: `Use team \u2014 ${labelName}`,
          defaultHotkey: null
        },
        null
      );
    });
  }
  updatePetKeybinds([]);
  var GAME_KEYBIND_TARGETS = {
    "game.action": "Space",
    "game.inventory": "KeyE",
    "game.move-up": "KeyW",
    // Z (AZERTY) == KeyW
    "game.move-down": "KeyS",
    // S
    "game.move-left": "KeyA",
    // Q (AZERTY) == KeyA
    "game.move-right": "KeyD"
    // D
  };
  var GAME_KEYBIND_IDS = [
    "game.action",
    "game.inventory",
    "game.move-up",
    "game.move-down",
    "game.move-left",
    "game.move-right"
  ];
  var gameActiveStates = /* @__PURE__ */ new Map();
  var gameKeybindsInstalled = false;
  var GAME_ACTION_ID = "game.action";
  var gameActionBlockers = /* @__PURE__ */ new Set();
  var gameActionBlockedCombos = /* @__PURE__ */ new Set();
  function getCombosForGameAction() {
    const state2 = gameActiveStates.get(GAME_ACTION_ID);
    if (!state2) return [];
    const combo = state2.combo;
    return typeof combo === "string" && combo.length ? [combo] : [];
  }
  function applyGameActionBlockers() {
    const shouldBlock = gameActionBlockers.size > 0;
    const desired = /* @__PURE__ */ new Set();
    if (shouldBlock) {
      for (const combo of getCombosForGameAction()) {
        if (combo) desired.add(combo);
      }
    }
    for (const combo of gameActionBlockedCombos) {
      if (!desired.has(combo)) {
        try {
          inGameHotkeys.unblock(combo);
        } catch {
        }
      }
    }
    if (shouldBlock) {
      for (const combo of desired) {
        if (!gameActionBlockedCombos.has(combo)) {
          try {
            inGameHotkeys.block(combo);
          } catch {
          }
        }
      }
    }
    gameActionBlockedCombos.clear();
    if (shouldBlock) {
      for (const combo of desired) gameActionBlockedCombos.add(combo);
    }
  }
  function hotkeyToCombo(hk) {
    if (!hk) return null;
    const combo = hotkeyToString(hk);
    return combo.length ? combo : null;
  }
  function purgeTargetBindings(emitCombo) {
    try {
      inGameHotkeys.unblock(emitCombo);
    } catch {
    }
    try {
      const curr = inGameHotkeys.current();
      for (const [from, to] of Object.entries(curr)) {
        const toCode = String(to).split("+").pop();
        if (toCode === emitCombo) {
          try {
            inGameHotkeys.remove(from);
          } catch {
          }
        }
      }
    } catch {
    }
  }
  function isMac2() {
    return typeof navigator !== "undefined" && /Mac|iPhone|iPad|iPod/.test(navigator.platform || "");
  }
  function codeToDisplay(code) {
    if (!code) return "";
    const mKey = code.match(/^Key([A-Z])$/);
    if (mKey) return mKey[1];
    const mDigit = code.match(/^Digit([0-9])$/);
    if (mDigit) return mDigit[1];
    if (code === "ControlLeft" || code === "ControlRight") return "Ctrl";
    if (code === "AltLeft" || code === "AltRight") return "Alt";
    if (code === "ShiftLeft" || code === "ShiftRight") return "Shift";
    if (code === "MetaLeft" || code === "MetaRight") return isMac2() ? "\u2318" : "Win";
    if (code === "Space") return "Space";
    if (code === "Enter") return "Enter";
    if (code === "Escape") return "Esc";
    if (code === "Tab") return "Tab";
    if (code === "Backspace") return "Backspace";
    if (code === "Delete") return "Del";
    if (code === "Insert") return "Ins";
    if (code === "ArrowUp") return "\u2191";
    if (code === "ArrowDown") return "\u2193";
    if (code === "ArrowLeft") return "\u2190";
    if (code === "ArrowRight") return "\u2192";
    return code;
  }
  function prettyHotkey(hk) {
    if (!hk) return "\u2014";
    const mods = [];
    if (hk.ctrl) mods.push("Ctrl");
    if (hk.shift) mods.push("Shift");
    if (hk.alt) mods.push("Alt");
    if (hk.meta) mods.push(isMac2() ? "\u2318" : "Win");
    let base = "";
    const k = hk.key;
    if (typeof k === "string" && k.length === 1) {
      base = k.toUpperCase();
    } else {
      base = codeToDisplay(hk.code);
    }
    const baseIsModifier = base && ["Ctrl", "Shift", "Alt", "\u2318", "Win"].includes(base);
    const parts = baseIsModifier ? mods : mods.concat(base ? [base] : []);
    return parts.join(" + ");
  }
  function syncGameKeybind(id) {
    if (typeof window === "undefined") return;
    const emitCombo = GAME_KEYBIND_TARGETS[id];
    purgeTargetBindings(emitCombo);
    const prev = gameActiveStates.get(id);
    if (prev) {
      if (prev.rapidFire) {
        try {
          inGameHotkeys.stopRapidFire(prev.combo);
        } catch {
        }
      }
      gameActiveStates.delete(id);
    }
    const combo = hotkeyToCombo(getKeybind(id));
    if (!combo) {
      if (id === GAME_ACTION_ID) {
        applyGameActionBlockers();
      }
      return;
    }
    const holdEnabled = getKeybindHoldDetection(id);
    let replaced = false;
    if (combo !== emitCombo) {
      try {
        inGameHotkeys.replace(emitCombo, combo);
        replaced = true;
      } catch {
      }
    }
    let rapidFire = false;
    if (holdEnabled) {
      try {
        inGameHotkeys.startRapidFire({
          trigger: combo,
          // on tient la touche choisie
          emit: combo,
          // remapper convertira en emitCombo si replace() actif
          mode: "tap",
          rateHz: 10
        });
        rapidFire = true;
      } catch {
      }
    }
    gameActiveStates.set(id, { combo, replaced, rapidFire });
    if (id === GAME_ACTION_ID) {
      applyGameActionBlockers();
    }
  }
  function cloneHotkey(hk) {
    return hk ? { ...hk } : null;
  }
  function hotkeysEqual(a, b) {
    if (!a && !b) return true;
    if (!a || !b) return false;
    return hotkeyToString(a) === hotkeyToString(b);
  }
  function readStored(id) {
    if (typeof window === "undefined") return void 0;
    const map2 = readAriesPath(KEYBINDS_BINDINGS_PATH);
    const raw = map2?.[id];
    if (raw == null) return void 0;
    if (raw === STORED_NONE) return null;
    if (typeof raw !== "string") return null;
    const parsed = stringToHotkey(raw);
    return parsed ?? null;
  }
  function writeStored(id, hk) {
    if (typeof window === "undefined") return;
    updateAriesPath(KEYBINDS_BINDINGS_PATH, (current) => {
      const base = current && typeof current === "object" ? { ...current } : {};
      if (hk) {
        base[id] = hotkeyToString(hk);
      } else {
        base[id] = STORED_NONE;
      }
      return base;
    });
  }
  function removeStored(id) {
    if (typeof window === "undefined") return;
    updateAriesPath(KEYBINDS_BINDINGS_PATH, (current) => {
      const base = current && typeof current === "object" ? { ...current } : {};
      delete base[id];
      return base;
    });
  }
  function readHoldStored(id) {
    if (typeof window === "undefined") return void 0;
    const map2 = readAriesPath(KEYBINDS_HOLD_PATH);
    const raw = map2?.[id];
    if (raw == null) return void 0;
    if (typeof raw === "string") return raw === "1";
    if (typeof raw === "number") return raw === 1;
    if (typeof raw === "boolean") return raw;
    return void 0;
  }
  function writeHoldStored(id, enabled) {
    if (typeof window === "undefined") return;
    updateAriesPath(KEYBINDS_HOLD_PATH, (current) => {
      const base = current && typeof current === "object" ? { ...current } : {};
      base[id] = !!enabled;
      return base;
    });
  }
  function emitHoldChange(id) {
    const set2 = holdListeners.get(id);
    if (!set2 || set2.size === 0) return;
    const current = getKeybindHoldDetection(id);
    for (const cb of set2) cb(current);
  }
  function emitChange(id) {
    const set2 = listeners2.get(id);
    if (!set2 || set2.size === 0) return;
    const current = cloneHotkey(getKeybind(id));
    for (const cb of set2) cb(current);
  }
  function ensureCache(id) {
    if (cache.has(id)) {
      return cloneHotkey(cache.get(id) ?? null);
    }
    const stored = readStored(id);
    const resolved = stored === void 0 ? cloneHotkey(defaultMap.get(id) ?? null) : cloneHotkey(stored);
    cache.set(id, resolved);
    return cloneHotkey(resolved);
  }
  function ensureHoldCache(id) {
    if (!holdDefaultMap.has(id)) return false;
    if (holdCache.has(id)) {
      return holdCache.get(id) ?? false;
    }
    const stored = readHoldStored(id);
    const resolved = stored === void 0 ? !!holdDefaultMap.get(id) : stored;
    holdCache.set(id, resolved);
    return resolved;
  }
  function getKeybind(id) {
    return ensureCache(id);
  }
  function getDefaultKeybind(id) {
    return cloneHotkey(defaultMap.get(id) ?? null);
  }
  function setKeybind(id, hk) {
    const current = getKeybind(id);
    if (hotkeysEqual(current, hk)) return;
    const next = cloneHotkey(hk);
    if (next) {
      const asString = hotkeyToString(next);
      for (const otherId of actionMap.keys()) {
        if (otherId === id) continue;
        const other = getKeybind(otherId);
        if (!other) continue;
        if (hotkeyToString(other) !== asString) continue;
        cache.set(otherId, null);
        writeStored(otherId, null);
        emitChange(otherId);
      }
    }
    cache.set(id, next);
    writeStored(id, next);
    emitChange(id);
  }
  function resetKeybind(id) {
    cache.delete(id);
    removeStored(id);
    emitChange(id);
  }
  function getKeybindHoldDetection(id) {
    return ensureHoldCache(id);
  }
  function setKeybindHoldDetection(id, enabled) {
    if (!holdDefaultMap.has(id)) return;
    const current = ensureHoldCache(id);
    if (current === enabled) return;
    holdCache.set(id, enabled);
    writeHoldStored(id, enabled);
    emitHoldChange(id);
  }
  function onKeybindHoldDetectionChange(id, cb) {
    if (!holdDefaultMap.has(id)) {
      return () => {
      };
    }
    const set2 = holdListeners.get(id) ?? /* @__PURE__ */ new Set();
    if (!holdListeners.has(id)) holdListeners.set(id, set2);
    set2.add(cb);
    return () => {
      set2.delete(cb);
      if (set2.size === 0) holdListeners.delete(id);
    };
  }
  function onKeybindChange(id, cb) {
    const set2 = listeners2.get(id) ?? /* @__PURE__ */ new Set();
    if (!listeners2.has(id)) listeners2.set(id, set2);
    set2.add(cb);
    return () => {
      set2.delete(cb);
      if (set2.size === 0) listeners2.delete(id);
    };
  }
  function eventMatchesKeybind(id, e) {
    return matchHotkey(e, getKeybind(id));
  }
  function installGameKeybindsOnce() {
    if (gameKeybindsInstalled || typeof window === "undefined") return;
    gameKeybindsInstalled = true;
    for (const id of GAME_KEYBIND_IDS) {
      syncGameKeybind(id);
      onKeybindChange(id, () => syncGameKeybind(id));
      onKeybindHoldDetectionChange(id, () => syncGameKeybind(id));
    }
  }
  function getKeybindLabel(id) {
    return prettyHotkey(getKeybind(id));
  }
  function getKeybindSections() {
    return keybindSections.map((section) => ({
      ...section,
      actions: section.actions.map((action2) => ({
        ...action2,
        defaultHotkey: cloneHotkey(action2.defaultHotkey),
        holdDetection: action2.holdDetection ? {
          label: action2.holdDetection.label,
          description: action2.holdDetection.description,
          defaultEnabled: action2.holdDetection.defaultEnabled
        } : void 0
      }))
    }));
  }
  if (typeof window !== "undefined") {
    window.addEventListener("storage", (event) => {
      if (event.key !== ARIES_ROOT_KEY) return;
      cache.clear();
      holdCache.clear();
      for (const id of actionMap.keys()) emitChange(id);
      for (const id of holdDefaultMap.keys()) emitHoldChange(id);
    });
  }

  // src/utils/keyboard.ts
  function shouldIgnoreKeydown(e) {
    const el2 = e.target;
    if (!el2) return false;
    return el2.isContentEditable || el2.tagName === "INPUT" || el2.tagName === "TEXTAREA" || el2.tagName === "SELECT";
  }

  // src/services/pets.ts
  var PATH_PETS_OVERRIDES = "pets.overrides";
  var PATH_PETS_UI = "pets.ui";
  var PATH_PETS_TEAMS = "pets.teams";
  var PATH_PETS_TEAM_SEARCH = "pets.teamSearch";
  var PATH_PETS_HOTKEYS = "pets.hotkeys";
  var PATH_PETS_ABILITY_LOGS = "pets.abilityLogs";
  var TEAM_HK_MAP = /* @__PURE__ */ new Map();
  var TEAM_HK_UNSUBS = /* @__PURE__ */ new Map();
  var hkNextTeam = null;
  var hkPrevTeam = null;
  var unsubNextHotkey = null;
  var unsubPrevHotkey = null;
  var orderedTeamIds = [];
  var lastUsedTeamId = null;
  function syncTeamHotkey(teamId) {
    const hk = getKeybind(getPetTeamActionId(teamId));
    if (hk) TEAM_HK_MAP.set(teamId, hk);
    else TEAM_HK_MAP.delete(teamId);
  }
  function syncNextTeamHotkey() {
    hkNextTeam = getKeybind(PET_TEAM_NEXT_ID);
  }
  function syncPrevTeamHotkey() {
    hkPrevTeam = getKeybind(PET_TEAM_PREV_ID);
  }
  function ensureLegacyTeamHotkeyMigration(teamId) {
    const hotkeys = readAriesPath(PATH_PETS_HOTKEYS) ?? {};
    const legacy = hotkeys[teamId];
    if (!legacy) return;
    const actionId = getPetTeamActionId(teamId);
    const existing = getKeybind(actionId);
    if (!existing) {
      const hk = stringToHotkey(legacy);
      if (hk) {
        setKeybind(actionId, hk);
      }
    }
    const clone = { ...hotkeys };
    delete clone[teamId];
    writeAriesPath(PATH_PETS_HOTKEYS, clone);
  }
  function normalizeTeamList(teams) {
    if (!Array.isArray(teams)) return [];
    return teams.map((t) => ({ id: String(t?.id ?? ""), name: t?.name ?? null })).filter((t) => t.id.length > 0);
  }
  function ensureLastUsedTeamIsValid() {
    if (!orderedTeamIds.length) {
      lastUsedTeamId = null;
      return;
    }
    if (!lastUsedTeamId || !orderedTeamIds.includes(lastUsedTeamId)) {
      lastUsedTeamId = orderedTeamIds[0] ?? null;
    }
  }
  function adjacentTeam(direction) {
    if (!orderedTeamIds.length) return null;
    if (!lastUsedTeamId || !orderedTeamIds.includes(lastUsedTeamId)) {
      return direction === 1 ? orderedTeamIds[0] ?? null : orderedTeamIds[orderedTeamIds.length - 1] ?? null;
    }
    if (orderedTeamIds.length === 1) return orderedTeamIds[0] ?? null;
    const currentIndex2 = orderedTeamIds.indexOf(lastUsedTeamId);
    let nextIndex = currentIndex2 + direction;
    if (nextIndex < 0) nextIndex = orderedTeamIds.length - 1;
    if (nextIndex >= orderedTeamIds.length) nextIndex = 0;
    return orderedTeamIds[nextIndex] ?? null;
  }
  function markTeamAsUsed(teamId) {
    lastUsedTeamId = teamId ? String(teamId) : null;
  }
  function setTeamsForHotkeys(rawTeams) {
    for (const unsub of TEAM_HK_UNSUBS.values()) {
      try {
        unsub();
      } catch {
      }
    }
    TEAM_HK_UNSUBS.clear();
    if (unsubNextHotkey) {
      try {
        unsubNextHotkey();
      } catch {
      }
      unsubNextHotkey = null;
    }
    if (unsubPrevHotkey) {
      try {
        unsubPrevHotkey();
      } catch {
      }
      unsubPrevHotkey = null;
    }
    const teams = normalizeTeamList(rawTeams);
    updatePetKeybinds(teams);
    orderedTeamIds = teams.map((t) => t.id);
    ensureLastUsedTeamIsValid();
    const keep = new Set(orderedTeamIds);
    for (const teamId of Array.from(TEAM_HK_MAP.keys())) {
      if (!keep.has(teamId)) TEAM_HK_MAP.delete(teamId);
    }
    teams.forEach((team) => {
      ensureLegacyTeamHotkeyMigration(team.id);
      syncTeamHotkey(team.id);
      const unsub = onKeybindChange(getPetTeamActionId(team.id), () => syncTeamHotkey(team.id));
      TEAM_HK_UNSUBS.set(team.id, unsub);
    });
    syncNextTeamHotkey();
    syncPrevTeamHotkey();
    unsubNextHotkey = onKeybindChange(PET_TEAM_NEXT_ID, () => syncNextTeamHotkey());
    unsubPrevHotkey = onKeybindChange(PET_TEAM_PREV_ID, () => syncPrevTeamHotkey());
  }
  function installPetTeamHotkeysOnce(onUseTeam) {
    const FLAG = "__qws_pet_team_hk_installed";
    if (window[FLAG]) return;
    window.addEventListener(
      "keydown",
      (e) => {
        if (shouldIgnoreKeydown(e)) return;
        const useTeam = (teamId) => {
          if (!teamId) return;
          markTeamAsUsed(teamId);
          onUseTeam(teamId);
        };
        if (hkPrevTeam && matchHotkey(e, hkPrevTeam)) {
          const target = adjacentTeam(-1);
          if (target) {
            e.preventDefault();
            e.stopPropagation();
            useTeam(target);
            return;
          }
        }
        if (hkNextTeam && matchHotkey(e, hkNextTeam)) {
          const target = adjacentTeam(1);
          if (target) {
            e.preventDefault();
            e.stopPropagation();
            useTeam(target);
            return;
          }
        }
        for (const [teamId, hk] of TEAM_HK_MAP) {
          if (matchHotkey(e, hk)) {
            e.preventDefault();
            e.stopPropagation();
            useTeam(teamId);
            break;
          }
        }
      },
      true
    );
    window[FLAG] = true;
  }
  var _AB = petAbilities ?? {};
  function _abilityName(id) {
    const key2 = String(id ?? "");
    const raw = typeof _AB?.[key2]?.name === "string" && _AB[key2].name.trim() ? _AB[key2].name : key2;
    return String(raw);
  }
  function _abilityNameWithoutLevel(id) {
    const key2 = String(id ?? "");
    const raw = typeof _AB?.[key2]?.name === "string" && _AB[key2].name.trim() ? _AB[key2].name : key2;
    return String(raw).replace(/(?:\s+|-)?(?:I|II|III|IV|V|VI|VII|VIII|IX|X)\s*$/, "").trim();
  }
  function _parseTeamSearch(raw) {
    const s = String(raw || "").trim();
    const m = s.match(/^(ab|sp):\s*(.*)$/i);
    if (!m) return { mode: "text", value: s };
    return { mode: m[1].toLowerCase() === "ab" ? "ability" : "species", value: (m[2] || "").trim() };
  }
  async function _abilityNameToPresentIds(name) {
    await _ensureInventoryWatchersStarted();
    const target = String(name || "").toLowerCase().trim().replace(/(?:\s+|-)?(?:i|ii|iii|iv|v|vi|vii|viii|ix|x)\s*$/i, "");
    const ids = /* @__PURE__ */ new Set();
    if (!target) return ids;
    for (const p of _invPetsCache) {
      const abs = Array.isArray(p.abilities) ? p.abilities : [];
      for (const id of abs) {
        if (_abilityNameWithoutLevel(id).toLowerCase() === target) ids.add(id);
      }
    }
    return ids;
  }
  var _s = (v) => (v ?? "").toLowerCase();
  var _sOpt = (v) => typeof v === "string" ? v : null;
  var _n = (v) => Number.isFinite(v) ? v : 0;
  var _sArr = (v) => Array.isArray(v) ? v.filter((x) => typeof x === "string") : [];
  function _canonicalSpecies(s) {
    if (!s) return s;
    if (petCatalog[s]) return s;
    const t = s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
    return petCatalog[t] ? t : s;
  }
  function _invPetToRawItem(p) {
    return {
      id: p.id,
      itemType: "Pet",
      petSpecies: _canonicalSpecies(p.petSpecies),
      name: p.name ?? null,
      xp: p.xp,
      hunger: p.hunger,
      mutations: Array.isArray(p.mutations) ? p.mutations.slice() : [],
      targetScale: p.targetScale,
      abilities: Array.isArray(p.abilities) ? p.abilities.slice() : []
    };
  }
  function loadTeams() {
    const arr = readAriesPath(PATH_PETS_TEAMS) ?? [];
    if (!Array.isArray(arr)) return [];
    return arr.map((t) => ({
      id: String(t?.id || ""),
      name: String(t?.name || "Team"),
      slots: Array.isArray(t?.slots) ? t.slots.slice(0, 3).map((x) => x ? String(x) : null) : [null, null, null]
    })).filter((t) => t.id);
  }
  function saveTeams(arr) {
    writeAriesPath(PATH_PETS_TEAMS, arr);
  }
  function _uid() {
    try {
      return crypto.randomUUID();
    } catch {
      return `t_${Date.now().toString(36)}_${Math.random().toString(16).slice(2)}`;
    }
  }
  function _loadTeamSearchMap() {
    const obj = readAriesPath(PATH_PETS_TEAM_SEARCH);
    return obj && typeof obj === "object" ? obj : {};
  }
  function _saveTeamSearchMap(map2) {
    writeAriesPath(PATH_PETS_TEAM_SEARCH, map2);
  }
  var _teams = loadTeams();
  var _teamSearch = _loadTeamSearchMap();
  var _invRaw = null;
  var _activeRaw = [];
  var _hutchRaw = [];
  var _invPetsCache = [];
  var _invUnsub = null;
  var _activeUnsub = null;
  var _hutchUnsub = null;
  var _invSig = null;
  var _activeSig = null;
  function _inventoryItemToPet(x) {
    if (!x || x.itemType !== "Pet") return null;
    const id = _s(x.id);
    if (!id) return null;
    return {
      id,
      itemType: "Pet",
      petSpecies: _s(x.petSpecies ?? x.data?.petSpecies),
      name: _sOpt(x.name ?? x.data?.name ?? null),
      xp: _n(x.xp ?? x.data?.xp),
      hunger: _n(x.hunger ?? x.data?.hunger),
      mutations: _sArr(x.mutations ?? x.data?.mutations),
      targetScale: Number.isFinite(x.targetScale ?? x.data?.targetScale) ? Number(x.targetScale ?? x.data?.targetScale) : void 0,
      abilities: _sArr(x.abilities ?? x.data?.abilities)
    };
  }
  function _activeSlotToPet(entry) {
    const slot = entry?.slot;
    if (!slot || typeof slot !== "object") return null;
    const id = _s(slot.id);
    if (!id) return null;
    return {
      id,
      itemType: "Pet",
      petSpecies: _s(slot.petSpecies),
      name: _sOpt(slot.name ?? null),
      xp: _n(slot.xp),
      hunger: _n(slot.hunger),
      mutations: _sArr(slot.mutations),
      targetScale: Number.isFinite(slot.targetScale) ? Number(slot.targetScale) : void 0,
      abilities: _sArr(slot.abilities)
    };
  }
  function _petSigStableNoXpNoHunger(p) {
    return JSON.stringify({
      id: p.id,
      itemType: "Pet",
      petSpecies: p.petSpecies,
      name: p.name ?? null,
      mutations: Array.isArray(p.mutations) ? p.mutations : [],
      targetScale: Number.isFinite(p.targetScale) ? p.targetScale : null,
      abilities: Array.isArray(p.abilities) ? p.abilities : []
    });
  }
  function _buildInvSigFromInventory(inv) {
    const out = /* @__PURE__ */ new Map();
    const items = Array.isArray(inv?.items) ? inv.items : Array.isArray(inv) ? inv : [];
    for (const it of items) {
      const p = _inventoryItemToPet(it);
      if (p) out.set(p.id, _petSigStableNoXpNoHunger(p));
    }
    return out;
  }
  function _buildActiveSig(list) {
    const out = /* @__PURE__ */ new Map();
    const arr = Array.isArray(list) ? list : [];
    for (const e of arr) {
      const p = _activeSlotToPet(e);
      if (p) out.set(p.id, _petSigStableNoXpNoHunger(p));
    }
    return out;
  }
  function _mapsEqual(a, b) {
    if (!a) return false;
    if (a.size !== b.size) return false;
    for (const [k, v] of b) if (a.get(k) !== v) return false;
    return true;
  }
  function _rebuildInvPets() {
    const map2 = /* @__PURE__ */ new Map();
    const hutchItems = Array.isArray(_hutchRaw) ? _hutchRaw : [];
    const invItems = Array.isArray(_invRaw?.items) ? _invRaw.items : Array.isArray(_invRaw) ? _invRaw : [];
    for (const it of hutchItems) {
      const p = _inventoryItemToPet(it);
      if (p && p.id) map2.set(p.id, p);
    }
    for (const it of invItems) {
      const p = _inventoryItemToPet(it);
      if (p && p.id) map2.set(p.id, p);
    }
    const act = Array.isArray(_activeRaw) ? _activeRaw : [];
    for (const e of act) {
      const p = _activeSlotToPet(e);
      if (p && p.id) map2.set(p.id, p);
    }
    _invPetsCache = Array.from(map2.values());
  }
  async function _startInventoryWatcher() {
    const unsub = await (async () => {
      try {
        const cur = await Atoms.inventory.myInventory.get();
        _invSig = _buildInvSigFromInventory(cur);
        _invRaw = cur;
        _rebuildInvPets();
      } catch {
      }
      return Atoms.inventory.myInventory.onChange((inv) => {
        const nextSig = _buildInvSigFromInventory(inv);
        if (_mapsEqual(_invSig, nextSig)) return;
        _invSig = nextSig;
        _invRaw = inv;
        _rebuildInvPets();
      });
    })();
    _invUnsub = () => {
      try {
        unsub();
      } catch {
      }
    };
  }
  async function _startActivePetsWatcher() {
    const unsub = await (async () => {
      try {
        const cur = await Atoms.pets.myPetInfos.get();
        _activeSig = _buildActiveSig(cur);
        _activeRaw = Array.isArray(cur) ? cur : [];
        _rebuildInvPets();
      } catch {
      }
      return Atoms.pets.myPetInfos.onChange((list) => {
        const nextSig = _buildActiveSig(list);
        if (_mapsEqual(_activeSig, nextSig)) return;
        _activeSig = nextSig;
        _activeRaw = Array.isArray(list) ? list : [];
        _rebuildInvPets();
      });
    })();
    _activeUnsub = () => {
      try {
        unsub();
      } catch {
      }
    };
  }
  async function _startHutchWatcher() {
    const unsub = await (async () => {
      try {
        const cur = await myPetHutchPetItems.get();
        _hutchRaw = Array.isArray(cur) ? cur : [];
        _rebuildInvPets();
      } catch {
      }
      return myPetHutchPetItems.onChange((list) => {
        _hutchRaw = Array.isArray(list) ? list : [];
        _rebuildInvPets();
      });
    })();
    _hutchUnsub = () => {
      try {
        unsub();
      } catch {
      }
    };
  }
  async function _ensureInventoryWatchersStarted() {
    if (!_invUnsub) await _startInventoryWatcher();
    if (!_activeUnsub) await _startActivePetsWatcher();
    if (!_hutchUnsub) await _startHutchWatcher();
    if (!_invPetsCache.length) {
      try {
        const [inv, active, hutch] = await Promise.all([
          Atoms.inventory.myInventory.get(),
          Atoms.pets.myPetInfos.get(),
          myPetHutchPetItems.get()
        ]);
        _invSig = _buildInvSigFromInventory(inv);
        _activeSig = _buildActiveSig(active);
        _invRaw = inv;
        _activeRaw = Array.isArray(active) ? active : [];
        _hutchRaw = Array.isArray(hutch) ? hutch : [];
        _rebuildInvPets();
      } catch {
      }
    }
  }
  async function clearHandSelection() {
    try {
      await Atoms.inventory.setSelectedIndexToEnd.set(null);
    } catch (err) {
    }
    try {
      await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(null);
    } catch (err) {
    }
    try {
      await PlayerService.setSelectedItem(null);
    } catch (err) {
    }
    try {
      await PlayerService.dropObject();
    } catch (err) {
    }
  }
  async function _waitValidatedInventoryIndex(timeoutMs = 2e4) {
    await clearHandSelection();
    const t0 = performance.now();
    while (performance.now() - t0 < timeoutMs) {
      try {
        const modalVal = await Atoms.ui.activeModal.get();
        if (!isInventoryOpen(modalVal)) return null;
      } catch {
        return null;
      }
      try {
        const v = await Atoms.inventory.myValidatedSelectedItemIndex.get();
        if (typeof v === "number" && Number.isInteger(v) && v >= 0) return v;
      } catch {
      }
      await new Promise((r) => setTimeout(r, 80));
    }
    return null;
  }
  var _belowThreshold = /* @__PURE__ */ new Map();
  var DEFAULT_OVERRIDE = { enabled: false, thresholdPct: 10, crops: {} };
  var DEFAULT_UI = { selectedPetId: null };
  var _currentPets = [];
  var _userTriggerCb = null;
  function saveOverrides(map2) {
    writeAriesPath(PATH_PETS_OVERRIDES, map2);
  }
  function loadOverrides() {
    const obj = readAriesPath(PATH_PETS_OVERRIDES);
    return obj && typeof obj === "object" ? obj : {};
  }
  function saveUIState(next) {
    writeAriesPath(PATH_PETS_UI, next);
  }
  function loadUIState() {
    const obj = readAriesPath(PATH_PETS_UI);
    const merged = { ...DEFAULT_UI, ...obj || {} };
    return merged;
  }
  function cloneOverride(o) {
    const src = o ?? DEFAULT_OVERRIDE;
    return {
      enabled: !!src.enabled,
      thresholdPct: Math.min(100, Math.max(1, Number(src.thresholdPct) || DEFAULT_OVERRIDE.thresholdPct)),
      crops: { ...src.crops || {} }
    };
  }
  function clampPct(n) {
    return Math.max(0, Math.min(100, n));
  }
  function getCompatibleCropsFromData(species) {
    const PC = petCatalog;
    const entry = PC?.[species];
    const raw = entry?.diet ?? entry?.compatibleCrops ?? entry?.crops ?? [];
    const arr = Array.isArray(raw) ? raw : [];
    return arr.filter((c) => typeof c === "string" && c.length > 0);
  }
  function getMaxHungerFromData(species) {
    const v = petCatalog?.[species]?.coinsToFullyReplenishHunger;
    if (typeof v === "number" && Number.isFinite(v) && v > 0) return v;
    return 3e3;
  }
  async function findPetById(petId) {
    try {
      const list = await PlayerService.getPets();
      const arr = Array.isArray(list) ? list : [];
      return arr.find((p) => String(p?.slot?.id || "") === String(petId)) ?? null;
    } catch {
      return null;
    }
  }
  function findFirstCompatibleInvItem(allowed, inv) {
    const arr = Array.isArray(inv) ? inv : [];
    for (const it of arr) {
      const species = String(it?.species || "");
      if (species && allowed.has(species)) return it;
    }
    return null;
  }
  function _emitTrigger(payload) {
    try {
      _userTriggerCb?.(payload);
    } catch {
    }
  }
  async function _evaluatePet(pet) {
    const petId = String(pet?.slot?.id || "");
    if (!petId) return;
    const ov = PetsService.getOverride(petId);
    if (!ov.enabled) {
      _belowThreshold.set(petId, false);
      return;
    }
    const hungerPct = PetsService.getHungerPctFor(pet);
    const thresholdPct = Math.max(1, Math.min(100, ov.thresholdPct | 0 || 10));
    const previouslyBelow = _belowThreshold.get(petId) === true;
    const nowBelow = hungerPct < thresholdPct;
    if (nowBelow && !previouslyBelow) {
      let allowedSet;
      try {
        allowedSet = await PetsService.getPetAllowedCrops(petId);
      } catch {
        const species = String(pet?.slot?.petSpecies || "");
        allowedSet = new Set(PetsService.getCompatibleCropsForSpecies(species));
      }
      const allowed = Array.from(allowedSet);
      let chosen = null;
      let didUnfavorite = false;
      try {
        const [invRaw, favIdsRaw] = await Promise.all([
          PlayerService.getCropInventoryState(),
          PlayerService.getFavoriteIds?.() ?? []
        ]);
        const inv = Array.isArray(invRaw) ? invRaw : [];
        const favSet = new Set(Array.isArray(favIdsRaw) ? favIdsRaw : []);
        const invNonFav = inv.filter((it) => !favSet.has(String(it?.id)));
        chosen = findFirstCompatibleInvItem(allowedSet, invNonFav);
        if (chosen?.id && PlayerService.feedPet) {
          try {
            await PlayerService.feedPet(petId, chosen.id);
          } catch {
          }
        }
      } catch {
      }
      _emitTrigger({
        pet,
        petId,
        species: String(pet?.slot?.petSpecies || ""),
        hungerPct,
        thresholdPct,
        allowedCrops: allowed,
        chosenItem: chosen,
        didUnfavorite
      });
    }
    _belowThreshold.set(petId, nowBelow);
  }
  async function _evaluateAll() {
    const arr = Array.isArray(_currentPets) ? _currentPets : [];
    for (const p of arr) {
      try {
        await _evaluatePet(p);
      } catch {
      }
    }
  }
  var PetsService = {
    /* --------- Player-facing (UI list/subscribe) --------- */
    getPets() {
      return PlayerService.getPets();
    },
    onPetsChange(cb) {
      return PlayerService.onPetsChange(cb);
    },
    onPetsChangeNow(cb) {
      return PlayerService.onPetsChangeNow(cb);
    },
    /* ------------------------- Abilities utils ------------------------- */
    getAbilityName(id) {
      return _abilityName(id);
    },
    getAbilityNameWithoutLevel(id) {
      return _abilityNameWithoutLevel(id);
    },
    /* ------------------------- Autofeed + per-pet UI state ------------------------- */
    setUIState(next) {
      const cur = loadUIState();
      const merged = { ...cur, ...next || {} };
      saveUIState(merged);
      return merged;
    },
    setSelectedPet(id) {
      return this.setUIState({ selectedPetId: id });
    },
    getSelectedPetId() {
      return loadUIState().selectedPetId ?? null;
    },
    getOverride(petId) {
      const all = loadOverrides();
      return cloneOverride(all[petId]);
    },
    setOverride(petId, patch) {
      const all = loadOverrides();
      const cur = cloneOverride(all[petId]);
      const next = {
        enabled: patch.enabled ?? cur.enabled,
        thresholdPct: Number.isFinite(patch.thresholdPct) ? Math.min(100, Math.max(1, Number(patch.thresholdPct))) : cur.thresholdPct,
        crops: { ...cur.crops, ...patch.crops || {} }
      };
      all[petId] = next;
      saveOverrides(all);
      void _evaluateAll();
      return next;
    },
    updateOverride(petId, fn) {
      const all = loadOverrides();
      const cur = cloneOverride(all[petId]);
      const next = cloneOverride(fn(cur));
      all[petId] = next;
      saveOverrides(all);
      void _evaluateAll();
      return next;
    },
    async setPetAutofeedEnabled(petId, enabled) {
      return this.setOverride(petId, { enabled: !!enabled });
    },
    getPetAutofeedEnabled(petId) {
      return this.getOverride(petId).enabled;
    },
    async setPetAutofeedThresholdPct(petId, pct) {
      const v = Math.min(100, Math.max(1, Math.floor(Number(pct) || 10)));
      return this.setOverride(petId, { thresholdPct: v });
    },
    getPetAutofeedThresholdPct(petId) {
      return this.getOverride(petId).thresholdPct;
    },
    async setPetAllowedCrop(petId, crop, allowed) {
      return this.updateOverride(petId, (cur) => {
        const next = cloneOverride(cur);
        const entry = next.crops[crop] ?? { allowed: true };
        next.crops[crop] = { allowed: allowed ?? entry.allowed };
        return next;
      });
    },
    async getPetAllowedCrops(petId) {
      const ov = this.getOverride(petId);
      const pet = await findPetById(petId);
      const species = pet?.slot?.petSpecies || "";
      const compatibles = this.getCompatibleCropsForSpecies(species);
      const allowed = /* @__PURE__ */ new Set();
      for (const c of compatibles) {
        const rule = ov.crops[c];
        if (rule ? !!rule.allowed : true) allowed.add(c);
      }
      return allowed;
    },
    getCompatibleCropsForSpecies(species) {
      return getCompatibleCropsFromData(species);
    },
    getMaxHungerForSpecies(species) {
      return getMaxHungerFromData(species);
    },
    getHungerPctFor(pet) {
      const cur = Number(pet?.slot?.hunger) || 0;
      const species = String(pet?.slot?.petSpecies || "");
      const max = this.getMaxHungerForSpecies(species);
      const pct = cur / max * 100;
      return +clampPct(pct).toFixed(1);
    },
    async startAutofeedWatcher(onTrigger) {
      _userTriggerCb = onTrigger ?? null;
      const stop2 = await PlayerService.onPetsChangeNow((arr) => {
        _currentPets = Array.isArray(arr) ? arr.slice() : [];
        void _evaluateAll();
      });
      return () => {
        try {
          stop2();
        } catch {
        }
        _currentPets = [];
        _belowThreshold.clear();
        _userTriggerCb = null;
      };
    },
    /* ------------------------- Teams (UI-less core used by UI) ------------------------- */
    _teams: loadTeams(),
    _teamSubs: /* @__PURE__ */ new Set(),
    _notifyTeamSubs() {
      const snap = this.getTeams();
      this._teamSubs.forEach((fn) => {
        try {
          fn(snap);
        } catch {
        }
      });
    },
    getTeams() {
      return Array.isArray(this._teams) ? this._teams.map((t) => ({ ...t, slots: t.slots.slice(0, 3) })) : [];
    },
    onTeamsChange(cb) {
      this._teamSubs.add(cb);
      try {
        cb(this.getTeams());
      } catch {
      }
      return () => {
        this._teamSubs.delete(cb);
      };
    },
    async onTeamsChangeNow(cb) {
      const unsub = this.onTeamsChange(cb);
      try {
        cb(this.getTeams());
      } catch {
      }
      return unsub;
    },
    createTeam(name) {
      const t = { id: _uid(), name: name?.trim() || `Team ${this._teams.length + 1}`, slots: [null, null, null] };
      this._teams.push(t);
      saveTeams(this._teams);
      this._notifyTeamSubs();
      return t;
    },
    deleteTeam(teamId) {
      const i = this._teams.findIndex((t) => t.id === teamId);
      if (i < 0) return false;
      this._teams.splice(i, 1);
      saveTeams(this._teams);
      this._notifyTeamSubs();
      return true;
    },
    saveTeam(patch) {
      const i = this._teams.findIndex((t) => t.id === patch.id);
      if (i < 0) return null;
      const cur = this._teams[i];
      const next = {
        id: cur.id,
        name: typeof patch.name === "string" ? patch.name : cur.name,
        slots: Array.isArray(patch.slots) ? patch.slots.slice(0, 3) : cur.slots
      };
      this._teams[i] = next;
      saveTeams(this._teams);
      this._notifyTeamSubs();
      return next;
    },
    setTeamsOrder(ids) {
      const byId = new Map(this._teams.map((t) => [t.id, t]));
      const next = [];
      for (const id of ids) {
        const t = byId.get(id);
        if (t) {
          next.push(t);
          byId.delete(id);
        }
      }
      for (const rest of byId.values()) next.push(rest);
      this._teams = next;
      saveTeams(this._teams);
      this._notifyTeamSubs();
    },
    getTeamById(teamId) {
      const t = this._teams.find((t2) => t2.id === teamId) || null;
      return t ? { ...t, slots: t.slots.slice(0, 3) } : null;
    },
    getTeamSearch(teamId) {
      return _teamSearch[teamId] || "";
    },
    setTeamSearch(teamId, q) {
      _teamSearch[teamId] = (q || "").trim();
      _saveTeamSearchMap(_teamSearch);
    },
    /* ------------------------- Inventory filters + pickers ------------------------- */
    async getInventoryPets() {
      await _ensureInventoryWatchersStarted();
      return _invPetsCache.slice();
    },
    async buildFilteredInventoryForTeam(teamId, opts) {
      await _ensureInventoryWatchersStarted();
      const { mode, value } = _parseTeamSearch(this.getTeamSearch(teamId) || "");
      let list = await this.getInventoryPets();
      if (mode === "ability" && value) {
        const idSet = await _abilityNameToPresentIds(value);
        list = idSet.size ? list.filter((p) => Array.isArray(p.abilities) && p.abilities.some((a) => idSet.has(a))) : [];
      } else if (mode === "species" && value) {
        const vv = value.toLowerCase();
        list = list.filter((p) => (p.petSpecies || "").toLowerCase() === vv);
      } else if (value) {
        const q = value.toLowerCase();
        list = list.filter(
          (p) => _s(p.id).includes(q) || _s(p.petSpecies).includes(q) || _s(p.name).includes(q) || Array.isArray(p.abilities) && p.abilities.some((a) => _s(a).includes(q) || _s(_abilityName(a)).includes(q)) || Array.isArray(p.mutations) && p.mutations.some((m) => _s(m).includes(q))
        );
      }
      if (opts?.excludeIds?.size) {
        const ex = opts.excludeIds;
        list = list.filter((p) => !ex.has(p.id));
      }
      const items = list.map(_invPetToRawItem);
      let favoritedItemIds = [];
      try {
        const favAll = await Atoms.inventory.favoriteIds.get().catch(() => []);
        const keep = new Set(list.map((p) => p.id));
        favoritedItemIds = (favAll || []).filter((id) => keep.has(id));
      } catch {
      }
      return { items, favoritedItemIds };
    },
    async buildFilteredInventoryByQuery(query, opts) {
      await _ensureInventoryWatchersStarted();
      const q = (query || "").toLowerCase().trim();
      let list = await this.getInventoryPets();
      if (q) {
        list = list.filter(
          (p) => _s(p.id).includes(q) || _s(p.petSpecies).includes(q) || _s(p.name).includes(q) || Array.isArray(p.abilities) && p.abilities.some((a) => _s(a).includes(q) || _s(_abilityName(a)).includes(q)) || Array.isArray(p.mutations) && p.mutations.some((m) => _s(m).includes(q))
        );
      }
      if (opts?.excludeIds?.size) {
        const ex = opts.excludeIds;
        list = list.filter((p) => !ex.has(p.id));
      }
      const items = list.map(_invPetToRawItem);
      let favoritedItemIds = [];
      try {
        const favAll = await Atoms.inventory.favoriteIds.get().catch(() => []);
        const keep = new Set(list.map((p) => p.id));
        favoritedItemIds = (favAll || []).filter((id) => keep.has(id));
      } catch {
      }
      return { items, favoritedItemIds };
    },
    async chooseSlotPet(teamId, slotIndex, searchOverride) {
      const idx = Math.max(0, Math.min(2, Math.floor(slotIndex || 0)));
      const team = this.getTeamById(teamId);
      if (!team) return null;
      const exclude = /* @__PURE__ */ new Set();
      team.slots.forEach((id, i) => {
        if (i !== idx && id) exclude.add(String(id));
      });
      const payload = searchOverride && searchOverride.trim().length ? await this.buildFilteredInventoryByQuery(searchOverride, { excludeIds: exclude }) : await this.buildFilteredInventoryForTeam(teamId, { excludeIds: exclude });
      const items = Array.isArray(payload?.items) ? payload.items : [];
      try {
        const rawHutch = await myPetHutchPetItems.get();
        const hutchArr = Array.isArray(rawHutch) ? rawHutch : [];
        let hutchPets = hutchArr.map((it) => _inventoryItemToPet(it)).filter((p) => !!p);
        const teamSearch = this.getTeamSearch(teamId) || "";
        if (searchOverride && searchOverride.trim().length) {
          const q = searchOverride.toLowerCase().trim();
          if (q) {
            hutchPets = hutchPets.filter(
              (p) => _s(p.id).includes(q) || _s(p.petSpecies).includes(q) || _s(p.name).includes(q) || Array.isArray(p.abilities) && p.abilities.some((a) => _s(a).includes(q) || _s(_abilityName(a)).includes(q)) || Array.isArray(p.mutations) && p.mutations.some((m) => _s(m).includes(q))
            );
          }
        } else if (teamSearch && teamSearch.trim().length) {
          const { mode, value } = _parseTeamSearch(teamSearch);
          if (mode === "ability" && value) {
            const idSet = await _abilityNameToPresentIds(value);
            hutchPets = idSet.size ? hutchPets.filter((p) => Array.isArray(p.abilities) && p.abilities.some((a) => idSet.has(a))) : [];
          } else if (mode === "species" && value) {
            const vv = value.toLowerCase();
            hutchPets = hutchPets.filter((p) => (p.petSpecies || "").toLowerCase() === vv);
          } else if (value) {
            const q = value.toLowerCase();
            hutchPets = hutchPets.filter(
              (p) => _s(p.id).includes(q) || _s(p.petSpecies).includes(q) || _s(p.name).includes(q) || Array.isArray(p.abilities) && p.abilities.some((a) => _s(a).includes(q) || _s(_abilityName(a)).includes(q)) || Array.isArray(p.mutations) && p.mutations.some((m) => _s(m).includes(q))
            );
          }
        }
        if (exclude.size) hutchPets = hutchPets.filter((p) => !exclude.has(p.id));
        const seen = new Set(items.map((it) => String(it?.id ?? "")));
        for (const p of hutchPets) {
          if (!seen.has(p.id)) {
            items.push(_invPetToRawItem(p));
            seen.add(p.id);
          }
        }
      } catch {
      }
      if (!items.length) return null;
      await fakeInventoryShow(payload, { open: true });
      const selIndex = await _waitValidatedInventoryIndex(2e4);
      await closeInventoryPanel();
      if (selIndex == null || selIndex < 0 || selIndex >= items.length) return null;
      const chosenPet = _inventoryItemToPet(items[selIndex]);
      if (!chosenPet) return null;
      const next = team.slots.slice(0, 3);
      next[idx] = String(chosenPet.id);
      this.saveTeam({ id: team.id, slots: next });
      try {
        await clearHandSelection();
      } catch {
      }
      return chosenPet;
    },
    async pickPetViaFakeInventory(search) {
      const payload = await this.buildFilteredInventoryByQuery(search || "");
      const items = Array.isArray(payload?.items) ? payload.items : [];
      if (!items.length) return null;
      await fakeInventoryShow(payload, { open: true });
      const selIndex = await _waitValidatedInventoryIndex(2e4);
      await closeInventoryPanel();
      if (selIndex == null || selIndex < 0 || selIndex >= items.length) return null;
      await clearHandSelection();
      return _inventoryItemToPet(items[selIndex]);
    },
    /* ------------------------- Team switching ------------------------- */
    async useTeam(teamId) {
      const t = this.getTeams().find((tt) => tt.id === teamId) || null;
      if (!t) throw new Error("Team not found");
      const targetInvIds = (t.slots || []).filter((x) => typeof x === "string" && x.length > 0).slice(0, 3);
      const targetSet = new Set(targetInvIds);
      let activeSlots = await _getActivePetSlotIds();
      const HUTCH_MAX = 25;
      let hutchCount = (() => {
        try {
          return Number(myNumPetHutchItems.get());
        } catch {
          return 0;
        }
      })();
      try {
        hutchCount = Number(await myNumPetHutchItems.get());
      } catch {
        hutchCount = 0;
      }
      let freeHutch = Math.max(0, HUTCH_MAX - (Number.isFinite(hutchCount) ? hutchCount : 0));
      let hutchItemsSet = /* @__PURE__ */ new Set();
      try {
        const hutchItems = await myPetHutchPetItems.get();
        if (Array.isArray(hutchItems)) {
          hutchItemsSet = new Set(hutchItems.map((it) => String(it?.id ?? "")));
        }
      } catch {
      }
      const missingFromActive = targetInvIds.filter((id) => !activeSlots.includes(id));
      const missingFromHutch = missingFromActive.filter((id) => hutchItemsSet.has(id));
      if (missingFromHutch.length > 0) {
        let invFull = false;
        try {
          invFull = !!await isMyInventoryAtMaxLength.get();
        } catch {
          invFull = false;
        }
        if (invFull && freeHutch <= 0) {
          try {
            await toastSimple("Inventory Full", "Cannot equip team: required pets are in the Pet Hutch and your inventory is full.");
          } catch {
          }
          markTeamAsUsed(teamId);
          return { swapped: 0, placed: 0, skipped: targetInvIds.length };
        }
      }
      let swapped = 0, placed = 0, skipped = 0;
      for (const invId of targetInvIds) {
        const isAlreadyActive = activeSlots.includes(invId);
        if (isAlreadyActive) {
          skipped++;
          continue;
        }
        const livesInHutch = hutchItemsSet.has(invId);
        if (livesInHutch) {
          let invFull = false;
          try {
            invFull = !!await isMyInventoryAtMaxLength.get();
          } catch {
            invFull = false;
          }
          if (invFull) {
            if (freeHutch > 0) {
              try {
                const invPets = await this.getInventoryPets();
                const invPet = (Array.isArray(invPets) ? invPets : []).find((p) => {
                  const id = String(p?.id || "");
                  return id && !hutchItemsSet.has(id) && !activeSlots.includes(id) && !targetSet.has(id);
                });
                if (invPet) {
                  await PlayerService.putItemInStorage(invPet.id, "PetHutch");
                  freeHutch = Math.max(0, freeHutch - 1);
                } else {
                  try {
                    await toastSimple("Inventory Full", "Cannot equip team: no free slot to retrieve a pet from the Pet Hutch.", "error");
                  } catch {
                  }
                  markTeamAsUsed(teamId);
                  return { swapped, placed, skipped };
                }
              } catch {
                try {
                  await toastSimple("Inventory Full", "Cannot equip team: failed to free up a slot.", "error");
                } catch {
                }
                markTeamAsUsed(teamId);
                return { swapped, placed, skipped };
              }
            } else {
              try {
                await toastSimple("Inventory Full", "Cannot equip team: required pets are in the Pet Hutch and your inventory is full.", "error");
              } catch {
              }
              markTeamAsUsed(teamId);
              return { swapped, placed, skipped };
            }
          }
          try {
            await PlayerService.retrieveItemFromStorage(invId, "PetHutch");
            hutchItemsSet.delete(invId);
            freeHutch = Math.min(25, freeHutch + 1);
          } catch {
            continue;
          }
        }
        const offTargetActive = activeSlots.find((id) => !targetSet.has(id));
        if (offTargetActive) {
          try {
            await PlayerService.swapPet(offTargetActive, invId);
            swapped++;
            if (freeHutch > 0) {
              try {
                await PlayerService.putItemInStorage(offTargetActive, "PetHutch");
                freeHutch = Math.max(0, freeHutch - 1);
              } catch {
              }
            }
            activeSlots = activeSlots.filter((x) => x !== offTargetActive);
            activeSlots.push(invId);
          } catch {
            try {
              await PlayerService.placePet(invId, { x: 0, y: 0 }, "Boardwalk", 64);
              placed++;
              activeSlots.push(invId);
            } catch {
            }
          }
        } else {
          try {
            await PlayerService.placePet(invId, { x: 0, y: 0 }, "Boardwalk", 64);
            placed++;
            activeSlots.push(invId);
          } catch {
          }
        }
      }
      try {
        try {
          hutchCount = Number(await myNumPetHutchItems.get());
        } catch {
        }
        freeHutch = Math.max(0, HUTCH_MAX - (Number.isFinite(hutchCount) ? hutchCount : 0));
        let leftovers = activeSlots.filter((id) => !targetSet.has(id));
        for (const slotId of leftovers) {
          if (freeHutch <= 0) break;
          try {
            await PlayerService.storePet(slotId);
            await PlayerService.putItemInStorage(slotId, "PetHutch");
            freeHutch = Math.max(0, freeHutch - 1);
            activeSlots = activeSlots.filter((x) => x !== slotId);
          } catch {
          }
        }
      } catch {
      }
      const res = await _applyTeam(targetInvIds);
      markTeamAsUsed(teamId);
      return res;
    },
    /* ------------------------- Ability logs ------------------------- */
    _logs: [],
    _logsMax: 500,
    _seenPerfByPet: /* @__PURE__ */ new Map(),
    _logSubs: /* @__PURE__ */ new Set(),
    _logsCutoffMs: 0,
    _logsCutoffSkewMs: 1500,
    _logsStorageKey: PATH_PETS_ABILITY_LOGS,
    _logsSessionStart: Date.now(),
    _extractAbilityValue(abilityId, rawData) {
      const num = (value) => {
        const parsed = Number(value);
        return Number.isFinite(parsed) ? Math.max(0, parsed) : 0;
      };
      const data = rawData ?? {};
      const base = petAbilities[abilityId]?.baseParameters ?? {};
      switch (abilityId) {
        case "CoinFinderI":
        case "CoinFinderII":
        case "CoinFinderIII": {
          const value = data["coinsFound"] ?? data["coins"] ?? 0;
          return num(value);
        }
        case "SellBoostI":
        case "SellBoostII":
        case "SellBoostIII":
        case "SellBoostIV": {
          const value = data["bonusCoins"] ?? data["coinsEarned"] ?? 0;
          return num(value);
        }
        case "ProduceEater":
          return num(data["sellPrice"] ?? 0);
        case "EggGrowthBoost":
        case "EggGrowthBoostII_NEW":
        case "EggGrowthBoostII": {
          const minutes = data["eggGrowthTimeReductionMinutes"] ?? data["minutesReduced"] ?? data["reductionMinutes"] ?? base["eggGrowthTimeReductionMinutes"] ?? 0;
          return num(minutes) * 60 * 1e3;
        }
        case "PlantGrowthBoost":
        case "PlantGrowthBoostII": {
          const minutes = data["minutesReduced"] ?? data["reductionMinutes"] ?? data["plantGrowthReductionMinutes"] ?? base["plantGrowthReductionMinutes"] ?? 0;
          return num(minutes) * 60 * 1e3;
        }
        case "PetXpBoost":
        case "PetXpBoostII": {
          const xp = data["bonusXp"] ?? base["bonusXp"] ?? 0;
          return num(xp);
        }
        case "PetAgeBoost":
        case "PetAgeBoostII": {
          const xp = data["bonusXp"] ?? base["bonusXp"] ?? 0;
          return num(xp);
        }
        case "PetHatchSizeBoost":
        case "PetHatchSizeBoostII": {
          const strength = data["strengthIncrease"] ?? 0;
          return num(strength);
        }
        case "HungerRestore":
        case "HungerRestoreII": {
          const amount = data["hungerRestoreAmount"] ?? data["hungerRestoredPercentage"] ?? base["hungerRestorePercentage"] ?? 0;
          return num(amount);
        }
        default:
          return 0;
      }
    },
    async startAbilityLogsWatcher() {
      await _ensureInventoryWatchersStarted();
      const indexInfosByPetId = (list) => {
        const out = {};
        const arr = Array.isArray(list) ? list : [];
        for (const e of arr) {
          const id = String(e?.slot?.id ?? e?.id ?? "");
          if (id) out[id] = e;
        }
        return out;
      };
      let myInfosMap = {};
      try {
        myInfosMap = indexInfosByPetId(await Atoms.pets.myPetInfos.get());
      } catch {
      }
      let stopInfos = null;
      try {
        stopInfos = await Atoms.pets.myPetInfos.onChange((list) => {
          try {
            myInfosMap = indexInfosByPetId(list);
          } catch {
          }
        });
      } catch {
      }
      const extractFlat = (src) => {
        const out = {};
        if (!src || typeof src !== "object") return out;
        const obj = src;
        for (const petId of Object.keys(obj)) {
          const entry = obj[petId] ?? {};
          const lat = entry.lastAbilityTrigger ?? null;
          let rawH = entry.hungerPct ?? entry.hunger_percentage ?? entry.hunger ?? entry.stats?.hungerPct ?? entry.stats?.hunger?.pct ?? entry.stats?.hunger?.percent ?? null;
          if (rawH == null) {
            const info = myInfosMap[petId];
            rawH = info?.hungerPct ?? info?.hunger_percentage ?? info?.hunger ?? info?.slot?.hungerPct ?? info?.slot?.hunger ?? info?.stats?.hungerPct ?? info?.stats?.hunger?.pct ?? info?.stats?.hunger?.percent ?? null;
          }
          let hungerPct = Number.isFinite(Number(rawH)) ? Number(rawH) : null;
          if (hungerPct != null && hungerPct > 0 && hungerPct <= 1) hungerPct *= 100;
          out[petId] = {
            petId,
            abilityId: lat?.abilityId ?? null,
            performedAt: Number.isFinite(lat?.performedAt) ? lat.performedAt : null,
            data: lat?.data ?? null,
            position: entry.position ?? null,
            hungerPct
          };
        }
        return out;
      };
      try {
        this._ingestAbilityMap(extractFlat(await Atoms.pets.myPetSlotInfos.get()));
      } catch {
      }
      const stopSlots = await Atoms.pets.myPetSlotInfos.onChange((src) => {
        try {
          this._ingestAbilityMap(extractFlat(src));
        } catch {
        }
      });
      return () => {
        try {
          stopSlots();
        } catch {
        }
        try {
          stopInfos?.();
        } catch {
        }
      };
    },
    getAbilityLogs(opts) {
      const ids = opts?.abilityIds && opts.abilityIds.length ? new Set(opts.abilityIds) : null;
      const since = Number.isFinite(opts?.since) ? opts.since : 0;
      const lim = Math.max(0, Math.floor(opts?.limit ?? 0));
      let arr = this._logs.filter(
        (e) => (since ? e.performedAt >= since : true) && (ids ? ids.has(e.abilityId) : true)
      );
      arr = arr.sort((a, b) => b.performedAt - a.performedAt);
      return lim ? arr.slice(0, lim) : arr;
    },
    getAbilityLogsSessionStart() {
      return this._logsSessionStart;
    },
    onAbilityLogs(cb) {
      this._logSubs.add(cb);
      try {
        cb(this.getAbilityLogs());
      } catch {
      }
      return () => {
        this._logSubs.delete(cb);
      };
    },
    getSeenAbilityIds() {
      const set2 = /* @__PURE__ */ new Set();
      for (const e of this._logs) set2.add(e.abilityId);
      return Array.from(set2).sort();
    },
    clearAbilityLogs() {
      this._logs.length = 0;
      this._seenPerfByPet.clear();
      this._logsCutoffMs = Date.now();
      this._notifyLogSubs();
      this._persistAbilityLogs();
    },
    _notifyLogSubs() {
      const snap = this.getAbilityLogs();
      this._logSubs.forEach((fn) => {
        try {
          fn(snap);
        } catch {
        }
      });
    },
    _pushLog(e) {
      this._logs.push(e);
      if (this._logs.length > this._logsMax) {
        this._logs.splice(0, this._logs.length - this._logsMax);
      }
      this._notifyLogSubs();
      this._persistAbilityLogs();
    },
    _persistAbilityLogs() {
      try {
        const payload = {
          version: 1,
          cutoff: this._logsCutoffMs,
          logs: this._logs.map((entry) => ({
            petId: entry.petId,
            species: entry.species ?? null,
            name: entry.name ?? null,
            abilityId: entry.abilityId,
            abilityName: entry.abilityName,
            data: entry.data,
            performedAt: entry.performedAt,
            time12: entry.time12
          }))
        };
        writeAriesPath(PATH_PETS_ABILITY_LOGS, payload);
      } catch {
      }
    },
    _restoreAbilityLogsFromStorage() {
      try {
        const parsed = readAriesPath(PATH_PETS_ABILITY_LOGS);
        if (!parsed || typeof parsed !== "object") return;
        const logsRaw = Array.isArray(parsed.logs) ? parsed.logs : [];
        const restored = [];
        for (const item of logsRaw) {
          if (!item || typeof item !== "object") continue;
          const abilityId = typeof item.abilityId === "string" ? String(item.abilityId) : "";
          const performedAt = Number(item.performedAt) || 0;
          if (!abilityId || !performedAt) continue;
          restored.push({
            petId: typeof item.petId === "string" ? String(item.petId) : "",
            species: typeof item.species === "string" && item.species ? String(item.species) : void 0,
            name: typeof item.name === "string" && item.name ? String(item.name) : void 0,
            abilityId,
            abilityName: typeof item.abilityName === "string" && item.abilityName ? String(item.abilityName) : abilityId,
            data: typeof item.data === "string" ? String(item.data) : item.data,
            performedAt,
            time12: typeof item.time12 === "string" && item.time12 ? String(item.time12) : new Date(performedAt).toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true })
          });
        }
        restored.sort((a, b) => a.performedAt - b.performedAt);
        this._logs = restored.slice(-this._logsMax);
        this._seenPerfByPet.clear();
        for (const entry of this._logs) {
          const prev = this._seenPerfByPet.get(entry.petId) || 0;
          if (entry.performedAt > prev) this._seenPerfByPet.set(entry.petId, entry.performedAt);
        }
        const cutoff = Number(parsed.cutoff);
        if (Number.isFinite(cutoff) && cutoff > 0) this._logsCutoffMs = cutoff;
      } catch {
      }
    },
    _ingestAbilityMap(map2) {
      if (!map2 || typeof map2 !== "object") return;
      const abilityDisplayName = (abilityId) => {
        const def = petAbilities[abilityId];
        return def?.name && def.name.trim() || abilityId;
      };
      const fmtTime12 = (ms) => new Date(ms).toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true });
      const fmtInt = (n) => Number.isFinite(Number(n)) ? Math.round(Number(n)).toLocaleString("en-US") : "0";
      const fmtPct0 = (n) => `${Number.isFinite(Number(n)) ? Number(n).toFixed(0) : "0"}%`;
      const fmtMin1 = (n) => `${Number.isFinite(Number(n)) ? Number(n).toFixed(1) : "0.0"} min`;
      const formatDetails = (abilityId, data) => {
        const d = data ?? {};
        const base = petAbilities[abilityId]?.baseParameters ?? {};
        const label2 = (value, fallback) => {
          const s = typeof value === "string" ? value.trim() : "";
          return s || fallback;
        };
        const percentOr = (value, fallback) => value != null ? value : fallback;
        const cropNameFromGrowSlot = (src) => {
          if (!src || typeof src !== "object") return null;
          const species = src.species;
          if (typeof species !== "string" || !species.trim()) return null;
          const key2 = species.trim();
          const variants = [key2, key2.charAt(0).toUpperCase() + key2.slice(1), key2.toLowerCase()];
          for (const v of variants) {
            const name = plantCatalog?.[v]?.crop?.name;
            if (typeof name === "string" && name.trim()) return name;
          }
          return null;
        };
        switch (abilityId) {
          case "CoinFinderI":
          case "CoinFinderII":
          case "CoinFinderIII": {
            const coins = d["coinsFound"] ?? d["coins"] ?? base["baseMaxCoinsFindable"];
            return coins != null ? `+ ${fmtInt(coins)} coins` : "Coins found";
          }
          case "SeedFinderI":
          case "SeedFinderII":
          case "SeedFinderIII":
          case "SeedFinderIV": {
            const seed = label2(d["seedName"], "seed");
            return `x1 ${seed}`;
          }
          case "HungerRestore":
          case "HungerRestoreII": {
            const whoRaw = d["petName"];
            const who = label2(whoRaw === "itself" ? "itself" : whoRaw, "pet");
            const amount = d["hungerRestoreAmount"];
            const pct = percentOr(d["hungerRestoredPercentage"], base["hungerRestorePercentage"]);
            if (amount != null) return `${who}: +${fmtInt(amount)} hunger`;
            return pct != null ? `${who}: ${fmtPct0(pct)}` : `${who}: Hunger restored`;
          }
          case "DoubleHarvest": {
            const crop = label2(d["cropName"], "crop");
            return `+1 ${crop}`;
          }
          case "DoubleHatch": {
            const pet = label2(d["petName"], "pet");
            return `+1 ${pet}`;
          }
          case "ProduceEater": {
            const name = label2(d["cropName"], "crop");
            if (d["sellPrice"] != null) return `Sold ${name}: +${fmtInt(d["sellPrice"])} coins`;
            const pct = base["cropSellPriceIncreasePercentage"];
            return pct != null ? `Eaten: ${name} (+${fmtPct0(pct)} value)` : `Eaten: ${name}`;
          }
          case "ProduceRefund": {
            const n = d["numCropsRefunded"] ?? d["numItemsRefunded"];
            return n != null ? `+ ${fmtInt(n)} crop(s)` : "Crops refunded";
          }
          case "SellBoostI":
          case "SellBoostII":
          case "SellBoostIII":
          case "SellBoostIV": {
            if (d["bonusCoins"] != null) return `Sale bonus: +${fmtInt(d["bonusCoins"])} coins`;
            const pct = base["cropSellPriceIncreasePercentage"];
            return pct != null ? `+ ${fmtPct0(pct)}` : "Sale bonus";
          }
          case "GoldGranter":
          case "RainbowGranter": {
            const cropFromSlot = cropNameFromGrowSlot(d["growSlot"]);
            const crop = label2(d["cropName"], cropFromSlot ?? "crop");
            const mut = abilityId === "GoldGranter" ? "Gold" : "Rainbow";
            return `${crop}`;
          }
          case "RainDance": {
            const cropFromSlot = cropNameFromGrowSlot(d["growSlot"]);
            const crop = label2(d["cropName"], cropFromSlot ?? "crop");
            const muts = Array.isArray(d.mutations) ? d.mutations : Array.isArray(d.growSlot?.mutations) ? d.growSlot.mutations : [];
            const hasFrozen = muts.some((m) => typeof m === "string" && m.toLowerCase() === "frozen");
            return hasFrozen ? `${crop}: Chilled + Frozen` : `${crop}: Wet`;
          }
          case "ProduceScaleBoost":
          case "ProduceScaleBoostII": {
            const inc = d["scaleIncreasePercentage"] ?? d["cropScaleIncreasePercentage"] ?? base["scaleIncreasePercentage"];
            return inc != null ? `+ ${fmtPct0(inc)}` : "Crop size boosted";
          }
          case "ProduceMutationBoost":
          case "ProduceMutationBoostII":
          case "PetMutationBoost":
          case "PetMutationBoostII": {
            const inc = percentOr(d["mutationChanceIncreasePercentage"], base["mutationChanceIncreasePercentage"]);
            return inc != null ? `+ ${fmtPct0(inc)} mutation chance` : "Mutation chance up";
          }
          case "EggGrowthBoost":
          case "EggGrowthBoostII_NEW":
          case "EggGrowthBoostII": {
            const mins = d["minutesReduced"] ?? d["eggGrowthTimeReductionMinutes"] ?? base["eggGrowthTimeReductionMinutes"];
            return mins != null ? `- ${fmtMin1(mins)}` : "Egg growth reduced";
          }
          case "PlantGrowthBoost":
          case "PlantGrowthBoostII": {
            const mins = d["minutesReduced"] ?? d["reductionMinutes"] ?? base["plantGrowthReductionMinutes"];
            return mins != null ? `- ${fmtMin1(mins)}` : "Plant growth reduced";
          }
          case "PetXpBoost":
          case "PetXpBoostII": {
            const xp = d["bonusXp"] ?? base["bonusXp"];
            return `+ ${fmtInt(xp)} XP`;
          }
          case "PetAgeBoost":
          case "PetAgeBoostII": {
            const xp = d["bonusXp"] ?? base["bonusXp"];
            const who = label2(d["petName"], "pet");
            return `+ ${fmtInt(xp)} XP (${who})`;
          }
          case "PetHatchSizeBoost":
          case "PetHatchSizeBoostII": {
            const who = label2(d["petName"], "pet");
            if (d["strengthIncrease"] != null) return `+${fmtInt(d["strengthIncrease"])} strength (${who})`;
            const pct = base["maxStrengthIncreasePercentage"];
            return pct != null ? `+ ${fmtPct0(pct)} (${who})` : `Strength increased (${who})`;
          }
          case "HungerBoost":
          case "HungerBoostII": {
            const pct = base["hungerDepletionRateDecreasePercentage"];
            return pct != null ? `- ${fmtPct0(pct)} hunger drain` : "Hunger reduced";
          }
          case "PetRefund":
          case "PetRefundII": {
            const egg = d["eggName"] ?? null;
            return egg ? `x1 ${egg}` : `Pet refunded as egg`;
          }
          case "Copycat":
            return "Copied another ability";
          case "MoonKisser":
            return "Amber mutations empowered";
          case "DawnKisser":
            return "Dawn mutations empowered";
          default: {
            const meta = petAbilities[abilityId];
            if (d && typeof d === "object" && Object.keys(d).length) return JSON.stringify(d);
            return meta?.description || "\u2014";
          }
        }
      };
      const EPS = 1e-6;
      for (const petId of Object.keys(map2)) {
        const entry = map2[petId];
        if (!entry || typeof entry !== "object") continue;
        const abilityId = entry.abilityId ?? null;
        const performedAtNum = Number(entry.performedAt) || 0;
        if (!abilityId || !performedAtNum) continue;
        const prev = this._seenPerfByPet.get(petId) || 0;
        if (performedAtNum <= prev) continue;
        if (this._logsCutoffMs && performedAtNum < this._logsCutoffMs - this._logsCutoffSkewMs) {
          this._seenPerfByPet.set(petId, performedAtNum);
          continue;
        }
        let hungerPct = Number.isFinite(Number(entry.hungerPct)) ? Number(entry.hungerPct) : null;
        if (hungerPct != null && hungerPct > 0 && hungerPct <= 1) hungerPct *= 100;
        if (hungerPct != null && hungerPct <= EPS) {
          this._seenPerfByPet.set(petId, performedAtNum);
          continue;
        }
        const pet = _invPetsCache.find((p) => String(p.id) === String(petId)) || null;
        const abilityIdStr = String(abilityId);
        const logLine = {
          petId,
          species: pet?.petSpecies || void 0,
          name: pet?.name ?? void 0,
          abilityId: abilityIdStr,
          abilityName: abilityDisplayName(abilityId),
          data: formatDetails(abilityIdStr, entry.data),
          performedAt: performedAtNum,
          time12: fmtTime12(performedAtNum)
        };
        this._seenPerfByPet.set(petId, performedAtNum);
        try {
          StatsService.incrementAbilityStat(abilityIdStr, "triggers");
          const abilityValue = this._extractAbilityValue(abilityIdStr, entry.data);
          if (abilityValue > 0) {
            StatsService.incrementAbilityStat(abilityIdStr, "totalValue", abilityValue);
          }
        } catch {
        }
        this._pushLog(logLine);
      }
    }
  };
  try {
    PetsService._restoreAbilityLogsFromStorage();
  } catch {
  }
  async function _getActivePetSlotIds() {
    try {
      const arr = await PlayerService.getPets();
      const list = Array.isArray(arr) ? arr : [];
      return list.map((p) => String(p?.slot?.id || "")).filter((id) => !!id).slice(0, 3);
    } catch {
      return [];
    }
  }
  async function _applyTeam(targetInvIds) {
    let activeSlots = await _getActivePetSlotIds();
    const targetSet = new Set(targetInvIds);
    const extras = activeSlots.filter((id) => !targetSet.has(id));
    const mustStore = Math.max(0, activeSlots.length - targetInvIds.length);
    if (mustStore > 0) {
      const toStore = extras.slice(0, mustStore);
      for (const itemId of toStore) {
        try {
          await PlayerService.storePet(itemId);
          activeSlots = activeSlots.filter((id) => id !== itemId);
        } catch {
        }
      }
    }
    const alreadyActive = /* @__PURE__ */ new Set();
    for (const invId of targetInvIds) if (activeSlots.includes(invId)) alreadyActive.add(invId);
    let swapped = 0, placed = 0, skipped = 0;
    if (alreadyActive.size) {
      activeSlots = activeSlots.filter((slotId) => !alreadyActive.has(slotId));
      skipped = alreadyActive.size;
    }
    const toDo = targetInvIds.filter((id) => !alreadyActive.has(id));
    for (const invId of toDo) {
      const slotId = activeSlots.shift();
      try {
        if (slotId) {
          await PlayerService.swapPet(slotId, invId);
          swapped++;
        } else {
          await PlayerService.placePet(invId, { x: 0, y: 0 }, "Boardwalk", 64);
          placed++;
        }
      } catch {
      }
    }
    return { swapped, placed, skipped };
  }

  // src/services/shops.ts
  var SHOP_KEYBINDS = [
    { id: "shops.seeds", modal: "seedShop" },
    { id: "shops.eggs", modal: "eggShop" },
    { id: "shops.decors", modal: "decorShop" },
    { id: "shops.tools", modal: "toolShop" }
  ];
  var shopKeybindsInstalled = false;
  function installShopKeybindsOnce() {
    if (shopKeybindsInstalled || typeof window === "undefined") return;
    shopKeybindsInstalled = true;
    window.addEventListener(
      "keydown",
      (event) => {
        if (shouldIgnoreKeydown(event)) return;
        for (const { id, modal } of SHOP_KEYBINDS) {
          if (!eventMatchesKeybind(id, event)) continue;
          event.preventDefault();
          event.stopPropagation();
          void Atoms.ui.activeModal.set(modal);
          break;
        }
      },
      true
    );
  }
  var ShopsService = {
    buyOne(kind, it) {
      if (kind === "seeds") {
        const species = it.species ?? it.name;
        if (species) {
          try {
            sendToGame({ type: "PurchaseSeed", species });
            StatsService.incrementShopStat("seedsBought");
          } catch (err) {
          }
        }
        return;
      }
      if (kind === "tools") {
        const toolId = it.toolId ?? it.id;
        if (toolId) {
          try {
            sendToGame({ type: "PurchaseTool", toolId });
            StatsService.incrementShopStat("toolsBought");
          } catch (err) {
          }
        }
        return;
      }
      if (kind === "eggs") {
        const eggId = it.eggId ?? it.id;
        if (eggId) {
          try {
            sendToGame({ type: "PurchaseEgg", eggId });
            StatsService.incrementShopStat("eggsBought");
          } catch (err) {
          }
        }
        return;
      }
      if (kind === "decor") {
        const decorId = it.decorId ?? it.id;
        if (decorId) {
          try {
            sendToGame({ type: "PurchaseDecor", decorId });
            StatsService.incrementShopStat("decorBought");
          } catch (err) {
          }
        }
        return;
      }
    }
  };

  // src/core/audioPlayer.ts
  var AudioPlayer = class {
    constructor(opts = {}) {
      __publicField(this, "found", /* @__PURE__ */ new Set());
      __publicField(this, "meta", /* @__PURE__ */ new Map());
      __publicField(this, "groupsMap", /* @__PURE__ */ new Map());
      // config volume
      __publicField(this, "atomKey");
      __publicField(this, "min");
      __publicField(this, "max");
      __publicField(this, "gainFactor");
      // Howler cache local
      __publicField(this, "howler", null);
      // options
      __publicField(this, "minVariantsPerAutoGroup");
      this.atomKey = opts.atomKey ?? "soundEffectsVolumeAtom";
      this.min = opts.min ?? 1e-3;
      this.max = opts.max ?? 0.2000000000000001;
      this.gainFactor = opts.gainFactor ?? 1;
      this.minVariantsPerAutoGroup = opts.minVariantsPerAutoGroup ?? 2;
      if (opts.autoScan) void this.init();
    }
    /** Lance un scan initial et reconstruit les groupes auto. */
    async init() {
      await this.scanAll();
    }
    // ----------------- Utils -----------------
    abs(u) {
      try {
        return new URL(u, location.href).href;
      } catch {
        return u;
      }
    }
    isMP3(u) {
      return /\.mp3(?:[\?#][^\s'"]*)?$/i.test(u);
    }
    fileName(u) {
      try {
        return new URL(u, location.href).pathname.split("/").pop() || u;
      } catch {
        return String(u);
      }
    }
    logicalName(fileName) {
      return fileName.replace(/-[A-Za-z0-9_=-]{6,}(?=\.mp3$)/i, "");
    }
    clamp(x, a, b) {
      return Math.max(a, Math.min(b, x));
    }
    choose(arr) {
      return arr && arr.length ? arr[Math.random() * arr.length | 0] : void 0;
    }
    toKey(name) {
      return String(name || "").trim().toLowerCase();
    }
    add(u, sourceTag) {
      if (!u || !this.isMP3(u)) return;
      const url = this.abs(u);
      if (!this.found.has(url)) {
        this.found.add(url);
        const name = this.fileName(url);
        this.meta.set(url, { from: /* @__PURE__ */ new Set([sourceTag]), name, logicalName: this.logicalName(name) });
      } else {
        this.meta.get(url)?.from.add(sourceTag);
      }
    }
    refreshHowler() {
      this.howler = window.Howler && Array.isArray(window.Howler._howls) ? window.Howler : null;
      return this.howler;
    }
    sameAsset(a, b) {
      try {
        const A = new URL(a, location.href).href;
        const B = new URL(b, location.href).href;
        if (A === B) return true;
        const fn = (p) => new URL(p, location.href).pathname.split("/").pop();
        const la = this.logicalName(fn(A));
        const lb = this.logicalName(fn(B));
        return la === lb;
      } catch {
        return a === b;
      }
    }
    readAtomRaw() {
      const raw = localStorage.getItem(this.atomKey);
      if (raw == null) return null;
      try {
        const val = JSON.parse(raw);
        if (typeof val === "number") return val;
        const m = JSON.stringify(val).match(/-?\d+(?:\.\d+)?/);
        return m ? parseFloat(m[0]) : null;
      } catch {
        const m = String(raw).match(/-?\d+(?:\.\d+)?/);
        return m ? parseFloat(m[0]) : null;
      }
    }
    howlerMaster() {
      try {
        return window.Howler && typeof window.Howler.volume === "function" ? window.Howler.volume() : 1;
      } catch {
        return 1;
      }
    }
    // 0.001 est considr comme un vrai mute ( 0)
    finalVolumeObj() {
      let raw = this.readAtomRaw();
      if (raw == null) raw = this.max;
      const clamped = this.clamp(raw, this.min, this.max);
      const nearMute = Math.abs(clamped - this.min) < 1e-6 ? 0 : clamped;
      const vol = nearMute * this.howlerMaster() * this.gainFactor;
      return { raw, clamped, vol };
    }
    // ----------------- Scanners -----------------
    async scanPerformance() {
      performance.getEntriesByType("resource").map((e) => e.name).filter(Boolean).forEach((u) => this.add(u, "perf"));
    }
    async scanHowler() {
      this.refreshHowler();
      if (!this.howler) return;
      this.howler._howls.forEach((h) => {
        const src = h && (h._src || h._urls && h._urls[0]);
        if (src) this.add(src, "howler");
      });
    }
    async scanCaches() {
      if (!("caches" in window)) return;
      try {
        const keys = await caches.keys();
        for (const k of keys) {
          const c = await caches.open(k);
          const reqs = await c.keys();
          for (const r of reqs) {
            const u = r.url;
            if (this.isMP3(u)) this.add(u, `cache:${k}`);
          }
        }
      } catch {
      }
    }
    async fetchText(u) {
      try {
        const res = await fetch(u, { mode: "same-origin", credentials: "same-origin" });
        if (!res.ok) return "";
        const ct = res.headers.get("content-type") || "";
        if (!/javascript|ecmascript|css|html/i.test(ct)) return "";
        return await res.text();
      } catch {
        return "";
      }
    }
    extractMp3s(text) {
      if (!text) return [];
      const re = /["'`](\/?[^"'`)\s]+?\.mp3(?:\?[^"'`\s]*)?)["'`]/ig;
      const out = [];
      let m;
      while (m = re.exec(text)) out.push(m[1]);
      return out;
    }
    async scanResourcesForRefs() {
      const urls = /* @__PURE__ */ new Set();
      document.querySelectorAll('script[src],link[rel="stylesheet"][href]').forEach((el2) => {
        const u = el2.src || el2.href;
        try {
          const url = new URL(u, location.href);
          if (url.origin === location.origin) urls.add(url.href);
        } catch {
        }
      });
      urls.add(location.href);
      const texts = await Promise.all([...urls].map((u) => this.fetchText(u)));
      texts.forEach((t, i) => {
        for (const match of this.extractMp3s(t)) this.add(match, `ref:${[...urls][i]}`);
      });
    }
    async scanDOM() {
      document.querySelectorAll("audio[src]").forEach((a) => this.add(a.getAttribute("src") || "", "dom"));
      document.querySelectorAll("source[src]").forEach((s) => this.add(s.getAttribute("src") || "", "dom"));
      const html = document.documentElement?.outerHTML || "";
      for (const m of this.extractMp3s(html)) this.add(m, "html");
    }
    async scanAll() {
      this.found.clear();
      this.meta.clear();
      await Promise.all([
        this.scanPerformance(),
        this.scanHowler(),
        this.scanCaches(),
        this.scanDOM()
      ]);
      await this.scanResourcesForRefs();
      this.autoGroups({ overwrite: true });
      return this.urls();
    }
    // ----------------- Groupes -----------------
    inferGroupKey(logicalName) {
      const base = String(logicalName || "").replace(/\.mp3$/i, "");
      let m = base.match(/^([A-Za-z]+)[_\-]/);
      if (m) return m[1].toLowerCase();
      m = base.match(/^([A-Za-z]+)\d+$/);
      if (m) return m[1].toLowerCase();
      m = base.match(/^([A-Za-z]+)/);
      return m ? m[1].toLowerCase() : base.toLowerCase();
    }
    defineGroup(name, matcher) {
      const key2 = this.toKey(name);
      const set2 = /* @__PURE__ */ new Set();
      const items = this.urls().map((u) => [u, this.meta.get(u)]);
      const test = (url, meta) => {
        if (!matcher) return false;
        if (typeof matcher === "function") return !!matcher(url, meta);
        const ln = meta?.logicalName || meta?.name || url;
        if (matcher instanceof RegExp) return matcher.test(ln) || matcher.test(url);
        const txt = String(matcher).toLowerCase();
        return ln.toLowerCase().startsWith(txt) || url.toLowerCase().includes("/" + txt);
      };
      for (const [url, meta] of items)
        if (test(url, meta && { name: meta.name, logicalName: meta.logicalName })) set2.add(url);
      this.groupsMap.set(key2, set2);
      return [...set2];
    }
    undefineGroup(name) {
      this.groupsMap.delete(this.toKey(name));
    }
    // --- Unique implmentation publique ---
    autoGroups({ overwrite = false, minVariants = this.minVariantsPerAutoGroup } = {}) {
      this.rebuildAutoGroups(overwrite, minVariants);
      return this.groups();
    }
    // Helper priv appel par autoGroups()
    rebuildAutoGroups(overwrite, minVariants) {
      const tmp = /* @__PURE__ */ new Map();
      for (const [url, m] of this.meta.entries()) {
        const grp = this.inferGroupKey(m?.logicalName || m?.name || url);
        if (!tmp.has(grp)) tmp.set(grp, /* @__PURE__ */ new Set());
        tmp.get(grp).add(url);
      }
      for (const [grp, set2] of tmp.entries()) {
        if (set2.size < minVariants) continue;
        if (overwrite || !this.groupsMap.has(grp)) this.groupsMap.set(grp, set2);
      }
    }
    groups() {
      const out = {};
      for (const [k, set2] of this.groupsMap.entries()) out[k] = [...set2];
      return out;
    }
    getGroup(name) {
      const set2 = this.groupsMap.get(this.toKey(name));
      return set2 ? [...set2] : [];
    }
    pick(name) {
      const g = this.getGroup(name);
      return this.choose(g);
    }
    // ----------------- Lecture -----------------
    findExistingHowlByUrl(url) {
      this.refreshHowler();
      if (!this.howler) return null;
      for (const h of this.howler._howls) {
        const src = h && (h._src || h._urls && h._urls[0]);
        if (src && this.sameAsset(src, url)) return h;
      }
      return null;
    }
    /** Volume calcul selon config + atom du jeu. */
    getGameSfxVolume() {
      return this.finalVolumeObj();
    }
    /** Ajoute un offset global (sans toucher  latom du jeu). */
    setGainFactor(g = 1) {
      this.gainFactor = +g || 1;
    }
    /** Permet dadapter la cl et la plage de latom si a change ct jeu. */
    setAtomConfig(key2 = "soundEffectsVolumeAtom", min = 1e-3, max = 0.2000000000000001) {
      this.atomKey = key2;
      this.min = min;
      this.max = max;
    }
    /** Joue une URL en respectant le volume du jeu et Howler si dispo. */
    playUrl(url) {
      const { vol } = this.finalVolumeObj();
      const existing = this.findExistingHowlByUrl(url);
      if (existing) {
        try {
          existing.play();
          return existing;
        } catch {
        }
      }
      const Howl = window.Howl && window.Howler ? window.Howl : null;
      if (Howl) {
        try {
          const h = new Howl({ src: [url], volume: vol });
          h.play();
          return h;
        } catch {
        }
      }
      try {
        const a = new Audio(url);
        a.volume = Math.max(0, Math.min(1, vol));
        void a.play().catch(() => {
        });
        return a;
      } catch {
        return null;
      }
    }
    /** Joue par motif (RegExp ou texte partiel). */
    playBy(matcher) {
      const list = this.urls();
      const re = matcher instanceof RegExp ? matcher : new RegExp(String(matcher).replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i");
      const hit = list.find((u) => re.test(u));
      return hit ? this.playUrl(hit) : null;
    }
    /** Joue par nom logique exact si possible, sinon via motif. */
    play(nameOrRegex) {
      if (typeof nameOrRegex === "string") {
        const m = this.map();
        if (m[nameOrRegex]?.[0]) return this.playUrl(m[nameOrRegex][0]);
      }
      return this.playBy(nameOrRegex);
    }
    /** Joue une entre dun groupe (index fixe, ou alatoire). */
    playGroup(name, opts = {}) {
      const { index, random = true, filter } = opts;
      let list = this.getGroup(name);
      if (!list.length) return null;
      if (typeof filter === "function") {
        list = list.filter((u) => {
          const m = this.meta.get(u);
          return filter(u, m && { name: m.name, logicalName: m.logicalName });
        });
        if (!list.length) return null;
      }
      const url = typeof index === "number" ? list[(index % list.length + list.length) % list.length] : random ? this.choose(list) : list[0];
      return this.playUrl(url);
    }
    /** Alias pratique pour jouer une variation alatoire dun groupe (ex: "harvest"). */
    playRandom(name) {
      return this.playGroup(name, { random: true });
    }
    // ----------------- Tables & export -----------------
    urls() {
      return [...this.found];
    }
    map() {
      const map2 = {};
      for (const [url, m] of this.meta.entries()) {
        const key2 = m.logicalName || m.name;
        (map2[key2] || (map2[key2] = [])).push(url);
      }
      return map2;
    }
    info() {
      return this.urls().map((u) => {
        const m = this.meta.get(u);
        return { url: u, name: m?.name, logicalName: m?.logicalName, sources: [...m?.from || []].join(",") };
      });
    }
    /** Exporte JSON (URLs + groupes). Retourne la string. */
    exportJSON() {
      return JSON.stringify({ urls: this.info(), groups: this.groups() }, null, 2);
    }
    /** Scan public de commodit. */
    async scan() {
      return this.scanAll();
    }
    /* Helpers */
    playHarvest() {
      return this.playGroup("harvest");
    }
    playPlantSeed() {
      return this.playGroup("plantseed");
    }
    playWaterPlant() {
      return this.playBy("water");
    }
    playDestroyPlant() {
      return this.playBy("Break_Dirt");
    }
    playDestroyStone() {
      return this.playBy("Break_Stone");
    }
    playSellNotification() {
      return this.playBy("Score_PlusOne");
    }
    playInfoNotification() {
      return this.playBy("Keyboard_Enter_01");
    }
    playBuy() {
      return this.playGroup("coinbuy");
    }
  };
  var audioPlayer = new AudioPlayer({ autoScan: true });
  window.__audioPlayer = audioPlayer;

  // src/utils/sellAllPets.ts
  var SELL_ALL_PETS_EVENT = "sell-all-pets:list";
  var DEFAULT_THEME = {
    text: "var(--chakra-colors-Neutral-TrueWhite, #FFFFFF)",
    bg: "var(--chakra-colors-Blue-Magic, #0067B4)",
    border: "var(--chakra-colors-Blue-Light, #48ADF4)",
    hoverBg: "var(--chakra-colors-Blue-Light, #48ADF4)",
    hoverBorder: "var(--chakra-colors-Blue-Baby, #25AAE2)",
    activeBg: "var(--chakra-colors-Blue-Dark, #264093)",
    ring: "var(--chakra-ring-color, rgba(66,153,225,0.6))"
  };
  var DEFAULTS = {
    rootSelector: ".McFlex.css-wqzc3n",
    // gate inchang : bloc qui contient le bouton
    checkSelector: ".McFlex.css-bvyqr8",
    // nouveau bouton "Sell Pet"
    buttonSelectorWide: "button.chakra-button.css-o7uz17, button.chakra-button, button.css-o7uz17",
    buttonSelectorStrict: "button.chakra-button.css-o7uz17",
    targetText: "Sell Pet",
    // Back-compat only
    injectText: "Sell all Pets",
    injectedClass: "tm-injected-sell-all",
    styleId: "tm-injected-sell-all-style"
  };
  function startInjectSellAllPets(options = {}) {
    if (!isBrowser()) return noSSRController();
    const ROOT_SEL = options.rootSelector ?? DEFAULTS.rootSelector;
    const CHECK_SEL = options.checkSelector ?? DEFAULTS.checkSelector;
    const BTN_WIDE = options.buttonSelectorWide ?? DEFAULTS.buttonSelectorWide;
    const BTN_STRICT = options.buttonSelectorStrict ?? DEFAULTS.buttonSelectorStrict;
    const BTN_TEXT = options.targetText ?? DEFAULTS.targetText;
    const INJ_TEXT = options.injectText ?? DEFAULTS.injectText;
    const INJ_CLASS = options.injectedClass ?? DEFAULTS.injectedClass;
    const THEME = options.theme ?? DEFAULT_THEME;
    const OBS_HIST = options.observeHistory ?? true;
    const logger = typeof options.log === "function" ? options.log : options.log ? (...a) => console.debug("[injectSellAllPets]", ...a) : () => {
    };
    const HANDLE = options.onClick ?? createDefaultClickHandler(logger);
    ensureStyle(INJ_CLASS, THEME);
    let running = true;
    let pending = false;
    const processAll = () => {
      if (!running || pending) return;
      pending = true;
      requestAnimationFrame(() => {
        try {
          document.querySelectorAll(ROOT_SEL).forEach((root) => processRoot(root));
        } finally {
          pending = false;
        }
      });
    };
    function processRoot(root) {
      const gate = root.querySelector(CHECK_SEL);
      if (!gate) {
        cleanup(root, INJ_CLASS);
        return;
      }
      const target = findTargetButton(root, BTN_WIDE, BTN_STRICT, BTN_TEXT);
      if (!target) {
        cleanup(root, INJ_CLASS);
        return;
      }
      ensureInjectedNextTo(target, INJ_CLASS, INJ_TEXT, (ev, ctx) => {
        safeInvokeClick(HANDLE, ev, ctx, logger);
      });
    }
    const mo = new MutationObserver(processAll);
    mo.observe(document.documentElement, { childList: true, subtree: true });
    processAll();
    let unhookHistory = null;
    if (OBS_HIST) {
      unhookHistory = hookHistory(processAll);
    }
    return {
      stop() {
        if (!running) return;
        running = false;
        mo.disconnect();
        unhookHistory?.();
        logger("stopped");
      },
      runOnce() {
        processAll();
      },
      isRunning() {
        return running;
      }
    };
  }
  async function runSellAllPetsFlow(logger = () => {
  }) {
    const pets = await runDefaultSellAllPetsAction(logger);
    if (pets.length === 0) return;
    await sellPetsFromInventory(pets, logger);
  }
  async function getUnfavoritedInventoryPets() {
    try {
      await ensureStore();
    } catch {
    }
    const [inventory, favoriteIds2] = await Promise.all([
      Atoms.inventory.myInventory.get().catch(() => null),
      Atoms.inventory.favoriteIds.get().catch(() => [])
    ]);
    const favSet = new Set(
      Array.isArray(favoriteIds2) ? favoriteIds2.filter((id) => typeof id === "string") : []
    );
    const items = Array.isArray(inventory?.items) ? inventory.items : [];
    const availablePets = [];
    items.forEach((item, index) => {
      if (!isInventoryPetItem(item)) return;
      if (favSet.has(item.id)) return;
      console.log("[sellAllPets] inventory index", index, item);
      availablePets.push({ ...item, inventoryIndex: index });
    });
    return availablePets;
  }
  function createDefaultClickHandler(logger) {
    return async () => {
      const pets = await runDefaultSellAllPetsAction(logger);
      if (pets.length === 0) return;
      await sellPetsFromInventory(pets, logger);
    };
  }
  async function runDefaultSellAllPetsAction(logger) {
    const pets = await getUnfavoritedInventoryPets();
    const detail = { pets, count: pets.length };
    globalThis.__sellAllPetsCandidates = pets;
    try {
      logger("collected-non-favorite-pets", detail);
    } catch {
    }
    try {
      globalThis.dispatchEvent?.(
        new CustomEvent(SELL_ALL_PETS_EVENT, { detail })
      );
    } catch {
    }
    return pets;
  }
  async function sellPetsFromInventory(pets, logger) {
    const toSell = pets.filter((pet) => typeof pet?.id === "string" && pet.id.trim().length > 0);
    if (toSell.length === 0) {
      try {
        logger("no-sellable-pets", { requested: pets.length });
      } catch {
      }
      try {
        globalThis.__sellAllPetsResult = { attempted: 0, sold: 0, failures: [] };
      } catch {
      }
      return;
    }
    const failures = [];
    let sold = 0;
    const totalValue = await computeTotalPetSellValue(toSell, logger);
    try {
      logger("sell-pets:total-value", { attempted: toSell.length, totalValue });
    } catch {
    }
    for (const pet of toSell) {
      try {
        logger("sell-pet:start", { id: pet.id, pet });
      } catch {
      }
      try {
        await PlayerService.sellPet(pet.id);
        sold += 1;
        StatsService.incrementShopStat("petsSoldCount");
        void (async () => {
          try {
            const total = await Atoms.pets.totalPetSellPrice.get();
            const value = Number(total);
            if (Number.isFinite(value) && value > 0) {
              StatsService.incrementShopStat("petsSoldValue", value);
            }
          } catch (error) {
            console.error("[SellPet] Unable to read pet sell price", error);
          }
        })();
        try {
          logger("sell-pet:success", { id: pet.id, pet });
        } catch {
        }
      } catch (error) {
        failures.push({ pet, error });
        try {
          logger("sell-pet:error", { id: pet.id, error, pet });
        } catch {
        }
      }
    }
    if (failures.length === 0) {
      toastSimple("Sell all Pets", `${sold} pets have been sold for ${totalValue} coins!`, "success");
    }
    try {
      globalThis.__sellAllPetsResult = { attempted: toSell.length, sold, failures };
    } catch {
    }
    audioPlayer.playSellNotification();
    try {
      logger("sell-pets:complete", { attempted: toSell.length, sold, failures });
    } catch {
    }
  }
  async function computeTotalPetSellValue(pets, logger) {
    if (!pets.length) return "";
    const selectionSnapshot = await captureInventorySelection();
    let total = 0;
    for (const pet of pets) {
      const index = getInventoryIndex(pet);
      if (index === null) continue;
      try {
        await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(index);
      } catch (error) {
        try {
          logger("sell-pet:selection-error", { id: pet.id, index, error, pet });
        } catch {
        }
        continue;
      }
      const value = await readSellPriceForSelection(index, pet, logger);
      if (value !== null) {
        total += value;
      }
    }
    await restoreInventorySelection(selectionSnapshot, logger);
    return total.toLocaleString("en-US");
  }
  async function captureInventorySelection() {
    try {
      const value = await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.get();
      if (typeof value === "number" && Number.isInteger(value) && value >= 0) {
        return { value, valid: true };
      }
      if (value === null) {
        return { value: null, valid: true };
      }
    } catch {
    }
    return { value: null, valid: false };
  }
  async function restoreInventorySelection(snapshot, logger) {
    if (!snapshot.valid) return;
    try {
      await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(snapshot.value);
    } catch (error) {
      try {
        logger("sell-pet:selection-restore-error", error);
      } catch {
      }
    }
  }
  function getInventoryIndex(pet) {
    const idx = pet.inventoryIndex;
    if (typeof idx === "number" && Number.isInteger(idx) && idx >= 0) return idx;
    return null;
  }
  async function readSellPriceForSelection(index, pet, logger, attempts = 3, delayMs = 50) {
    for (let attempt = 0; attempt < attempts; attempt++) {
      try {
        const value = await Atoms.pets.totalPetSellPrice.get();
        const numericValue = Number(value);
        if (Number.isFinite(numericValue)) {
          return numericValue;
        }
      } catch (error) {
        if (attempt === attempts - 1) {
          try {
            logger("sell-pet:price-read-error", { id: pet.id, index, error, pet });
          } catch {
          }
        }
      }
      if (attempt < attempts - 1) {
        await delay2(delayMs);
      }
    }
    try {
      logger("sell-pet:price-missing", { id: pet.id, index, pet });
    } catch {
    }
    return null;
  }
  function delay2(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  function safeInvokeClick(handler, ev, ctx, logger) {
    try {
      const result = handler(ev, ctx);
      if (isPromiseLike(result)) {
        result.catch((err) => logClickError(err, logger));
      }
    } catch (err) {
      logClickError(err, logger);
    }
  }
  function logClickError(error, logger) {
    try {
      logger("sell-all-click-error", error);
    } catch {
    }
  }
  function isPromiseLike(value) {
    return !!value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function";
  }
  function isInventoryPetItem(item) {
    return !!item && item.itemType === "Pet" && typeof item.id === "string";
  }
  function isBrowser() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function noSSRController() {
    return { stop() {
    }, runOnce() {
    }, isRunning: () => false };
  }
  function norm(s) {
    return (s ?? "").replace(/\s+/g, " ").trim();
  }
  function getLabel(el2) {
    const t = norm(el2.textContent);
    if (t) return t;
    const a = norm(el2.getAttribute("aria-label"));
    return a;
  }
  function getWords(label2) {
    return label2.trim().split(/\s+/).filter(Boolean);
  }
  function isSellTwoWordLabel(label2) {
    const words = getWords(label2);
    return words.length === 2 && /^sell$/i.test(words[0]);
  }
  function findTargetButton(scope, btnWide, btnStrict, _btnText) {
    const all = Array.from(/* @__PURE__ */ new Set([
      ...Array.from(scope.querySelectorAll(btnWide)),
      ...Array.from(scope.querySelectorAll(btnStrict))
    ])).filter((b) => b instanceof HTMLButtonElement).filter((b) => !b.classList.contains(DEFAULTS.injectedClass));
    const target = all.find((b) => {
      const label2 = getLabel(b);
      if (/crops/i.test(label2)) return false;
      return isSellTwoWordLabel(label2);
    });
    return target ?? null;
  }
  function ensureInjectedNextTo(targetBtn, injectedClass, injectedText, onClick) {
    const parent = targetBtn.parentElement || targetBtn.closest(".McFlex, .css-0") || targetBtn.parentNode;
    if (!parent) return;
    let injected = parent.querySelector(`.${injectedClass}`);
    if (injected) {
      if (targetBtn.nextElementSibling !== injected) {
        parent.insertBefore(injected, targetBtn.nextSibling);
      }
      if (injected.textContent !== injectedText) injected.textContent = injectedText;
      return;
    }
    injected = document.createElement("button");
    injected.type = "button";
    injected.className = `${injectedClass} chakra-button`;
    injected.textContent = injectedText;
    injected.setAttribute("aria-label", injectedText);
    injected.title = injectedText;
    injected.style.marginLeft = "8px";
    const cs = getComputedStyle(parent);
    if (cs.display !== "flex") {
      injected.style.display = "inline-flex";
      injected.style.alignItems = "center";
    }
    injected.addEventListener("click", (ev) => onClick(ev, {
      host: targetBtn.closest(".McFlex.css-1wu1jyg"),
      targetBtn,
      injectedBtn: injected
    }));
    parent.insertBefore(injected, targetBtn.nextSibling);
  }
  function cleanup(root, injectedClass) {
    root.querySelectorAll(`.${injectedClass}`).forEach((n) => n.remove());
  }
  function ensureStyle(injectedClass, theme) {
    const STYLE_ID3 = `${injectedClass}-style`;
    if (document.getElementById(STYLE_ID3)) return;
    const css = `
.${injectedClass}{
  font-synthesis: none;
  -webkit-font-smoothing: antialiased;
  -webkit-text-size-adjust: 100%;
  cursor: pointer;
  display: inline-flex;
  appearance: none;
  align-items: center;
  justify-content: center;
  user-select: none;
  white-space: nowrap;
  vertical-align: middle;

  outline: transparent solid 2px;
  outline-offset: 2px;
  line-height: 1.2;

  border-radius: 15px;                        /* aligns with provided design */
  font-weight: 700;
  height: auto;
  min-width: var(--chakra-sizes-10, 2.5rem);
  box-shadow: rgba(0, 0, 0, 0.3) 0px 4px 12px;
  transform: translateY(0px);
  transition: 0.2s;

  border: 2px solid ${theme.border};
  color: ${theme.text};
  background: ${theme.bg};

  text-transform: none;
  overflow: hidden;
  font-size: 20px;
  padding-inline-start: var(--chakra-space-4, 1rem);
  padding-inline-end: var(--chakra-space-4, 1rem);
  padding-top: var(--chakra-space-3, 0.75rem);
  padding-bottom: var(--chakra-space-3, 0.75rem);

  -webkit-tap-highlight-color: transparent;
}
.${injectedClass}:hover{
  transform: translateY(-1px);
  background: ${theme.hoverBg};
  border-color: ${theme.hoverBorder};
}
.${injectedClass}:active{
  transform: translateY(1px);
  background: ${theme.activeBg};
}
.${injectedClass}:focus-visible{
  box-shadow: 0 0 0 3px ${theme.ring};
}
`.trim();
    const s = document.createElement("style");
    s.id = STYLE_ID3;
    s.textContent = css;
    document.head.appendChild(s);
  }
  function hookHistory(onNavigate) {
    const p = history.pushState?.bind(history);
    const r = history.replaceState?.bind(history);
    const wrap = (fn) => fn ? function(...args) {
      const ret = fn.apply(this, args);
      onNavigate();
      return ret;
    } : fn;
    if (p) history.pushState = wrap(p);
    if (r) history.replaceState = wrap(r);
    const onPop = () => onNavigate();
    window.addEventListener("popstate", onPop);
    return () => {
      if (p) history.pushState = p;
      if (r) history.replaceState = r;
      window.removeEventListener("popstate", onPop);
    };
  }

  // src/services/sell.ts
  var sellKeybindsInstalled = false;
  function installSellKeybindsOnce() {
    if (sellKeybindsInstalled || typeof window === "undefined") return;
    sellKeybindsInstalled = true;
    window.addEventListener(
      "keydown",
      (event) => {
        if (shouldIgnoreKeydown(event)) return;
        if (eventMatchesKeybind("sell.sell-all", event)) {
          event.preventDefault();
          event.stopPropagation();
          void PlayerService.sellAllCrops();
          return;
        }
        if (eventMatchesKeybind("sell.sell-all-pets", event)) {
          event.preventDefault();
          event.stopPropagation();
          void runSellAllPetsFlow();
        }
      },
      true
    );
  }

  // src/utils/audio.ts
  var EMBED_DEFAULT_MP3_BASE64 = "SUQzBAAAAAAAIlRTU0UAAAAOAAADTGF2ZjYxLjEuMTAwAAAAAAAAAAAAAAD/+1QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJbmZvAAAADwAAAFIAAHvAAAQHCg0RERQXGh0gICMmKSwsMDM2OTw8P0JFSEhMT1JVWFhbXmFkZGdrbnF0dHd6fYCDg4aKjZCQk5aZnJ+foqaprKyvsrW4u7u+wcXIyMvO0dTX19rd4OTk5+rt8PPz9vn8/wAAAABMYXZjNjEuMy4AAAAAAAAAAAAAAAAkAkAAAAAAAAB7wKXVMdj/+5RkAAQADACAAgAACAGgEABgAAEHaUyIwIBLKM+o0SQQCSQDEIaNCM1/ySH1oT/q///zvyf9YG/SjE//w48Qevu9CaCJBDzvPQn6ORUIT2oyoUcWIDpVOp+BlKPfgK5H/0AoAQKo1/HXt//3//9mPXq7p1q7kX8///Orf/6nnckjI3QlZXFhG3V00IuCERBPt4qB84TVBEWrkSJvtJkEz0M3rvQfekFCTNggegdtW+E8vSBBntIAYny+IxOgyoQhc51CnI5z812/y4bOBinWP16+/0TiWf7f8wwdtV0l275xZRfkwiGI7856yFfOnZPHgXrL6OZaLBLf5CERxhRPInDTOuOwRV5CNxKN4VYJ9JLLcaBoI9rZ4afOcubE4URZc3Pfu3ubUJIOBwajID/BjwqJ9nY1e/3VnhgDV/BAgsL3wYA0ozmZes4Ds+pv5e9pBwtfdOIjLvP/Ek0977ltnPVZZSWHCur2ZbfxiL4FEB50+2frHL0heWUmm2PKNvz/+5RkdIiFHWOnkSx/oJrMNQIZj+ZN5Y7IwYTKwb0wWVgxpnkn96XYcbXn/r36LFjjB4vUSw6IYVpnVcZgSCcHQ4LhZLeXBWRIe/ArHjm4LgpULvCcNzvH+4DJhWRI9G9nXBoOCkJwZZKyxwKEgEwZbR2oVw0EMZJyAiAQDREz6EA4nyckjO4TbPd97e9uiCDGbEZ3Tu88Z/D2CBGdzyex/ZRDNdqIIP3tlEJvYMy+eTv/tEf8/c7Zafu3YhykHMCIMQ93RDN/eIjH2EOxBAwyJAetD7Dk7J5exIOtyYwHC9c+2jWiGe2QhECIBQ5k56I5n7i/QviUOBr08g4tDgAX8/+JQ4un4cDhH1/30nAAnPguu46IjgCE7u57miFym/oAAFR9TJ+e2j3UGUgVJ6y0aTCjEIo0DFwYyc+mFzaaOdIEEoZ8nPYZOekCD76QZO0bajGqOnm8PfIx7JZs2Pg41+Y+cH/7xu9/+COSNf0BR+YEY3wMsZJ9tZiD7+722P7/+5RkFA2SmGM7gCE08k/sV4kEI55MeZD+NCQAAVcxoAKCcAHbMs9MxV3u+9iMt0HPTghj3l3dEIeyGE9swYDpiw4ARJshGECB48wgaF7HcyFFEgAuY2zNSzeU3/NzkCBGNwKSwL5I/UtbG/8kYyWBDcGP/ecjFwDNL7vuaIW5lTTRHfdzQu+aU48JycyDsTxksLRzc0KhzQgAnlFhBi8BIuSpqXtWr/XP/fN6c/+0f/zH999f+33//z///NffaL//dPCbxxL9NM9Q6vacrZCvePmkU6yVPb6tHDs+4NmDjKNKFxwfw1kl2LkjIUPg5IIEEHqNQeg4G4jiHhwC8hQWB+Wn/+evXTt/2p//3r7r76v/z85kOq16503fnr2R5xVDDXoZJq63dY3MdjGLoqFzCpxAfigSS9jpYgVHjRWHmkBeL2MHCJQqe7PG44WKIxODwRBSPEyBAQoCDOBDThAAAAB1eqWyAjLzO9Kq/uP77r7Wkal8/q9/QUAlidP+qEH/+5RkE4AC+oFDzhSgAF8wKEDAlAAOgO1ruYeAEMPAooMAIABRcgp7rr6VW7H1sv5S5UZSJ3TmNmIY4mcpxFWHjZBqkcVFVMJCi93puoqVjDv////xit////+5RRVLtkWzJf//7ITZP2/3q6/107P+nIRu/siFRrJ1XZDKZhfIg9kIrKOM4dVGKNFh4pUzCYoEgOaKkD48XZ7OEgkAgIBw+UjCJzgQOKqgYeOCYmKv////+BlF/////3BBob5IT7PK6HR6Pa7IaEf/Uetc4NTnyXv2kYkV/xCcpBkOdnQwIS5U+aMkpfRzmJv6c1XhsTlPT/01jUSC2rcPH+v8a3FZ8R4sQ9xyOpNfO7/4pelKUjZtGg334Gv//qmvSt81+qYmFfvWmfBs0eV/+iqecPJf/////////////1///T37olUzfuX3ZEdyq/MqNUsrHbI7qrNkWpv////z/////5ShaqAIAAACKkkKjqNYHpHrgEqzZ2UlgRaLCUK7Yq40Mwz/+5RkD4L0FTtWV2YgBCngqIDhCAAPvO9FTbxWwLsQo0CTCTi44jkEoFzJBB6GiViZIqOWaBf0OwpSjeOUoOVIKefSRLpmOa58umTpo6Rso6QViiOaXR/FKk6gkjTQSZklqsk7PSXT7aVHpPWaol1FHMUg7BU7Ku4KxK9ook8WsmG4hEwNPO9f+QWbify5cH3kEwff6D/8P///+3/8vsvAZMSVD5eUKOGlHpCxI8HgGeFoAAARmsIS1GVk3gNDQUdjETBUEAg8SaZFqPy3VwpVONfJAOqSHAshgEWUkkVDUWdlNJVZ5wcOxTda23AuJBB+21vNYu8Rz0Mbol1hhjeTfkfwGBRXURITx3A1JNO13mwWmUyspK9+s30OJXBHDGMNtW8hzTCcAA1g89DhXXK/+qguFw2ShZNO99poP78REA4DT73rTBML99+R6uT/U65AggaH////////96FXzFWAAAARdDntlBrvNqD85WDjK8fMEAFGkzMHTA+lCNankkv/+5RkEI7ETUrOu4kWIC6kaTIBhw4PxPM4biR4gL2RZYj0lShlEKWaBQBeQCjQy+BA4FOFAzZIGa0XdQCg0CDQLgrPkGNgYigEeaT0tXHLvUNAMKikhehAPZUvKAS0+AoWE4nFIC5BE6x2bxTqpLi1LK1fS0yWkFOBGZFlEkQ/7M9d9SXYhzLDNONxkNABICcd1jZimHwBqDVv5yJw8MKECl1cWERKe8m48EoqN5iPW+n76zCtiyez2/7qUpQoMmiBZyaGG5wgIG7lMEHIwEMhoFmEvOEalkzNlcug68aMBhJOVAiAgcKANWmxQ0TXWbMgZ6gdLab77Kpxo0PU9jWGW4xyAQsvuqbnG6qKqFPicDg0hFblzgsQOP1A8P608ty8v1f4ZlATLHMEzgwzE06FUEakw6yeY4klIIYB+pTIT8sVzLuTJpafnSIYUEB5N7eddC8GSXjEUDB335QUun39IdYwY6qru/+pgAAAGpRTL7JKmZIFxudJm3SgY+AAkAj/+5RkC47DlzjOO4sdQC7jGXIxJ0wOBOM2bjCxQMkRJcj0nSjLAgMH60ewKQCMs/k06lSEa64okBHEh2Gf/UOvy/4nMkks8RCSYuji7a6SVN7ab7o4dGoYGxQs0pa2DsGC5AlUhXS55VT568lIu5QUEscRsQouh4SkTo5Jhgjq3ARoE2RDEyfRl4gh8SZfj1xBRGS6Ttt+I+4CldyTGQhDGu1ZQ9CVZgUArg76f/+luQPQoqIrmQgQ1w+jVU9KCeVAUZwCZhj7k2pTVTIac+7TqNFZOplgOFpcF5kvomSwAMDhRTbGR4IARzf5zb9Zpy77t9rmW7PbswHiQpXGNGUIMPKpNqopaM1Lu7saYodFY1AhCrEvdxwGI9TAiSeM1gBwH6KQkuJoYbyAEeDGSqeLgk8dHWkZJLaLKqja13UBgFJ9jtVEV/X79R8fGw/++z/0qoAwLVJHIq5BKmxlQ6zy85VQyZidohmpx1IpYjM4hF3EaOHjR9OMEzB9YAqvxYT/+5RkFwAjMzfW6wkbzjEESZc9J0oMcLNBrbBrgMwRZnD2FWBQIBVP5+8QYI7bz+5HQRGDt+FghrmFuYZDgmjiTUU6XKvIf/1AKbiz0zDZdkyIL269V8CdhAMAeyAoAARgD5Ph4fJjLJ/HWL08l8i5gaDQJkDDzO+UFy4+mhihARp+6tXTrv8k3yb/Z/0YAABBkJMfbiEqLiCNBVmYE4GgwocAtKMkBAJwjUTDQPu1GLw7GhCjLSy1OvGlHof7TvaZHrc5M6qmW7odOzLYx5tk3CwRaaQQ1JVUOBqHFTrmijhdgQHMWhbCJuzarFaXNSSUAAHSCOA+R7NAYQQ1vYxdwqLIkrWrqVJImk40Vqln6vlM1asNExH/u7dv34kYLBHf/V/RwAsUgoW/BorlgxGmiRQZOP5pYUFYXQ+MQA0wHIx5SscUAe+SLgeCUR6ae4NmKzaSmZONRrpWjN7X/mmBBrX6c5kW4V8aCGgqlJRVKYw1SuXq+5k4fTccab5J1pf/+5RkLgiDLSzPU4kUMjMiicoBhggMSN8/TaRtSL4M52jzCWCpvf9pXbq77Q3oACDhICcAF5EACJRuwYl8INt34iNBAsCsne4SBwQn/34GOMqTi4O3dEuXDX9DvksK3gghhUoB9+KBdYIPTsQ01tyN5ZA4EbAk4BOUmcYOaVygFkQrNogwhk1L4TnBWu6/SSoLiafvKRgwgiqF//+3d6fS4NwgyqbNSd1UhSuXCtvrSn4R6wXzwkHKfskveV7bnVfec7AwQGxqAPiCfQ4j621MhzBMabHQoOmtK5OrdLoJFaIqDCO026DRVesUWExH92a3fpXBB2kmzEkGmteaSGWzRHTBMV9v6UACxLKAN8F7on0AnmZLatH+UiIOQlNyxEuivPW4yqhepNK40haajFOxiBVZJqYXXDjIsUEwuH2SOt3fuF+Ip65+GGjyQUGo2KBMzj22OdcdajWAB5TCa3AHxoxdJB1AU50B596WQlKwIILVUWQeCoNNRVnDUj/rfU7/+5RkRoCDMTfTU0lC/DMEWeo8x1YM0Tc5rhxPQMkRpxzzCWD9Te54in/9P65lQeVAAAAAACzbsHCTmMDE42KBjfqGMYQJCcWoMOA0LUEaNtI2lNchUfpXMFY6Q8sOhQMrtICO5n3WgmJHE2RVosMLBThww1lo1JjYxVKyverWUnrZkjHuznV21RkZtbdd31bprS4V7z1IgC1qAPiwzRuhC6vjvLCDpj/HiiTgQAIsnOH7pgA3qLXs/WTT5qDKVAAYWKav10/36R6AAQUGjruHRfYGIIDYYI3poNCiwga+FgABI2UEV1AFImTZTNjklp+jz8pxMCxY+UKExdvnYwHFDGTeqlR+5xBqPGPTa6q44VnRUINS1a3qVeZOhUZaW96Wa20qq2xquWUJCxEEI4AACslpWmwAYRBKJn9ROMcvkOL1iw4omyl2B+N0sjjcakvZ2Y0MHo5Zmu+9txo7+vV/1wAAKpIpISSBgKHIRRBxIWdahm7B5ENNcDGgG8ZESzb/+5RkW4ADKk7O04wqwDKkOh0Bhw0M4Mk9raSw6MSRaTDDjp6qdPNxKCnRlEvW82mYTkXVSeDWyqciJhS5XC2eQpWP+zzFLUIi7OisMS827NVGQm79XD3561XidOozz/2oXMIva8p9rjO318rAAEbbanQJ2UAxPqVwu1l1EVd4wMwmD15ZA/zqipUDXViInDVv4oO1v01+uIX+Kf/oAQAEG5BDiyhAwxkOFhrogBl+qw8NhEDZgsBJgtAoYELDhtGMvoxwPBQB9hFo+eLC/7GY4L3sykw4CGtXueIKKJ/+Fbsymk7pn2mJ5oR+UOBF51aWBVh1BmKXLmxrYmOOGo3c10jBwAIMbrrlNYA4zg6KVLE9JBFUJChyAz/GiUe3aBRAGBt1/PrsZudN+qQMVxsQf6W9/rvagAJwASktEfUWEVuM3mw4u7wbfU50TzCgoMM7khqECPJTSaRCARhmj1UWpY3hLKnIIAb29g8M6v5+5WZt4e/mU0GiHALWy+kmK6P/+5RkcYADMyhMO69CwDKECq0JKGmM7KMzTj0JSM8RKvQUrZ6G7PylcjQ1qusf/NE8i/DUhvmpKNPVddr/dSo1JoAIGR2xyyQAdAIjOHMeYamVH0ESF2si4iC5z2LvPjc2v++HvnmuvmJefuYPikZuhL9H0enAFxwXpt+IyxohyjERk1CWNSpg4SvkS4FvGLtqJrpSUxlhy4xXURTeTHzEKf3aHX9X8vRrSSy3Y4pqJINtxRgVVvcjB/ozXNRxMl0hNpMgTY2m6iP+L168fQ1k+WdOs3+HP9fXfLAAotzaS6AAD+pvgQiU+5qIYDQaHkhGVcA8eDY9bz5hMW2tZakolszPeKxRHbdNMGN9gAEiAuS7YKUAACCNnA5OjrFNTjMIJgAARhACGJYaFgchZMv+71WZpICkfCgmTP1AeRxU3UMYff31W/Zd2377nutspmxjXL4SdFNSdx4OoSs+dYFwVLMBwo95RSMcAmv1PY9iA8Cz10AASORqV1gDJ3izvcD/+5RkhYADLS1O02xCwjHESs0hRrGM0KE5VcWAAM8RanaSgAb7Hv9cLhDDkNB8SQ1lKdv+nAkr//mXPVub+IRFe5KwRQhKeRYr/0UAABJ6j6ez+7a2CMMgQqLJmlVY2MVOkbCoMbQRRcADWJpdJIyJuXAYMEGAEswbVAWCAWDhthOg2CQamgLUA+UQeGZAOLgZQcAUMC2AGEAANAjQLzcaAWKFEkA302Ho6bjPCFScL47yBizxxilCAl4ckMwYFI+akyO4hyI1xYwy2OebmZcRupBA4ZIs6a00xzBzCIDLkC/61K0GHBKZPpqQIp/+93boMRcn4nc2NC+n////kTIoaMRQihoRcvusvm4AAABsn22m12gAAAAAHQckWNOGmpghn//0cBKTmyJm5F9F1FqUpNBnrkGUKpPlN0uDBu1vtw0jG3mE3l4rWWjLrxXbw61mXcFcGILSgAAAAAF3bHvl0mAIAABKYHphVKEsokGGgEjoI0QiXGIImWBhm6KBee7/+5RkmoAF/17X7maEhEyEOp3DPACZ0UVNua2AAHmE62sGEAIaM75mQEmftYGHTSh0iLzAYpBQaNFilgbZozklAkaBGDpvBjQWVeV4Y49y6pPgBQJDFPlhSGNq3W1qlrTlvFdrWq0WiUA5xmW52qGpIqTtjDB/X+jbi0IjBLW914Fq0luXfLZDUcwtu/jovte1JY05EZ/v//ItWrc1j/14anCoBF3jAQZK6RZd5Mx2SLaZLZ3/9xpcN2cv/6arZpcst/laq8fb/2QqAAeAgQJBIAAAAABXoDeCaPE9hAwtFl2fO/PUfK0l1YjE8ga7tYlBCJ8XYRk6jfL6lbCCjGWh2sB9wjAUUkgfR6o1ByzszMSguiRSCOafWNqK1oPqprooOtSblA+pFnMUqVF2Q2Rdv/UkZPWiv6XV+vq9F0nSzJEuoGRq5SRNFszJI2rrV/LyMJ1AG6VO1yE6WARqUPQ10eTKbu9bjOVBOcU6RSeHY+7msur/+8YwsIuDPooBb6//+5RkS4ADPVFa7z2gDDGDOcPsIAAMnUVdrCxReMORKnRTDlb/9fBgVQcUsjRYV0u2aU4QNLwCzl22E21P/GZxROAF1PZM1ikpsPlSAUWPokE38gTrQ+SYjGa16nN4nbxs+zK40OYCaVuzGfR//qYSMKbZi6M6s3/81DIAqygzGFqVSslqVajku+JbYBAoCkkriIFRrh52soZFA62tq27VE7CPmHYDnD67/DM6l82wcMmZdzkCBz/9jP//0IAQWASvWmS5PV9yY4LLhY0xSB2glVKVg7Dd51o8cSlswC45HBUM+hi+OCPxkWWnlkzL8j2YhjJ+ccrXdRAdunQesrbTMY9HGykILo3M+zuv29pdDNAx2ZSQ4ooHVKKDxVbicJRQh3j2FgMCS6oD9s9bO011dwBDy6yam7Zf2FiGIY3GxFM0QBNHqo/7ZFIdfb1tGECAc//NtT//1QAAAAAFFSChlzFAaVQVSAjGmXEihXE0/DBDjJjfDrR5xkIwCjCwCHj/+5RkYgADUFFTY0ssPjHkSdNhhVQNmSM3rhxUSMaQqrQ3nM4W8hhcahuhly9bUwpfU+5XED4QlySRCCNpSwaMpKU6jNkQoMhtvadLOQqzKSxtAZUEEmHO9K0f//6s2s6iZI+luBZze9wA1MhVuR1kDejimLFuQ8ies3SVcx9CgwKxkEbodcbF39tkep3+1JMee3f9gu/e63/6qoAAAAITaiSoVRMByk60GTwpTMO54KgALhMHNQL/siryjK7VuJKgAeGFUoNAwwAEQwrNk/WA15y/UKbGIwEg23IXGJgMrW62MKzi8HNhc3l7kug0OC6/i7mxoixNMcULgTiFSGqCu1ZpSLqSh2OVnsSO4UlEOSzjd8aMWtIf7+a6tEoQhBh88Ss6IObmqIqiSMYNHD2qSwielFi7V9hcAICAFpSKggMmGLeMkOlTeZV07Krqfrq6fSkoeR5Cs79NOqv///QjkYAAGYJzKbGEKb+MMaSyOBiVHgSMlBTMFMxA1PlykWz/+5RkcoQE7lJK051DwCZjGp0AxweT+TUiDvkPAMsianRwC8aYIEBZgUJxhSYYOHUGBFGAaOqbEgEM2YBgCsIdUwKABVbIlGX5CAAYCt6tOszFQ2KsZU9nuu7uPDwe5T1Z7JQHgtkVYkOA6oIxbJHxcMWfLNFO0bkTv/waWOuVRe/21+Tbe+eN6pLRbU+hlR9973NSgxwkI3jlqaomutdK44xVAAhCDEZGIwKFBkXFMfCEYmutEa9sxVHyYfm1q/9sjQ7b2WyFVIf+ZBhVuUWv///6ZwQ9h8t2Ib9NWBmN45tNqD2McQfCgQmCQUBXdQjJyYOR0FR4BVSgAXDJwgTC8BQSCYYGBKZtJAYmACAMYCIDDzteDAX2Bw7EKEaAXeKMRqCqjC2c1VG2oXLeTFkjQwMk0EekjdJYKz52aNzhgSTiizIiGoEozp6iVe6qdUW6lU5PNOxVPmqmJuf+Jm7673R7KTYm9Zi3JRuZaiKVAHjH5cmhZe36eX//7+2BEWL/+5RkVQyFOUXIA75bwjfGKfY8xVWWXWsgTvkPiR0iJeWECiBA+CoLUYhK82mO0eOabeSFKEhR0faogDFJY4uA4gv9BiUdSPS9O5Hb//6f8wiplkx/40YTNgIzMpFATMCrdMjCNNUKcNt08ARoAgQTNAUDFDKRrMhoKVEEWUtwYNxhofhg2BykTBOKNNgAB8wBwEBEAutZkJgFAEMie51GBp1RiLQw8E1AMBxdR1q2+anqejrS+nvbtd+/jnXeGnsVdIGgaALI2tRyUVlvLy1RSHLaIQQD4SA9iLFCYtxr15Gb9Nw+0Q7012OTD0OGQZiu6q1wMQtyC2xouOqDcaa6fuvDVcEEXbzY6dBuAA+2DGsOaWcaTg7k/L2kJ+kwKaL3s6VYN3oEUWXoESiHKIcgLOkGmyoTm1f+9wGxEajm6Tm7sAmEN6f//y4Vf////0RSIoQEFIgh7wsypjWGpUXEyWUsMBcLAKYZA6DXVCG6ftOpKCPgAIAgKgMIAFB0wOb/+5RkFowUE09KE6wtMDVGKq0F5QOQUTcmLph4QMkY6zQ3lOYU86Bttk7p94FVW400iiYxWtHEcXIK8aUW5iia8edWr//v/0MeXwYJ0RCrSrojIRdkmLtuHSDmHVmrtO3R/9dEK5rgdiEPTkuYrMoaYcUEj3fEWMf9UYIEIEkkkiAkFEttUZqM3G0Sn6GIYhxggCkMLnvW/EWy/66IYLe1CJ//+S40JHa2xyP+QgZwFN2XyCGbMtwwM11gFF8AoIAwGTBICDA5vyiBmJMZQhbQwCBowyHFVMYE8wAes9WBNkwqANyHw4Dnns0mcU1qW5XL7OIvBc7Vr/7ng3h/XiIoWOy3Zh08lKFCXh6H28nVvKCGpUjkyjQstY3nDL4XGhkRHmnpl/tbBeGA+5AQydjLNFAdnTclglCAiB0yXgziJseioX/bLEYDkZLvvOp4Kx5KLXxP//pEAGN////mhxN1Sf/zaoIAkzM66xgh7mtRcbWcZotagYUioBDEKYErZNf/+5RkDgAD3k3Ks50bwC9mOmoFIgOPATUoTnRPAL6Y6nSgD8a4cdxfvgwLGKhMgTBgXhVbzkoAWeMMlVKnBAu7taQ1uzFurOUlaP3vs9Pj2qlTpZhR4cHBGJXI+qZqVIuXPM8+yCUQiI2y3LZX//9L/GdFzzixpPKkpFnq4ZyELT/YP7MAMCLsQRAkcPDQxRnGh7VRQzv0XMZPMVUe6LKFGR0C0Wv1k2////2BAYrR//QMDwAMBBK8zBC9OTmE5C4A7MAIZEAJMLAkwfbRrttdYUvynBgWHRQLAAwGAkwLa05SA9lS76CaXPD2+YvljLpPnbgp4NzOFPziupWUQfKvKO5FipCs2a/ISZdkzIjIzixiOSDBJKwdm3/t3vMqXDOzJt6UWQGkwc79lYQIGZDakgbAwrBAQkbIiNEINh1RAMp/8+p1CCyf31JO/+vcgLjX/pBR//1tJBNgZsTCuxLbtbJBiM2lcKSToyC70FNES9gyRzNhuuPNkbTx1rLFrWr/+5RkEoATEE7XaeYVrjRjOn08yzmMURs1TaRwgL8RaCT0lK4pq6ma9YglAuM/p9bAk2nl7ZVOO7bDXEHKl1O6oSeis/IyJdwhYt1ZmRmpXe2v0WyC9ld4J1S/1ZGMGsOxiNAjFbVbhIFqxisQ5Ui1FDsK4NBGAYAMBrB+Cx08TRyjlnLtKv/uKYLEIX7Fm//5Sj//81gBgATTkcDqqSVIa+ID28YEzs/bqJDojhyimnL7atwbINALU1GixPguRMn0UxLuUobj4p6bEDftPKBw+XT7CmpkWDdMv/KZvKnXL1OWcY8/sP7c1XKl//nMi9JYx0EUK5WjNIYYCOPyvoAfpdgoNELQ5p1gNcqkydJmpYsjLdqRD9DuLAccQaT/9RMgv//IlS2eRaAAGAAXHIixA7XRwUBvZwBBhGkDPW4opJKM3G6SCCHoTkvwYQWx+y4i1j6nYIuyrohQgJq6pa9BtXHHu83x5oNRZ1ccv1qyFknnrbXd0tdcWY8JGposruX/+5RkLAADFTNO60gceDHmOq08xU2MxHsqTfEqyMSRKzUDFN7vXEzyx3YBhWdwGAvjWJG6IIAP86L0epC08dwRQbvNMIBm/9Tlz4OX4ZUlI/11HNl//QpGf///+c4DGdkgkWx/VpAx8A7me+8m/u5EWEoOJEgh+ymLbZwoqz5GRViFKWgXn50AC3HmjFcwjrXiSdIHMQcmr/Xl+maTqV3scyeNfAyt/77+4MS/0/+Hw/ffT//v05iIvLpGJcAmNPhKQ2tQ80zlK5GpNjtocAsdjeIABeKTNnORlAECbu/QlAsWYzHVDf6qd9P6NqQoac//lv//Eri4eWAAOACU5JExXtklARccjQdqx90U4RyOUZ7TLZYyqYVLLrAguk5nkz/AsUoJlBfgQ5H+RNXIybkNDBPaeoGOOpfCSvt+/QWnltEosYMLaGKRfCL3Nv/Xfrl6ubEaa1E177+K6wYB0C25HEgPtruLWlysUW26bluuiH3cle//N3dD6cYlAwDBn7b/+5RkRAADFTTO6zoZajOEam08xWmMUHkoLfEHgM6MaDTzChTJo/99aCI5/7Oysz//9ZtTi8hjcODBDWZs2eeHhAsBpMDQZLRrpwAqpUjydgCFil44BwBXTiAHjippbHYa+zx0Q8IhzmJDY13uppNZ3WpWYhRjQRUFUUWquHlEjQIYBUJPfniilE6OlTOy1Qesyv//cAIF6BicGJAP21nDkLil2mGRgtJmF8r29EpC9lVT/lmLkQn3p4UH+tYIkX/Jt//zP//QihU/vlQ7cA5zMWjjDrOGSqBhiAI/Ebjmms65BCsgAAE1C6opNRbU4Njo8xFNQYKmGoIcGHhyG3953uRSj1hL7VRjtb7DD5y9YLzBNY1RSPPCuPrFiB1oiONpOpFiI4CDe0nXFp2BcBwauXQMASsXM9hMDc8DXx9URUD0c1ot6OWTOJGAgla7IERZf8QTS7bE96kHv//BKCrPZ7yENkYQOAClMsghIKLAGLFIg7SeKjNh+25L6AAK9pb/+5RkW4gDGCHKi3xDlDGEap0F5R+MjIsqzfEOANUMaPQXoD70GSUBVkogPFPF6sGwPkjxilmokvMDbdLLeP77qiPqKXFMNBpiGGN1j0AgbDKqT+OPTiQgphi4gUGtoArYHNNDaSbZocIbSkQQAkmBcw4B9laQm57CIx3zI8ze2mI2woSbZirFFxFjmU83//djyAcxAQRHAb/+hCqAICkNpyNtIQW7yL06hOZO9jd7xUKUC9VB824XITc4WGqECKWKaJfAjNERoEQy7qLUWRlR/bSogSVSRqrDZBfySfXKmfkxziDDjOEesgsFCkY4tKnOUz/MQ+sDFU+SYl1JgDCdIBGlsqmBKScQcvA1zMR4YxaQjhVpBEWxqJ4OwLcxOt2bZIOMFwGd4lK/U7Z/+qd//+kCAS0pg/AXngh9OEizaj0SAywChxwYFuh71ArPs5IvoIDIGRoEMtDKC77uUtJKat3CHKfCjmJnFQMs+7roKrZH2+CQuEuwd2tEra0YnET/+5RkcgADBUDSawgcXDVh+f8F5g8MTI0ozfBuwNMJ6rQMJCbxUTKOJCLs8bF7rE0C4CkU+33//WG+t4JZboIALldHZiQcAUHXbExGKARITF2mecFzDmPWLKlR7enPICxgmvLvvUogED4Ef//LVQAQMAADXMYPsIzMHMkz6QjFZmZwkuLCUQLcWj1Oo8uYLABoyXCwjDhWAkTxB4V42s+OiIeeTUljDJmXvLQdcszm+ymd3yFn6l5mJCliJwHF2Gi/AOechf3p9NoQXYvoBOB6BjckAYG0SE3RxgLXTDnxMBHgMErnTnYWq/FXKITBAqDQpV9vb9b6UjUDwp///+z5wEjYNliAQKAAE25GxGoFEZYRVJswqQorOUPXMFIcmwostBWtYLJK1/KAgtw6RIKXFln1eP/f0gM2t7VkGze5eiyGCh2Oe075KT/S/th1SLzmJOKR4+PYaWWHWqR6221O9I00AeBoHHJYGgP/fuVBSB4Xn5cjkdDo4IKCOcicMn//+5RkiQAC+ChK44kcIDfEal0F5R2LxNMvrZhxAOGRKbWGFP6pv45VlubrtpCin++j6s3ZN0UcJCZn/+L///oVQAAgCBVcqSCgCZRFUKQRhiUKbqmYOQytvOMye+NVmoytxhTOUNQIQldSsFEiExAKmZk6oOQxk/z4YYbPgiYJUsk4xEkTtMdGU7fKpn71s3VQu6pV3Tvrt0r//7zvN/AZwBUDMNuWwIAf54ZJfytJFuE09PINAqWPFqfB9kayG9aWSb9OTQhG879dCCFp2V7u9Cigg+z/9zAIFAJLkkbQl8raWPkgcAoTai3dzBzEnfnXbkTROtc+OFiWULQsi/Q8vo+87W9BfzN8Tsb/9/bdo538smUWoHPm4tcaA852vIaQkn5p8rnxZw2XKmHv9b+f//j/1/7/QAGABSAE1spnnFAAoq9z7teiQk+yfavA0NtTVveQsVgH3HhSIeqodTEQ+k0t4rpOvkgLa5bcUD3/+hUCA/caaKnYPLTa1kzA3Zv/+5RkoAADBCxNaHoYejakSl08woeL6Is3rOjKqOeKJOQdJDiX1ZYFLUfdn/l8Dt2nlWQUrswDzJuUlj8dSd7HhiqvZt2fcGdNnf6gKnZBjdgRD3PIyMYqKtnUGtjU2OyuzW0221R2thDxK6WFKCROZ9Fa8WV/6tKBgFgkTlYQA+ZYwPA7qksrefop4tsKiOCYew1hMWe3W7+KB0h3YgALPv1cK9UpZtDMWYBMf//iMwCsqRpyxC1i4KbI+GFsyuB0JAxSIKEPjpFJJPATjBgCwxgIM+ybpQArbsqiXwFg1qJhTpsAimbzj5BR8+AjgZQtAuRHB2fcH1E1EyYLAuo2aJqVFKQEcQp1CWjMmq3oyPt3eLdAE2C17QyceOwuMyt6XReCzT2qHdrLpVETKDtXh1umCNTzUUgoN2n/dXxT8V/8JNbqNhWUMJHdc44YND1zEZVfo6JmOCphH6Ph6BHbi8TY0JCBhaNYEs4tmGjOkyenilWK22nhHh0DssEgwkH/+5RktYgTFzrJq2wUNDiESi09goOMiGMkTbDQQMaRZyQMID6iDFrkdn7xbr01NU3CQIMMY3OtDAGqfCbDpN4qeQ1JlSgMWCgJARqR5UhNPSbZqfY9QVpWOTRzmSlQBQIQBLAAa2wtS8+AMQA40ok7vKQoocfZ4ZS/7VJCQrEZyJpmXvIjAbewKEEaTNIs2/etqBJLX9NvAlZzKhcVWjGBRONHdPgLPJSBwdBs/Nvsj5Py8gjwyxImhOk15yIQRl4QgkiZn75mTl70np4YylX6drFYl90di5mkIim+Z0sCNOqErb1JJIy7Dyyczr5EIf/9ZAgGAKJ2oYAmmTiAzjGJokdEaNXKkuweR5kZAOpj2VBEUK50sP96VNV6LrROVhiX/+8gACAAAJKNtYwCSWyzJlnIYmgVWVJkRUSPXhKFvReGoEwvivcMcgbsMxGZlTZ9hxcL/8kh08yM/LqmdMqZfnCJyMzzshpxLzRizggaY0TLMB4MVE6EPcDQxrDWRU7/+5RkyoADlCbHg3xCUDSCeWxjKTkL7MsozZixQMaRJvQXiDxiAV6/6ABQ2gAC6wABOyvcCMCg5OqdYcUsnzKLWduuzqHZESSViAhVp0qpeR0MJk8qcpFrdgUAAwCJM9uEkWNDRraoZEaq7TJStKjiJuWDjvg+kiLosFVQCluClSEw/rYSBTx6rffBSJAr92TPluYy27TMOYMmHZNkvtvTxkVgGhTbF5qQtA7fR/cbUx5CMkhwymHqmt/yL7zzOP8nM5vKaKHBLY6vSvWqTC/7iwA8zAr8gfUCw4OHg3sCncUq27L0tblbaCO1kFpyjQiyZKX5Q1zB02uAwKA7P3rE1q6+aXuEBAOB9pB//pV6ldgxumMwGbcOZgtBA4BBYHjwxMEOEDkpia8ZqOMSGgQ45KBAZLRIywY6Do0sjoZ621AECVAG5H5kZKIkFbDejs6nSXycZyzkvtwuutPTeHl1DzIzJ8h2zSHFEktLMqRfS3GMGGZ1yjBoWHIUGq3D4pP/+5Rk3IITEDLK60MUcDFCWX0HAw4OcT0lTZhzgP8RpAmmFhCS7scLrCSaCCBIBQAHJogDhIqMDSjG0VkMLVkAsEbaBy6ET028JeKH2qDC0UAQG19bn2pTpTaPzNVQLlXP6nVjryQW7cDf/yrv//bABMQS1ARSJroaeicGLp7TRwFMOCzB6UByzlwFIm2rDQIpVEgJ2maAyyKV/p6QSympnCDac2WrbXYGHQS/3U0qy3eGffRJ52ZUWGc7naRIDUyiM9NqdY0pAwY0hXjhUBJQp7ByFBhpY/qQLUIyYUZTagrKCrg5qAAgAOv0QDRMBmUIotAkwmrKBioGqgezvNDjT7Dyt2a8VgQ4xQkLDApkDCS81h/YkmISrgUdPkECxZpy067ULj5xb//Z//////+hAAAgAAdTJXi4ogmhhBuASZAGLqUxY6DFseotL2tNDvrVbtBIxHjTQ9kVpOMYLydbkINZBB7rqRjSOBWTB6zMxQxQpT5tPSQ0p1+iqqNZzu//+5Rk5wgT1jtHA4kdMEJjGPZth4QO1M0fDaR0wSgRY+W0nhDYnRW7/boVR7WCB4SDagiM/bVv/69AAEAAwAH3CwgFj5n3hoZSkBwKLAgDOK9GHoxEcIqrGulNEUYAEoLlpJ+tgo6AsM1F8WSNRtC6i7RemTCNoe//r///sKTcjYvVRgaJRgF3CEUUbmuEkWk0+TRF93p+KM6YaMQxZKYG6lrSRyM7o5ZIgFeuq9vdrtfbLAm/IbCOZovcyhFTaGT5yUuTSjLOKZW+efBTAL3LY6YqquLf/9/rFzRCoMOENg/MFbZqIhZZEATCnWY++9I8sYYA8iBEcUBJdUrD/XD/NVAehXJbY4Dj0tlZbtfIA3/////Vb9P99ffd29JgQioF9/slFdBJuHQfpjA24pAS10ylxVNEww3IzHFC4iIIJEEznULFnUaM/PVJWMpWvBZkVQQZmrE9YhtRi/eKRr2Xh9/LJe89ypAkEiR8wIkLbI1Ir3o70gQAgAP2VCwoATX/+5Rk1gzTLTvJY2gU0EMiePlraUgLiO0qbSBxQQ+JY4WtsRgRoyRMbEOAZacwIsD/qcf1+pQ7BapJ5BOYSdAZYA2clg/q7dkajvdYJqEeiHNa9OeDLrppKKLAzP////1f6f//6UIQGIpELc0rLHZu8NaM5RQEAjIYKIQlIsXTlshp47DN4kKlm6sqxuuaiAJ8BjQJG92sOQ10T9C5ZgIn6NLVUFcT0N6oz6hqbIFYg1RWSQuTu7WilO6oQGGSTToIwQeJAACCBAC4vwITlWncabYafCb6RSxiuRkMcn4ChlpcJWqCCorREETE3VdYWYdYDhangXkaTdV+vMmn0LA25Kz4DWDf/+3/////+uoAjCAC1EkKF0BQobiN7w0T4OUrSEEHYu3lzMXKj0fZy286OMSbU4r62MjCxWhAFll3rY8iuZPlsb7TmNdIWDBc1LNVRHFfNY1EqeXVziwIn4RcfZYMSo0LkVAITsRW6so5hOJGoQ6j6vv1gCAQBgAbwIT/+5Rk34ASxz3QYeUcXExj+NZtgoYLwL8zrAkSoSQM5DWdoLBQOSH1JG8co1ipVXgqDIwNeswt3H7V2/4QCBhMGYgewVjcNU0O0sOwe5DyWLlPLr44BQNkGT1mdTjr+SOIAT////+/7v/oX9vt0T5NgTrM5tS2toUs8thJsVBtQf9qoUDFiGTa6OAIKh63Aj9RQqiVJJ6w/KrJaG7Rt0Wi7FJN//W/DIbMdvtNYZnfOuCRj+S2GrFilkB4DpiFLW95wWJLaTMnZk2UF9369VABCAC/iUg19H3AF0OQIx4kEMQYE/qL0EDPpCF5F3H7AnMbYBCSPwYnTdj9IStY8sVLaovm7EnkKMiJNVMKh7/+U////9f7E8apnyy6QEg7GltssbGVRKRPMZMuZqzSaQQ9KV+wqkcuVwA5MfJQqjfiNRiQkil8KMTG85VthlVubkqP/fa+76NDZr63I6qjZEGkqiGZShcLlRhB0oHykxWNaLrl9KKGYs+bMVpUAQAgCAj/+5Rk5wATUS1JUzpCQFOj6Mlrh0wL5L81rRhzIS6J4yGtsRiQP6Y0TJJn4+Ymhq5T3CoYZEFkaNL5XXuSMiC0+I2FaoDRqsCsd2XDhI+gSIeo0q9h4Gv9Mee9FbW+3Tl9H/2f/+//v2N+sAACgABJKJoWH+JWQFBGikiJDE1DVsjC8jvU7btNa5EXVqNbHX5FPDClMks+4yPy1RdhZ5lTK9kgzWG/T7dxp+bpF7z7MOst2vQQASX8u/Z/5w/Mnh1sgYQ09iab+QrSy0cU//7X9pUEZygBzohtkCZ4iDhQEWiGv2671x6AnuQPEIBbuF5ATEAOJRtyvjs6MaIZN9vkTLEgNy0NuYt933kf//////u21ruT/NbDxqoBDACk422IMVJnPOOIYMmmZqcCOcb6sv7SyuSvbOuWOUi34DkvUzsY+mrhDnijWtmZ/cPm5fbfpsjeTCYwGhwGppMEhQY1qGvHY9tCmLfFnO+b15IvxX/9f0IyXB4U7cs2pBB0YAr/+5Rk4IAC/y3NawYsyEujKOptJZIMtPslrSRwwSSJ4sGuPRgomKSh4P2/MXeB6gwNIyiIHgCSGCACDwE0jSjm3VZtlSlHZGdORZNQ63RVkwA7//////3L/iquY1BtOdJwBgCmQht0hm4okfJiZMeulL0eKhfqG1pWjM8jgRWHEglbCW+AvzlMkgK4MKRkI7MVUXOYcV216VEQ8YwXgZHIVtyKnzCIjEg+Dk4VcI2PcXExZ5lZ9DVvCfEONG7/9b9G62Za0hagATBAIy0SNXiRMBgmt4aW6mZAOimmCPwTmN3ftOyJJxNBfwL6gsOrnikauBfaQicsmnJp5FH//GuxocLHLI6WWL//UtXd9v7P/5BH/+/ZZEBzNjksjSEGUsmg1oqmN/nuWvOs8ErDgr8Mq0GgVWrGoJUjeIcujLORLqtblQuD3aHnAlARBnMmMBhHc1WOFGRGPhCWrKtMmxoNH2Dhc3HJvJ/10R185YnKPEKcmomjkiKsnUDBpMRMiVL/+5Rk4QgCwx9KUHkwcEoCmLBrjEYMzIsfjSUSQTiMo2mdmOgv1ehmXS90BIJNMQkCKKA5KK3P64mCKMWK1Af6eRfKUtw7VY29emIRQ/////0+3o/6bSXAayaWvKvYkAECgEBVcGEMEsQMmgO4ZcRHEv1LRWWPbrC6WmKAeyFu7jBROAhQBGRDEXq6OGPZD5EGAmPpczYJE4RmMwcpvuTSeUjEeFqGxM6GUDDIOKAoTHOAM2G1l5mNX/Qln+yzQ33pJqsMsTSDzVdDLt2KjodHwK6Tg4AZPTTsKvBwbc8qAgkmgYyWKQLZhLGEsiWJiCH42hIpH8hE3dex0oL+vyeEf///72/RX/dyNodkTSC6HFQzhuAFZNS0EslkjSG7mcmhjpEXMuKpBIkOqJi5tEcBeKdofC3SS7xG9zc71k9KcapqEKOwbxq50zVfzDB5COEgRtsK8y84DgFDCSiSD5IzPjVa4r6tN+qS5z6QcagYyaembgImsMCzClgJbFuFDcj/+5Rk44DSyCzRaeYcrEyCiLBrjEgMUKMhjSRwgU4NYoWuLSDh2ONgAQfL6skHZcZ4ASgcTltxLE5eZh+hh950xPk26+/rUf7d6P////r2fpqX/whzN6rxVIcAAwFP+gsuoMvCep+UGBMv504dKmY9tVlD8PHnDcQd4RokU5HWs2TxNuLRdeWGHpevvli/cT4X+hDYYCoPjn0fMs3zvnvlomWjEOYxSzLyTwEkUAiwIbmzKbWdnVT1/6md8ABTSH9HSMmFDDDwycKkJc8OHBlTI1OHl4u5L4809lSU4NujcgcUiz0ZnCkDIn1ias1yPJ5n7UV2o9PnTrH//dk///Y7/u7/qcL+ETq1ABAgAAUjjRFu2QkDehz5meO02OxQRnlCUzHopL/fePOyQgkTcNTVXE6t1ZGG7+aQKX6d2jZCiyu0HZw1SQtXiyWsW2wUChU2wDCxYyOAiGPQtPiJG+MR/+rZ/+oCAAbulhSHJBSOZJyz9LUBAQDpE6OKstyuM7T/+5Rk44CCqihRaeka/EwDGKBri0gMJKEhLLDQgTSRYyW0ihgeS0BgCOZAO5B8ThVl5MQyOGHqMD6bFtleVPs/ELP////6fs093etalsehrbSkIlVUsAVkwnSY3w9i27ivYKpjzcje6kinGUwyy8cHJww+0YaYhQOHbIvd0MHS6CoJJBM2ERAJTqDrCcspgPkkJUmqKIGqa8XXXZETizmq2a/d2f+VRrg63DhpvfRYhNOC4lDYwgkw8LO7EojYbGAg+DgWHAgZihnYIlsnFgSkzld+inkIN33rfzMMFHdb9SEFRH70PC3/////7l/n9rQKUZc8poVPpUoCQKyBk3QRpxtiFbpj4SYjVV0DqIv+9mFWKPuxJglcEuhqTD4o78qo4lRSWUAGQgQxOAMLt65kFJOyPRUuK0MsiKTKcMgrXnlGK3ykc8rPuflg1uRSSyu9sY73btzobx84leSQKAAYACIo2T/CwXLsGiUgUTIUPQEACrEf3cZG/DtUbloC2hD/+5Rk6YSy4ChI6yYcsEnieLVraUYKeE8gQ+TBwUcM4kGuCPhXkxBIQOxByFiQlCYRQIVHT+n1frdG1DP99Sv/6/sTtc/r7/9ruoBBCAlUCaYSK0T0DTF6BHnX4mWn8IUoHzwJGNRpsbJXTh0R5SguEAmKuNePfOYEg2V2O2Y6EGsl67tHSDD062HjMWhlRCKUXiATJAKwUFwVCSWygoYMESS7SYv2Ve2wUNVBHpPp03m9jVSDqoAgTOofokKx0/2REppK5gValJaLvbXitMpU9NYkfIwhutXQx+7NECrzz/QmXudv9Osl9f9X7df/f/crMdXtsakQVQAAEBQDdIX38JYpFRMtRMY4aczF7R0+T1rVJlSwyull7LxmmuQ0xDE4XRhxzEiWcErqMLY+14hgZ0ih+Zq2dZUA0qPAede1pdAylAuo8QIhwEHhxHAkXTu39//Q1Nf9SQIG59wqJ0sz3MwuaWYOh1BQtQhL1DbxRnLQCC17iwSKRQs4tNfiISj/+5Rk8YCDJzjGs1kZcEhkWOpowoQNeIkZLTDSQQSJZDGNMORAMmw2bDqjFlEnog6/cDHrYjd/Vq3f3XVdI3YUQ/Z8lZRZTd4MuogAFZA218cuhDE3cgHb04WZwCOuxfVAkexl89Oo+N0FMYZsFumebxhEotWQZtDATpcSoKBsMABbSAlbDrjyjRaG4+Fw2eMGdwdpZvejFc/6t4g9ez9swSfQhAEwhjTFQdJgI3UMFCdkqyTHggVoSNPe6bjmo4FQ9OlL4RtAdCr3bM8MrcOS1GIobtLUzcSwK30gxvvfG//r9v1OK9UVIW+vt2v1wuL7+YSixQAIAB2AKr8EusMcnOhmwbpnlQCv0QKRPdAMMQ9XssNVsS5FcYPQBksRWICqJCBQJspVrU0H1d+33UjPG6UkQLQOxBAdAzhwq4gdAQmgwKtFguijRTilqPv6RtqaDi7G0e/DimSVIEAYgCY4Eo7G9AYkEKiVnMKChzTAX1IYFeuVsKU1TnWAAqcBjij/+5Rk8giDACXHY08cAE6CaKVraToLNFMbLS0wAUGMoom2CkiDHOGLUFxzlisF9RrNx6D+3fWW/7/7f/+S02Chq/sRjFiA45Uwgw0UWu8BDAAr1CSQ+QQY2b0gYWI6C2UfAq3Iyz3PFJ7mMRpnOGGpFNAhdE8vVTVFXlSLKIFIO9ztgwiOuYksxEMrQBmJARGZpCLPy8fMOea7N22/R9/9913qnu3dTqbS1FkY5sFAoQ/wqAiAEEWWRV61X2uUDDFMkqsAKWFFQf5SKhXM7W1vT2K2HSOyxyHsn1gjN/Yv//t/Z1cpWqjYxsuvK3RwPloutsitZAiFVQIEICBAKR3RS2ZcIEwTH2RYCwlHAKaRPFK7kxTUatrsyoUSk1ANHiUV6RpGxoEmvOMelGUtysqDNppJcAEyqRKLtWUYRhpYmYLGQIRPPxT3OkEKHJn/r/YddSCeQW1SWseSFI8uX3QKUAp0fwUDC7zoemICIxEg5eajD348WHXgnGEBYGoAJmD/+5Rk84CTKx7GS0k0IE+ieKYHaQ4LFLEdLSRwgUKMokG3ihDvJIzd1cIvsusxwHbkXtu/Lf///i+3JI6H2XozwvUK0BR99oVY+sYDxFoEjP24QiVyaeB4ObMIDxOqUrACC9DMaVvjMtebIsRiRd4Rlo9cAQCID8IiLSguExSqlWtqZQINn/ycb9yx5D/UIqB6Ve4kj/CdSwHxRW0Jvln5wbvrh7K3uasr8Qkx/+0/670Dhi+uf2Xr/+J/HYvJm3liZiEFkDGVDAwvofFqIkkOScGBQbXD07OPxiQiAdbxdEcvD3QOlnD8msxUCw9O8nO7VJjlPp0Dv1/tV7fu7P/+Pmhr/uthttEKqgIFhLV9hYZGqc0QWMxKEuGZiwSKRYQnVWtQG69+fVUZ4BTUOOQeXzJozqGB7JwWzRBQrNWnQMxsmhmRxC9fHareElVjaroaNAZYBaXP8Y9C0po/yKXuUss2ldRko5bFEEF0BxbzYkB4AD5gqFggSdB8YUOogMj/+5Rk8gHDLhpFy0xMEEwiiJBrbCoOnIMSrbBxCRmJ4omssRgVHAAlKObzzEPxmGE1IJUrKrGlBoMTqRfdmkRVnKLgifIsHOKVodv//////6zvuue6tnovQ4LqlrpFlDmRw2kzMckVFU5zFAkyzLKDp9HmygV6EfAUEoLhePNEBgPylWkmjGUpqgjBgfJ0kwuEFibJRxWHckBWB2HW0QamDYaW6VLMA0aWu3ks1DtRUSyOVouDUDQ8cvC4VLEnJUCAaIB8ekkSGmUgAIQDGPDo4ZQAGlwZiQa9MhMEAHF4S/lz3OxGocGASvVkmV5hDRI+LwM/RgyJkTa8S6CUkjJ72Z3/////+j//a1O4A+GUQAOQZyJWAAgAqxxsi5mSHUBsWCjDfQazUcxIupDN7xxWBlM+IqZM8sn2DKs8NLSU6KtYHSNTHCc+MtJCHLUdtVSV+7+3JbMXb/Vu/3/SBANGAmJ8LEBt8YvphJMWlxbgKPjfEEyiW19pKQGyZhJW0Pj/+5Rk6QgTKy1Fq2kcJEejGLZpJYINzGUODb0wAS2KImG9JLBCPXYcOE14XiFjNdUxifndFUksb6VYv/69FX2//pR0l9fZykpeSxyhQ2UQvFATNKMQlMDIaTZkWSx9MUAwR8W5lSddyYQGqmgIUqzJgV9GnQPbDpFyYT7GJMTAQRv/aUfSjGHHr27vb9ziyD3zS/uri32GE29FwseWhwbFmFWirHARgtGvfgx0KSEdwiyIkmSMaSIQ9F8I1LsKHKHkHHKT1JqQyM1ng6VJBIXtlopIHrfP8zPBkrEb+G6f/lKq77VEEv2VexnZr/+jsorqAgEiAUMFFiEAyUNNZjRWle/ScRiAWGNjQXfhlnUfbViCmQAZSh8XRTwq6RJXYKRDLoUW7xBGn/BhJHNa+Sq7m9v/7uyOlWmTp/t/v/T/l86X36t/reyZPXqy2VjJK6LNSZUcO4Ag40DKIioqGNpk8IDAx3lgy6Jhw2AwaGc6aCHiQJLDlygQXgZIBiPx6dD/+5RE44iCPxPHUzpKoE4DKKZrKxwLEGUSTWzKwSOMoxmWGgC27DhqUL61VGJMls/64Z0SWUYYrbr/DaqXqQ37b32+3SnZSdnm743EQWcPTYLPGiIQjj5UNVAm5gqbAgQDnQrtF1qsTMgAfpp6Hc1LGswWoeWDxdAAjAUrCSYGB+ITzbfvXslXz09LUTVlh813jErT0V5L2X1XdPq6Ppc9rlNuJpm40pQXAjDBwo90A99DUpFU5RANtPMKUgRoKNIhFhnabbBFYIdhgMBWB02NsBSfWvZ+KIlK712lIwEn9ghtdhja3/9y5GL4Gy/5Q7s/012bkUuQGJ9z4wHaCQAIpHix8JmBikmTapq+xaEVeDxaeapIMgdao6SoumgJcyhxXYtioRobUJO2gHnSgHZ//1OpEclGALobQ7/93+7d+YzSmJL3PFhw5AgQ4PDZ5R49MJrvE4NSBqOkNMxgc8t4xbWHHDR6BgkWnMXgKkh5bSZrAWRmEuIPQGgyOSRB67H/+5Rk9YiDIWPEM2sUoF6jWIZthoQK3GMSTWWDgTeMYpmmChBBw3dHE4pLF5////r5Z3qSpl5T/XszdiLvRrMtbRWpFlobF+HxxEoUAiVgydBJQtKIty4K+AeVEYgMYoRMYMqOCsRDF0Lc1H51VI0BCEjACqkQAw1AwRqWFhStGdQZUH51/dyvFmP2AM8cfNixAk7Ykz9ti+lS2PHr81dCgMuNmb58uJrJQNKAygHmwoKioRoPGA3lVKt9eZ5opAWrw4iiMnyiFKKWYehRZHBlKAUw+xN4C05qaikxMaDU0YnYVrkhxqus50K2iX/sJI9fkNG3ai4l2t4pECkhyPSApRqWgREssD0kGABkCEjDdjjSskaH1KgMK4wj/HnV1QuUQgUQBYMYy+HaADgwQVKtYZ+hLOuyti4hmxhCaYWe7VUj+x+xn/Z55dtqpZtTk4rYSE97hEIVFg+IXPYoXAhMW4YEewfEnUYgRdSVkExg3ySbrymR0TPyydUZBAZsE1H/+5Rk747ywRlEE1lI8FtDKIJraVYMWGsOLWEowUIJ4gGtmVgxeclEiO3Vjocn1oGdZgj46stVf6tH1fFO6N/6Pq0PfC1qmvUrAWRz4nLiaWJgJJaAxjpVCwUsGjAxYOa77gIBMbiSankcginYaLqo3AwRZQNq/a152yZA+QALUSYL5hY/P/lb9hTTeyqx/so6WNchHGR7f+m/oJhNgpm6XS1RAiwwo8NARQgVBPVkIJmDb09IoxZlkqJiWBkWxaxi1Ncl8DF/yEOoADYkLJpc9elnDrOGCRzQTI2fowaxLxZaUVaknv/dTr55fg/1psImEYlWGQINcxg0Ci5asa1hc2KIDbBWgGUCFAA69S/2RhrJjBmQA09YVnwpBDi0midmejSfnWcgXMDoAM1HQQ36DEFBuAeoq5vrZdFdCf9KvG2UK3o9CfEdEy+z36E/2nxubHKw8IpDgCSN7OAI0MJvyLjhWepE/xAAqZoFEsyPNDoQDqaHDgSsJchQWAikbq3/+5RE6gxStxPDiHpgcE+ieIFrbEgLMGUQTeDKwW8J4dWuGcimvp+ub//b/t8jf2bkz7dqdv2fVrNpZVZKpTLV2+ipRdarsFVyUjPspHMx1OP7BGEOSIS4WmLACH+lEr2rEIS9REGSIEjJm3hyBqQUYa9fhUkpKd5otjfkM9mJMGVmn2EG2/Xt3v3//t/0Rk/2dvdrr69f0/zsyXrRsbc5lJp8teyb+T0r5LmbaepCIIZYAxuiiTqA3gaMBE2gLBjQQK4Y2HwNE+U9dGlh6GYpajAK0J/c5XdU5oeaQsuQafKzzP5f1jGnX6Nr/6G9cbr7OyT5FnYm1x4UQpZBJF6QgXkwVTFAdIMDptUquQ7SlVUToGiDIhZvDqrArNGh9PH9TVZfKVDW0EKmTz3qa8VL2II9qjqAaB8imxQVXt/imlJfravf36399vVvfq0a02JFTS0z9lwfFDGmTkFjo4kzMmB5ehJSFMG0ydmmL8FXpQjiW+acMzLYkxpDMWzdDUv/+5Rk6gCCNw/FyzphUFnMGHFnYh5MYY8MDRR3gWqM4dmNpHij2MfeYV1YRARP8/Jp/1//56/+/T/36f7fYlZ/r2R5lyW3Kzq6zV6F2nZWlKt6nM1B2WQ/M5CSrStQr4AOmtMrTpBEkmpxah7TzTSFhxIBhnNOPd182cIgcUXRXsDQfoNHZwqu5ttPT+gnq1L1lWPWfsSmz9iFH2EHEBM9RNbxHF3uDzCQTEQgEhORID9FQQHRm9EBQHocNWkLRRsFKX0rxymg564DFHb5NpP98TXHAxnY83xP6+u5tKx2ysVqJO/mP/T/0Fv1W19ljFxVygBDToGdOVIYlVZSbFSrDPt4DNJNyj0G35fdb5TRcoWwy5yJ+Q3VwWOYgznhNSUMzM+3d3e/Trfun9e357+9/9v5U//8mm7bb6dSdEJNqvVK3zURirR3ZVWpgnGZyJQDdQkFggyM1TRGIxtRAFBoUjTOwZxbUMy6nXmXXY+LEIczskl0svOQPbeeiqhqZQj/+5Rk6IwCYBPFEzoxYFwMOGFthZJKWE8SLWDK0R6J4umdDLCHKnnl9/9/6v///tr///p//fX37qnb6FYliqiXoVGXkdEPR9CqlbHDmdkGyBLIFJLxxuAmAACArKpJpKoBjqPfodoKS9eL6sOiYgfhBsaEoMY5WNRR3J1LhSa9GnGMH/tuen0dX61To2c6m/0XtjLJy0qmKFioXCQeEYneSARMoMAUTRA/RUWEhzKyMJCBHQSgGNZmAUB0MZtTLTVXq2CsQOxAAnl1OKr3MUCrVr19OiDvNETK84fPOJv9mSlhNxynTdOdo6UVMsuqxOXnHmWlxhwqk2ICZlld9WwlV0ghoKAZ+ZmQ0wLgxIgYaaDxzq7nY09JANeZS8yAMw5IHRYx9LnTY7B9MUEbQQMLPyor1Yn7f6/++dNE/p/6dP/9f3ullTedaf50k0PQu8hTPZnRURa3FVQjEe51EGAAAgSZA/IsQF8wRKapLmu4DgkGToC/HOkU/Hn4l1CuQUT/+5Rk9QjC4mDEM0YUol2sWHJtIpRKlGUQTSSwgWOJ4g2dMKgCQEp3WZy70tNhz6h58c837+++v6rfY/WnzGzuyfPQW0IYqtLyjSRgTimTCgUhssGWMBhQO2SVi1A1BgUxxeMt2OIIXDmYHnZucEAxeydEaxekQNkT6OLRIRaqQQ7nOt06Gxu9aIhT/Z39VxfVdVtNu459ouQFDrHKMjxVTRORIDGvMmASLERPEShUTPbqFU0nFABZK11UhYJMBcycQi3c68qZG+c8DH4aGReTIL2V8zY6YTuwWsiJWX5hm7rb3b12/2P7aNNNBp9zPeKqosMJfiiiI8LmwcBNrAeBpSZAChsjilIYUamarPdK25kzZSHI4zT9sqiGjUEo6qRxvRH5P8EAlvF/KXsFyxIGhYnFEKd6v+j/d/QL11ZypTnBivSt4FY4uowkaLuRIjRpBQe3MMuGhRIgASOUh0h0giQkRdSpGJW0ZniQyZRjK4BkAAYIvVdZC5Yh/LpQXUj/+5Rk7wyTBGPDC0wsIFNCeHlnZiwLIFEOTWUnAUcKIhmNsOCdt//////7vfHjsWYQUIWXCcIQkMeGhOKwgRDASDxQPHx6BIBVl4iRgKGa1UcUuTFJWuQxSUI/wqapX/UPERVn7Sy1gfbTollumcvBIGkSy4iJYqEAVf9V/+vWyt/k7/+nq/3b/+mj+j6/dX62ZER1RazMp1Vn46RnM1jJ0wJXLjAcSAkAKYE0DkteYM7DrXEbQp/CcLqzlBKaBXQODslBpcfAvNF7VIYacJBQQQaZmYD/t1+3/7f+7N9/T9/5/2/1/5NP7siNMlLa1M5+5LId0SjxMQcimd3HqePVbSQmICKhCHF5uRKaYmkQWikBhgkdw6mn260sfaKl4QAKXxjEAPmVeKQzqznVxgui3X5Zzoe0ef/+5CIbka3neeVf/GXrWl97c5/KJCMnRljMz7y6PTARxI0pnEZbq0BbS0YIcETkJycmGcFkAEAIBVFesuejC23EkRBaLW2Kex3/+5Rk7YzCkhPDk1lJYE5ieHBnaTgMIV0MTSRSSWivYYkNFHmSLCtLlpUnDuRpMfyXagjFvMzvVQt67//////R9qlc8ruskj1I5TQkHjIcOPC9qEgLAExERwZM1Cx9PMvmi4i8wEGBbNHqZqL+3mjtqXWgVGQxu8MtEluM2ebKlhmU37Mjr4Y2+4yvvf/W84FF77H4/VYNTyNtGM9Uz/ykfGVQoamIwBeLY0Vl18zNkKNMsKxBSZCrmopDjR8vOtQ5DhnxIWiFEAiYCJNvAtAY6ynEPMtCsLT871aMySTPwv4kFbMJz6PepHhVGO5B+Ves9f//////796b7tCvc1qUJTS+bJiAdlRiAE1VAbuJSjSc6xAxM1yWjv0IJ40ugSf5yGky39fYQNk6TUaHoN8uNHPGzIlEwfXaB0/JL1xQz9GqmvH5/b6WWueLV6DARUUSxJBbQEXBw1EoTFFhMSjHYB+14tPAzcQL3FqNYIJJEbYta3MZuuwpiQiJMJdi7ln/+5Rk7YzTYGDCi2EeYkKiiIEHKQ4OtY8ITYR5QP2J4kgcsDjlW1nYr6xzs5d3r/////0/31on9l0syUkfmUfa/jlkq7f3XYn2sFWssKgGPKtOU8XulKngGPR6/FO7eeUI4rUk4siXY6XJHT1Ka/Zh0TIRDR5A06f1X9U/+vv//9f//7//f/63fy/6eSFPt/eHKUT3OnGOyteMWQ8XQxlmpAymdjTjJQwYacsddghgx5PjVWxqXPSx5lpgpaDjsAJluBQx0NYMed/2j8JGyW2jrpevpY7/2Im3z//cO9anBwJvIvHiywwegQ2GhwUAYufCAnI1ACKtAUOSfzVTu8AfxMI6LdzA8KZpbNYUktHQIlFhYROEpGSBReDpIB7KYvnEZufyPx67PX0ShPR7G3V1bBZSFwEt26tmLGoACyRQmkLHXJTEAWZ/gPzkAKsVOg97qtzSwJMo1jvUPPk00oK4pIxK0YDNMJx8eMmdk2Y1JtQ51f3Dq+hWhOLa9fZlvXr/+5Rk6YjCuRHEM0xMAETKyIFoAshKxX0MLRR1yVGJocmNsOAti5cdeqmulJrH0MNCZYQMuOghORxVYvcIHc0Jxd9sIKLxyuHp964blsAxlrpMCo8CxWLJgFVCBG+hsri084vQnMMgGX379O/obq2S6+v+ZCyU6UT12Vcjfmf222Qqse2+dHaYk5rtEmMdmclTw6hGG8o5COMRzlItijnBxMKv6BvNMgabOOozl0g3DLsg2eRm3ymqS29bOZ4vWYIWRj45FM+GOyAhDAwzWEg/+366fei+/0/11Wr/9LvezJ+XV/3p1p/2dKKzI9XKtGQxuHdStRlZVVigk0K4hVeYCaxj6OJq4hDQZ5KVPjHoShUczNxGTIdVyvGKy1SmmLXNrFgabbkvKJ/5vas39rJ///26dU70tZOn+n2/r9luivR3YfTZxVV7mXXvFtxfTAqM8uAgbkAz4VQBkjSDRDCpFgUpQoXH11JuxEn1mXhYkMBgjciCHbJ7ISEsWQBcLV3/+5Rk9AiClBRDsy9MAEsieIJjSSoNdY8ILbCwgXEvYdmdCLHM/Xr//d/yL6tRtW8olesfdOBww9TCCSFSg+QBkEXHAmFXzdRo4QNOpDM/XY6NAUVwL6QivYyuJy8uQ2YmJGMRjQB55icu2r27tQPOwgdYIZqf1//f///0///v9dfm0vTZvVfbOfhlachDxTudL8G+HBqbrbVANaFNsNQFUIdHHuOSTgYrEzxoZKZqsqkRIIEppbhKI9KG7KowUYMACxcCPxO1uYc+C5Zy9jzAGrf+3+///////tr/z9uxq21+haZV7Feb5las7S90lHcqomUg7hIxGiWUH1RsMfKoFYU4Ko1RIeBqmLxmFyF+KR6Mo3YJQybkBGbsl3Q1A2vBmUR4zDVIU5xyvL7X+vf7p231XrqZ//vt/+/U7b6kStWardxBXRDvIxTi8c5JKMPpothiGR7IVAsguWKsOIRXMKgwMoBrBKQvGfDRyBLPYqoYkWEDP/XoprJs7ZGMgi//+5Rk7wySo1LDk0YUIk/CGHZjRhwLwY8KDRR1wV+wYUGhDvkT6h6duY519bjFn/t5/LfZ6/P+X5f/9//p/r96/jM7z7rmpERHlxUiIYkjQiXNpEKKbsW0YRkuMEMINIHagyHLSkSEy5B7WxNSApQmGQrHvthUpdlxTJQVCj5DjdT1yIfeSPchRH/b/9//Z20/Wv/6r+3r1/TT9H2T8l9ne6t3uqlRHZX1ZQ1rEQFOxR5OPN2FIxpEDmknICNtwWZ/IcZgFYurqlsU0pWBo58wGicO0A2kPdGhqORzonFfdRXn/Nf7ulD+78pXDk3Nyq2XhJIBe0u2VvcGgdGiwlWESAkeCGCnGyAQCV7SEUwte7OPewgmpfod2bL8LajAByi0C5pVN8th3IFAdBHrSxF30Cmm8q+qbYaASmPXo9njayYzevF06iY2UYY4nQsEk3vAEHVAGRYCWFEFAMpalEGukksXlN+zblK8HjiZi0FHwBwPLtsxZfdZ0sejrCLVK/r/+5Rk8AyDNWLCi0ksIlbL2GJkI75K2X0OTRhQiTsJ4h2MmRi2Uct00UzhRSlfe7MNJaqKb1gglVhUThwH1h8JrEiDQcJExAlVQdgphIAgRIbs1fEIDD4BxYxIqZ9a7cELjIYQju2Js9JUxpcbjvjynlYwaV/9va/3Z+23/7+n+ZdkT+del/fkRWVGSvLO35vR/o1+/29p5mvncwixkcqRerPLku72KSyehpUEFoAAAnj9EISahpUgDhdzfxsRWi0ci3vC/L3EbKmkG1lHNNn+nR0IZTLouv/r/9P1/9r/ujfv/98tbeqL0z96VMtKrd9ze+jV2vQZb2lPaMHJBSkGhgxuAAAIjpAq+Q2r2YSZaLJWjLFQ5ldX16m3hyf1MI1HBtcWvUuvK7jYInC32cU/W/VYo73C+9Z/Tt7iu+39S9VyjZNCosKMQPKuLH2mDJQMFZKdDYqPII9wH6U6SxNWABPsUeuWAwkWii1NXzia62tOWtETXjBKqIdOSZEMscL/+5Rk7IACag/EuDhIcFICOHYHKQ4M2YkILRTV2VcuYaGUihG/dW6t+r3d8mlur7H/JjK700tUl4hQ9tBc1RInGHA6ITAaEAUE4GICSb8ypKENDA4Kxd9QBQ0Ewx6JL6GvfquC77dQLSDAROMI0GVuTIK7AEEx/tO/ZX9TzfF9nalL0K+RS6MkIooY0XjhEEEhdDBQ0OLlCANmAGLmCQODRAYGk5CQB2o+ynj1U0Fh++txpbbU/L1qC4w/8HmInB3oQmptKypyqDcXu4TY1N+1O+h9Tv6v7//sqqQLulmng4dtYymKsQ0KY8IAgsN1AAYlKSNIDWZIkm2YWAE1iVMAFdSayjlNP8EQQ6D8iEwiQAcltHNV8VkPettbNpuPjUaXClAoihS5Orp/pU8bopqQVIMff9O0mulJNiHsQyJEQoRG4gBeElPLgLSUNYmQsISpRTFmvOrfjEUJMw8efcaChkoGx6yDc+8h7WbteD1yHHGEmb3s69P6Brf3tuUPxDn/+5Rk7ImCpxPDyywcEE+B+HJnRlQK3EUOzOknASyJ4h2NJOAYhWaKqHJaVWNMDCVig2NQ5qSGIj+A5UAhALZIlQv1MW5YypQyTuGYWVlExA0X7TgyixhgBDFFh8RGhq/XbTfVV1/1/0/09qKrbs1T5+vT1cryZ0mpXP6cuZFr9IyMO4l1hC6pO5ORAgS0QghmoIESeKQyE0mMGciU3G0SK9+A6qVTM+ypmzfFFDu7PwxCYMlJhYwKMCc5KE/rxkzUNQYaXB6ldvca4X+lEulKCYC1XVvHdC47ShBisUx1MSKKBVEst7XAcJDj7SBxBJUAAAl75DWbWCnZ5ACHTEsRNC1coWTncb92zIIfGFIsJBaF4YJosgsEyp4OP96nZDaN9SVSJRjskhqt791Owbv1aV20DeAyBBjSxE8YCpEBuDsDOJULIAmqm/YOzgQtFnATkL+CZC7nzOCnSZM1UEiR8oOMhnIRwENYIrKF/v9M1Lv//637J2rmZPpr/6f1723/+5Rk9wgCkxPE0xlJwEjhaIMHGggNvY8GLZRzwVCJohwdJDgq/RL/mpketpmau1X5mg0Rkd0KoUppIKUYEC7oYMCYsBlTPjV6L+LymItlbRzMPlTwspaU0owAJ+8IBsZTeOt05joqTBU+3Lp1p9n3/7f2/tXy/tv9idEt2rS2pfsDgw6nTpkRSmaVhcjz/IQcqGAEqBE8I+OAL9oQhA7ZIQlA42IwJkJSKBBI1FMXFZ7VXkENEZTGzCVsFQMutT1/nL1u/O56u/wyDf9fnzl/y7/z/6/35b3vS6xDVuQJXpqhZyLiCzKrg0HYhKHtA4McoWLAhS1KZfTBuMFyKgFpORogcrECijQOuWhe+AmsoykbIrH1aGToqogTYXY0hJ01I7irWZW1BC78/42R3KzzVrUnLaFoa9z+q4WQl9K37bHXh+Wh5AsoEVp1oB9MNCygCBBKsjRAkgW3I37LY1ZIn2rKPw0l/P6eleGcET7VgZUeEpOhYi6BrHDEK3EdaNP/+5Rk9gjClg9ESxpJUFZL2HMHQg5MCY8ILQh1wX+woQWwjvFJPIfoVst7N6G+jUxghH1UN3yY8uZHqGBU84JAAwkhLcNNAdAVydx6HvJbSeWtHc4hEWG6TWOKgp2tWbVyctYY5znP//aAv0RsiMvzy+///5v/+ROaOcGidfMliGdJEMjJNzMEoH9qoODQzC6GrZGS2mRJuoOHQYgZgijiqsKo6TLZmIpBUpUUWfgxYsfg0UZkONZZqlTFxl23GB5dXwpce1I6AVCnqjf/////Tt/r7L/0f/Ry4eVaKiw0spdSdI/OPkv9L8SlE9jFwcBJqQpIYAOdEkKcjA8ZmDsSVR/0CCZ8PFENIBXjr7JglQ0px3Nf2wzqExohKW0jmjrhhM/q319l+nb6mtrX172Ikpns3//zOn/v6UrTrRedl+2fQ7yISV8zOytRhJDxp31EBg7ohWO6adgDScMr7ZfGBI9Tx3PWbzvTEB3QGBnTpruOuZ7q2u55d2Ea/+f5eqL/+5Rk7wgClBREOw9KoEnBWJoHGQIMWYUITIR3iXyw4QGhDrH/n//Nr79+a88AdovyhRNfbmZ+Yenk3Q6qZb4Efkgh7mo4ZlSEArkVUEjCUznRUbQAtsCuzHeARDfvQ5IVRK6rW+YUzCXrutaXOjPlbIRowECun+RQu7Nqa/cm1KHtd3t1+hFKLXjJbU950yi28KMEj3EQWHDQgw840N8GXC0B8EoIMYZL8iMhUdyU1rsobpbkAKODoJ+Dr+eOH7piwkI0v/Xs//8v/zl1P/+WuufS8CnXPy0ff8jLPJEctLkOkMjxqY0M0LIgpvli1LNUqgAguOIAfoqIQ0MZwkTUaaCxyo9Gkxt1ewxXYaDfVaKV2Y58An3FjO9jKxGLrF6E11Xqk0XJaz2UOe7GvnHrThFIenJgc0vACg2hhwhSCSi7oZHmDJ4auO4BjZxC6DTyy5agy1HwtulvYSuQupOlQAERq+r+HO/lK7/7w7yBf785+nzL85bP9b/y37Nuf/D/+5RE7YzCglvDkFkQclwMOEFoI7xJcEcQYORBwVGv4UWQjrnOCfAKRyiCfEd/IOixRsZ1U1cQJ0OIW5A4sGNwox8IUPGjJEiBv0OTNAYQEXppeyZI8OPSV7tWVwmUxcKQw42QK7flXRi4GHFPLjWd8ERrWSZpP2RjS3uUgV3M3otd+6LKoAghSBjziioJFlqueLFVjMayOhMyBWYLhX9Z4kiIZYdZtWd5QXDTtQcQDEfoRc/+7w+lYpCkH//9////////7/53SsyfLy826Z/f/cqUJ+mZKUqnAdSTFSadJFtIZyZmqsMEZg44YNGMNlJMZsPIV25fWvTMRZK6LGjDDzegHVi0p32lxwjMW3jhzqIK/r9+//7P/+uze6+zU9lXd6EVa16ostmRkT51eQjj7O4Oh7MzBa07VnrauVt5Eo4yWKwCY5ZtwGIOsompbd9cSEmML/Vody/MRMhehDKKrG5NIhCFZb6NlE2f7m77iWVbAc81z/+roRu/67lo+xf/+5Rk9QjSoQ9DuxkyoFpsWFFoI77KED8Q7GkqgUEwoUGgjrnfF7d7L9rL2jRqQDvysaoGTDJJbVpLHHWI+mzyWpLYBZWvBwk0hYsNt6g9taWbc9GVv2deir5G0v7eRN/v2//rSmv2/zbV0ZDIzdpKq2LVFQ5qODIxyWBNCpcE+YJBB+UTRl2/oCqcDAzKhIGxCZLoBfSpCQ3dxyacukU2IJSo4pnS7v/T4U1nmeOXMX///L/7//zX85eeisg5BPRZ1oPDCQmtpxt23qPe9nrMKz5DSW/9Zmf7jSc/dZz3EiFIaoxVEoABAT/QP4z8mJAwoOZgeDX2XmTlY4fnH1VItLUdyhPK3r+95q5W/e+Zv/xcl13WdF/y/9Jxfl9en/y/lyM6OqkiyFpFBIjr8zScU0NIV+Itru6Y4oGQA3UKo4WLBQGtGRwYGDRxmJKH9puVo4h80p+ixSWvQzmeWuZarc/G7zdf/l5/v5ev//85+uXLFlAcv22s4E9PmbklsvL/+5Rk+wwDLWNBg0I18j0iCMoHEAgLWW8KTJhQiXoxoMGgmvEcT2Q1y6qhTIx3QxDPubNFUnQEBsEEEEqAZXSqeBhTvGM3B7H/XoiGN5Tt6vdd19mmSsOAFzorVim4opQICsliMf9divRvf/6fv/X3PZUS3/9KeH3mqdYqus87tuhktKmKoWqDoKUOpG6AgmCZA4JC8mpKQoDD9Eg4tMIDGlDpAPuFUjDwVIdJGHQc8QLK+UWWGcaZdKXlMNl1SPet5/z79v+fn5n/Bhakf0WfrrrP80vyv/+Rn7kcpUQtVXktmdOZIEhEbEQ2R5CYtrTppZnXRKYoY8TVTEFNRQhACvVISKFIckELuhpfBMselSOvalE4revx/AuOFtdJqxljWxzlVn+5c0QT+cpXXl/WVLL/785+zY/qWFqTvCvzPWdwxdKQqzNBJML1xsyhDtXHhI4Uw5BmQJAQgYSHguiA9AxYsjEIFGlGGlbm0BI9kYCJOeZ+fyRCd3vPymYL0ur/+5Rk+wDComHDyyEd8lxsaEJoI7wM3Y0GTJRzyV6xIUmAjvhxqTc+IKHbNP6vfWHD/6Pptt+2Tzm3/czr6qU6lG888BERkrZGiCNJ2IOOWofp3YZGZUks9d5HbblWRQRGobVAzAwZBRADHtjFQlSdDPafM1GFagFj32kKVlgnNHh1gokYsUEAtxc1VeK3i47EiGtWLsMiW8QBCIljZAtQ6Hbd23GE+Wep42sfwzkFPC1oEzyAzLtOLBUK3+yjmk61G6a3od5qFNzIUZajbbGWdu/Z1Cwhs6kFWPc1igqkDtVF2NmSFA41GIMUtGIIY8wmt8kMWruEIqyLUVv28s/vfMg+zP5rUuJ/WVrl/XmbMykydf5Vf7nn5J+ul/wZ3pvO58rvPKQ+iPmOAkVjxWnBycGJoukoZwgsHREgzKB3jGSIc+yy47ZmsiQC6SYKrP1e0sJadcLhwJ3Kmwxsc/weqsjDGfromdaX/bQrvRFsdO+RE0Ps7ulF6MymG7fkVHf/+5Rk7wADUmNBk0Ed0jdB+LcF4w4KvD0RQORBwQwH4lwMFDhV8u6b9vSD96IbuTDz3LUx0nvmXEPMbZWtzTYfaRpdiNZI8GNslIcwB+0C2QF3xwe97dHIC8ciwb3vHCBqkEEEZLilt4c5jvVtXLv/nX9Tkbvr+eX0Dy/5df9N/I59kJ3/Gvp/7vv5lTMxPJLGciz61yMr5ytVpEJgXSBzUBoRgsR+Z9xJaoY1OjwxpsKe4xIGFCVnJzeXcseW7X9/+z/83uUjNZ+ULw5f5z2Ti/ZylUw5fcXe8ZGJpGssC84zQLFy6cOnSLAzrDGLBssKSF3xM9UATf8hltTuLPIQESqJKsEfZSBO1tnAPI6pj4RRlV+8PFJkFXChqjcrbdXzeVi0jooZwS7EMFiQHeqH33vKChtcOxBfS606KMHCFgMNLCc0GDDP0Sjlujnbo9P0uJlzDIVcwnIAlF0vMEFg/F85nDmG6nYjlzlj/o7z/9fnsZfn7/rL7+LPS+NlnmT/+5RE/4zC9WJCk0EdYmqMeDJkRq4KUY8MTQR1wWIxYUmQjvlDBMCDCyGNqNbNxu1vuY/46E0bOTnYcjH64MKrmGfSOi8bqyVlokTCfW4/QAY1srfRfQHt6+zXRTUpMn7m/uNEoZhW0oFAi2pkLZm6fp9/X/9V/9vfr//9L9Ju7S2dfs6LuvmfnWrO19CFoh3rb5DFKhBAaiMjIGMOD+QN6SnpRaBUsnrNoOhjzlffPr14EiojlIiJdY1zf83WUiHRL/+O7y93n7r/I785/l/zg/5n8qUjXyXeSVyK859IjJ0UqZ9JkSs6Usqb3LDhiBLI1sqhUoxREBgr3OgngItZGYl2VypJHoVLFC0ZFNg/DdrVTD7jl5//r////l///T/Kee8fcwgRsvyU0qMfEPmUrpDtQ4t2GMU2KWChAkKewwkBFBCHEAwEcIAigCGAg0dbGiMOKd7SLaQ6z6QCn6TJsZ75TuDH4OCyYrDbYtwZynjPcSN0oOnhaD6EC0zekaP/+5RE8wjCjAxDsynCkGJseCBkJrwJ5YcMQORByU+xYYmQjrmU7oWwupKApP8gyLmUTe6ppQVBp5ZcxcVehFiCRS0UYEnc3BS7MGbFR0olBfkUjkXWk7UmsnhkDviiceISy7rmtYZ7KcNJffl3z/f/9/+8WWv+Ymb3f8y0pc2+fw519vPft86mi/Op9stszOb0CvJbM9VGklUYOqTJMwoO7LBZg5EZbHoefsLpGoyDmq0zCF9rqgVRmhpMs8d75kM5TN37dd/9v1v9v7/+///+1+ikYOS6dTK5GO2/Xb/M7Z71sqMzJamz7Bdvk4zq9syzWNt0b6gKoSMlagAicoGOa2Q5bPFdwlp0OlQodXlTLL4aq0xfxqFDjj9Oh2XL//PXc4ET9Z3y/X3Pjl5/fkS+bTizItTOlS9y3+rKkY6NQRCzuwhRJ0NkalDh3xAJmDHRIajDoJP2ncgeZXhKK9sBOvGR7V+LfLnvqy6Njiqwty5Uzzz5vgy76N/p////7///+5RE9Y0C2mLBg0EdclNh6JpgJoALVY8ITQTVwXExoQWBGrn/q/6ddt2pckvKrVkmV7vk4zNL7rS3ufZutVZMxlJHdsfTFTCOzCeToEcYMno8nlxTtIMuwtGB5IwwEFjMKt8xoGAO69hKRCiU3t5b/mqosgbX////////56/5fORSJgUBZax0iz3yPw8dzBVhB6gtn1F2yZ2vEiPY5qVB8o8EQABB1t6bFDwNpJhGzwtYaB0DZBS27daYjUrBBiLdzHetfjnkq5v////////+5/L54/NXxwSMz+AHw2O/jK35r1m00Fslhk5KbY2pc6XLm+O50xLRmsV09z04N9lokuEFohR6QM+CrYQxbx3uONvBj5EoQ+pVzwxv7/9jec2n71ZUC9GcL6o3aOsz/kWY5/qss7m5m7RmzLcUXOf40+vW1b/YfcTi93sTQbyzqGyY6NGsmczVRxfN3C1IkawAEECNtADW4800KuTG1ZgVVdf/W3CA4bWIROIEp0uzcjv/+5Rk8Ijy1mHCMwEc8ljsODBkRq5KjY0IDAR1yVKw4QGQmrlyjPFMxuq9VNX7H/+FHI1UKGjokQZAqoqeEp5UQCM3ya27I2AMeQbYRgg7pEgELBkq7K1D2s/wasYVkbhHQ7eSExBVvSQTt1fkLS14mS8h/pXey9l1LEtizd4YkVLOLpCgQvID+Q2VgHQ+WV5C10iAkWanq3K2p+GLQwcRYWL3dsjwzrEv/nl///L/9/f8sss3rCLL+3/32Nz2Q6V08zaKbEJyaE73YNnjiwa0YQtuqKzKDGCtgw4YYJEKEAIEpyREDeEACyjClRiRt0ZCIISaHnM9R5fTmPcOulABPM0uKEHCPyYzzvrtJJldGxF1/vFpuhm3UIzq1yLVMb1T2jdY6hxGTnlmVSQ4NtT6U9k7nwsjPaMryWc1epAawvZy1HKiXHaoD3TEpABoLUliIHe1W9OoGeeCriAlq79KYYVLZT+JoXmuHFgzcx2pKvfVUhizpWZL3tgSuha0NVf/+5Rk8AgDFGPBiyE1dEGhWIpg2FIITC0S58XkwV+xoQWQjngK0oatjUr991aMWTsa8gMJhoWCIHY8uBSuPXqUmMLBcaTUbviOMiVqW/oMq7OKYLDiw8C7/fM9V9GQam3/P6l/6l//zgL8+9k8qoj/PsNQWphuE8MsoU4bR6ZQIY/WfI6ISI4UICNKc3MNmw70OHAAj1SEMPQQsdq7aThB+Jb+HMkqBFKiPFrv4R5pTOYcHQhMHKdvb/X8uh+Qj/9//////wS7z/zyCMEi5kRUSMSRkAzJv5Xa4pszq739M8XKS3hE06S77Rue6yT0DlQPvUTiFaU03QpkDL+O+BtjB5vrHAv0WXapb+68AwxAiUseoiPpfxf5EvOv8//zryqnMzdNK/z/r3fdc89cnSszMe5UbRWapiFUznMtSuibGV3u5SmZDqHB4RnFzpRtogFwNcDyN+a5PAogR2c2w/eP52TDY7fQw2cqkuha0pptXc1zOoZSCwGV1Riw9elbRqH/+5Rk/oADZWNC0xkZUE0BaIph+CgL2Y0GDIR1iXEw4MGQmrnIoUw4MpMrUOLnSw1AROizHgZBcaWULEodBIgIG818KXhQYYQhPvo3g5ZHk2r0/em4Yd+XKaiRyzq9+Gsc7ucOT/r/f/ef/8/z/f/3JmWaMoLqMSzJCYrrnoMZpsvDItDQY+T3p6aw3imUPq97G5sOzJyQvrm8TD1mOxsgZxpVBFlgnmcgJgVOzubjUTvTQ9q/a4dSA94PsdpxS2dSzSYS6xZWinrVpOkW7UIRfAGQWfkJrdsWKlRYzAwuJioHAZgVaNUIMKySy5zCJCF52G2EBeuHPuX9YvU+kbFCAhShw5+OPfq2tfzX4/13/znr41Ov2XNe6/hUyIzbaJGAJAJIiNE1MZNw9Z2xbulMFy1mz0ZKkb1xLtIqwMvJzrbssw0uLv0QosYdBGoAIAPvUP1JH6TnZnlSqtC8EmFS/fdVpinpnnFhvedw5/55nl0Rojnmf998uHXa5k7eUiD/+5RE8gyCn2PCkwEscE9BeHMF+AwLlYkGLQTVySsGIhzw4UB8ym/yPy13K/8hSyL83RYX+RHkzpO9kdKKhHuqEZK+tZ4IrAGOCE26kiB34MctOZQGjqwcMpLtuLKCbBPgRziFb53v3WtTRCRrv+7RLVd+SZ/W3XrU3OeYgng2KiwAAwcD5Q25TTgMgB/Z6ndRTTUNuqFMIsCp8sa01GHUsiqMiGX949odI6/Z//7/6V/0///v+t+ttXLPz/Ne5r0prz54I8+O5tVPJVmwJFJLeHhw0fpbLUygt7g1UjIMJUxBTUVVEDelGlLzaNFaJDlIQIuNL/XrauS2jlgUCG0c8MN/h3uV7mv58eCtSRrLL/8vX1/+Po3cpknqd09RmYU0Zkoz+cpvGef5bbj1koXJNfY/Cmg76zmrc9zi30H6JlDcRTBjAMmnowfgvtuAyDWUzh8QwAQ65Z2X6zj0Jfx+yGKpbX3Y2akMsn3X/0eD5dfH/8Yuej83nO+dbv4vd+3/+5Rk+oCDLmPBCyE14FhMKGloI65IHC0Q7CHogVex4QmhDnj9f/vtOcp7nvCHzr5bvg3Ofrx0EO3ty2hzGNVZvM6Pk2OSraTQuXFiUtCXJGiAWPP2DpBcMzarA4y1980smGF6tFhhJG0NK0tdeFTToSSmRFwJCy0BMXdcuyvxk4rLuFXFndConVprFxVjlCgwRBqGyRoeoqaihEXJLRksZAkNZwEgL7A8pJeE63++UVJaIFy8FASo2K+mZ1aI5JFh/tWLrurU11ikf6sZXnuhPVsQXGklCBbHw0FGHRYQDfGNvMAnTOAgaUOQQ/iwFLhbzqzNaMiAdZ1bD8cMsfrLo/f+1hJ6rv1+frXl1L/8zCf8yMmzxmQJGFaZ2mm8/HfS9nUG+w5ana9zPUw27URztZ14g8WOJJECmCC7tFxX41YJhtNLnGBMQiJ2+d1aYXgwNhQYMxsU37wy3W5vuf5f8/+quc2v7+Dl54IJfLyESczA6EejYPy2zZxDU/n0z7H/+5Rk+4iDG2RBCyE14GEsiCFoJp4J9C0O4OHgQP+FYlwWYBBxMOdaS1Wz+zs5ypxcmajL2omcK55xEDacZQAw9Rtj4mEAolPSBWARXkUssubpZmcmKODnmlH/tNM81lny/Rv9a7///y/nXXNLVmpOT/z/LZS9q1LrnfohVNXevsgSrEU1Bhu+BCHCiQxLVHogKEUdxARxVHh7ClCzdDLJQJGVpCkhWDLrvL1V/J687SA2/dxx/+aum6Zye/5n685FOtZf/9oeXyy6vTfx/8Tx8r9VBrTFwnLXK2hGnHUVtJMFpKlIkDBziljpFMcZweooEZawOYbIekg1jBLXjiIMKdt+xhlMC1f/OtELEJgGIVNd13ffzFd6+1/tr3/383/+//dH/J6UZ0psXI7m8EWYrn7LyNrWKbG9R9mLZ9P73Mnztu+8gyRCtjqEaHNJ6TY1xKAALIB/Wy2AMCm7F7DiiupMpP5483lFH6Z53+81PNZuX/zP1/5n/nz73Lq+/57/+5RE/4zS5mLBkyE1cF8MWCFoJq5LYY0GTIRzwX+xYMWQorEF/+R3z+/pbTkfy71oFpIv5q9R7k4dUr1zClDM2BPQjMYIGHeC6CFFLvJldxnthah+ppu0oQoncu37V/uKHdoN/lfmLZStmv8/8zXU/z//y5/lmeU3D4eEu5f1bmzAyheUI5oRMa5UFeIY0ORdQghwgQabwIodw7uUuTWChtwOK/VetDcBPhkhGJIrwAVSZLPZ6/cbhl2Bgovy9hvwqze+f/y/1/+vnL1rMfpHVcxT863qunji/m5uofHKOqqiuyaidUSqIqUsgs4YeehdBxUl0IxVjxBWyKl5ewjJehDvCY2AIccZIGO5uLjgkAdFNYOwTI2y3cYegXcZ71Ua3J3FAES9+7YtTFatVvb++YRyrGqh+SsH54mg3UYNlg+5RCbUHEgOABQd+DVfiViAuEWFwjGKkeZ7rzl2XRQkQVZSaz5na/r/8+///8l//y93/0I7//vmXr2zLK5mnMP/+5Rk8g1C0mDBiyI1clWsaEZkI54LAY0GLIRzyYSx4IGgoniq7HuRq2xCrRscydAcAzjoEJAw40FuaCyAWBEYUdcoAVuNVboMHjzrZ4MhaSg+5/e4172V0QFjSfM8Nciak4rGCNq//XB1+f+v5H/WzzX8uGdh/T/rf+v0rGLg1LPM3Jvg5skfYRdBQSAmiOarQoVGBipTASgsfkA5qOqcgp9PGLU3BimP5fztBI6KJDjyLFrD/83+zlwjVJg6OM9Vy/Ly9vkcvWa+Xs/bMrFmvD3Uv/2UGUwZT30Lifk7hW0Z1UjFswmwzI0tGJscI6jKISreTRUmzAQM9htLTZioqToXv3nYlD95KbJ1TfNe5CLAP2fPf0v/+f1//P137vXy7nqp+WmOIfaa51HPwYly0fFZhOkGxLG25yGDbFlq2ZxitY1A4qbRixxR4T1JvebY0+E800qJfUSEcBPDb/lPyIX28EAZR9vtvhkYxL1fn/9f////88/7+dmH9W5x+sT/+5Rk64TCFgrEOwF6gFWsSEVkI55LDYcITIRzyWIx4QmQjniP/DFmXUHhpXgYKiwj0jItaDYoKCJwwYeA8MCCDGJuOoIQJFQEHjhJiW1NwKgKQTnbpNVZyKIIqeEtci87LqvPjrDXFvdx/v/r9eT//////////8X/O/34YjQv//nbVV62e+zRaNdv5k3Nlkv54MsiVZJ2XPNImgx6LJVuEpwRk5xtEkjOFydK6U44SZKtPgOpWFyUrA5KVwmCTAGQasapCi+pBXrShYhskHhSRHScOBoQjCMWFSqaA+hRJoD6EhSXc0qk25kNUMSzoQpY4x2EatYayUjWUjakatczs/X6ssMtcmvSZausPNb1Z7MvsZNtBRrR1vBf8Fl4/xpo2gYAPVqmZh3Zqv0o3AwpxomhWHeCsQjJYtDR7Oz09UeaGmZLiY9UBT1bvBXDXLaLg7lpUq79eJRnBoGZcjQTIU2QmlCpBRpZLpk6gKKER4ApYROtLHiXKhLWJYoV9Wv/+5RE9I8C3GLBgyFE8lsMeDBkI54KgY8CDATVwgApIWj0jpl1oLeWDtoUPes6hly6zueDsS8io9hriUNB3GPDCgoloBCgoCpRstUAnAQHUSTcAmVGcv2VV/9aWqqu212q5xjVZI4mG8LIwk8L0T/zXdc6WGAln0Kv8/jUBpZGq6nVUmNf89VL2oCVJjqk2qiS//YwrDQXEBQxI1VUaWqnglaJ0ZnIUsbjOFEozLLDhrJUFUmZpqv9Vv9mjF7HV2XZv9s/2Paeaw1JVh3NZ3alqp89m2L6vxi1jBjFS8S7FguQVjiwFeb/8O/5ZkxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5Rk3QDBygs8yCEYED0hV4IEJgwLEY7GIYR+QVyl2chTDDGqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqo=";
  function clamp01(v) {
    return Math.max(0, Math.min(1, v));
  }
  function looksLikeDataURL(s) {
    return /^data:audio\/[a-z0-9.+-]+;base64,/i.test(s.trim());
  }
  function toDataUrl(dataOrBase64, mime = "audio/mpeg") {
    const s = (dataOrBase64 || "").trim();
    if (!s) return "";
    if (looksLikeDataURL(s)) return s;
    return `data:${mime};base64,${s}`;
  }
  var AUDIO_SETTINGS_PATH = "audio.settings";
  var AUDIO_LIBRARY_PATH = "audio.library";
  var AudioNotifier = class {
    constructor(opts) {
      // ===== Core state
      __publicField(this, "enabled", true);
      __publicField(this, "volume", 0.7);
      __publicField(this, "minPlayGapMs", 1200);
      __publicField(this, "lastPlayTs", 0);
      // ===== Sound Library (name -> dataURL)
      __publicField(this, "library", /* @__PURE__ */ new Map());
      __publicField(this, "defaultSoundName", null);
      // Legacy fallback (pour compat)
      __publicField(this, "defaultSoundDataUrl", null);
      // Playback logic
      __publicField(this, "mode", "oneshot");
      __publicField(this, "stopConf", { mode: "manual" });
      __publicField(this, "loopIntervalMs", 1500);
      __publicField(this, "weatherMode", "oneshot");
      __publicField(this, "weatherStopConf", { mode: "manual" });
      __publicField(this, "weatherLoopIntervalMs", 1500);
      __publicField(this, "petMode", "oneshot");
      __publicField(this, "petStopConf", { mode: "manual" });
      __publicField(this, "petLoopIntervalMs", 1500);
      __publicField(this, "loops", /* @__PURE__ */ new Map());
      __publicField(this, "oneshotQueue", []);
      __publicField(this, "oneshotQueueTimer", null);
      __publicField(this, "oneshotProcessing", false);
      __publicField(this, "weatherVolume", 0.7);
      __publicField(this, "weatherDefaultSoundName", null);
      __publicField(this, "petVolume", 0.7);
      __publicField(this, "petDefaultSoundName", null);
      // Optional purchase checker (for stop: purchase)
      __publicField(this, "purchaseChecker");
      // WebAudio priming (optional)
      __publicField(this, "audioCtx", null);
      __publicField(this, "primed", false);
      __publicField(this, "builtinDefault", null);
      __publicField(this, "suppressPersist", 0);
      if (opts?.minPlayGapMs != null) this.minPlayGapMs = Math.max(0, opts.minPlayGapMs | 0);
      if (opts?.volume != null) this.volume = clamp01(opts.volume);
      this.suppressPersist++;
      try {
        if (EMBED_DEFAULT_MP3_BASE64 && EMBED_DEFAULT_MP3_BASE64.trim() && EMBED_DEFAULT_MP3_BASE64.indexOf("TODO:") === -1) {
          const dataUrl = toDataUrl(EMBED_DEFAULT_MP3_BASE64);
          this.registerSound("Default", dataUrl);
          this.defaultSoundName = "Default";
          this.builtinDefault = { name: "Default", dataUrl };
        }
        if (opts?.defaultSound) {
          const du = toDataUrl(opts.defaultSound);
          this.defaultSoundDataUrl = du;
          this.registerSound("LegacyDefault", du);
          this.defaultSoundName = "LegacyDefault";
        }
      } finally {
        this.suppressPersist--;
      }
      this.loadFromStorage();
      this.ensureBuiltinPresent();
      if (this.ensureDefaultSoundValidity()) this.persistSettings();
    }
    ensureBuiltinPresent() {
      if (this.builtinDefault && !this.library.has(this.builtinDefault.name)) {
        this.library.set(this.builtinDefault.name, this.builtinDefault.dataUrl);
      }
    }
    ensureDefaultSoundValidity() {
      let changed = false;
      const fallback = () => {
        if (this.builtinDefault && this.library.has(this.builtinDefault.name)) {
          return this.builtinDefault.name;
        }
        const first = this.library.keys().next();
        return first.done ? null : first.value;
      };
      const ensureName = (current, prefer) => {
        if (current && this.library.has(current)) return current;
        if (prefer && this.library.has(prefer)) return prefer;
        return fallback();
      };
      const nextShops = ensureName(this.defaultSoundName);
      if (nextShops !== this.defaultSoundName) {
        this.defaultSoundName = nextShops;
        changed = true;
      }
      const nextWeather = ensureName(this.weatherDefaultSoundName, nextShops);
      if (nextWeather !== this.weatherDefaultSoundName) {
        this.weatherDefaultSoundName = nextWeather;
        changed = true;
      }
      const nextPets = ensureName(this.petDefaultSoundName, nextShops);
      if (nextPets !== this.petDefaultSoundName) {
        this.petDefaultSoundName = nextPets;
        changed = true;
      }
      return changed;
    }
    persistSettings() {
      if (this.suppressPersist > 0) return;
      try {
        const payload = {
          enabled: this.enabled,
          volume: this.volume,
          minPlayGapMs: this.minPlayGapMs,
          mode: this.mode,
          stop: this.stopConf,
          loopIntervalMs: this.loopIntervalMs,
          defaultSoundName: this.defaultSoundName,
          contexts: {
            shops: {
              volume: this.volume,
              mode: this.mode,
              stop: this.stopConf,
              loopIntervalMs: this.loopIntervalMs,
              defaultSoundName: this.defaultSoundName
            },
            weather: {
              volume: this.weatherVolume,
              mode: this.weatherMode,
              stop: this.weatherStopConf,
              loopIntervalMs: this.weatherLoopIntervalMs,
              defaultSoundName: this.weatherDefaultSoundName
            },
            pets: {
              volume: this.petVolume,
              mode: this.petMode,
              stop: this.petStopConf,
              loopIntervalMs: this.petLoopIntervalMs,
              defaultSoundName: this.petDefaultSoundName
            }
          }
        };
        writeAriesPath(AUDIO_SETTINGS_PATH, payload);
      } catch {
      }
    }
    persistLibrary() {
      if (this.suppressPersist > 0) return;
      try {
        const entries = [];
        for (const [name, data] of this.library.entries()) {
          if (this.builtinDefault && name === this.builtinDefault.name) continue;
          entries.push({ name, data });
        }
        writeAriesPath(AUDIO_LIBRARY_PATH, entries);
      } catch {
      }
    }
    loadFromStorage() {
      this.suppressPersist++;
      try {
        try {
          const parsed = readAriesPath(AUDIO_LIBRARY_PATH);
          if (Array.isArray(parsed)) {
            this.library.clear();
            this.ensureBuiltinPresent();
            for (const entry of parsed) {
              const name = String(entry && entry.name || "").trim();
              const data = String(entry && entry.data || "").trim();
              if (!name || !data) continue;
              if (this.builtinDefault && name === this.builtinDefault.name) continue;
              this.library.set(name, looksLikeDataURL(data) ? data : toDataUrl(data));
            }
          }
        } catch (err) {
        }
        try {
          const parsed = readAriesPath(AUDIO_SETTINGS_PATH);
          if (parsed && typeof parsed === "object") {
            if (typeof parsed.enabled === "boolean") this.enabled = parsed.enabled;
            if (typeof parsed.minPlayGapMs === "number") this.minPlayGapMs = Math.max(0, parsed.minPlayGapMs | 0);
            if (typeof parsed.volume === "number") this.volume = clamp01(parsed.volume);
            if (parsed.mode === "loop" || parsed.mode === "oneshot") this.mode = parsed.mode;
            if (parsed.stop && typeof parsed.stop === "object") {
              const stopMode = parsed.stop.mode;
              if (stopMode === "purchase") {
                this.stopConf = { mode: "purchase" };
              } else if (stopMode === "manual") {
                this.stopConf = { mode: "manual" };
              } else if (stopMode === "repeat") {
                this.stopConf = { mode: "manual" };
              }
            }
            if (typeof parsed.loopIntervalMs === "number") this.loopIntervalMs = Math.max(150, parsed.loopIntervalMs | 0);
            if (typeof parsed.defaultSoundName === "string") {
              const nm = parsed.defaultSoundName.trim();
              this.defaultSoundName = nm ? nm : null;
            }
            let weatherVolumeLoaded = false;
            let weatherModeLoaded = false;
            let weatherStopLoaded = false;
            let weatherLoopLoaded = false;
            let weatherDefaultLoaded = false;
            let petVolumeLoaded = false;
            let petModeLoaded = false;
            let petStopLoaded = false;
            let petLoopLoaded = false;
            let petDefaultLoaded = false;
            const applyContext = (ctx, conf) => {
              if (!conf || typeof conf !== "object") return;
              const applyVolume = (value) => {
                if (typeof value !== "number") return;
                const normalized = clamp01(value);
                if (ctx === "weather") {
                  this.weatherVolume = normalized;
                  weatherVolumeLoaded = true;
                } else if (ctx === "pets") {
                  this.petVolume = normalized;
                  petVolumeLoaded = true;
                } else this.volume = normalized;
              };
              const applyMode = (value) => {
                if (value === "loop" || value === "oneshot") {
                  if (ctx === "weather") {
                    this.weatherMode = value;
                    weatherModeLoaded = true;
                  } else if (ctx === "pets") {
                    this.petMode = value;
                    petModeLoaded = true;
                  } else this.mode = value;
                }
              };
              const applyStop = (value) => {
                if (!value || typeof value !== "object") return;
                const mode = value.mode;
                if (mode === "purchase") {
                  if (ctx === "weather") {
                    this.weatherStopConf = { mode: "purchase" };
                    weatherStopLoaded = true;
                  } else if (ctx === "pets") {
                    this.petStopConf = { mode: "purchase" };
                    petStopLoaded = true;
                  } else this.stopConf = { mode: "purchase" };
                } else if (mode === "manual") {
                  if (ctx === "weather") {
                    this.weatherStopConf = { mode: "manual" };
                    weatherStopLoaded = true;
                  } else if (ctx === "pets") {
                    this.petStopConf = { mode: "manual" };
                    petStopLoaded = true;
                  } else this.stopConf = { mode: "manual" };
                } else if (mode === "repeat") {
                  if (ctx === "weather") {
                    this.weatherStopConf = { mode: "manual" };
                    weatherStopLoaded = true;
                  } else if (ctx === "pets") {
                    this.petStopConf = { mode: "manual" };
                    petStopLoaded = true;
                  } else {
                    this.stopConf = { mode: "manual" };
                  }
                }
              };
              const applyLoop = (value) => {
                if (typeof value !== "number" || !Number.isFinite(value)) return;
                const normalized = Math.max(150, Math.floor(value));
                if (ctx === "weather") {
                  this.weatherLoopIntervalMs = normalized;
                  weatherLoopLoaded = true;
                } else if (ctx === "pets") {
                  this.petLoopIntervalMs = normalized;
                  petLoopLoaded = true;
                } else this.loopIntervalMs = normalized;
              };
              const applyDefault = (value) => {
                if (typeof value !== "string") return;
                const nm = value.trim();
                if (ctx === "weather") {
                  this.weatherDefaultSoundName = nm ? nm : null;
                  weatherDefaultLoaded = true;
                } else if (ctx === "pets") {
                  this.petDefaultSoundName = nm ? nm : null;
                  petDefaultLoaded = true;
                } else this.defaultSoundName = nm ? nm : null;
              };
              applyVolume(conf.volume);
              applyMode(conf.mode);
              applyStop(conf.stop);
              applyLoop(conf.loopIntervalMs);
              applyDefault(conf.defaultSoundName);
            };
            if (parsed.contexts && typeof parsed.contexts === "object") {
              applyContext("shops", parsed.contexts.shops);
              applyContext("weather", parsed.contexts.weather);
              applyContext("pets", parsed.contexts.pets);
            }
            if (!weatherVolumeLoaded) this.weatherVolume = this.volume;
            if (!weatherModeLoaded) this.weatherMode = this.mode;
            if (!weatherStopLoaded) {
              this.weatherStopConf = this.stopConf.mode === "purchase" ? { mode: "purchase" } : { mode: "manual" };
            }
            if (!weatherLoopLoaded) this.weatherLoopIntervalMs = this.loopIntervalMs;
            if (!weatherDefaultLoaded) this.weatherDefaultSoundName = this.defaultSoundName;
            if (!petVolumeLoaded) this.petVolume = this.volume;
            if (!petModeLoaded) this.petMode = this.mode;
            if (!petStopLoaded) {
              this.petStopConf = this.stopConf.mode === "purchase" ? { mode: "purchase" } : { mode: "manual" };
            }
            if (!petLoopLoaded) this.petLoopIntervalMs = this.loopIntervalMs;
            if (!petDefaultLoaded) this.petDefaultSoundName = this.defaultSoundName;
          }
        } catch (err) {
        }
      } finally {
        this.suppressPersist--;
      }
    }
    isProtectedSound(name) {
      return !!(this.builtinDefault && this.builtinDefault.name === name);
    }
    // =========================
    // Sound Library API
    // =========================
    /** Add or replace a sound in the registry by name. Accepts dataURL or bare base64. */
    registerSound(name, dataOrBase64, mime) {
      const safeName = String(name || "").trim();
      if (!safeName) return;
      const dataUrl = toDataUrl(dataOrBase64, mime || "audio/mpeg");
      this.library.set(safeName, dataUrl);
      const prevDefault = this.defaultSoundName;
      const prevWeatherDefault = this.weatherDefaultSoundName;
      const prevPetDefault = this.petDefaultSoundName;
      if (!this.defaultSoundName) this.defaultSoundName = safeName;
      if (!this.weatherDefaultSoundName) this.weatherDefaultSoundName = safeName;
      if (!this.petDefaultSoundName) this.petDefaultSoundName = safeName;
      this.ensureBuiltinPresent();
      this.persistLibrary();
      if (prevDefault !== this.defaultSoundName || prevWeatherDefault !== this.weatherDefaultSoundName || prevPetDefault !== this.petDefaultSoundName) {
        this.persistSettings();
      }
    }
    unregisterSound(name) {
      if (this.isProtectedSound(name)) return;
      const existed = this.library.delete(name);
      if (!existed) return;
      const prevDefault = this.defaultSoundName;
      const prevWeatherDefault = this.weatherDefaultSoundName;
      const prevPetDefault = this.petDefaultSoundName;
      if (prevDefault === name) this.defaultSoundName = null;
      if (prevWeatherDefault === name) this.weatherDefaultSoundName = null;
      if (prevPetDefault === name) this.petDefaultSoundName = null;
      const changed = prevDefault === name || prevWeatherDefault === name || prevPetDefault === name || this.ensureDefaultSoundValidity();
      this.persistLibrary();
      if (changed) this.persistSettings();
    }
    listSounds() {
      return Array.from(this.library.keys());
    }
    setDefaultSoundByName(name, context = "shops") {
      if (!this.library.has(name)) return;
      if (context === "weather") {
        if (this.weatherDefaultSoundName === name) return;
        this.weatherDefaultSoundName = name;
      } else if (context === "pets") {
        if (this.petDefaultSoundName === name) return;
        this.petDefaultSoundName = name;
      } else {
        if (this.defaultSoundName === name) return;
        this.defaultSoundName = name;
      }
      this.persistSettings();
    }
    resetLibrary(entries) {
      const prevDefault = this.defaultSoundName;
      const prevWeatherDefault = this.weatherDefaultSoundName;
      this.suppressPersist++;
      try {
        this.library.clear();
        this.ensureBuiltinPresent();
        const added = [];
        for (const e of entries) {
          const safeName = String(e?.name || "").trim();
          if (!safeName) continue;
          if (this.isProtectedSound(safeName)) continue;
          const dataUrl = looksLikeDataURL(e.data) ? e.data : toDataUrl(e.data);
          this.library.set(safeName, dataUrl);
          added.push(safeName);
        }
        if (added.length) {
          this.defaultSoundName = added[0];
          this.weatherDefaultSoundName = added[0];
        }
      } finally {
        this.suppressPersist--;
      }
      const changed = this.ensureDefaultSoundValidity() || prevDefault !== this.defaultSoundName || prevWeatherDefault !== this.weatherDefaultSoundName;
      this.persistLibrary();
      if (changed) this.persistSettings();
    }
    setNotificationBase64(dataUriOrBase64) {
      const du = dataUriOrBase64 && dataUriOrBase64.trim() ? looksLikeDataURL(dataUriOrBase64) ? dataUriOrBase64 : toDataUrl(dataUriOrBase64) : "";
      this.defaultSoundDataUrl = du || null;
      if (du) {
        this.registerSound("LegacyDefault", du);
        this.defaultSoundName = "LegacyDefault";
        this.weatherDefaultSoundName = "LegacyDefault";
      }
      this.persistSettings();
    }
    getDefaultSoundName(context = "shops") {
      if (context === "weather") {
        return this.weatherDefaultSoundName ?? this.defaultSoundName;
      }
      if (context === "pets") {
        return this.petDefaultSoundName ?? this.defaultSoundName;
      }
      return this.defaultSoundName;
    }
    resolveToDataUrl(src, context) {
      if (!src) {
        const name = context === "weather" ? this.weatherDefaultSoundName ?? this.defaultSoundName : context === "pets" ? this.petDefaultSoundName ?? this.defaultSoundName : this.defaultSoundName;
        if (name && this.library.has(name)) return this.library.get(name);
        return this.defaultSoundDataUrl || null;
      }
      const s = src.trim();
      if (this.library.has(s)) return this.library.get(s);
      if (looksLikeDataURL(s)) return s;
      if (/^[A-Za-z0-9+/=\s]+$/.test(s) && s.length > 100) return toDataUrl(s);
      return null;
    }
    // =========================
    // Settings API (Playback)
    // =========================
    setEnabled(on) {
      const next = !!on;
      if (this.enabled === next) return;
      this.enabled = next;
      this.persistSettings();
    }
    isEnabled() {
      return this.enabled;
    }
    setMute(muted) {
      this.setEnabled(!muted);
    }
    isMuted() {
      return !this.enabled;
    }
    setVolume(v, context = "shops") {
      const next = clamp01(v);
      if (context === "weather") {
        if (this.weatherVolume === next) return;
        this.weatherVolume = next;
      } else if (context === "pets") {
        if (this.petVolume === next) return;
        this.petVolume = next;
      } else {
        if (this.volume === next) return;
        this.volume = next;
      }
      this.forEachLoop(context, (st) => {
        st.volume = next;
      });
      this.persistSettings();
    }
    getVolume(context = "shops") {
      if (context === "weather") return this.weatherVolume;
      if (context === "pets") return this.petVolume;
      return this.volume;
    }
    setMinPlayGap(ms) {
      const next = Math.max(0, ms | 0);
      if (this.minPlayGapMs === next) return;
      this.minPlayGapMs = next;
      this.persistSettings();
    }
    getMinPlayGap() {
      return this.minPlayGapMs;
    }
    setPlaybackMode(mode, context = "shops") {
      if (context === "weather") {
        if (this.weatherMode === mode) return;
        this.weatherMode = mode;
      } else if (context === "pets") {
        if (this.petMode === mode) return;
        this.petMode = mode;
      } else {
        if (this.mode === mode) return;
        this.mode = mode;
      }
      this.persistSettings();
    }
    getPlaybackMode(context = "shops") {
      if (context === "weather") return this.weatherMode;
      if (context === "pets") return this.petMode;
      return this.mode;
    }
    setStopRepeat(repeats, context = "shops") {
      this.setStopManual(context);
    }
    setStopManual(context = "shops") {
      if (context === "weather") {
        if (this.weatherStopConf.mode === "manual") return;
        this.weatherStopConf = { mode: "manual" };
      } else if (context === "pets") {
        if (this.petStopConf.mode === "manual") return;
        this.petStopConf = { mode: "manual" };
      } else {
        if (this.stopConf.mode === "manual") return;
        this.stopConf = { mode: "manual" };
      }
      this.forEachLoop(context, (st) => {
        st.baseStop = { mode: "manual" };
      });
      this.persistSettings();
    }
    setStopPurchase(context = "shops") {
      if (context === "weather") {
        if (this.weatherStopConf.mode === "purchase") return;
        this.weatherStopConf = { mode: "purchase" };
      } else if (context === "pets") {
        if (this.petStopConf.mode === "purchase") return;
        this.petStopConf = { mode: "purchase" };
      } else {
        if (this.stopConf.mode === "purchase") return;
        this.stopConf = { mode: "purchase" };
      }
      this.forEachLoop(context, (st) => {
        st.baseStop = { mode: "purchase" };
      });
      this.persistSettings();
    }
    clearStopCondition(context = "shops") {
      this.setStopManual(context);
    }
    setLoopInterval(ms, context = "shops") {
      const next = Math.max(150, ms | 0);
      if (context === "weather") {
        if (this.weatherLoopIntervalMs === next) return;
        this.weatherLoopIntervalMs = next;
      } else if (context === "pets") {
        if (this.petLoopIntervalMs === next) return;
        this.petLoopIntervalMs = next;
      } else {
        if (this.loopIntervalMs === next) return;
        this.loopIntervalMs = next;
      }
      this.forEachLoop(context, (st) => {
        st.baseLoopInterval = next;
      });
      this.persistSettings();
    }
    getLoopInterval(context = "shops") {
      if (context === "weather") return this.weatherLoopIntervalMs;
      if (context === "pets") return this.petLoopIntervalMs;
      return this.loopIntervalMs;
    }
    setPurchaseChecker(fn) {
      this.purchaseChecker = fn;
    }
    getPlaybackSettings(context = "shops") {
      const volume = this.getVolume(context);
      const mode = this.getPlaybackMode(context);
      const stop2 = context === "weather" ? this.weatherStopConf : context === "pets" ? this.petStopConf : this.stopConf;
      const stopSnapshot = stop2.mode === "purchase" ? { mode: "purchase" } : { mode: "manual" };
      const loopIntervalMs = this.getLoopInterval(context);
      const defaultSoundName = this.getDefaultSoundName(context);
      return {
        enabled: this.enabled,
        volume,
        minPlayGapMs: this.minPlayGapMs,
        mode,
        stop: stopSnapshot,
        loopIntervalMs,
        primed: this.primed,
        defaultSoundName,
        hasLegacyDefault: !!this.defaultSoundDataUrl,
        librarySize: this.library.size,
        libraryNames: this.listSounds()
      };
    }
    // =========================
    // Actions
    // =========================
    async notify(context = "shops") {
      const du = this.resolveToDataUrl(null, context);
      await this.playOnce(du, this.getVolume(context), context);
    }
    async playNotify(context = "shops") {
      await this.notify(context);
    }
    /**
     * Trigger using the current mode.
     * @param key  Unique key (e.g. item id). "global" if generic.
     * @param sound Optional: NAME from registry or a dataURL/bare base64 to override.
     */
    async trigger(key2 = "global", overrides = {}, context = "shops") {
      const normalizeSound = (raw) => {
        if (typeof raw !== "string") return void 0;
        const trimmed = raw.trim();
        return trimmed ? trimmed : void 0;
      };
      const normalizeStop = (raw) => {
        if (!raw) return null;
        if (raw.mode === "purchase") return { mode: "purchase" };
        if (raw.mode === "manual") return { mode: "manual" };
        if (raw.mode === "repeat") return { mode: "manual" };
        return { mode: "manual" };
      };
      const sound = normalizeSound(overrides.sound ?? null);
      const baseMode = this.getPlaybackMode(context);
      const mode = overrides.mode === "oneshot" || overrides.mode === "loop" ? overrides.mode : baseMode;
      const baseStopSource = context === "weather" ? this.weatherStopConf : context === "pets" ? this.petStopConf : this.stopConf;
      const baseStop = baseStopSource.mode === "purchase" ? { mode: "purchase" } : { mode: "manual" };
      const baseLoopInterval = this.getLoopInterval(context);
      const baseVolume = this.getVolume(context);
      if (mode === "oneshot") {
        this.stopLoop(key2);
        const du = this.resolveToDataUrl(sound ?? null, context);
        this.enqueueOneshot({ key: key2, dataUrl: du, volume: baseVolume, context });
        return;
      }
      this.stopLoop(key2);
      const stopOverride = normalizeStop(overrides.stop ?? null);
      const loopIntervalOverride = overrides.loopIntervalMs != null && Number.isFinite(overrides.loopIntervalMs) ? Math.max(150, Math.round(overrides.loopIntervalMs)) : null;
      const state2 = {
        key: key2,
        timer: null,
        plays: 0,
        soundOverride: sound,
        stopped: false,
        stopOverride,
        loopIntervalOverride,
        context,
        baseStop,
        baseLoopInterval,
        volume: baseVolume
      };
      this.loops.set(key2, state2);
      this.scheduleNext(state2, 0);
    }
    forEachLoop(context, fn) {
      for (const st of this.loops.values()) {
        if (st.context === context) fn(st);
      }
    }
    stopLoop(key2 = "global") {
      const st = this.loops.get(key2);
      if (!st) return;
      st.stopped = true;
      if (st.timer != null) {
        clearTimeout(st.timer);
        st.timer = null;
      }
      this.loops.delete(key2);
    }
    stopAllLoops(context) {
      if (context) {
        for (const [k, st] of this.loops) {
          if (st.context === context) this.stopLoop(k);
        }
        return;
      }
      for (const [k] of this.loops) this.stopLoop(k);
    }
    /** Prime audio once on a user gesture for stricter browsers. */
    async prime() {
      try {
        if (!this.audioCtx) this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.audioCtx.state === "suspended") await this.audioCtx.resume();
        const o = this.audioCtx.createOscillator();
        const g = this.audioCtx.createGain();
        g.gain.value = 1e-4;
        o.connect(g).connect(this.audioCtx.destination);
        o.start();
        o.stop(this.audioCtx.currentTime + 0.02);
        this.primed = true;
      } catch {
        this.primed = true;
      }
    }
    // =========================
    // Import / compression  200 KB
    // =========================
    async importFileAsSound(file, opts = {}) {
      const {
        name,
        maxBytes = 200 * 1024,
        maxSeconds = 10,
        bitrates = [48e3, 32e3, 2e4, 12e3, 8e3],
        maxInputBytes = 8 * 1024 * 1024
      } = opts;
      const notifyInvalid = (description) => {
        try {
          toastSimple("Audio import", description, "error").catch(() => {
          });
        } catch {
        }
      };
      let decoded = null;
      const ensureDecoded = async () => {
        if (!decoded) decoded = await this.decodeFileToBuffer(file);
        return decoded;
      };
      if (!file || !(file instanceof File)) throw new Error("No file provided.");
      const allowedMimeByExtension = /* @__PURE__ */ new Map([
        ["mp3", /* @__PURE__ */ new Set(["audio/mpeg", "audio/mp3"])],
        ["wav", /* @__PURE__ */ new Set(["audio/wav", "audio/x-wav", "audio/wave"])],
        ["ogg", /* @__PURE__ */ new Set(["audio/ogg"])]
      ]);
      const fileType = (file.type || "").toLowerCase();
      const fileExtension = (file.name?.split(".").pop() || "").toLowerCase();
      if (!fileExtension || !allowedMimeByExtension.has(fileExtension)) {
        notifyInvalid("Unsupported audio format. Allowed formats: MP3, WAV, OGG.");
        throw new Error(`Unsupported audio extension: ${fileExtension || "unknown"}`);
      }
      const allowedMimes = allowedMimeByExtension.get(fileExtension);
      if (!fileType || !allowedMimes.has(fileType)) {
        notifyInvalid("File extension and MIME type must match (MP3, WAV, OGG only).");
        throw new Error(
          fileType ? `MIME type ${fileType} is not valid for .${fileExtension} files.` : `Missing MIME type for .${fileExtension} files.`
        );
      }
      if (file.size > maxInputBytes) throw new Error(`Input file too large (${Math.round(file.size / 1024)}KB). Limit is ${Math.round(maxInputBytes / 1024)}KB.`);
      if (file.size <= maxBytes) {
        const buf = await ensureDecoded();
        if (buf.duration > maxSeconds) {
          const duration = buf.duration;
          const formattedLimit = maxSeconds.toFixed(1).replace(/\.0$/, "");
          const formattedDuration = duration.toFixed(1).replace(/\.0$/, "");
          notifyInvalid(`File duration is ${formattedDuration}s (limit: ${formattedLimit}s).`);
          throw new Error(`Audio duration ${formattedDuration}s exceeds limit of ${formattedLimit}s.`);
        }
        const dataUrl = await this.blobToDataURL(file);
        const finalName = this.uniqueName(name || file.name);
        this.registerSound(finalName, dataUrl);
        return { name: finalName, dataUrl, bytes: file.size, wasCompressed: false };
      }
      const mime = this.chooseAudioMime();
      const canEncode = !!mime && typeof MediaRecorder !== "undefined" && MediaRecorder.isTypeSupported?.(mime);
      if (!canEncode) throw new Error("Compression unavailable in this browser; file exceeds 200KB.");
      decoded = await ensureDecoded();
      if (decoded.duration > maxSeconds) {
        const duration = decoded.duration;
        const formattedLimit = maxSeconds.toFixed(1).replace(/\.0$/, "");
        const formattedDuration = duration.toFixed(1).replace(/\.0$/, "");
        notifyInvalid(`File duration is ${formattedDuration}s (limit: ${formattedLimit}s).`);
        throw new Error(`Audio duration ${formattedDuration}s exceeds limit of ${formattedLimit}s.`);
      }
      for (const br of bitrates) {
        const blob = await this.recordBufferToBlob(decoded, mime, br);
        if (blob.size <= maxBytes) {
          const dataUrl = await this.blobToDataURL(blob);
          const finalName = this.uniqueName(name || file.name);
          this.registerSound(finalName, dataUrl);
          return { name: finalName, dataUrl, bytes: blob.size, wasCompressed: true };
        }
      }
      notifyInvalid(`Unable to compress under ${Math.round(maxBytes / 1024)}KB. Try a shorter clip.`);
      throw new Error(`Could not compress under ${Math.round(maxBytes / 1024)}KB. Try a shorter clip.`);
    }
    // =========================
    // Internals
    // =========================
    async playOnce(dataUrl, volume, _context, opts = {}) {
      if (!this.enabled) return true;
      const now2 = Date.now();
      if (now2 - this.lastPlayTs < this.minPlayGapMs) return false;
      this.lastPlayTs = now2;
      if (!dataUrl) {
        if (this.primed && this.audioCtx) {
          try {
            const o = this.audioCtx.createOscillator();
            const g = this.audioCtx.createGain();
            g.gain.value = volume * 0.1;
            o.frequency.value = 880;
            o.connect(g).connect(this.audioCtx.destination);
            o.start();
            o.stop(this.audioCtx.currentTime + 0.06);
          } catch {
          }
        }
        return true;
      }
      try {
        const a = new Audio();
        a.src = dataUrl;
        a.volume = volume;
        a.muted = !this.enabled;
        a.crossOrigin = "anonymous";
        const awaitEnd = opts?.awaitEnd === true;
        let endPromise = null;
        let resolveEnd = null;
        if (awaitEnd) {
          endPromise = new Promise((resolve2) => {
            const cleanup2 = () => {
              a.removeEventListener("ended", cleanup2);
              a.removeEventListener("error", cleanup2);
              resolve2();
            };
            resolveEnd = cleanup2;
            a.addEventListener("ended", cleanup2);
            a.addEventListener("error", cleanup2);
          });
        }
        const p = a.play();
        if (p && typeof p.then === "function") await p.catch(() => {
          resolveEnd?.();
        });
        if (endPromise) await endPromise;
      } catch {
      }
      return true;
    }
    scheduleNext(state2, delayMs) {
      const run = async () => {
        if (state2.stopped) return;
        const stopConf = state2.stopOverride ?? state2.baseStop;
        if (stopConf.mode === "purchase" && this.purchaseChecker) {
          try {
            if (this.purchaseChecker(state2.key)) {
              this.stopLoop(state2.key);
              return;
            }
          } catch {
          }
        }
        const du = this.resolveToDataUrl(state2.soundOverride, state2.context);
        const played = await this.playOnce(
          du,
          state2.volume,
          state2.context,
          { awaitEnd: true }
        );
        if (played) state2.plays++;
        if (stopConf.mode === "repeat") {
          const max = Math.max(1, stopConf.repeats | 0);
          if (state2.plays >= max) {
            this.stopLoop(state2.key);
            return;
          }
        }
        const intervalBase = state2.loopIntervalOverride ?? state2.baseLoopInterval;
        const gap = Math.max(150, intervalBase | 0);
        state2.timer = setTimeout(() => this.scheduleNext(state2, 0), gap);
      };
      if (delayMs > 0) state2.timer = setTimeout(run, delayMs);
      else run().catch(() => {
      });
    }
    enqueueOneshot(entry) {
      if (entry.context === "weather") {
        const idx = this.oneshotQueue.findIndex((item) => item.context !== "weather");
        if (idx === -1) this.oneshotQueue.push(entry);
        else this.oneshotQueue.splice(idx, 0, entry);
      } else {
        this.oneshotQueue.push(entry);
      }
      this.scheduleOneshotProcessing();
    }
    scheduleOneshotProcessing() {
      if (!this.oneshotQueue.length) return;
      if (this.oneshotQueueTimer != null) return;
      const delta = Date.now() - this.lastPlayTs;
      const wait = Math.max(0, this.minPlayGapMs - delta);
      this.oneshotQueueTimer = window.setTimeout(() => {
        this.oneshotQueueTimer = null;
        if (this.oneshotProcessing) return;
        this.processOneshotQueue();
      }, wait);
    }
    processOneshotQueue() {
      if (this.oneshotProcessing) return;
      if (!this.oneshotQueue.length) return;
      const next = this.oneshotQueue.shift();
      this.oneshotProcessing = true;
      const run = async () => {
        let replay = false;
        try {
          const played = await this.playOnce(next.dataUrl, next.volume, next.context);
          replay = !played;
        } finally {
          this.oneshotProcessing = false;
          if (replay) this.enqueueOneshot(next);
          this.scheduleOneshotProcessing();
        }
      };
      run().catch(() => {
      });
    }
    // ===== Helpers import/compress =====
    chooseAudioMime() {
      const candidates = ["audio/webm;codecs=opus", "audio/ogg;codecs=opus", "audio/webm", "audio/ogg", "audio/mp4"];
      for (const m of candidates) {
        try {
          if (typeof MediaRecorder !== "undefined" && MediaRecorder.isTypeSupported?.(m)) return m;
        } catch {
        }
      }
      return null;
    }
    uniqueName(raw) {
      const base = String(raw || "Sound").replace(/\.[a-z0-9]+$/i, "").trim() || "Sound";
      if (!this.library.has(base)) return base;
      let i = 2;
      while (this.library.has(`${base} (${i})`)) i++;
      return `${base} (${i})`;
    }
    async blobToDataURL(blob) {
      return await new Promise((resolve2, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve2(String(fr.result));
        fr.onerror = reject;
        fr.readAsDataURL(blob);
      });
    }
    async decodeFileToBuffer(file) {
      const arrayBuf = await file.arrayBuffer();
      const Ctx = window.AudioContext || window.webkitAudioContext;
      const ctx = new Ctx();
      try {
        const buf = await new Promise((res, rej) => {
          ctx.decodeAudioData(arrayBuf.slice(0), res, rej);
        });
        await ctx.close().catch(() => {
        });
        return buf;
      } catch (e) {
        try {
          await ctx.close();
        } catch {
        }
        throw new Error("Failed to decode audio file.");
      }
    }
    async recordBufferToBlob(buffer, mime, bitsPerSecond) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      const ctx = new Ctx();
      const dest = ctx.createMediaStreamDestination();
      const src = ctx.createBufferSource();
      src.buffer = buffer;
      const gain = ctx.createGain();
      gain.gain.value = 0.9;
      src.connect(gain).connect(dest);
      const chunks = [];
      const rec = new MediaRecorder(dest.stream, { mimeType: mime, bitsPerSecond });
      const recorded = new Promise((resolve2, reject) => {
        rec.ondataavailable = (e) => {
          if (e.data && e.data.size) chunks.push(e.data);
        };
        rec.onerror = (e) => reject(e.error || new Error("MediaRecorder error"));
        rec.onstop = () => {
          try {
            resolve2(new Blob(chunks, { type: mime }));
          } catch (err) {
            reject(err);
          }
        };
      });
      rec.start();
      src.start();
      await new Promise((res) => {
        src.onended = () => res();
      });
      rec.stop();
      const out = await recorded;
      try {
        await ctx.close();
      } catch {
      }
      return out;
    }
  };
  var audio = new AudioNotifier({
    minPlayGapMs: 1200,
    volume: 0.7
  });

  // src/core/sprite.ts
  var import_jszip = __toESM(require_jszip_min(), 1);
  function isImageUrl(u) {
    try {
      if (!u || u.startsWith("blob:")) return false;
      return /\.(png|jpe?g|gif|webp|svg|avif|bmp|ico|ktx2|basis)$/i.test(u);
    } catch {
      return false;
    }
  }
  function toAbs(u) {
    try {
      return new URL(u, location.href).href;
    } catch {
      return String(u);
    }
  }
  function fileBase(url) {
    const name = decodeURIComponent(url.split("/").pop() || "");
    return name.replace(/\.[a-z0-9]+$/i, "");
  }
  function guessFamiliesFromUrl(u) {
    const families = [];
    const normalized = u.replace(/^\/+/, "").toLowerCase();
    if (/(^|\/)ui\//.test(normalized)) families.push("ui");
    if (/(^|\/)tiles\//.test(normalized) || /(map|plants|allplants|items|seeds|pets|animations|mutations)\.(png|webp)$/i.test(normalized)) {
      families.push("tiles");
    }
    return families;
  }
  var spriteFilters = {
    Gold: {
      blendMode: "source-atop",
      colors: ["rgb(255, 215, 0)"],
      alpha: 0.7
    },
    Rainbow: {
      blendMode: "color",
      colors: ["#FF1744", "#FF9100", "#FFEA00", "#00E676", "#2979FF", "#D500F9"],
      gradientAngle: 130,
      masked: true
    },
    Wet: {
      blendMode: "source-atop",
      colors: ["rgb(128, 128, 255)"],
      alpha: 0.2
    },
    Chilled: {
      blendMode: "source-atop",
      colors: ["rgb(183, 183, 236)"],
      alpha: 0.5
    },
    Frozen: {
      blendMode: "source-atop",
      colors: ["rgb(128, 128, 255)"],
      alpha: 0.6
    },
    Dawnlit: {
      blendMode: "source-atop",
      colors: ["rgb(120, 100, 180)"],
      alpha: 0.4
    },
    Ambershine: {
      blendMode: "source-atop",
      colors: ["rgb(255, 140, 26)", "rgb(230, 92, 26)", "rgb(178, 58, 26)"],
      alpha: 0.5
    },
    Dawncharged: {
      blendMode: "source-atop",
      colors: ["rgb(100, 80, 160)", "rgb(110, 90, 170)", "rgb(120, 100, 180)"],
      alpha: 0.5
    },
    Ambercharged: {
      blendMode: "source-atop",
      colors: ["rgb(167, 50, 30)", "rgb(177, 60, 40)", "rgb(187, 70, 50)"],
      alpha: 0.5
    }
  };
  var MUTATION_PRIORITY = [
    "Gold",
    "Rainbow",
    "Wet",
    "Chilled",
    "Frozen",
    "Dawnlit",
    "Ambershine",
    "Dawncharged",
    "Ambercharged",
    "Dawnbound",
    "Amberlit",
    "Amberbound"
  ];
  var HIGH_MUTATIONS = /* @__PURE__ */ new Set([
    "Dawnlit",
    "Ambershine",
    "Dawncharged",
    "Ambercharged"
  ]);
  var SpritesCore = class {
    constructor(autoStart = true) {
      /** Configuration (ajuste  la vole si besoin) */
      __publicField(this, "cfg", {
        skipAlphaBelow: 1,
        blackBelow: 8,
        tolerance: 5e-3,
        ruleAllplants512: /allplants|mutation-overlays/i
      });
      __publicField(this, "initialized", false);
      __publicField(this, "onAssetCb");
      __publicField(this, "onMessageListener");
      // URLs rcoltes
      __publicField(this, "all", /* @__PURE__ */ new Set());
      __publicField(this, "familyAssets", /* @__PURE__ */ new Map());
      __publicField(this, "assetFamilies", /* @__PURE__ */ new Map());
      // Caches de sprites dcoups par feuille et par mode
      __publicField(this, "tileCacheBitmap", /* @__PURE__ */ new Map());
      __publicField(this, "tileCacheCanvas", /* @__PURE__ */ new Map());
      __publicField(this, "tileCacheDataURL", /* @__PURE__ */ new Map());
      // Images UI charges
      __publicField(this, "uiCache", /* @__PURE__ */ new Map());
      // Hooks / sniffers
      __publicField(this, "observers", []);
      __publicField(this, "patched", {});
      __publicField(this, "blobText", /* @__PURE__ */ new WeakMap());
      if (autoStart) this.init();
    }
    normalizeFamilies(families) {
      const set2 = /* @__PURE__ */ new Set();
      for (const raw of families ?? []) {
        const normalized = raw?.trim().toLowerCase();
        if (normalized) set2.add(normalized);
      }
      return Array.from(set2);
    }
    familySet(name) {
      return this.familyAssets.get(name) ?? /* @__PURE__ */ new Set();
    }
    init(opts) {
      if (opts?.config) Object.assign(this.cfg, opts.config);
      if (opts?.onAsset) this.onAssetCb = opts.onAsset;
      if (this.initialized) {
        console.debug("[Sprites] SpritesCore d\xE9j\xE0 initialis\xE9", {
          totals: {
            all: this.all.size,
            ui: this.familySet("ui").size,
            tiles: this.familySet("tiles").size
          }
        });
        return this;
      }
      console.debug("[Sprites] Initialisation des sniffers de sprites", {
        config: this.cfg
      });
      this.onMessageListener = (e) => {
        const d = e.data;
        if (d && d.__awc && d.url) this.add(d.url, "worker");
      };
      pageWindow.addEventListener("message", this.onMessageListener, true);
      this.initialized = true;
      console.debug("[Sprites] SpritesCore initialis\xE9", {
        globals: {
          hasWindowSprites: Boolean(pageWindow.Sprites)
        }
      });
      return this;
    }
    /** Dsinstalle les hooks et nettoie. */
    destroy() {
      if (!this.initialized) return;
      this.observers.forEach((o) => {
        try {
          o.disconnect();
        } catch {
        }
      });
      this.observers = [];
      if (this.patched.imgDesc) {
        Object.defineProperty(HTMLImageElement.prototype, "src", this.patched.imgDesc);
        this.patched.imgDesc = void 0;
      }
      if (this.patched.setAttr) {
        HTMLImageElement.prototype.setAttribute = this.patched.setAttr;
        this.patched.setAttr = void 0;
      }
      if (this.patched.Worker) {
        pageWindow.Worker = this.patched.Worker;
        if (pageWindow !== pageWindow) pageWindow.Worker = this.patched.Worker;
        this.patched.Worker = void 0;
      }
      if (this.patched.Blob) {
        pageWindow.Blob = this.patched.Blob;
        if (pageWindow !== pageWindow) pageWindow.Blob = this.patched.Blob;
        this.patched.Blob = void 0;
      }
      if (this.patched.createObjectURL) {
        const pageURL = pageWindow.URL ?? URL;
        pageURL.createObjectURL = this.patched.createObjectURL;
        if (pageWindow !== pageWindow) URL.createObjectURL = this.patched.createObjectURL;
        this.patched.createObjectURL = void 0;
      }
      if (this.onMessageListener) {
        pageWindow.removeEventListener("message", this.onMessageListener, true);
        this.onMessageListener = void 0;
      }
      this.initialized = false;
    }
    /* ===================== PUBLIC API ===================== */
    /** URLs collectes */
    lists() {
      const result = { all: [...this.all] };
      for (const [family, assets] of this.familyAssets) {
        result[family] = [...assets];
      }
      const ensureFamily = (name) => {
        if (!result[name]) {
          result[name] = [...this.familySet(name)];
        }
      };
      ensureFamily("tiles");
      ensureFamily("ui");
      return result;
    }
    listFamilies() {
      return [...this.familyAssets.keys()];
    }
    listAssetsForFamily(family) {
      const normalized = family?.trim().toLowerCase();
      if (!normalized) return [];
      return [...this.familySet(normalized)];
    }
    /** Ajout manuel d'un asset connu (ex: manifest) */
    registerKnownAsset(url, families = ["tiles"]) {
      return this.addAsset(url, families);
    }
    /** Liste des tilesheets par catgorie de nom (regex sur l'URL) */
    listTilesByCategory(re) {
      return [...this.familySet("tiles")].filter((u) => re.test(u));
    }
    listPlants() {
      const urls = new Set(this.listTilesByCategory(/plants/i));
      for (const url of this.listAllPlants()) urls.add(url);
      return [...urls];
    }
    listAllPlants() {
      return this.listTilesByCategory(this.cfg.ruleAllplants512);
    }
    listItems() {
      return this.listTilesByCategory(/items/i);
    }
    listSeeds() {
      return this.listTilesByCategory(/seeds/i);
    }
    listPets() {
      return this.listTilesByCategory(/pets/i);
    }
    listMap() {
      return this.listTilesByCategory(/map\.(png|webp)$/i);
    }
    /** Charge toutes les images UI (retourne Map<basename, HTMLImageElement>) */
    async loadUI() {
      const out = /* @__PURE__ */ new Map();
      for (const u of this.familySet("ui")) {
        if (!this.uiCache.has(u)) {
          const im = await this.loadImage(u);
          this.uiCache.set(u, im);
        }
        out.set(fileBase(u), this.uiCache.get(u));
      }
      return out;
    }
    /** Charge & dcoupe les tilesheets (retourne Map<basename, TileInfo[]>) */
    async loadTiles(options = {}) {
      const {
        mode = "bitmap",
        includeBlanks = false,
        forceSize,
        onlySheets
      } = options;
      const out = /* @__PURE__ */ new Map();
      const tiles = [...this.familySet("tiles")];
      const list = onlySheets ? tiles.filter((u) => onlySheets.test(u)) : tiles;
      for (const u of list) {
        const tiles2 = await this.ensureTilesForUrl(u, { mode, includeBlanks, forceSize });
        out.set(fileBase(u), tiles2);
      }
      return out;
    }
    async preloadTilesGradually(options = {}) {
      const {
        mode = "bitmap",
        includeBlanks = false,
        forceSize,
        onlySheets,
        batchSize = 1,
        delayMs = 40,
        onProgress
      } = options;
      const tiles = [...this.familySet("tiles")];
      const list = onlySheets ? tiles.filter((u) => onlySheets.test(u)) : tiles;
      const total = list.length;
      if (!total) return;
      const throttleBatch = Math.max(1, batchSize);
      const throttleDelay = Math.max(0, delayMs);
      let processed = 0;
      for (const url of list) {
        await this.ensureTilesForUrl(url, { mode, includeBlanks, forceSize });
        processed += 1;
        onProgress?.(processed, total);
        if (throttleDelay > 0 && processed < total && processed % throttleBatch === 0) {
          await this.delay(throttleDelay);
        }
      }
    }
    /** Raccourcis pratiques */
    async loadTilesAuto() {
      return this.loadTiles({ mode: "bitmap" });
    }
    async loadTiles256() {
      return this.loadTiles({ mode: "bitmap", forceSize: 256 });
    }
    async loadTiles512() {
      return this.loadTiles({ mode: "bitmap", forceSize: 512 });
    }
    getCacheForMode(mode) {
      if (mode === "canvas") return this.tileCacheCanvas;
      if (mode === "dataURL") return this.tileCacheDataURL;
      return this.tileCacheBitmap;
    }
    async ensureTilesForUrl(url, opts) {
      const cache2 = this.getCacheForMode(opts.mode);
      let cached = cache2.get(url);
      if (cached) return cached;
      const tiles = await this.sliceOne(url, opts);
      cache2.set(url, tiles);
      return tiles;
    }
    async delay(ms) {
      if (ms <= 0) return;
      await new Promise((resolve2) => {
        pageWindow.setTimeout(resolve2, ms);
      });
    }
    /** Rcupre un sprite prcis (par feuille + index) */
    async getTile(sheetBase, index, mode = "bitmap") {
      const url = [...this.familySet("tiles")].find((u) => fileBase(u) === sheetBase);
      if (!url) return null;
      const map2 = await this.loadTiles({ mode, onlySheets: new RegExp(sheetBase.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\.(png|webp)$", "i") });
      const tiles = map2.get(sheetBase) || [];
      const tile = tiles.find((t) => t.index === index);
      return tile ?? null;
    }
    /** Aplatis toutes les tiles en un seul tableau (utile pour un index global) */
    async flatTiles(options = {}) {
      const maps = await this.loadTiles(options);
      const all = [];
      maps.forEach((arr) => all.push(...arr));
      return all;
    }
    /** Exporte les UI en ZIP (brut, sans dcoupe) */
    async zipUI(name = "ui_assets.zip") {
      const zip = new import_jszip.default();
      const list = [...this.familySet("ui")];
      let i = 0;
      for (const u of list) {
        try {
          const b = await this.fetchBlob(u);
          const fn = decodeURIComponent(u.split("/").pop() || "").replace(/\?.*$/, "");
          zip.file(fn, b);
        } catch {
        }
        if (++i % 10 === 0) console.log(`[zipUI] ${i}/${list.length}`);
      }
      await this.saveZip(zip, name);
    }
    /** Exporte les tiles dcoupes en ZIP (auto 256/512 selon rgle allplants) */
    async zipTilesAuto(name = "tiles_auto.zip") {
      await this.zipTiles({ name, mode: "bitmap" });
    }
    /** Exporte les tiles en ZIP (forc 256/512) */
    async zipTiles256(name = "tiles_256.zip") {
      await this.zipTiles({ name, mode: "bitmap", forceSize: 256 });
    }
    async zipTiles512(name = "tiles_512.zip") {
      await this.zipTiles({ name, mode: "bitmap", forceSize: 512 });
    }
    /** Exporte toutes les tiles dcoupes + les assets UI dans un seul ZIP */
    async zipAllSprites(name = "sprites_all.zip") {
      const zip = new import_jszip.default();
      const tilesFolder = zip.folder("tiles");
      const uiFolder = zip.folder("ui");
      if (tilesFolder) {
        for (const url of this.familySet("tiles")) {
          try {
            const tiles = await this.sliceOne(url, {
              mode: "canvas",
              includeBlanks: false
            });
            if (!tiles.length) continue;
            const base = fileBase(url);
            const sheetFolder = tilesFolder.folder(base) ?? tilesFolder;
            let index = 0;
            for (const tile of tiles) {
              const canvas = tile.data;
              const baseName = `tile_${String(++index).padStart(4, "0")}`;
              try {
                const blob = await new Promise((resolve2, reject) => {
                  canvas.toBlob((b) => {
                    if (!b) {
                      reject(new Error("toBlob returned null"));
                      return;
                    }
                    resolve2(b);
                  }, "image/png");
                });
                sheetFolder.file(`${baseName}.png`, blob);
              } catch (error) {
                console.warn("[Sprites] Failed to export tile", { url, error });
              }
            }
          } catch (error) {
            console.warn("[Sprites] Failed to export sheet", { url, error });
          }
        }
      }
      if (uiFolder) {
        let fallbackIndex = 0;
        for (const url of this.familySet("ui")) {
          try {
            const blob = await this.fetchBlob(url);
            const base = decodeURIComponent(url.split("/").pop() || "").replace(/\?.*$/, "");
            const fileName = base || `asset_${String(++fallbackIndex).padStart(4, "0")}.png`;
            uiFolder.file(fileName, blob);
          } catch (error) {
            console.warn("[Sprites] Failed to export UI asset", { url, error });
          }
        }
      }
      await this.saveZip(zip, name);
    }
    /** Exporte une slection de tiles avec les filtres (si fournis). */
    async exportFilteredTileset(opts) {
      const { tiles, filters = [], baseName, filename = `${baseName}_tiles.zip` } = opts;
      const zip = new import_jszip.default();
      let index = 0;
      for (const tile of tiles) {
        const baseCanvas = this.tileToCanvas(tile);
        let canvas = baseCanvas;
        for (const filterName of filters) {
          const filtered = this.applyCanvasFilter(canvas, filterName);
          if (filtered) canvas = filtered;
        }
        const blob = await new Promise((resolve2, reject) => {
          canvas.toBlob((b) => {
            if (!b) {
              reject(new Error("canvas.toBlob returned null"));
              return;
            }
            resolve2(b);
          }, "image/png");
        });
        zip.file(`${baseName}/tile_${String(++index).padStart(4, "0")}.png`, blob);
        opts.onProgress?.(index, tiles.length);
      }
      await this.saveZip(zip, filename);
    }
    async exportAssets(opts) {
      const { urls, baseName, filename = `${baseName}_assets.zip` } = opts;
      if (!urls.length) return;
      const zip = new import_jszip.default();
      const folder = zip.folder(baseName) ?? zip;
      let index = 0;
      for (const url of urls) {
        index++;
        try {
          const blob = await this.fetchBlob(url);
          let name = decodeURIComponent(url.split("/").pop() ?? "");
          name = name.replace(/\?.*$/, "");
          if (!name) name = `asset_${String(index).padStart(4, "0")}.png`;
          folder.file(name, blob);
        } catch (error) {
          console.warn("[Sprites] Failed to fetch asset", { url, error });
        } finally {
          opts.onProgress?.(index, urls.length);
        }
      }
      await this.saveZip(zip, filename);
    }
    /** Vide les caches */
    clearCaches() {
      this.tileCacheBitmap.forEach((arr) => arr.forEach((t) => t.data.close?.()));
      this.tileCacheBitmap.clear();
      this.tileCacheCanvas.clear();
      this.tileCacheDataURL.clear();
      this.uiCache.clear();
    }
    toCanvas(tile) {
      return this.tileToCanvas(tile);
    }
    applyCanvasFilter(canvas, filterName) {
      const cfg = spriteFilters[filterName];
      if (!cfg) return null;
      const w = canvas.width;
      const h = canvas.height;
      const out = document.createElement("canvas");
      out.width = w;
      out.height = h;
      const ctx = out.getContext("2d");
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(canvas, 0, 0);
      ctx.save();
      ctx.globalCompositeOperation = cfg.blendMode;
      if (cfg.alpha != null) ctx.globalAlpha = cfg.alpha;
      if (cfg.masked) {
        const mask = document.createElement("canvas");
        mask.width = w;
        mask.height = h;
        const mctx = mask.getContext("2d");
        this.drawGradient(mctx, w, h, cfg);
        mctx.globalCompositeOperation = "destination-in";
        mctx.drawImage(canvas, 0, 0);
        mctx.globalCompositeOperation = "source-over";
        ctx.drawImage(mask, 0, 0);
      } else {
        this.drawGradient(ctx, w, h, cfg);
      }
      ctx.restore();
      return out;
    }
    applySpriteFilter(tile, filterName) {
      const canvas = this.tileToCanvas(tile);
      return this.applyCanvasFilter(canvas, filterName);
    }
    renderPlantWithMutationsNonTall(opts) {
      const { baseTile, mutations, mutationIcons } = opts;
      let canvas = this.tileToCanvas(baseTile);
      const size = canvas.width;
      let ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = false;
      const ordered = this.sortMutations(mutations);
      const colorMutations = ordered.filter(
        (m) => m === "Gold" || m === "Rainbow" || m === "Wet" || m === "Chilled" || m === "Frozen" || m === "Dawnlit" || m === "Ambershine" || m === "Dawncharged" || m === "Ambercharged"
      );
      const iconMutations = ordered.filter(
        (m) => m !== "Gold" && m !== "Rainbow"
        // Gold / Rainbow = que couleur
      );
      if (colorMutations.length) {
        canvas = this.applyColorMutations(canvas, colorMutations);
        ctx = canvas.getContext("2d");
      }
      if (iconMutations.length) {
        this.drawMutationIconsNonTall(ctx, iconMutations, size, mutationIcons);
      }
      return canvas;
    }
    sortMutations(mutations) {
      const seen = /* @__PURE__ */ new Set();
      for (const raw of mutations) {
        const key2 = raw;
        if (MUTATION_PRIORITY.includes(key2) && !seen.has(key2)) {
          seen.add(key2);
        }
      }
      return Array.from(seen).sort(
        (a, b) => MUTATION_PRIORITY.indexOf(a) - MUTATION_PRIORITY.indexOf(b)
      );
    }
    applyColorMutations(input, mutations) {
      if (!mutations.length) return input;
      if (mutations.includes("Gold")) {
        return this.applyFilterChain(input, ["Gold"]);
      }
      if (mutations.includes("Rainbow")) {
        return this.applyFilterChain(input, ["Rainbow"]);
      }
      const others = mutations.filter((m) => m !== "Gold" && m !== "Rainbow");
      return this.applyFilterChain(input, others);
    }
    applyFilterChain(input, filters) {
      let current = input;
      for (const f of filters) {
        const next = this.applyCanvasFilter(current, f);
        if (next) current = next;
      }
      return current;
    }
    drawMutationIconsNonTall(ctx, mutations, tileSize, mutationIcons) {
      ctx.save();
      ctx.imageSmoothingEnabled = false;
      for (const m of mutations) {
        const conf = mutationIcons[m];
        if (!conf) continue;
        const iconCanvas = this.tileToCanvas(conf.tile);
        const srcW = iconCanvas.width;
        const srcH = iconCanvas.height;
        const scale = conf.scale ?? 1;
        const dstW = tileSize * scale;
        const dstH = tileSize * scale;
        const baseOffsetY = HIGH_MUTATIONS.has(m) ? -tileSize * 0.25 : 0;
        const offsetX = (conf.offsetX ?? 0) * tileSize;
        const offsetY = (conf.offsetY ?? 0) * tileSize + baseOffsetY;
        ctx.drawImage(
          iconCanvas,
          0,
          0,
          srcW,
          srcH,
          offsetX,
          offsetY,
          dstW,
          dstH
        );
      }
      ctx.restore();
    }
    drawGradient(ctx, w, h, cfg) {
      const baseColors = cfg.colors.length ? cfg.colors : ["#ffffff"];
      const colors = cfg.reverse ? [...baseColors].reverse() : baseColors;
      if (cfg.gradientAngle != null) {
        const grad2 = this.makeAngleGradient(ctx, w, h, cfg.gradientAngle);
        if (colors.length === 1) {
          grad2.addColorStop(0, colors[0]);
          grad2.addColorStop(1, colors[0]);
        } else {
          colors.forEach((color, idx) => {
            grad2.addColorStop(idx / (colors.length - 1), color);
          });
        }
        ctx.fillStyle = grad2;
        ctx.fillRect(0, 0, w, h);
        return;
      }
      const grad = ctx.createLinearGradient(0, 0, 0, h);
      if (colors.length === 1) {
        grad.addColorStop(0, colors[0]);
        grad.addColorStop(1, colors[0]);
      } else {
        colors.forEach((color, idx) => {
          grad.addColorStop(idx / (colors.length - 1), color);
        });
      }
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);
    }
    /* ===================== INTERNE: chargement/dcoupe ===================== */
    async loadImage(url) {
      return await new Promise((res, rej) => {
        const im = new Image();
        im.crossOrigin = "anonymous";
        im.onload = () => res(im);
        im.onerror = rej;
        im.src = url;
      });
    }
    guessSize(url, img, forced) {
      if (forced) return forced;
      if (this.cfg.ruleAllplants512.test(url)) return 512;
      if (img.width % 256 === 0 && img.height % 256 === 0) return 256;
      if (img.width % 512 === 0 && img.height % 512 === 0) return 512;
      return 256;
    }
    isBlankOrBlack(data) {
      const aThr = this.cfg.skipAlphaBelow;
      const bThr = this.cfg.blackBelow;
      const tol = this.cfg.tolerance;
      const d = data.data;
      const maxColored = Math.ceil(d.length / 4 * tol);
      let colored = 0;
      for (let i = 0; i < d.length; i += 4) {
        const a = d[i + 3];
        if (a > aThr) {
          const r = d[i], g = d[i + 1], b = d[i + 2];
          if (r > bThr || g > bThr || b > bThr) {
            if (++colored > maxColored) return false;
          }
        }
      }
      return true;
    }
    async sliceOne(url, opts) {
      const img = await this.loadImage(url);
      const size = this.guessSize(url, img, opts.forceSize);
      const cols = Math.floor(img.width / size);
      const rows = Math.floor(img.height / size);
      const base = fileBase(url);
      const can = document.createElement("canvas");
      can.width = size;
      can.height = size;
      const ctx = can.getContext("2d", { willReadFrequently: true });
      ctx.imageSmoothingEnabled = false;
      const list = [];
      let idx = 0;
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          ctx.clearRect(0, 0, size, size);
          ctx.drawImage(img, col * size, row * size, size, size, 0, 0, size, size);
          let blank = false;
          try {
            const data = ctx.getImageData(0, 0, size, size);
            blank = this.isBlankOrBlack(data);
          } catch {
            blank = false;
          }
          if (!opts.includeBlanks && blank) {
            idx++;
            continue;
          }
          if (opts.mode === "bitmap") {
            const bmp = await createImageBitmap(can);
            list.push({ sheet: base, url, index: idx, col, row, size, data: bmp });
          } else if (opts.mode === "canvas") {
            const clone = document.createElement("canvas");
            clone.width = size;
            clone.height = size;
            clone.getContext("2d").drawImage(can, 0, 0);
            list.push({ sheet: base, url, index: idx, col, row, size, data: clone });
          } else {
            const dataURL = await new Promise((resolve2, reject) => {
              can.toBlob((blob) => {
                if (!blob) {
                  reject(new Error("toBlob returned null"));
                  return;
                }
                const fr = new FileReader();
                fr.onerror = reject;
                fr.onload = () => resolve2(fr.result);
                fr.readAsDataURL(blob);
              }, "image/png");
            });
            list.push({ sheet: base, url, index: idx, col, row, size, data: dataURL });
          }
          idx++;
        }
      }
      return list;
    }
    async zipTiles(opts) {
      const zip = new import_jszip.default();
      for (const u of this.familySet("tiles")) {
        const tiles = await this.sliceOne(u, { mode: "canvas", includeBlanks: false, forceSize: opts.forceSize });
        const base = fileBase(u);
        let k = 0;
        for (const t of tiles) {
          const can = t.data;
          const blob = await new Promise((res) => can.toBlob((b) => res(b), "image/png"));
          zip.file(`${base}/tile_${String(++k).padStart(4, "0")}.png`, blob);
        }
      }
      await this.saveZip(zip, opts.name);
    }
    /** Convertit tile.data -> Canvas (ImageBitmap/Canvas). Refuse dataURL (string). */
    tileToCanvas(tile) {
      const src = tile.data;
      let w = tile.size, h = tile.size;
      const out = document.createElement("canvas");
      out.width = w;
      out.height = h;
      const ctx = out.getContext("2d");
      ctx.imageSmoothingEnabled = false;
      if (src instanceof HTMLCanvasElement) {
        w = src.width;
        h = src.height;
        out.width = w;
        out.height = h;
        ctx.drawImage(src, 0, 0);
      } else if (typeof ImageBitmap !== "undefined" && src instanceof ImageBitmap) {
        w = src.width;
        h = src.height;
        out.width = w;
        out.height = h;
        ctx.drawImage(src, 0, 0);
      } else if (typeof src === "string") {
        throw new Error("Sprites: tile.data est un dataURL (string). Recharge la tuile en mode 'canvas' ou 'bitmap'.");
      } else {
        ctx.drawImage(src, 0, 0);
      }
      return out;
    }
    /** Cre un gradient linaire  un angle (deg) couvrant tout le canvas */
    makeAngleGradient(ctx, w, h, angleDeg) {
      const rad = (angleDeg - 90) * Math.PI / 180;
      const cx = w / 2;
      const cy = h / 2;
      const R = Math.min(w, h) / 2;
      const x0 = cx - Math.cos(rad) * R;
      const y0 = cy - Math.sin(rad) * R;
      const x1 = cx + Math.cos(rad) * R;
      const y1 = cy + Math.sin(rad) * R;
      return ctx.createLinearGradient(x0, y0, x1, y1);
    }
    /* ===================== SNIFFERS (UI + Tiles) ===================== */
    add(url, _why = "") {
      const families = guessFamiliesFromUrl(url);
      if (!families.length) return;
      this.addAsset(url, families);
    }
    addAsset(url, families = ["tiles"]) {
      const abs = toAbs(url);
      if (!isImageUrl(abs) || this.all.has(abs)) return false;
      const normalized = this.normalizeFamilies(families);
      if (!normalized.length) return false;
      this.all.add(abs);
      this.assetFamilies.set(abs, normalized);
      for (const family of normalized) {
        let bucket = this.familyAssets.get(family);
        if (!bucket) {
          bucket = /* @__PURE__ */ new Set();
          this.familyAssets.set(family, bucket);
        }
        bucket.add(abs);
      }
      const kind = normalized[0] ?? "unknown";
      this.onAssetCb?.(abs, kind);
      return true;
    }
    /* ===================== Utils ZIP ===================== */
    async fetchBlob(u) {
      const r = await fetch(u, { credentials: "include" });
      if (!r.ok) throw new Error(`HTTP ${r.status} for ${u}`);
      return r.blob();
    }
    async saveZip(zip, name) {
      const blob = await zip.generateAsync({ type: "blob" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = name;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(a.href), 1e4);
    }
  };
  var sharedSpritesInstance = new SpritesCore(false);
  shareGlobal("Sprites", sharedSpritesInstance);
  var Sprites = sharedSpritesInstance;
  function initSprites(options) {
    const instance = Sprites.init(options);
    shareGlobal("Sprites", instance);
    console.debug("[Sprites] Instance globale disponible sur pageWindow.Sprites", {
      hasWindowProperty: "Sprites" in pageWindow,
      lists: instance.lists()
    });
    return instance;
  }
  shareGlobal("initSprites", initSprites);

  // src/utils/tileSheet.ts
  var sheetCache = /* @__PURE__ */ new Map();
  var escapeRegExp = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  function clearTileSheetCache() {
    sheetCache.clear();
  }
  function normalizeSheetBase(urlOrBase) {
    const clean = urlOrBase.split(/[?#]/)[0] ?? urlOrBase;
    const file = clean.split("/").pop() ?? clean;
    return file.replace(/\.[^.]+$/, "");
  }
  function uniqueBases(urls, fallback) {
    const set2 = /* @__PURE__ */ new Set();
    for (const url of urls) {
      if (typeof url === "string" && url.length) {
        set2.add(normalizeSheetBase(url));
      }
    }
    if (set2.size === 0) {
      for (const base of fallback) set2.add(base);
    }
    return [...set2];
  }
  async function loadTileSheet(base) {
    const key2 = base.toLowerCase();
    if (sheetCache.has(key2)) return sheetCache.get(key2);
    const regex = new RegExp(`${escapeRegExp(base)}\\.(png|webp)$`, "i");
    const promise = Sprites.loadTiles({ mode: "canvas", onlySheets: regex }).then((map2) => {
      for (const [sheetBase, tiles] of map2.entries()) {
        if (sheetBase.toLowerCase() === key2) return tiles ?? [];
      }
      const direct = map2.get(base);
      return direct ?? [];
    }).catch(() => []);
    sheetCache.set(key2, promise);
    return promise;
  }

  // src/utils/gameVersion.ts
  var gameVersion = null;
  function initGameVersion(doc) {
    if (gameVersion !== null) {
      return;
    }
    const d = doc ?? (typeof document !== "undefined" ? document : null);
    if (!d) {
      return;
    }
    const scripts = d.scripts;
    for (let i = 0; i < scripts.length; i++) {
      const script = scripts.item(i);
      if (!script) continue;
      const src = script.src;
      if (!src) continue;
      const match = src.match(/\/(?:r\/\d+\/)?version\/([^/]+)/);
      if (match && match[1]) {
        gameVersion = match[1];
        return;
      }
    }
  }

  // src/services/assetManifest.ts
  var LOG_PREFIX = "[AssetManifest]";
  var ASSET_BASE_RE = /(https?:\/\/[^/]+\/(?:version\/[^/]+\/)?assets\/)/i;
  var VERSION_RE = /\/version\/([^/]+)\//i;
  var VERSION_PATH_RE = /\/version\/([^/]+)\//i;
  var manifestCache = null;
  var manifestPromise = null;
  var resolvedAssets = [];
  var aliasIndex = /* @__PURE__ */ new Map();
  var manifestFamilyIndex = /* @__PURE__ */ new Map();
  var assetBaseUrl = null;
  var assetVersion = null;
  var autoLoadScheduled = false;
  var manifestBaseUsed = null;
  function normalizeManifest(manifest) {
    if (!manifest || typeof manifest !== "object") return null;
    if (!Array.isArray(manifest.bundles)) {
      return { bundles: [] };
    }
    const bundles = manifest.bundles.map((b) => ({
      name: typeof b.name === "string" && b.name ? b.name : "default",
      assets: Array.isArray(b.assets) ? b.assets : []
    })).filter((b) => b.assets.length > 0);
    return { bundles };
  }
  function normalizeFamilyName(name) {
    if (!name) return null;
    const normalized = name.trim().toLowerCase();
    return normalized ? normalized : null;
  }
  function extractFamilyFromPath(path) {
    if (!path) return null;
    const cleaned = path.replace(/^\/+/, "").replace(/\\/g, "/").replace(/[\?#].*$/, "");
    const slashIndex = cleaned.indexOf("/");
    if (slashIndex <= 0) return null;
    return normalizeFamilyName(cleaned.slice(0, slashIndex));
  }
  function deriveAssetFamilies(src, aliases, bundleName) {
    const families = /* @__PURE__ */ new Set();
    const add = (path) => {
      const family = extractFamilyFromPath(path);
      if (family) families.add(family);
    };
    add(src);
    for (const alias of aliases) {
      add(alias);
    }
    if (!families.size) {
      const fallback = normalizeFamilyName(bundleName);
      if (fallback) families.add(fallback);
    }
    return Array.from(families);
  }
  function toAbsoluteUrl(base, rel) {
    if (/^https?:\/\//i.test(rel)) return rel;
    const cleanBase = base.endsWith("/") ? base : `${base}/`;
    return `${cleanBase}${rel.replace(/^\/+/, "")}`;
  }
  function inferAssetBase(url) {
    try {
      const href = new URL(url, location.href).href;
      const m = href.match(ASSET_BASE_RE);
      if (m && m[1]) {
        return m[1];
      }
    } catch {
    }
    return null;
  }
  function setAssetBase(url) {
    if (!url) return;
    const base = inferAssetBase(url);
    if (!base) return;
    if (assetBaseUrl && assetBaseUrl === base) return;
    assetBaseUrl = base;
    const match = base.match(VERSION_RE);
    assetVersion = match?.[1] ?? assetVersion;
  }
  function getManifestUrl(custom) {
    if (custom) return custom;
    if (assetBaseUrl) return `${assetBaseUrl}manifest.json`;
    return null;
  }
  function inferBaseFromLocation() {
    try {
      const href = location.href;
      const match = href.match(VERSION_PATH_RE);
      if (match?.[1]) {
        return `${location.origin}/version/${match[1]}/assets/`;
      }
    } catch {
    }
    return null;
  }
  function baseFromGameVersion() {
    if (!gameVersion) return null;
    try {
      return `${location.origin}/version/${gameVersion}/assets/`;
    } catch {
      return null;
    }
  }
  function sleep2(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  function indexResolvedAssets(list) {
    resolvedAssets = list;
    aliasIndex = /* @__PURE__ */ new Map();
    manifestFamilyIndex = /* @__PURE__ */ new Map();
    for (const asset of list) {
      aliasIndex.set(asset.src, asset);
      aliasIndex.set(asset.url, asset);
      for (const alias of asset.aliases) {
        aliasIndex.set(alias, asset);
      }
      for (const family of asset.families) {
        const bucket = manifestFamilyIndex.get(family);
        if (bucket) {
          bucket.push(asset);
        } else {
          manifestFamilyIndex.set(family, [asset]);
        }
      }
    }
  }
  function resolveManifest(manifest, base) {
    const out = [];
    for (const bundle of manifest.bundles ?? []) {
      const bundleName = bundle.name ?? "default";
      for (const asset of bundle.assets ?? []) {
        const aliases = Array.isArray(asset.alias) ? asset.alias.filter(Boolean) : [];
        for (const src of asset.src ?? []) {
          const url = base ? toAbsoluteUrl(base, src) : src;
          const families = deriveAssetFamilies(src, aliases, bundleName);
          const primaryFamily = families[0] ?? null;
          out.push({
            bundle: bundleName,
            aliases,
            src,
            url,
            tags: asset.data?.tags ?? {},
            families,
            primaryFamily
          });
        }
      }
    }
    return out;
  }
  function registerSpritesFromResolved(list) {
    let added = 0;
    for (const asset of list) {
      const wasNew = Sprites.registerKnownAsset(asset.url, asset.families);
      if (wasNew && (asset.families.includes("tiles") || asset.families.includes("ui"))) {
        added += 1;
      }
    }
    if (added > 0) {
      try {
        pageWindow.dispatchEvent(new CustomEvent("mg:sprite-detected", { detail: { source: "manifest" } }));
      } catch {
      }
    }
    return added;
  }
  async function fetchManifest(manifestUrl) {
    try {
      const res = await fetch(manifestUrl, { cache: "no-store", credentials: "include" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const json = await res.json();
      return normalizeManifest(json);
    } catch (error) {
      console.warn(LOG_PREFIX, "unable to fetch remote manifest", { manifestUrl, error });
      return null;
    }
  }
  function recordAssetUrlHint(url) {
    const previousBase = assetBaseUrl;
    setAssetBase(url);
    if (assetBaseUrl && assetBaseUrl !== previousBase) {
      scheduleAutoLoad();
    }
  }
  function scheduleAutoLoad() {
    if (autoLoadScheduled) return;
    autoLoadScheduled = true;
    setTimeout(() => {
      autoLoadScheduled = false;
      void prefetchManifest({ registerSprites: true }).catch(() => {
      });
    }, 100);
  }
  async function prefetchManifest(options = {}) {
    const desiredBase = assetBaseUrl ?? null;
    if (!options.force && manifestCache) {
      if (!desiredBase || manifestBaseUsed === desiredBase) {
        return manifestCache;
      }
    }
    if (!options.force && manifestPromise) return manifestPromise;
    if (!assetBaseUrl) {
      const hintedVersionBase = baseFromGameVersion();
      if (hintedVersionBase) {
        setAssetBase(hintedVersionBase);
      } else {
        const hintedBase = inferBaseFromLocation();
        if (hintedBase) setAssetBase(hintedBase);
      }
    }
    if (!assetBaseUrl && options.waitForVersionMs) {
      const deadline = Date.now() + options.waitForVersionMs;
      while (!assetBaseUrl && !gameVersion && Date.now() < deadline) {
        await sleep2(50);
      }
      if (!assetBaseUrl && gameVersion) {
        const hintedVersionBase = baseFromGameVersion();
        if (hintedVersionBase) setAssetBase(hintedVersionBase);
      }
    }
    const manifestUrl = getManifestUrl(options.url);
    if (!manifestUrl) {
      console.warn(LOG_PREFIX, "no manifest URL could be resolved");
      return null;
    }
    manifestPromise = (async () => {
      const manifest = manifestUrl ? await fetchManifest(manifestUrl) : null;
      if (!manifest) return null;
      if (manifestUrl) {
        setAssetBase(manifestUrl);
      }
      const baseForResolution = assetBaseUrl ?? (manifestUrl ? inferAssetBase(manifestUrl) : null);
      const resolved = resolveManifest(manifest, baseForResolution);
      indexResolvedAssets(resolved);
      manifestBaseUsed = baseForResolution ?? manifestBaseUsed;
      if (options.registerSprites !== false && baseForResolution) {
        registerSpritesFromResolved(resolved);
      }
      manifestCache = manifest;
      return manifest;
    })();
    try {
      return await manifestPromise;
    } finally {
      manifestPromise = null;
    }
  }
  var spritesReadyPromise = null;
  function ensureSpritesReady() {
    if (spritesReadyPromise) return spritesReadyPromise;
    spritesReadyPromise = (async () => {
      await prefetchManifest({ registerSprites: true, waitForVersionMs: 4e3 });
    })();
    return spritesReadyPromise;
  }

  // src/utils/sprites.ts
  var spriteConfig = /* @__PURE__ */ new WeakMap();
  var spriteSubscribers = /* @__PURE__ */ new Map();
  var spriteCache = /* @__PURE__ */ new Map();
  var spritePromises = /* @__PURE__ */ new Map();
  var nowMs = () => typeof performance !== "undefined" ? performance.now() : Date.now();
  var plantCatalogLookup = plantCatalog;
  var FALLBACK_BASES = {
    Seed: ["seeds"],
    Egg: ["pets"],
    Tool: ["items"],
    Decor: ["decor"],
    Crop: ["plants"]
  };
  var baseCache = {};
  var tallCropSheetBases = null;
  var computeBases = (provider, fallback) => {
    try {
      const list = provider() ?? [];
      return uniqueBases(list, fallback);
    } catch {
      return [...fallback];
    }
  };
  var LIST_PROVIDERS = {
    Seed: () => typeof Sprites.listSeeds === "function" ? Sprites.listSeeds() : [],
    Egg: () => typeof Sprites.listPets === "function" ? Sprites.listPets() : [],
    Tool: () => typeof Sprites.listItems === "function" ? Sprites.listItems() : [],
    Decor: () => typeof Sprites.listTilesByCategory === "function" ? Sprites.listTilesByCategory(/decor/i) : []
  };
  var TALL_CROP_SPECIES = /* @__PURE__ */ new Set(["Cactus", "Bamboo"]);
  var SHOP_SPRITE_ID_BUILDERS = {
    Seed: () => Object.keys(plantCatalogLookup).filter((id) => Boolean(plantCatalogLookup[id]?.seed?.tileRef)),
    Crop: () => Object.keys(plantCatalogLookup).filter((id) => Boolean(plantCatalogLookup[id]?.crop?.tileRef)),
    Egg: () => Object.keys(eggCatalog),
    Tool: () => Object.keys(toolCatalog),
    Decor: () => Object.keys(decorCatalog)
  };
  var warmupIdCache = {};
  function getShopSpriteWarmupIds(type) {
    const cached = warmupIdCache[type];
    if (cached) return cached;
    const builder = SHOP_SPRITE_ID_BUILDERS[type];
    if (!builder) return [];
    const ids = builder().filter((id) => typeof id === "string" && id.length > 0);
    warmupIdCache[type] = ids;
    return ids;
  }
  function spriteKey(type, id) {
    return `${type}::${id}`;
  }
  function defaultFallback(type) {
    switch (type) {
      case "Seed":
        return "\u{1F331}";
      case "Egg":
        return "\u{1F95A}";
      case "Tool":
        return "\u{1F9F0}";
      case "Decor":
        return "\u{1F3E0}";
      case "Crop":
        return "\u{1F34E}";
    }
  }
  function getCropBases() {
    if (baseCache.Crop) return baseCache.Crop;
    const provider = () => {
      if (typeof Sprites.listTilesByCategory !== "function") return [];
      const all = Sprites.listTilesByCategory(/plants|allplants/i);
      const filtered = all.filter((u) => !/tallplants/i.test(u) && !/tall/i.test(u));
      return filtered.length ? filtered : all;
    };
    const bases = computeBases(provider, FALLBACK_BASES.Crop);
    baseCache.Crop = bases;
    return bases;
  }
  function getTallCropBases() {
    if (tallCropSheetBases) return tallCropSheetBases;
    const provider = () => {
      if (typeof Sprites.listTilesByCategory !== "function") return [];
      return Sprites.listTilesByCategory(/tallplants/i);
    };
    tallCropSheetBases = computeBases(provider, ["tallplants", "TallPlants"]);
    return tallCropSheetBases;
  }
  function getBases(type, id) {
    if (type === "Crop") {
      const bases2 = getCropBases();
      if (id && TALL_CROP_SPECIES.has(id)) {
        return [...getTallCropBases(), ...bases2];
      }
      return bases2;
    }
    if (baseCache[type]) return baseCache[type];
    const builder = LIST_PROVIDERS[type];
    const fallback = FALLBACK_BASES[type];
    const bases = builder ? computeBases(builder, fallback) : [...fallback];
    baseCache[type] = bases;
    return bases;
  }
  function toTileIndex(tileRef) {
    if (tileRef == null) return null;
    const value = typeof tileRef === "number" && Number.isFinite(tileRef) ? tileRef : Number(tileRef);
    if (!Number.isFinite(value)) return null;
    if (value <= 0) return value;
    return value - 1;
  }
  function getTileRef(type, id) {
    switch (type) {
      case "Seed":
        return plantCatalog?.[id]?.seed?.tileRef ?? null;
      case "Egg":
        return eggCatalog?.[id]?.tileRef ?? null;
      case "Tool":
        return toolCatalog?.[id]?.tileRef ?? null;
      case "Decor":
        return decorCatalog?.[id]?.tileRef ?? null;
      case "Crop":
        return plantCatalog?.[id]?.crop?.tileRef ?? null;
    }
  }
  function subscribeSprite(key2, el2) {
    let subs = spriteSubscribers.get(key2);
    if (!subs) {
      subs = /* @__PURE__ */ new Set();
      spriteSubscribers.set(key2, subs);
    }
    subs.add(el2);
  }
  function unsubscribeIfDisconnected(key2, el2) {
    const subs = spriteSubscribers.get(key2);
    if (!subs) return;
    if (!el2.isConnected) {
      subs.delete(el2);
      spriteConfig.delete(el2);
    }
    if (subs.size === 0) {
      spriteSubscribers.delete(key2);
    }
  }
  function applySprite(el2, src) {
    const cfg = spriteConfig.get(el2);
    if (!cfg) return;
    const { size, fallback, alt } = cfg;
    el2.innerHTML = "";
    el2.style.display = "inline-flex";
    el2.style.alignItems = "center";
    el2.style.justifyContent = "center";
    el2.style.width = `${size}px`;
    el2.style.height = `${size}px`;
    el2.style.flexShrink = "0";
    el2.style.position = "relative";
    el2.setAttribute("role", "img");
    if (src) {
      el2.removeAttribute("aria-label");
      el2.style.fontSize = "";
      const img = document.createElement("img");
      img.src = src;
      img.alt = alt;
      img.decoding = "async";
      img.loading = "lazy";
      img.draggable = false;
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "contain";
      el2.appendChild(img);
    } else {
      el2.textContent = fallback;
      el2.style.fontSize = `${Math.max(10, Math.round(size * 0.72))}px`;
      el2.setAttribute("aria-label", alt || fallback);
    }
  }
  function notifySpriteSubscribers(key2, src) {
    const subs = spriteSubscribers.get(key2);
    if (!subs) return;
    subs.forEach((el2) => {
      if (!el2.isConnected) {
        unsubscribeIfDisconnected(key2, el2);
        return;
      }
      applySprite(el2, src);
    });
  }
  async function fetchSprite(type, id) {
    await ensureSpritesReady();
    if (typeof pageWindow === "undefined") return null;
    if (typeof Sprites?.getTile !== "function") return null;
    const tileRef = getTileRef(type, id);
    const index = toTileIndex(tileRef);
    if (index == null) return null;
    const bases = getBases(type, id);
    for (const base of bases) {
      try {
        const tiles = await loadTileSheet(base);
        const tile = tiles.find((t) => t.index === index);
        const canvas = tile?.data;
        if (!canvas || canvas.width <= 0 || canvas.height <= 0) continue;
        const dataUrl = canvas.toDataURL();
        return dataUrl;
      } catch (error) {
      }
    }
    return null;
  }
  function loadSprite(type, id, key2 = spriteKey(type, id)) {
    if (typeof pageWindow === "undefined") {
      spriteCache.set(key2, { payload: null, createdAt: nowMs() });
      notifySpriteSubscribers(key2, null);
      return Promise.resolve(null);
    }
    const cached = spriteCache.get(key2);
    if (cached !== void 0) {
      notifySpriteSubscribers(key2, cached.payload);
      return Promise.resolve(cached.payload);
    }
    const inflight = spritePromises.get(key2);
    if (inflight) return inflight;
    const promise = fetchSprite(type, id).then((src) => {
      spriteCache.set(key2, { payload: src, createdAt: nowMs() });
      spritePromises.delete(key2);
      return src;
    }).catch(() => {
      spritePromises.delete(key2);
      return null;
    });
    spritePromises.set(key2, promise);
    return promise;
  }
  function prefetchShopSprite(type, id) {
    const key2 = spriteKey(type, id);
    return loadSprite(type, id, key2);
  }
  var SHOP_SPRITE_WARMUP_TYPES = ["Seed", "Egg", "Tool", "Decor", "Crop"];
  var DEFAULT_SHOP_SPRITE_WARMUP_LIMITS = {
    Seed: 18,
    Egg: 6,
    Tool: 6,
    Decor: 24,
    Crop: 10
  };
  var waitMs = (ms) => new Promise((resolve2) => setTimeout(resolve2, ms));
  function resolveWarmupLimit(type, options) {
    const limitConfig = options.limit;
    if (typeof limitConfig === "number") {
      return limitConfig;
    }
    if (limitConfig && typeof limitConfig === "object" && limitConfig[type] != null) {
      return limitConfig[type];
    }
    return DEFAULT_SHOP_SPRITE_WARMUP_LIMITS[type] ?? Infinity;
  }
  async function warmUpShopSprites(options = {}) {
    if (typeof pageWindow === "undefined") return;
    const delay4 = Math.max(0, options.delayMs ?? 0);
    const step = Math.max(0, options.stepMs ?? 0);
    const types = options.types ?? SHOP_SPRITE_WARMUP_TYPES;
    if (delay4 > 0) {
      await waitMs(delay4);
    }
    for (const type of types) {
      const ids = getShopSpriteWarmupIds(type);
      if (ids.length === 0) continue;
      const limit = resolveWarmupLimit(type, options);
      if (limit <= 0) {
        continue;
      }
      const selected = limit < ids.length ? ids.slice(0, limit) : ids;
      for (const id of selected) {
        try {
          await prefetchShopSprite(type, id);
        } catch {
        }
        if (step > 0) {
          await waitMs(step);
        }
      }
    }
  }
  var SHOP_SPRITE_BATCH_SIZE = 12;
  var SHOP_SPRITE_BATCH_DELAY_MS = 0;
  var SHOP_SPRITE_BATCH_THRESHOLD = 10;
  var shopSpriteBatchConfig = {
    enabled: true,
    batchSize: SHOP_SPRITE_BATCH_SIZE,
    delayMs: SHOP_SPRITE_BATCH_DELAY_MS,
    threshold: SHOP_SPRITE_BATCH_THRESHOLD
  };
  var shopSpriteBatchQueue = [];
  var shopSpriteBatchScheduled = false;
  var shopSpriteBurstCount = 0;
  var shopSpriteBurstResetToken = null;
  var resetShopSpriteBurst = () => {
    shopSpriteBurstCount = 0;
    shopSpriteBurstResetToken = null;
  };
  var trackShopSpriteBurst = () => {
    shopSpriteBurstCount += 1;
    if (shopSpriteBurstResetToken != null) return shopSpriteBurstCount;
    if (typeof requestAnimationFrame === "function") {
      shopSpriteBurstResetToken = requestAnimationFrame(resetShopSpriteBurst);
    } else if (typeof window !== "undefined") {
      shopSpriteBurstResetToken = window.setTimeout(resetShopSpriteBurst, 16);
    } else {
      resetShopSpriteBurst();
    }
    return shopSpriteBurstCount;
  };
  var resolveShopSpriteBatchConfig = (batchOptions) => ({
    enabled: batchOptions?.enabled ?? shopSpriteBatchConfig.enabled,
    batchSize: Math.max(1, Math.floor(batchOptions?.batchSize ?? shopSpriteBatchConfig.batchSize)),
    delayMs: Math.max(0, Math.floor(batchOptions?.delayMs ?? shopSpriteBatchConfig.delayMs)),
    threshold: Math.max(1, Math.floor(batchOptions?.threshold ?? shopSpriteBatchConfig.threshold))
  });
  var shouldBatchShopSprite = (resolved, batchOptions) => {
    if (!resolved.enabled) return false;
    if (batchOptions?.force === true) return true;
    if (batchOptions?.force === false) return false;
    if (typeof window === "undefined") return false;
    const burst = trackShopSpriteBurst();
    return burst >= resolved.threshold;
  };
  var normalizeShopSpriteOptions = (type, options) => {
    const size = Math.max(12, options.size ?? 36);
    const fallback = String(options.fallback ?? defaultFallback(type));
    const alt = typeof options.alt === "string" ? options.alt : "";
    return { size, fallback, alt };
  };
  var createShopSpriteImmediate = (type, id, options) => {
    const { size, fallback, alt } = options;
    const el2 = document.createElement("span");
    spriteConfig.set(el2, { size, fallback, alt });
    if (typeof pageWindow === "undefined") {
      applySprite(el2, null);
      return el2;
    }
    const key2 = spriteKey(type, id);
    subscribeSprite(key2, el2);
    applySprite(el2, spriteCache.get(key2)?.payload ?? null);
    const promise = loadSprite(type, id, key2);
    return el2;
  };
  function flushShopSpriteBatch() {
    shopSpriteBatchScheduled = false;
    if (!shopSpriteBatchQueue.length) return;
    const batchSize = Math.max(1, shopSpriteBatchQueue[0]?.batchSize ?? SHOP_SPRITE_BATCH_SIZE);
    const tasks = shopSpriteBatchQueue.splice(0, batchSize);
    tasks.forEach((task) => {
      const { placeholder } = task;
      if (!placeholder.isConnected) return;
      const sprite = createShopSpriteImmediate(task.type, task.id, task.options);
      try {
        placeholder.replaceWith(sprite);
      } catch {
      }
    });
    if (shopSpriteBatchQueue.length) {
      scheduleShopSpriteBatch();
    }
  }
  function scheduleShopSpriteBatch() {
    if (shopSpriteBatchScheduled) return;
    shopSpriteBatchScheduled = true;
    const delayMs = Math.max(0, shopSpriteBatchQueue[0]?.delayMs ?? SHOP_SPRITE_BATCH_DELAY_MS);
    const run = () => {
      if (delayMs > 0) {
        setTimeout(flushShopSpriteBatch, delayMs);
      } else {
        flushShopSpriteBatch();
      }
    };
    if (typeof requestAnimationFrame === "function") {
      requestAnimationFrame(run);
    } else {
      setTimeout(run, delayMs);
    }
  }
  var enqueueShopSpriteBatch = (type, id, options, batchOptions) => {
    const placeholder = document.createElement("span");
    spriteConfig.set(placeholder, options);
    applySprite(placeholder, null);
    shopSpriteBatchQueue.push({
      type,
      id,
      options,
      placeholder,
      batchSize: batchOptions.batchSize,
      delayMs: batchOptions.delayMs
    });
    scheduleShopSpriteBatch();
    return placeholder;
  };
  function createShopSprite(type, id, options = {}, batchOptions) {
    const normalizedOptions = normalizeShopSpriteOptions(type, options);
    const resolvedBatch = resolveShopSpriteBatchConfig(batchOptions);
    if (shouldBatchShopSprite(resolvedBatch, batchOptions)) {
      return enqueueShopSpriteBatch(type, id, normalizedOptions, resolvedBatch);
    }
    return createShopSpriteImmediate(type, id, normalizedOptions);
  }
  var weatherSpriteConfig = /* @__PURE__ */ new WeakMap();
  var weatherSpriteSubscribers = /* @__PURE__ */ new Map();
  var weatherSpriteCache = /* @__PURE__ */ new Map();
  var weatherSpritePromises = /* @__PURE__ */ new Map();
  var weatherListenerAttached = false;
  var animationBases = null;
  var weatherTileIndices = (() => {
    const map2 = /* @__PURE__ */ new Map();
    for (const [rawKey, rawValue] of Object.entries(tileRefsAnimations ?? {})) {
      const key2 = normalizeWeatherRawKey(rawKey);
      const index = toAnimationTileIndex(rawValue);
      if (key2 && index != null) {
        map2.set(key2, index);
      }
    }
    return map2;
  })();
  function normalizeWeatherRawKey(raw) {
    const str = typeof raw === "string" ? raw : String(raw ?? "");
    return str.trim().replace(/^Weather:/i, "").replace(/[^a-z0-9]+/gi, "").toLowerCase();
  }
  function toAnimationTileIndex(value) {
    const num = typeof value === "number" ? value : Number(value);
    if (!Number.isFinite(num)) return null;
    return num > 0 ? Math.trunc(num) - 1 : Math.trunc(num);
  }
  function getAnimationBases() {
    if (animationBases) return animationBases;
    const bases = /* @__PURE__ */ new Set();
    try {
      const listFn = Sprites?.listTilesByCategory;
      if (typeof listFn === "function") {
        for (const url of listFn(/anim/i)) {
          if (typeof url !== "string" || !url.length) continue;
          const clean = url.split(/[?#]/)[0] ?? url;
          const file = clean.split("/").pop() ?? clean;
          bases.add(file.replace(/\.[^.]+$/, ""));
        }
      }
    } catch {
    }
    if (bases.size === 0) {
      bases.add("animations");
    }
    animationBases = [...bases];
    return animationBases;
  }
  function subscribeWeatherSprite(key2, el2, config) {
    let subs = weatherSpriteSubscribers.get(key2);
    if (!subs) {
      subs = /* @__PURE__ */ new Set();
      weatherSpriteSubscribers.set(key2, subs);
    }
    subs.add(el2);
    weatherSpriteConfig.set(el2, config);
  }
  function notifyWeatherSpriteSubscribers(key2, src) {
    const subs = weatherSpriteSubscribers.get(key2);
    if (!subs) return;
    subs.forEach((el2) => {
      if (!el2.isConnected) {
        subs.delete(el2);
        weatherSpriteConfig.delete(el2);
        return;
      }
      applyWeatherSprite(el2, src);
    });
    if (subs.size === 0) {
      weatherSpriteSubscribers.delete(key2);
    }
  }
  function ensureWeatherSpriteListener() {
    if (weatherListenerAttached || typeof window === "undefined") return;
    weatherListenerAttached = true;
    window.addEventListener("mg:sprite-detected", () => {
      weatherSpriteCache.clear();
      weatherSpritePromises.clear();
      animationBases = null;
      clearTileSheetCache();
      const keys = Array.from(weatherSpriteSubscribers.keys());
      keys.forEach((key2) => {
        void loadWeatherSprite(key2);
      });
    });
  }
  function applyWeatherSprite(el2, src) {
    const cfg = weatherSpriteConfig.get(el2);
    if (!cfg) return;
    const { size, fallback, alt } = cfg;
    el2.innerHTML = "";
    el2.style.display = "inline-flex";
    el2.style.alignItems = "center";
    el2.style.justifyContent = "center";
    el2.style.width = `${size}px`;
    el2.style.height = `${size}px`;
    el2.style.flexShrink = "0";
    el2.style.position = "relative";
    el2.setAttribute("role", "img");
    if (src) {
      el2.removeAttribute("aria-label");
      el2.style.fontSize = "";
      const img = document.createElement("img");
      img.src = src;
      img.alt = alt;
      img.decoding = "async";
      img.loading = "lazy";
      img.draggable = false;
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "contain";
      el2.appendChild(img);
    } else {
      el2.textContent = fallback;
      el2.style.fontSize = `${Math.max(10, Math.round(size * 0.72))}px`;
      if (alt) el2.setAttribute("aria-label", alt);
      else el2.removeAttribute("aria-label");
    }
  }
  async function fetchWeatherSprite(key2) {
    await ensureSpritesReady();
    const index = weatherTileIndices.get(key2);
    if (index == null) return null;
    const bases = getAnimationBases();
    for (const base of bases) {
      try {
        const tiles = await loadTileSheet(base);
        const tile = tiles.find((t) => t.index === index);
        if (!tile) continue;
        const canvas = Sprites.toCanvas(tile);
        if (!canvas || canvas.width <= 0 || canvas.height <= 0) continue;
        return canvas.toDataURL();
      } catch {
      }
    }
    return null;
  }
  function loadWeatherSprite(key2) {
    if (typeof window === "undefined") {
      weatherSpriteCache.set(key2, null);
      notifyWeatherSpriteSubscribers(key2, null);
      return Promise.resolve(null);
    }
    const cached = weatherSpriteCache.get(key2);
    if (cached !== void 0) {
      notifyWeatherSpriteSubscribers(key2, cached);
      return Promise.resolve(cached);
    }
    const inflight = weatherSpritePromises.get(key2);
    if (inflight) return inflight;
    const promise = fetchWeatherSprite(key2).then((src) => {
      weatherSpriteCache.set(key2, src);
      weatherSpritePromises.delete(key2);
      notifyWeatherSpriteSubscribers(key2, src);
      return src;
    }).catch(() => {
      weatherSpritePromises.delete(key2);
      return null;
    });
    weatherSpritePromises.set(key2, promise);
    return promise;
  }
  async function prefetchWeatherSprites(options = {}) {
    const { keys, limit = 20, delayMs = 40 } = options;
    const sourceKeys = (keys ?? Array.from(weatherTileIndices.keys())).map((value) => normalizeWeatherRawKey(value)).map((value) => getWeatherSpriteKey(value)).filter((value) => Boolean(value));
    const max = limit && limit > 0 ? Math.min(limit, sourceKeys.length) : sourceKeys.length;
    for (let i = 0; i < max; i += 1) {
      const key2 = sourceKeys[i];
      try {
        await loadWeatherSprite(key2);
      } catch {
      }
      if (delayMs > 0 && i < max - 1) {
        await waitMs(delayMs);
      }
    }
  }
  function getWeatherSpriteKey(raw) {
    if (raw == null) return null;
    const normalized = normalizeWeatherRawKey(raw);
    if (!normalized) return null;
    if (weatherTileIndices.has(normalized)) return normalized;
    return null;
  }
  function createWeatherSprite(rawKey, options = {}) {
    const size = Math.max(12, options.size ?? 36);
    const fallback = String(options.fallback ?? "\u011EYO\u0130");
    const alt = typeof options.alt === "string" ? options.alt : "";
    const el2 = document.createElement("span");
    weatherSpriteConfig.set(el2, { size, fallback, alt });
    if (typeof window === "undefined") {
      applyWeatherSprite(el2, null);
      return el2;
    }
    ensureWeatherSpriteListener();
    const key2 = getWeatherSpriteKey(rawKey);
    if (!key2) {
      applyWeatherSprite(el2, null);
      return el2;
    }
    subscribeWeatherSprite(key2, el2, { size, fallback, alt });
    applyWeatherSprite(el2, weatherSpriteCache.get(key2) ?? null);
    const promise = loadWeatherSprite(key2);
    return el2;
  }
  var PET_VARIANT_COLOR_FILTER = {
    normal: null,
    gold: "Gold",
    rainbow: "Rainbow"
  };
  var petSpriteCache = /* @__PURE__ */ new Map();
  var petSpritePromises = /* @__PURE__ */ new Map();
  var petSheetBasesCache = null;
  var petListenerAttached = false;
  function canonicalSpecies(raw) {
    if (!raw) return raw;
    if (petCatalog[raw]) return raw;
    const pretty = raw.charAt(0).toUpperCase() + raw.slice(1).toLowerCase();
    return petCatalog[pretty] ? pretty : raw;
  }
  function toPetTileIndex(tileRef) {
    const value = typeof tileRef === "number" && Number.isFinite(tileRef) ? tileRef : Number(tileRef);
    if (!Number.isFinite(value)) return null;
    if (value <= 0) return value;
    return value - 1;
  }
  function getPetSheetBases() {
    if (petSheetBasesCache) return petSheetBasesCache;
    const urls = /* @__PURE__ */ new Set();
    try {
      const list = typeof Sprites.listPets === "function" ? Sprites.listPets() : [];
      for (const url of list) {
        if (typeof url === "string" && url.length) {
          urls.add(url);
        }
      }
    } catch {
    }
    const bases = Array.from(urls, (url) => normalizeSheetBase(url));
    petSheetBasesCache = bases;
    return bases;
  }
  function resetPetCaches() {
    petSpriteCache.clear();
    petSpritePromises.clear();
    petSheetBasesCache = null;
    clearTileSheetCache();
  }
  function ensurePetListener() {
    if (petListenerAttached || typeof window === "undefined") return;
    petListenerAttached = true;
    window.addEventListener("mg:sprite-detected", () => {
      resetPetCaches();
    });
  }
  function keyForPet(species, variant) {
    return `${species.toLowerCase()}::${variant}`;
  }
  function hasMutation(target, mutations) {
    if (!mutations) return false;
    const list = Array.isArray(mutations) ? mutations : [mutations];
    return list.map((value) => String(value ?? "").toLowerCase()).some((value) => value.includes(target));
  }
  function determinePetSpriteVariant(mutations) {
    if (hasMutation("rainbow", mutations)) return "rainbow";
    if (hasMutation("gold", mutations)) return "gold";
    return "normal";
  }
  async function fetchPetSprite(species, variant) {
    await ensureSpritesReady();
    if (typeof window === "undefined") return null;
    if (typeof Sprites.getTile !== "function") return null;
    const entry = petCatalog[species];
    const tileRef = entry?.tileRef;
    if (tileRef == null) return null;
    const index = toPetTileIndex(tileRef);
    if (index == null) return null;
    const baseCandidates = new Set(getPetSheetBases());
    if (baseCandidates.size === 0) {
      baseCandidates.add("pets");
      baseCandidates.add("Pets");
    }
    for (const base of baseCandidates) {
      try {
        const tiles = await loadTileSheet(base);
        const tile = tiles.find((t) => t.index === index);
        if (!tile) continue;
        const canvas = Sprites.toCanvas(tile);
        if (!canvas || canvas.width <= 0 || canvas.height <= 0) continue;
        let finalCanvas = canvas;
        const filterName = PET_VARIANT_COLOR_FILTER[variant];
        if (filterName) {
          const filtered = Sprites.applyCanvasFilter(finalCanvas, filterName);
          if (filtered) finalCanvas = filtered;
        }
        return finalCanvas.toDataURL();
      } catch {
      }
    }
    return null;
  }
  function loadPetSprite(speciesRaw, variant = "normal") {
    if (typeof window === "undefined") {
      return Promise.resolve(null);
    }
    const species = canonicalSpecies(String(speciesRaw ?? "").trim());
    if (!species) return Promise.resolve(null);
    ensurePetListener();
    const key2 = keyForPet(species, variant);
    const cached = petSpriteCache.get(key2);
    if (cached !== void 0) {
      return Promise.resolve(cached);
    }
    const inflight = petSpritePromises.get(key2);
    if (inflight) return inflight;
    const promise = fetchPetSprite(species, variant).then((src) => {
      petSpriteCache.set(key2, src);
      petSpritePromises.delete(key2);
      return src;
    }).catch(() => {
      petSpritePromises.delete(key2);
      return null;
    });
    petSpritePromises.set(key2, promise);
    return promise;
  }
  function loadPetSpriteFromMutations(species, mutations) {
    const variant = determinePetSpriteVariant(mutations);
    return loadPetSprite(species, variant);
  }
  async function prefetchPetSprites(options = {}) {
    const { species, variants = ["normal", "gold", "rainbow"], delayMs = 10, limit } = options;
    const allSpecies = (species ?? Object.keys(petCatalog)).map((value) => canonicalSpecies(value)).filter((value) => Boolean(value));
    const combos = [];
    for (const entry of allSpecies) {
      for (const variant of variants) {
        combos.push({ species: entry, variant });
      }
    }
    const max = typeof limit === "number" && limit > 0 ? Math.min(limit, combos.length) : combos.length;
    for (let i = 0; i < max; i += 1) {
      const combo = combos[i];
      try {
        await loadPetSprite(combo.species, combo.variant);
      } catch {
      }
      if (delayMs > 0 && i < max - 1) {
        await waitMs(delayMs);
      }
    }
  }
  var FULL_SHOP_WARMUP_LIMIT = {
    Seed: Infinity,
    Egg: Infinity,
    Tool: Infinity,
    Decor: Infinity,
    Crop: Infinity
  };
  async function warmUpAllSprites(options = {}) {
    const shopOptions = {
      delayMs: options.shop?.delayMs,
      stepMs: options.shop?.stepMs,
      types: options.shop?.types,
      limit: options.shop?.limit ?? FULL_SHOP_WARMUP_LIMIT
    };
    await warmUpShopSprites(shopOptions);
    await prefetchWeatherSprites(options.weather ?? { delayMs: 5, limit: 0 });
    await prefetchPetSprites(options.pet ?? { delayMs: 5 });
  }

  // src/services/notifier.ts
  var PATH_NOTIFIER_PREFS = "notifier.prefs";
  var PATH_NOTIFIER_RULES = "notifier.rules";
  var PATH_NOTIFIER_WEATHER = "notifier.weatherPrefs";
  var PATH_NOTIFIER_DEFAULTS = "notifier.loopDefaults";
  var DISPLAY_RARITY = {
    [rarity.Common]: "Common",
    [rarity.Uncommon]: "Uncommon",
    [rarity.Rare]: "Rare",
    [rarity.Legendary]: "Legendary",
    [rarity.Mythic]: "Mythical",
    [rarity.Divine]: "Divine",
    [rarity.Celestial]: "Celestial"
  };
  var norm2 = (s) => String(s ?? "").toLowerCase();
  var formatRuleSummary = (rule) => {
    if (!rule) return "";
    const parts = [];
    if (rule.sound) {
      const names = audio.listSounds();
      const label2 = names.includes(rule.sound) ? rule.sound : rule.sound.length > 32 ? `${rule.sound.slice(0, 29)}\u2026` : rule.sound;
      parts.push(`Sound: ${label2}`);
    }
    if (rule.playbackMode === "oneshot") parts.push("Mode: One-shot");
    else if (rule.playbackMode === "loop") parts.push("Mode: Loop");
    if (rule.stopMode === "purchase") parts.push("Stop: Until purchase");
    else if (rule.stopMode === "manual") parts.push("Stop: Manual");
    if (rule.loopIntervalMs != null) {
      const raw = Number(rule.loopIntervalMs);
      if (Number.isFinite(raw)) {
        const ms = Math.max(1, Math.round(raw));
        const seconds = ms / 1e3;
        const label2 = seconds >= 1 ? `${(seconds >= 10 ? Math.round(seconds) : Math.round(seconds * 10) / 10).toFixed(seconds >= 10 ? 0 : 1)} s` : `${ms} ms`;
        parts.push(`Interval: ${label2}`);
      }
    }
    return parts.join(" \u2022 ");
  };
  var formatLastSeen = (timestamp, isCurrent) => {
    if (isCurrent) {
      const title = timestamp ? new Date(timestamp).toLocaleString() : "Currently active";
      return { label: "Now", title };
    }
    if (!timestamp) return { label: "Never", title: "Never seen" };
    const now2 = Date.now();
    const diff = Math.max(0, now2 - timestamp);
    let label2;
    if (diff < 45e3) label2 = "Just now";
    else if (diff < 9e4) label2 = "1 min ago";
    else if (diff < 60 * 60 * 1e3) {
      const mins = Math.round(diff / 6e4);
      label2 = `${mins} min${mins > 1 ? "s" : ""} ago`;
    } else if (diff < 36 * 60 * 60 * 1e3) {
      const hours = Math.round(diff / 36e5);
      label2 = `${hours} hour${hours > 1 ? "s" : ""} ago`;
    } else {
      const days = Math.round(diff / 864e5);
      label2 = `${days} day${days > 1 ? "s" : ""} ago`;
    }
    return { label: label2, title: new Date(timestamp).toLocaleString() };
  };
  var weatherStateSignature = (rows) => JSON.stringify(
    rows.map((r) => [r.id, r.notify ? 1 : 0, r.lastSeen || 0, r.isCurrent ? 1 : 0])
  );
  var formatWeatherMutation = (mutation) => {
    const parts = [mutation.name];
    if (mutation.multiplier != null) {
      const raw = Number(mutation.multiplier);
      if (Number.isFinite(raw)) {
        const rounded = Math.abs(raw - Math.round(raw)) < 0.01 ? Math.round(raw) : Math.round(raw * 100) / 100;
        parts[0] = `${parts[0]} \xD7${rounded}`;
      }
    }
    return parts.join(" ");
  };
  var normalizeNumber = (value) => {
    const num = typeof value === "number" ? value : Number(value);
    return Number.isFinite(num) ? num : void 0;
  };
  var normalizeCycle = (raw) => {
    if (!raw || typeof raw !== "object") return null;
    const rawKind = typeof raw.kind === "string" ? raw.kind.trim() : "";
    const kindLc = rawKind.toLowerCase();
    let kind = "unknown";
    if (kindLc === "weather" || kindLc === "lunar" || kindLc === "base") kind = kindLc;
    const meta = { kind, rawKind: rawKind || void 0 };
    const startWindowMin = normalizeNumber(raw.startWindowMin);
    if (startWindowMin !== void 0) meta.startWindowMin = startWindowMin;
    const startWindowMax = normalizeNumber(raw.startWindowMax);
    if (startWindowMax !== void 0) meta.startWindowMax = startWindowMax;
    const durationMinutes = normalizeNumber(raw.durationMinutes);
    if (durationMinutes !== void 0) meta.durationMinutes = durationMinutes;
    const periodMinutes = normalizeNumber(raw.periodMinutes);
    if (periodMinutes !== void 0) meta.periodMinutes = periodMinutes;
    return meta;
  };
  var normalizeMutations = (raw) => {
    if (!Array.isArray(raw)) return [];
    const items = [];
    for (const entry of raw) {
      if (!entry || typeof entry !== "object") continue;
      const name = typeof entry.name === "string" ? entry.name.trim() : "";
      if (!name) continue;
      const mutation = { name };
      const multiplier = normalizeNumber(entry.multiplier);
      if (multiplier !== void 0) mutation.multiplier = multiplier;
      const conditional = typeof entry.conditional === "string" ? entry.conditional.trim() : "";
      if (conditional) mutation.conditional = conditional;
      items.push(mutation);
    }
    return items;
  };
  var WEATHER_DEFS = (() => {
    const entries = [];
    for (const [rawName, rawValue] of Object.entries(weatherCatalog ?? {})) {
      const safeName = String(rawName || "").trim();
      if (!safeName) continue;
      const rawDisplayName = typeof rawValue?.displayName === "string" ? String(rawValue.displayName).trim() : "";
      const displayName = (rawDisplayName || safeName).replace(/([a-z])([A-Z])/g, "$1 $2").replace(/_/g, " ").replace(/\s+/g, " ").trim();
      const atomValue = typeof rawValue?.atomValue === "string" ? String(rawValue.atomValue).trim() : "";
      const spriteKey2 = getWeatherSpriteKey(safeName) ?? getWeatherSpriteKey(rawDisplayName) ?? null;
      const type = atomValue || displayName;
      const description = typeof rawValue?.description === "string" ? String(rawValue.description).trim() : null;
      const weightInCycle = normalizeNumber(rawValue?.weightInCycle);
      const cycle = normalizeCycle(rawValue?.cycle);
      const mutations = normalizeMutations(rawValue?.mutations);
      entries.push({
        id: `Weather:${safeName}`,
        name: displayName || safeName,
        atomValue,
        spriteKey: spriteKey2,
        type,
        description,
        cycle,
        weightInCycle: weightInCycle ?? null,
        mutations
      });
    }
    return entries;
  })();
  var WEATHER_BY_ID = /* @__PURE__ */ new Map();
  var WEATHER_BY_ATOM = /* @__PURE__ */ new Map();
  var WEATHER_BY_NAME = /* @__PURE__ */ new Map();
  for (const def of WEATHER_DEFS) {
    WEATHER_BY_ID.set(def.id, def);
    WEATHER_BY_NAME.set(def.name.toLowerCase(), def);
    WEATHER_BY_ATOM.set(def.atomValue.toLowerCase(), def);
    WEATHER_BY_NAME.set(def.id.slice("Weather:".length).toLowerCase(), def);
  }
  var _staticMeta = null;
  function buildStaticMeta() {
    if (_staticMeta) return _staticMeta;
    const map2 = /* @__PURE__ */ new Map();
    for (const [species, entry] of Object.entries(plantCatalog)) {
      if (entry?.seed) {
        const id = `Seed:${species}`;
        map2.set(id, {
          type: "Seed",
          name: entry.seed.name,
          rarity: DISPLAY_RARITY[entry.seed.rarity] ?? entry.seed.rarity
        });
      }
    }
    for (const [eggId, entry] of Object.entries(eggCatalog)) {
      const id = `Egg:${eggId}`;
      map2.set(id, {
        type: "Egg",
        name: entry.name,
        rarity: DISPLAY_RARITY[entry.rarity] ?? entry.rarity
      });
    }
    for (const [toolId, entry] of Object.entries(toolCatalog)) {
      const id = `Tool:${toolId}`;
      map2.set(id, {
        type: "Tool",
        name: entry.name,
        rarity: DISPLAY_RARITY[entry.rarity] ?? entry.rarity
      });
    }
    for (const [decorId, entry] of Object.entries(decorCatalog)) {
      const id = `Decor:${decorId}`;
      map2.set(id, {
        type: "Decor",
        name: entry.name,
        rarity: DISPLAY_RARITY[entry.rarity] ?? entry.rarity
      });
    }
    _staticMeta = map2;
    return map2;
  }
  var _prefs = /* @__PURE__ */ new Map();
  var _weatherPrefs = /* @__PURE__ */ new Map();
  var _weatherPrefsLoaded = false;
  var _contextDefaults = {};
  var _contextDefaultsLoaded = false;
  var _rules = /* @__PURE__ */ new Map();
  var _rulesLoaded = false;
  var _rulesSubs = /* @__PURE__ */ new Set();
  var _hasOwn = Object.prototype.hasOwnProperty;
  var _weatherState = null;
  var _weatherSig = null;
  var _weatherSubs = /* @__PURE__ */ new Set();
  var _currentWeatherId = null;
  var _currentWeatherValue = null;
  var _unsubWeather = null;
  function _ensureRulesLoaded() {
    if (_rulesLoaded) return;
    _rulesLoaded = true;
    _rules = /* @__PURE__ */ new Map();
    try {
      const obj = readAriesPath(PATH_NOTIFIER_RULES);
      if (obj && typeof obj === "object") {
        for (const [id, value] of Object.entries(obj)) {
          const norm3 = _normalizeRule(value);
          if (norm3) _rules.set(String(id), norm3);
        }
      }
    } catch {
      _rules = /* @__PURE__ */ new Map();
    }
  }
  function _normalizeRule(raw) {
    const patch = {};
    if (_hasOwn.call(raw ?? {}, "sound")) patch.sound = raw?.sound ?? null;
    if (_hasOwn.call(raw ?? {}, "playbackMode")) patch.playbackMode = raw?.playbackMode ?? null;
    if (_hasOwn.call(raw ?? {}, "stopMode")) patch.stopMode = raw?.stopMode ?? null;
    if (_hasOwn.call(raw ?? {}, "stopRepeats")) patch.stopRepeats = raw?.stopRepeats ?? null;
    if (_hasOwn.call(raw ?? {}, "loopIntervalMs")) patch.loopIntervalMs = raw?.loopIntervalMs ?? null;
    return _mergeRule(void 0, patch);
  }
  function _saveRules() {
    if (!_rulesLoaded) return;
    try {
      const obj = {};
      for (const [id, rule] of _rules.entries()) {
        obj[id] = { ...rule };
      }
      writeAriesPath(PATH_NOTIFIER_RULES, obj);
    } catch {
    }
  }
  function _ensureWeatherPrefsLoaded() {
    if (_weatherPrefsLoaded) return;
    _weatherPrefsLoaded = true;
    _weatherPrefs = /* @__PURE__ */ new Map();
    try {
      const obj = readAriesPath(PATH_NOTIFIER_WEATHER);
      if (obj && typeof obj === "object") {
        for (const [id, value] of Object.entries(obj)) {
          if (!id) continue;
          const pref = {};
          if (typeof value?.notify === "boolean") pref.notify = !!value.notify;
          if (typeof value?.lastSeen === "number" && Number.isFinite(value.lastSeen)) {
            pref.lastSeen = Number(value.lastSeen);
          }
          _weatherPrefs.set(String(id), pref);
        }
      }
    } catch {
      _weatherPrefs = /* @__PURE__ */ new Map();
    }
  }
  function _saveWeatherPrefs() {
    if (!_weatherPrefsLoaded) return;
    try {
      const obj = {};
      for (const [id, pref] of _weatherPrefs.entries()) {
        const entry = {};
        if (pref.notify) entry.notify = true;
        if (typeof pref.lastSeen === "number" && Number.isFinite(pref.lastSeen)) entry.lastSeen = pref.lastSeen;
        if (entry.notify || entry.lastSeen != null) obj[id] = entry;
      }
      writeAriesPath(PATH_NOTIFIER_WEATHER, obj);
    } catch {
    }
  }
  function _getWeatherPref(id) {
    _ensureWeatherPrefsLoaded();
    const existing = _weatherPrefs.get(id);
    if (existing) return existing;
    const fresh = {};
    _weatherPrefs.set(id, fresh);
    return fresh;
  }
  function _ensureContextDefaultsLoaded() {
    if (_contextDefaultsLoaded) return;
    _contextDefaultsLoaded = true;
    _contextDefaults = {};
    try {
      const obj = readAriesPath(PATH_NOTIFIER_DEFAULTS);
      if (obj && typeof obj === "object") {
        for (const [context, value] of Object.entries(obj)) {
          const ctx = context;
          if (ctx !== "shops" && ctx !== "weather") continue;
          const modeRaw = value?.stopMode;
          const stopMode = modeRaw === "purchase" ? "purchase" : "manual";
          const repeatsRaw = Number(value?.stopRepeats);
          const stopRepeats = Number.isFinite(repeatsRaw) ? Math.max(1, Math.floor(repeatsRaw)) : null;
          const intervalRaw = Number(value?.loopIntervalMs);
          const playback = audio.getPlaybackSettings(ctx);
          const baseLoop = Number.isFinite(intervalRaw) ? intervalRaw : playback.loopIntervalMs;
          const loopIntervalMs = Math.max(150, Math.floor(baseLoop || 0));
          _contextDefaults[ctx] = { stopMode, stopRepeats, loopIntervalMs };
        }
      }
    } catch {
      _contextDefaults = {};
    }
  }
  function _saveContextDefaults() {
    if (!_contextDefaultsLoaded) return;
    try {
      const obj = {};
      for (const [ctx, value] of Object.entries(_contextDefaults)) {
        if (!value) continue;
        const loopIntervalMs = Math.max(150, Math.floor(value.loopIntervalMs | 0));
        const normalizedRepeats = value.stopRepeats != null ? Math.max(1, Math.floor(value.stopRepeats | 0)) : null;
        obj[ctx] = {
          stopMode: value.stopMode,
          stopRepeats: normalizedRepeats,
          loopIntervalMs
        };
      }
      writeAriesPath(PATH_NOTIFIER_DEFAULTS, obj);
    } catch {
    }
  }
  function _getContextStopDefaultsInternal(context) {
    _ensureContextDefaultsLoaded();
    const stored = _contextDefaults[context];
    const playback = audio.getPlaybackSettings(context);
    const playbackLoop = Math.max(150, Math.floor(playback.loopIntervalMs || 0));
    const storedLoop = stored?.loopIntervalMs;
    const loopIntervalMs = Math.max(150, Math.floor(storedLoop ?? playbackLoop));
    const storedMode = stored?.stopMode === "purchase" ? "purchase" : null;
    const playbackMode = playback.stop.mode === "purchase" ? "purchase" : null;
    if (context === "shops") {
      const stopMode = storedMode ?? playbackMode ?? "purchase";
      return { stopMode, stopRepeats: null, loopIntervalMs };
    }
    return { stopMode: "manual", stopRepeats: null, loopIntervalMs };
  }
  function _notifyWeather() {
    if (!_weatherState) return;
    _weatherSubs.forEach((fn) => {
      try {
        fn(_weatherState);
      } catch {
      }
    });
  }
  function _recomputeWeatherState() {
    _ensureWeatherPrefsLoaded();
    const rows = WEATHER_DEFS.map((def) => {
      const pref = _getWeatherPref(def.id);
      const notify2 = !!pref.notify;
      const lastSeen = typeof pref.lastSeen === "number" && Number.isFinite(pref.lastSeen) ? pref.lastSeen : null;
      return {
        id: def.id,
        name: def.name,
        type: def.type,
        spriteKey: def.spriteKey,
        atomValue: def.atomValue,
        notify: notify2,
        lastSeen,
        isCurrent: def.id === _currentWeatherId,
        description: def.description,
        cycle: def.cycle ? { ...def.cycle } : null,
        weightInCycle: def.weightInCycle,
        mutations: def.mutations.map((mutation) => ({ ...mutation }))
      };
    });
    const sig = JSON.stringify(rows.map((r) => [r.id, r.notify ? 1 : 0, r.lastSeen || 0, r.isCurrent ? 1 : 0]));
    const changed = sig !== _weatherSig;
    _weatherSig = sig;
    _weatherState = {
      updatedAt: Date.now(),
      currentId: _currentWeatherId,
      rows
    };
    if (changed) _notifyWeather();
  }
  function _buildWeatherOverrides(id) {
    const overrides = {};
    const rule = _rules.get(id);
    if (rule?.sound) overrides.sound = rule.sound;
    overrides.mode = "oneshot";
    return overrides;
  }
  function _triggerWeatherNotification(id) {
    const def = WEATHER_BY_ID.get(id);
    if (!def) return;
    const overrides = _buildWeatherOverrides(id);
    audio.trigger(id, overrides, "weather").catch(() => {
    });
  }
  function _handleWeatherUpdate(raw, opts = {}) {
    const normalize3 = (value) => {
      if (value == null) return "";
      if (typeof value === "string") return value.trim();
      return String(value || "").trim();
    };
    const nextValue = normalize3(raw);
    if (!opts.force && _currentWeatherValue === nextValue) return;
    const lookupKey = nextValue.toLowerCase();
    let def = WEATHER_BY_ATOM.get(lookupKey) || WEATHER_BY_NAME.get(lookupKey);
    if (!def && lookupKey) {
      const noSpace = lookupKey.replace(/\s+/g, "");
      def = WEATHER_BY_NAME.get(noSpace);
    }
    const prevId = _currentWeatherId;
    const now2 = Date.now();
    if (def) {
      const pref = _getWeatherPref(def.id);
      pref.lastSeen = now2;
      _weatherPrefs.set(def.id, pref);
    }
    _currentWeatherId = def?.id ?? null;
    _currentWeatherValue = nextValue;
    if (_currentWeatherId) {
      StatsService.incrementWeatherStat(_currentWeatherId.replace("Weather:", ""));
    }
    if (prevId && prevId !== _currentWeatherId) {
      audio.stopLoop(prevId);
    }
    if (def && _getWeatherPref(def.id).notify) {
      _triggerWeatherNotification(def.id);
    }
    if (def) _saveWeatherPrefs();
    _recomputeWeatherState();
  }
  function _rulesEqual(a, b) {
    if (!a && !b) return true;
    if (!a || !b) return false;
    return a.sound === b.sound && a.playbackMode === b.playbackMode && a.stopMode === b.stopMode && a.loopIntervalMs === b.loopIntervalMs;
  }
  function _sanitizeSound(value) {
    if (typeof value !== "string") return void 0;
    const trimmed = value.trim();
    return trimmed ? trimmed : void 0;
  }
  function _sanitizePlaybackMode(value) {
    if (value == null) return void 0;
    const v = String(value);
    return v === "oneshot" || v === "loop" ? v : void 0;
  }
  function _sanitizeStopMode(value) {
    if (value == null) return void 0;
    const v = String(value);
    if (v === "purchase") return "purchase";
    return void 0;
  }
  function _sanitizeLoopInterval(value) {
    if (value == null) return void 0;
    const n = Number(value);
    if (!Number.isFinite(n)) return void 0;
    const normalized = Math.max(150, Math.floor(n));
    return normalized >= 150 ? normalized : void 0;
  }
  function _mergeRule(prev, patch) {
    const next = { ...prev ?? {} };
    if (_hasOwn.call(patch, "sound")) {
      const s = _sanitizeSound(patch.sound);
      if (s) next.sound = s;
      else delete next.sound;
    }
    if (_hasOwn.call(patch, "playbackMode")) {
      const mode = _sanitizePlaybackMode(patch.playbackMode);
      if (mode) next.playbackMode = mode;
      else delete next.playbackMode;
    }
    if (_hasOwn.call(patch, "stopMode")) {
      const mode = _sanitizeStopMode(patch.stopMode);
      if (mode) next.stopMode = mode;
      else delete next.stopMode;
      delete next.stopRepeats;
    }
    if (_hasOwn.call(patch, "stopRepeats")) {
      delete next.stopRepeats;
    }
    if (_hasOwn.call(patch, "loopIntervalMs")) {
      const interval = _sanitizeLoopInterval(patch.loopIntervalMs);
      if (interval != null) next.loopIntervalMs = interval;
      else delete next.loopIntervalMs;
    }
    return Object.keys(next).length ? next : null;
  }
  function _rulesSnapshot() {
    _ensureRulesLoaded();
    const out = {};
    for (const [id, rule] of _rules.entries()) {
      out[id] = {
        ...rule.sound ? { sound: rule.sound } : {},
        ...rule.playbackMode ? { playbackMode: rule.playbackMode } : {},
        ...rule.stopMode ? { stopMode: rule.stopMode } : {},
        ...rule.loopIntervalMs != null ? { loopIntervalMs: rule.loopIntervalMs } : {}
      };
    }
    return out;
  }
  function _emitRules() {
    if (!_rulesLoaded) return;
    const snap = _rulesSnapshot();
    _rulesSubs.forEach((fn) => {
      try {
        fn(snap);
      } catch {
      }
    });
  }
  function _loadPrefs() {
    try {
      const obj = readAriesPath(PATH_NOTIFIER_PREFS) ?? {};
      const m = /* @__PURE__ */ new Map();
      if (obj && typeof obj === "object") {
        for (const [k, v] of Object.entries(obj)) {
          const n = Number(v) | 0;
          const popupBits = n & 1;
          if (k && popupBits !== void 0) m.set(String(k), popupBits);
        }
      }
      _prefs = m;
    } catch {
      _prefs = /* @__PURE__ */ new Map();
    }
  }
  function _savePrefs() {
    try {
      const obj = {};
      for (const [k, v] of _prefs) obj[k] = v & 1;
      writeAriesPath(PATH_NOTIFIER_PREFS, obj);
    } catch {
    }
  }
  var _getPrefBits = (id) => (_prefs.get(id) ?? 0) & 1;
  var _setPrefBits = (id, bits) => {
    if (!id) return;
    const masked = bits & 1;
    if (masked) _prefs.set(id, masked);
    else _prefs.delete(id);
    _savePrefs();
    _recomputeFromCacheAndNotify();
  };
  var _rowsById = /* @__PURE__ */ new Map();
  var _lastSig = "";
  var _state = null;
  var _unsubShops = null;
  var _unsubPurchases = null;
  var _subs = /* @__PURE__ */ new Set();
  var _toolInv = /* @__PURE__ */ new Map();
  var _unsubToolInv = null;
  var TOOL_CAPS = {
    Shovel: 1,
    WateringCan: 99
  };
  function _isToolCapReached(toolId) {
    const cap = TOOL_CAPS[toolId];
    if (!cap) return false;
    const q = _toolInv.get(toolId) || 0;
    return q >= cap;
  }
  function _updateToolInv(raw) {
    try {
      const arr = Array.isArray(raw) ? raw : [];
      _toolInv = new Map(arr.map((it) => [String(it.toolId), Number(it.quantity) || 0]));
    } catch {
      _toolInv = /* @__PURE__ */ new Map();
    }
    _recomputeFromCacheAndNotify();
  }
  function _resolveToolInvAtom() {
    const a = Atoms;
    return a.inventory?.myToolInventory ?? a.shop?.myToolInventory ?? a.myToolInventoryAtom ?? null;
  }
  function _computeSig(ids) {
    return ids.slice().sort().join("|");
  }
  var _purchasesSubs = /* @__PURE__ */ new Set();
  function _coercePurchases(raw) {
    const co = (sec) => ({
      createdAt: Number(sec?.createdAt) || 0,
      purchases: sec?.purchases && typeof sec.purchases === "object" ? sec.purchases : {}
    });
    return {
      seed: co(raw?.seed),
      egg: co(raw?.egg),
      tool: co(raw?.tool),
      decor: co(raw?.decor)
    };
  }
  function _notifyPurchases(raw) {
    const snap = _coercePurchases(raw);
    _purchasesSubs.forEach((fn) => {
      try {
        fn(snap);
      } catch {
      }
    });
  }
  var _shopsSubs = /* @__PURE__ */ new Set();
  function _coerceSnap(raw) {
    const co = (sec) => ({
      inventory: Array.isArray(sec?.inventory) ? sec.inventory : [],
      secondsUntilRestock: Number(sec?.secondsUntilRestock) || 0
    });
    return {
      seed: co(raw?.seed),
      egg: co(raw?.egg),
      tool: co(raw?.tool),
      decor: co(raw?.decor)
    };
  }
  function _notifyShops(raw) {
    const snap = _coerceSnap(raw);
    _shopsSubs.forEach((fn) => {
      try {
        fn(snap);
      } catch {
      }
    });
  }
  function _recomputeFromRaw(raw) {
    const staticMeta = buildStaticMeta();
    const sections = [
      { key: "seed", type: "Seed" },
      { key: "egg", type: "Egg" },
      { key: "tool", type: "Tool" },
      { key: "decor", type: "Decor" }
    ];
    const seen = /* @__PURE__ */ new Set();
    for (const { key: key2, type } of sections) {
      const sec = raw?.[key2] ?? {};
      const inv = Array.isArray(sec?.inventory) ? sec.inventory : [];
      for (const entry of inv) {
        const id = type === "Seed" ? `Seed:${entry.species}` : type === "Egg" ? `Egg:${entry.eggId}` : type === "Tool" ? `Tool:${entry.toolId}` : `Decor:${entry.decorId}`;
        seen.add(id);
        const meta = staticMeta.get(id);
        const bits = _getPrefBits(id);
        const popup = !!(bits & 1);
        const row = {
          id,
          type,
          name: meta?.name ?? id.split(":")[1] ?? id,
          rarity: meta?.rarity,
          popup,
          followed: popup
          // compat
        };
        _rowsById.set(id, row);
      }
    }
    for (const id of Array.from(_rowsById.keys())) {
      if (!seen.has(id)) _rowsById.delete(id);
    }
    const rows = Array.from(_rowsById.values());
    const followed = rows.reduce((n, r) => n + (r.followed ? 1 : 0), 0);
    const next = {
      updatedAt: Date.now(),
      rows,
      counts: { items: rows.length, followed }
    };
    const sig = _computeSig(rows.map((r) => r.id));
    const changed = sig !== _lastSig;
    _state = next;
    if (changed) {
      _lastSig = sig;
      _notify();
    } else {
    }
  }
  function _recomputeFromCacheAndNotify() {
    if (!_state) return;
    for (const [id, row] of _rowsById) {
      const bits = _getPrefBits(id);
      let popup = !!(bits & 1);
      if (id.startsWith("Tool:")) {
        const toolId = id.slice(5);
        if (_isToolCapReached(toolId)) {
          popup = false;
        }
      }
      row.popup = popup;
      row.followed = popup;
    }
    const rows = Array.from(_rowsById.values());
    const followed = rows.reduce((n, r) => n + (r.followed ? 1 : 0), 0);
    _state = {
      ..._state,
      updatedAt: Date.now(),
      rows,
      counts: { items: rows.length, followed }
    };
    _notify();
  }
  function _notify() {
    if (!_state) return;
    const snap = { ..._state, rows: _state.rows.slice() };
    _subs.forEach((fn) => {
      try {
        fn(snap);
      } catch {
      }
    });
  }
  var _started = false;
  async function _ensureStarted() {
    if (_started) {
      return;
    }
    _started = true;
    _loadPrefs();
    _ensureRulesLoaded();
    try {
      const cur = await Atoms.shop.shops.get();
      _recomputeFromRaw(cur);
      _notifyShops(cur);
    } catch (err) {
    }
    try {
      _unsubShops = await Atoms.shop.shops.onChange((next) => {
        try {
          _recomputeFromRaw(next);
        } catch {
        }
        try {
          _notifyShops(next);
        } catch {
        }
      });
    } catch (err) {
    }
    try {
      const curP = await Atoms.shop.myShopPurchases.get();
      _notifyPurchases(curP);
    } catch (err) {
    }
    try {
      _unsubPurchases = await Atoms.shop.myShopPurchases.onChange((next) => {
        try {
          _notifyPurchases(next);
        } catch {
        }
      });
    } catch (err) {
    }
    try {
      const invAtom = _resolveToolInvAtom();
      if (invAtom) {
        try {
          _updateToolInv(await invAtom.get());
        } catch (err) {
        }
        try {
          _unsubToolInv = await invAtom.onChange((next) => {
            try {
              _updateToolInv(next);
            } catch {
            }
          });
        } catch (err) {
        }
      }
    } catch (err) {
    }
    try {
      const weatherAtom = Atoms.data?.weather;
      if (weatherAtom) {
        try {
          _handleWeatherUpdate(await weatherAtom.get(), { force: true });
        } catch (err) {
        }
        try {
          _unsubWeather = await weatherAtom.onChange((next) => {
            try {
              _handleWeatherUpdate(next);
            } catch {
            }
          });
        } catch (err) {
        }
      } else {
      }
    } catch (err) {
    }
  }
  function _stop() {
    try {
      _unsubShops?.();
    } catch {
    }
    _unsubShops = null;
    try {
      _unsubPurchases?.();
    } catch {
    }
    _unsubPurchases = null;
    try {
      _unsubToolInv?.();
    } catch {
    }
    _unsubToolInv = null;
    try {
      _unsubWeather?.();
    } catch {
    }
    _unsubWeather = null;
    if (_currentWeatherId) {
      try {
        audio.stopLoop(_currentWeatherId);
      } catch {
      }
    }
    _currentWeatherId = null;
    _currentWeatherValue = null;
    _started = false;
  }
  var NotifierService = {
    // lifecycle
    async start() {
      await _ensureStarted();
      return () => _stop();
    },
    async get() {
      await _ensureStarted();
      if (!_state) {
        _recomputeFromRaw(await Atoms.shop.shops.get().catch(() => null));
      }
      return _state;
    },
    onChange(cb) {
      _subs.add(cb);
      return () => {
        _subs.delete(cb);
      };
    },
    async onChangeNow(cb) {
      await _ensureStarted();
      if (_state) cb(_state);
      else {
        try {
          _recomputeFromRaw(await Atoms.shop.shops.get());
        } catch {
        }
        if (_state) cb(_state);
      }
      return this.onChange(cb);
    },
    onShopsChange(cb) {
      _shopsSubs.add(cb);
      return () => {
        _shopsSubs.delete(cb);
      };
    },
    async onShopsChangeNow(cb) {
      await _ensureStarted();
      try {
        cb(_coerceSnap(await Atoms.shop.shops.get()));
      } catch {
      }
      return this.onShopsChange(cb);
    },
    onPurchasesChange(cb) {
      _purchasesSubs.add(cb);
      return () => {
        _purchasesSubs.delete(cb);
      };
    },
    async onPurchasesChangeNow(cb) {
      await _ensureStarted();
      try {
        cb(_coercePurchases(await Atoms.shop.myShopPurchases.get()));
      } catch {
      }
      return this.onPurchasesChange(cb);
    },
    async getWeatherState() {
      await _ensureStarted();
      if (!_weatherState) _recomputeWeatherState();
      return _weatherState;
    },
    onWeatherChange(cb) {
      _weatherSubs.add(cb);
      return () => {
        _weatherSubs.delete(cb);
      };
    },
    async onWeatherChangeNow(cb) {
      await _ensureStarted();
      if (!_weatherState) _recomputeWeatherState();
      if (_weatherState) cb(_weatherState);
      return this.onWeatherChange(cb);
    },
    getWeatherNotify(id) {
      if (!id) return false;
      return !!_getWeatherPref(id).notify;
    },
    setWeatherNotify(id, enabled) {
      if (!id) return;
      _ensureWeatherPrefsLoaded();
      const pref = _getWeatherPref(id);
      const next = !!enabled;
      if (!!pref.notify === next) return;
      pref.notify = next;
      _weatherPrefs.set(id, pref);
      _saveWeatherPrefs();
      if (!next) {
        try {
          audio.stopLoop(id);
        } catch {
        }
      } else if (_currentWeatherId === id) {
        _triggerWeatherNotification(id);
      }
      _recomputeWeatherState();
    },
    getContextStopDefaults(context) {
      return _getContextStopDefaultsInternal(context);
    },
    setContextStopDefaults(context, conf) {
      if (context !== "shops" && context !== "weather") return;
      _ensureContextDefaultsLoaded();
      const current = _getContextStopDefaultsInternal(context);
      const loopRaw = Number(conf?.loopIntervalMs);
      const loopIntervalMs = Number.isFinite(loopRaw) ? Math.max(150, Math.floor(loopRaw)) : current.loopIntervalMs;
      const normalizedMode = conf.stopMode === "purchase" ? "purchase" : "manual";
      const normalized = {
        stopMode: context === "weather" ? "manual" : normalizedMode,
        stopRepeats: null,
        loopIntervalMs
      };
      _contextDefaults[context] = normalized;
      _saveContextDefaults();
    },
    // prefs (popup only)
    getPref(id) {
      if (id.startsWith("Tool:")) {
        const toolId = id.slice(5);
        if (_isToolCapReached(toolId)) {
          return { popup: false, followed: false };
        }
      }
      const bits = _getPrefBits(id);
      const popup = !!(bits & 1);
      return { popup, followed: popup };
    },
    setPopup(id, enabled) {
      if (enabled && id.startsWith("Tool:") && _isToolCapReached(id.slice(5))) {
        return;
      }
      const bits = _getPrefBits(id);
      const next = enabled ? bits | 1 : bits & ~1;
      _setPrefBits(id, next);
    },
    setPrefs(id, prefs2) {
      const bits = _getPrefBits(id);
      let next = bits;
      if (typeof prefs2.popup === "boolean") next = prefs2.popup ? next | 1 : next & ~1;
      _setPrefBits(id, next);
    },
    clearPrefs(id) {
      _setPrefBits(id, 0);
    },
    isIdCapped(id) {
      if (!id.startsWith("Tool:")) return false;
      return _isToolCapReached(id.slice(5));
    },
    // pure filter util (no side-effects)
    filterRows(rows, f) {
      let arr = rows.slice();
      const ft = f.type ?? "all";
      if (ft && ft !== "all") {
        arr = arr.filter((r) => r.type.toLowerCase() === ft);
      }
      const fr = f.rarity ?? "all";
      if (fr !== "all") {
        arr = arr.filter((r) => norm2(r.rarity) === fr);
      }
      return arr;
    },
    getRule(id) {
      if (!id) return null;
      _ensureRulesLoaded();
      const rule = _rules.get(id);
      if (!rule) return null;
      return {
        ...rule.sound ? { sound: rule.sound } : {},
        ...rule.playbackMode ? { playbackMode: rule.playbackMode } : {},
        ...rule.stopMode ? { stopMode: rule.stopMode } : {},
        ...rule.loopIntervalMs != null ? { loopIntervalMs: rule.loopIntervalMs } : {}
      };
    },
    getAllRules() {
      return _rulesSnapshot();
    },
    setRule(id, patch) {
      if (!id || !patch || typeof patch !== "object") return;
      _ensureRulesLoaded();
      const prev = _rules.get(id);
      const next = _mergeRule(prev, patch);
      if (_rulesEqual(prev, next)) return;
      if (next) _rules.set(id, next);
      else _rules.delete(id);
      _saveRules();
      _emitRules();
    },
    clearRule(id) {
      if (!id) return;
      _ensureRulesLoaded();
      const existed = _rules.delete(id);
      if (existed) {
        _saveRules();
        _emitRules();
      }
    },
    onRulesChange(cb) {
      _ensureRulesLoaded();
      _rulesSubs.add(cb);
      return () => {
        _rulesSubs.delete(cb);
      };
    },
    async onRulesChangeNow(cb) {
      await _ensureStarted();
      cb(_rulesSnapshot());
      return this.onRulesChange(cb);
    }
  };

  // src/utils/catalogIndex.ts
  function seedNameFromSpecies(species, cat = plantCatalog) {
    const e = cat?.[species];
    return e?.seed?.name ?? e?.plant?.name ?? e?.crop?.name ?? void 0;
  }
  function eggNameFromId(eggId, cat = eggCatalog) {
    return cat?.[eggId]?.name ?? void 0;
  }
  function toolNameFromId(toolId, cat = toolCatalog) {
    return cat?.[toolId]?.name ?? void 0;
  }
  function decorNameFromId(decorId, cat = decorCatalog) {
    return cat?.[decorId]?.name ?? void 0;
  }

  // src/ui/menus/notificationOverlay.ts
  var style = (el2, s) => Object.assign(el2.style, s);
  var setProps = (el2, props) => {
    for (const [k, v] of Object.entries(props)) el2.style.setProperty(k, v);
  };
  function iconOf(id, size = 24) {
    const wrap = document.createElement("div");
    Object.assign(wrap.style, {
      width: `${size}px`,
      height: `${size}px`,
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flex: `0 0 ${size}px`
    });
    const [rawType, rawId] = id.split(":");
    const type = rawType === "Seed" || rawType === "Egg" || rawType === "Tool" || rawType === "Decor" ? rawType : null;
    const fallback = type === "Seed" ? "\u{1F331}" : type === "Egg" ? "\u{1F95A}" : type === "Tool" ? "\u{1F9F0}" : type === "Decor" ? "\u{1F3E0}" : "\u{1F514}";
    if (type && rawId) {
      const sprite = createShopSprite(type, rawId, {
        size,
        fallback,
        alt: labelOf(id)
      });
      wrap.appendChild(sprite);
    } else {
      const span = document.createElement("span");
      span.textContent = fallback;
      span.style.fontSize = `${Math.max(10, size - 2)}px`;
      span.setAttribute("aria-hidden", "true");
      wrap.appendChild(span);
    }
    return wrap;
  }
  function labelOf(id) {
    const [type, raw] = id.split(":");
    switch (type) {
      case "Seed":
        return seedNameFromSpecies(raw) ?? raw;
      case "Egg":
        return eggNameFromId(raw) ?? raw;
      case "Tool":
        return toolNameFromId(raw) ?? raw;
      case "Decor":
        return decorNameFromId(raw) ?? raw;
      default:
        return raw;
    }
  }
  function purchasedCountForId(id, purchases) {
    if (!purchases) return 0;
    const [type, raw] = String(id).split(":");
    const sec = type === "Seed" ? purchases.seed : type === "Egg" ? purchases.egg : type === "Tool" ? purchases.tool : purchases.decor;
    if (!sec || !sec.purchases) return 0;
    const n = sec.purchases[raw];
    return typeof n === "number" && n > 0 ? n : 0;
  }
  var OverlayBarebone = class {
    constructor() {
      __publicField(this, "slot", document.createElement("div"));
      __publicField(this, "btn", document.createElement("button"));
      __publicField(this, "badge", document.createElement("span"));
      __publicField(this, "panel", document.createElement("div"));
      __publicField(this, "bellWrap", document.createElement("div"));
      __publicField(this, "lastShops", null);
      __publicField(this, "lastPurch", null);
      // Suivi des IDs visibles dans loverlay (pour loops & diff)
      __publicField(this, "prevOverlayIds", /* @__PURE__ */ new Set());
      __publicField(this, "currentOverlayIds", /* @__PURE__ */ new Set());
      __publicField(this, "rulesById", /* @__PURE__ */ new Map());
      __publicField(this, "shopUpdates", 0);
      __publicField(this, "purchasesUpdates", 0);
      __publicField(this, "bootArmed", false);
      __publicField(this, "justRestocked", false);
      __publicField(this, "mo", null);
      // Items  afficher dans loverlay (dj filtrs)
      __publicField(this, "rows", []);
      __publicField(this, "lastPanelSig", null);
      this.slot = this.createSlot();
      this.btn = this.createButton();
      this.ensureBellCSS();
      this.badge = this.createBadge();
      this.panel = this.createPanel();
      this.installScrollGuards(this.panel);
      let primedOnce = false;
      this.btn.onclick = async () => {
        if (!primedOnce) {
          primedOnce = true;
          try {
            await audio.prime();
          } catch {
          }
        }
        const on = this.panel.style.display !== "block";
        this.panel.style.display = on ? "block" : "none";
        if (on) this.renderPanel();
        this.updateBellWiggle();
      };
      this.slot.append(this.btn, this.badge, this.panel);
      this.attachLeftOfTargetCanvas();
      this.observeDomForRelocation();
      window.addEventListener("pointerdown", (e) => {
        if (this.panel.style.display !== "block") return;
        const t = e.target;
        if (!this.slot.contains(t)) this.panel.style.display = "none";
      });
      audio.setPurchaseChecker((itemId) => {
        if (!itemId) return false;
        if (this.currentOverlayIds.has(itemId)) return false;
        return purchasedCountForId(itemId, this.lastPurch) > 0;
      });
    }
    destroy() {
      try {
        this.mo?.disconnect();
      } catch {
      }
      try {
        this.slot.remove();
      } catch {
      }
      try {
        audio.stopAllLoops();
      } catch {
      }
    }
    ensureBellCSS() {
      if (document.getElementById("qws-bell-anim-css")) return;
      const style2 = document.createElement("style");
      style2.id = "qws-bell-anim-css";
      style2.textContent = `
@keyframes qwsBellShake {
  0% { transform: rotate(0deg); }
  10% { transform: rotate(-16deg); }
  20% { transform: rotate(12deg); }
  30% { transform: rotate(-10deg); }
  40% { transform: rotate(8deg); }
  50% { transform: rotate(-6deg); }
  60% { transform: rotate(4deg); }
  70% { transform: rotate(-2deg); }
  80% { transform: rotate(1deg); }
  100% { transform: rotate(0deg); }
}

/* Classe appliqu\xE9e sur le span cloche quand il y a des items dans l'overlay */
.qws-bell--wiggle {
  animation: qwsBellShake 1.2s ease-in-out infinite;
  transform-origin: 50% 0%;
  display: inline-block;
}

/* Respecte l'accessibilit\xE9 */
@media (prefers-reduced-motion: reduce) {
  .qws-bell--wiggle { animation: none !important; }
}
`;
      document.head.appendChild(style2);
    }
    /* ========= SETTERS (subs) ========= */
    setShops(s) {
      const prev = this.lastShops;
      this.lastShops = s;
      this.shopUpdates++;
      this.justRestocked = !!(prev && ((prev.seed?.secondsUntilRestock ?? 0) < (s.seed?.secondsUntilRestock ?? 0) || (prev.tool?.secondsUntilRestock ?? 0) < (s.tool?.secondsUntilRestock ?? 0) || (prev.egg?.secondsUntilRestock ?? 0) < (s.egg?.secondsUntilRestock ?? 0) || (prev.decor?.secondsUntilRestock ?? 0) < (s.decor?.secondsUntilRestock ?? 0)));
      this.recompute();
    }
    setPurchases(p) {
      this.lastPurch = p;
      this.purchasesUpdates++;
      this.recompute();
    }
    notifyStateUpdated() {
      void this.recompute();
    }
    setRules(rules) {
      this.rulesById.clear();
      for (const [id, rule] of Object.entries(rules)) {
        if (!id || !rule) continue;
        this.rulesById.set(id, { ...rule });
      }
      this.refreshActiveLoops();
    }
    /* ========= Core compute ========= */
    buildTriggerOverrides(rule) {
      if (!rule) return null;
      const overrides = {};
      if (rule.sound) overrides.sound = rule.sound;
      if (rule.playbackMode === "loop" || rule.playbackMode === "oneshot") {
        overrides.mode = rule.playbackMode;
      }
      if (rule.stopMode === "purchase") overrides.stop = { mode: "purchase" };
      else if (rule.stopMode === "manual") overrides.stop = { mode: "manual" };
      if (rule.loopIntervalMs != null && Number.isFinite(rule.loopIntervalMs)) {
        overrides.loopIntervalMs = Math.max(150, Math.floor(Number(rule.loopIntervalMs)));
      }
      return Object.keys(overrides).length ? overrides : null;
    }
    triggerMany(ids) {
      const entries = [];
      for (const id of ids) {
        const overrides = this.buildTriggerOverrides(this.rulesById.get(id)) ?? {};
        const mode = this.resolvePlaybackMode(id);
        const soundKey = overrides.sound ? `sound:${overrides.sound.trim().toLowerCase()}` : "sound:__default__";
        entries.push({ id, overrides, mode, soundKey });
      }
      if (!entries.length) return;
      const grouped = /* @__PURE__ */ new Map();
      for (const entry of entries) {
        const bucket = grouped.get(entry.soundKey) ?? { loops: [], oneshots: [] };
        if (entry.mode === "loop") bucket.loops.push(entry);
        else bucket.oneshots.push(entry);
        grouped.set(entry.soundKey, bucket);
      }
      for (const { loops, oneshots } of grouped.values()) {
        if (loops.length) {
          for (const entry of loops) {
            audio.trigger(entry.id, entry.overrides, "shops").catch(() => {
            });
          }
          continue;
        }
        if (oneshots.length) {
          const first = oneshots[0];
          audio.trigger(first.id, first.overrides, "shops").catch(() => {
          });
        }
      }
    }
    triggerWithRule(id) {
      this.triggerMany([id]);
    }
    resolvePlaybackMode(id) {
      const rule = this.rulesById.get(id);
      const baseMode = audio.getPlaybackMode("shops");
      if (!rule) return baseMode;
      if (rule.playbackMode === "loop") return "loop";
      if (rule.playbackMode === "oneshot") return "oneshot";
      if ((rule.stopMode || rule.loopIntervalMs != null) && baseMode === "loop") return "loop";
      return baseMode;
    }
    refreshActiveLoops() {
      if (!this.currentOverlayIds.size) return;
      const loopIds = [];
      for (const id of this.currentOverlayIds) {
        if (this.resolvePlaybackMode(id) === "loop") {
          audio.stopLoop(id);
          loopIds.push(id);
        }
      }
      if (loopIds.length) this.triggerMany(loopIds);
    }
    async recompute() {
      if (!this.lastShops || !this.lastPurch) return;
      const out = [];
      const consider = (id, initialStock) => {
        const pref = NotifierService.getPref?.(id) || {};
        if (!pref.popup) return;
        const bought = purchasedCountForId(id, this.lastPurch);
        const remaining = Math.max(initialStock - bought, 0);
        if (remaining > 0) out.push({ id, qty: remaining });
      };
      for (const it of this.lastShops.seed.inventory) consider(`Seed:${it.species}`, it.initialStock);
      for (const it of this.lastShops.tool.inventory) consider(`Tool:${it.toolId}`, it.initialStock);
      for (const it of this.lastShops.egg.inventory) consider(`Egg:${it.eggId}`, it.initialStock);
      for (const it of this.lastShops.decor.inventory) consider(`Decor:${it.decorId}`, it.initialStock);
      this.rows = out;
      this.renderBadge();
      if (this.panel.style.display === "block") this.renderPanel();
      this.updateBellWiggle();
      const overlayIds = new Set(out.map((r) => r.id));
      this.currentOverlayIds = overlayIds;
      const shopEmpty = (this.lastShops.seed?.inventory?.length ?? 0) + (this.lastShops.tool?.inventory?.length ?? 0) + (this.lastShops.egg?.inventory?.length ?? 0) + (this.lastShops.decor?.inventory?.length ?? 0) === 0;
      const ready2 = this.shopUpdates >= 3 && this.purchasesUpdates >= 2 && !shopEmpty;
      if (!this.bootArmed) {
        if (!ready2) {
          this.prevOverlayIds = overlayIds;
          return;
        }
        this.bootArmed = true;
        if (overlayIds.size > 0) {
          this.triggerMany(overlayIds);
        }
        this.prevOverlayIds = overlayIds;
        this.justRestocked = false;
        return;
      }
      if (overlayIds.size === 0) {
        audio.stopAllLoops();
        this.prevOverlayIds = overlayIds;
        this.justRestocked = false;
        return;
      }
      if (this.justRestocked) {
        this.triggerMany(overlayIds);
        for (const oldId of this.prevOverlayIds) {
          if (!overlayIds.has(oldId)) audio.stopLoop(oldId);
        }
        this.prevOverlayIds = overlayIds;
        this.justRestocked = false;
        return;
      }
      const newIds = [];
      for (const id of overlayIds) {
        if (!this.prevOverlayIds.has(id)) {
          newIds.push(id);
        }
      }
      if (newIds.length) this.triggerMany(newIds);
      for (const oldId of this.prevOverlayIds) {
        if (!overlayIds.has(oldId)) {
          audio.stopLoop(oldId);
        }
      }
      this.prevOverlayIds = overlayIds;
      this.justRestocked = false;
    }
    /* ========= Render ========= */
    renderBadge() {
      const n = this.rows.length;
      this.badge.textContent = n ? String(n) : "";
      style(this.badge, { display: n ? "inline-flex" : "none" });
    }
    resolveShopItem(id) {
      if (!this.lastShops) return null;
      const [type, raw] = String(id).split(":");
      if (!type || !raw) return null;
      if (type === "Seed") {
        const item = this.lastShops.seed?.inventory?.find((it) => String(it.species) === raw);
        return item ? { kind: "seeds", item } : null;
      }
      if (type === "Tool") {
        const item = this.lastShops.tool?.inventory?.find((it) => String(it.toolId) === raw);
        return item ? { kind: "tools", item } : null;
      }
      if (type === "Egg") {
        const item = this.lastShops.egg?.inventory?.find((it) => String(it.eggId) === raw);
        return item ? { kind: "eggs", item } : null;
      }
      if (type === "Decor") {
        const item = this.lastShops.decor?.inventory?.find((it) => String(it.decorId) === raw);
        return item ? { kind: "decor", item } : null;
      }
      return null;
    }
    async handleBuyClick(id, btn) {
      const resolved = this.resolveShopItem(id);
      if (!resolved) {
        btn.disabled = true;
        return;
      }
      btn.disabled = true;
      const prevLabel = btn.textContent;
      btn.textContent = "Buying...";
      try {
        await Promise.resolve(ShopsService.buyOne(resolved.kind, resolved.item));
      } catch {
      } finally {
        btn.textContent = prevLabel || "Buy";
        btn.disabled = false;
      }
    }
    async handleBuyAllClick(id, btn) {
      const resolved = this.resolveShopItem(id);
      if (!resolved) {
        btn.disabled = true;
        return;
      }
      const available = this.rows.find((r) => r.id === id)?.qty ?? 0;
      if (available <= 0) {
        btn.disabled = true;
        return;
      }
      btn.disabled = true;
      const prevLabel = btn.textContent;
      btn.textContent = "Buying...";
      try {
        for (let i = 0; i < available; i++) {
          await Promise.resolve(ShopsService.buyOne(resolved.kind, resolved.item));
        }
      } catch {
      } finally {
        btn.textContent = prevLabel || "Buy all";
        btn.disabled = false;
      }
    }
    renderPanel() {
      const sig = JSON.stringify(this.rows.map((r) => [r.id, r.qty]));
      if (sig === this.lastPanelSig) return;
      this.lastPanelSig = sig;
      this.panel.replaceChildren();
      const head = document.createElement("div");
      head.textContent = "Tracked items available";
      style(head, {
        fontWeight: "700",
        opacity: "0.9",
        padding: "4px 2px",
        borderBottom: "1px solid var(--qws-border-2, #ffffff14)",
        marginBottom: "4px"
      });
      this.panel.appendChild(head);
      if (!this.rows.length) {
        const empty = document.createElement("div");
        empty.textContent = "No tracked items are available.";
        style(empty, { opacity: "0.75", padding: "8px 2px" });
        this.panel.appendChild(empty);
        return;
      }
      for (const r of this.rows) {
        const row = document.createElement("div");
        Object.assign(row.style, {
          display: "grid",
          gridTemplateColumns: "24px 1fr max-content max-content max-content",
          alignItems: "center",
          gap: "8px",
          padding: "6px 4px",
          borderBottom: "1px solid var(--qws-border-2, #ffffff14)"
        });
        const icon = iconOf(r.id, 24);
        const title = document.createElement("div");
        title.textContent = labelOf(r.id);
        Object.assign(title.style, {
          fontWeight: "600",
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap",
          color: "var(--qws-text, #e7eef7)"
        });
        const qty = document.createElement("div");
        qty.textContent = `\xD7${r.qty}`;
        Object.assign(qty.style, {
          fontVariantNumeric: "tabular-nums",
          opacity: "0.9",
          color: "var(--qws-text-dim, #b9c3cf)",
          textAlign: "right"
        });
        const buyBtn = document.createElement("button");
        buyBtn.type = "button";
        buyBtn.textContent = "Buy";
        Object.assign(buyBtn.style, {
          padding: "4px 10px",
          borderRadius: "10px",
          border: "1px solid var(--qws-border, #ffffff33)",
          background: "var(--qws-accent, #7aa2ff)",
          color: "#0b1017",
          fontWeight: "700",
          cursor: "pointer",
          fontSize: "12px",
          boxShadow: "var(--qws-shadow, 0 6px 18px rgba(0,0,0,.35))",
          transition: "filter 120ms ease, transform 120ms ease"
        });
        buyBtn.onmouseenter = () => {
          buyBtn.style.filter = "brightness(1.05)";
        };
        buyBtn.onmouseleave = () => {
          buyBtn.style.filter = "";
          buyBtn.style.transform = "";
        };
        buyBtn.onmousedown = () => {
          buyBtn.style.transform = "translateY(1px)";
        };
        buyBtn.onmouseup = () => {
          buyBtn.style.transform = "";
        };
        buyBtn.onclick = (e) => {
          e.stopPropagation();
          void this.handleBuyClick(r.id, buyBtn);
        };
        if (!this.resolveShopItem(r.id)) {
          buyBtn.disabled = true;
          buyBtn.style.opacity = "0.6";
          buyBtn.style.cursor = "not-allowed";
          buyBtn.title = "Unavailable";
        }
        const buyAllBtn = document.createElement("button");
        buyAllBtn.type = "button";
        buyAllBtn.textContent = "Buy all";
        Object.assign(buyAllBtn.style, {
          padding: "4px 10px",
          borderRadius: "10px",
          border: "1px solid var(--qws-border, #ffffff33)",
          background: "var(--qws-panel, #111823cc)",
          color: "var(--qws-text, #e7eef7)",
          fontWeight: "700",
          cursor: "pointer",
          fontSize: "12px",
          boxShadow: "var(--qws-shadow, 0 6px 18px rgba(0,0,0,.35))",
          transition: "filter 120ms ease, transform 120ms ease"
        });
        buyAllBtn.onmouseenter = () => {
          buyAllBtn.style.filter = "brightness(1.08)";
        };
        buyAllBtn.onmouseleave = () => {
          buyAllBtn.style.filter = "";
          buyAllBtn.style.transform = "";
        };
        buyAllBtn.onmousedown = () => {
          buyAllBtn.style.transform = "translateY(1px)";
        };
        buyAllBtn.onmouseup = () => {
          buyAllBtn.style.transform = "";
        };
        buyAllBtn.onclick = (e) => {
          e.stopPropagation();
          void this.handleBuyAllClick(r.id, buyAllBtn);
        };
        if (!this.resolveShopItem(r.id)) {
          buyAllBtn.disabled = true;
          buyAllBtn.style.opacity = "0.6";
          buyAllBtn.style.cursor = "not-allowed";
          buyAllBtn.title = "Unavailable";
        }
        row.append(icon, title, qty, buyBtn, buyAllBtn);
        this.panel.appendChild(row);
      }
    }
    /* ========= DOM bits ========= */
    createSlot() {
      const d = document.createElement("div");
      style(d, {
        position: "relative",
        display: "inline-flex",
        alignItems: "center",
        marginRight: "0",
        pointerEvents: "auto",
        fontFamily: "var(--chakra-fonts-body, GreyCliff CF), system-ui, sans-serif",
        color: "var(--chakra-colors-chakra-body-text, #e7eef7)",
        userSelect: "none"
      });
      setProps(d, {
        "-webkit-font-smoothing": "antialiased",
        "-webkit-text-size-adjust": "100%",
        "text-rendering": "optimizeLegibility"
      });
      return d;
    }
    createButton() {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.setAttribute("aria-label", "Notifications");
      const bell = document.createElement("span");
      bell.className = "qws-bell";
      bell.textContent = "\u{1F514}";
      bell.setAttribute("aria-hidden", "true");
      this.bellWrap = document.createElement("div");
      this.bellWrap.className = "qws-bell-wrap";
      this.bellWrap.appendChild(bell);
      this.applyFallbackButtonStyles();
      btn.appendChild(this.bellWrap);
      btn.addEventListener("mouseenter", () => {
        if (btn.hasAttribute("style")) btn.style.borderColor = "var(--qws-accent, #7aa2ff)";
      });
      btn.addEventListener("mouseleave", () => {
        if (btn.hasAttribute("style")) btn.style.borderColor = "var(--chakra-colors-chakra-border-color, #ffffff33)";
      });
      return btn;
    }
    updateBellWiggle() {
      const bell = this.btn.querySelector(".qws-bell");
      if (!bell) return;
      const shouldWiggle = this.rows.length > 0 && this.panel.style.display !== "block";
      bell.classList.toggle("qws-bell--wiggle", shouldWiggle);
    }
    createBadge() {
      const badge = document.createElement("span");
      style(badge, {
        position: "absolute",
        top: "-6px",
        right: "-6px",
        minWidth: "18px",
        height: "18px",
        padding: "0 6px",
        borderRadius: "999px",
        background: "var(--chakra-colors-Red-Magic, #D02128)",
        color: "var(--chakra-colors-Neutral-TrueWhite, #fff)",
        fontSize: "12px",
        fontWeight: "700",
        display: "none",
        alignItems: "center",
        justifyContent: "center",
        border: "1px solid rgba(0,0,0,.35)",
        lineHeight: "18px",
        pointerEvents: "none"
      });
      return badge;
    }
    createPanel() {
      const panel = document.createElement("div");
      panel.setAttribute("role", "dialog");
      panel.setAttribute("aria-label", "Tracked items available");
      style(panel, {
        position: "absolute",
        top: "calc(100% + var(--chakra-space-2, 0.5rem))",
        right: "0",
        width: "min(280px, 70vw)",
        //  largeur rduite (tait 360px)
        maxHeight: "50vh",
        overflow: "auto",
        overscrollBehavior: "contain",
        //  empche le scroll de remonter au jeu
        touchAction: "pan-y",
        //  gestes tactiles = scroll vertical, pas zoom/pan global
        borderRadius: "var(--chakra-radii-card, 12px)",
        border: "1px solid var(--qws-border, #ffffff22)",
        background: "var(--qws-panel, #111823cc)",
        backdropFilter: "blur(var(--qws-blur, 8px))",
        color: "var(--qws-text, #e7eef7)",
        boxShadow: "var(--qws-shadow, 0 10px 36px rgba(0,0,0,.45))",
        padding: "8px",
        display: "none",
        zIndex: "var(--chakra-zIndices-DialogModal, 7010)"
      });
      setProps(panel, { "-webkit-backdrop-filter": "blur(var(--qws-blur, 8px))" });
      return panel;
    }
    installScrollGuards(el2) {
      const stop2 = (e) => {
        e.stopPropagation();
      };
      el2.addEventListener("wheel", stop2, { passive: true, capture: true });
      el2.addEventListener("mousewheel", stop2, { passive: true, capture: true });
      el2.addEventListener("DOMMouseScroll", stop2, { passive: true, capture: true });
      el2.addEventListener("touchmove", stop2, { passive: true, capture: true });
    }
    /* ========= Anchoring ========= */
    findTargetCanvas() {
      try {
        const c1 = document.querySelector("span[tabindex] canvas");
        if (c1) return c1;
        const all = Array.from(document.querySelectorAll("canvas"));
        const candidates = all.map((c) => ({ c, r: c.getBoundingClientRect() })).filter(({ r }) => r.width <= 512 && r.height <= 512 && r.top < 300).sort((a, b) => a.r.left - b.r.left || a.r.top - b.r.top);
        return candidates[0]?.c ?? null;
      } catch {
        return null;
      }
    }
    closestFlexWithEnoughChildren(el2, minChildren = 3) {
      let cur = el2;
      while (cur && cur.parentElement) {
        const parent = cur.parentElement;
        const cs = getComputedStyle(parent);
        if (cs.display.includes("flex") && parent.children.length >= minChildren) return parent;
        cur = parent;
      }
      return null;
    }
    findToolbarContainer() {
      try {
        const mcFlex = document.querySelector(".McFlex.css-13izacw");
        if (mcFlex) return mcFlex;
        const chatBtn = document.querySelector('button[aria-label="Chat"]');
        const flexFromChat = chatBtn ? this.closestFlexWithEnoughChildren(chatBtn) : null;
        if (flexFromChat) return flexFromChat;
        const canvas = this.findTargetCanvas();
        if (canvas) {
          const flexFromCanvas = this.closestFlexWithEnoughChildren(canvas);
          if (flexFromCanvas) return flexFromCanvas;
          const block = this.findAnchorBlockFromCanvas(canvas);
          if (block && block.parentElement) return block.parentElement;
        }
        return null;
      } catch {
        return null;
      }
    }
    applyFallbackButtonStyles() {
      this.btn.className = "";
      style(this.btn, {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "6px",
        height: "36px",
        padding: "0 12px",
        borderRadius: "var(--chakra-radii-button, 50px)",
        border: "1px solid var(--chakra-colors-chakra-border-color, #ffffff33)",
        background: "var(--qws-panel, #111823cc)",
        backdropFilter: "blur(var(--qws-blur, 8px))",
        color: "var(--qws-text, #e7eef7)",
        boxShadow: "var(--qws-shadow, 0 10px 36px rgba(0,0,0,.45))",
        cursor: "pointer",
        transition: "border-color var(--chakra-transition-duration-fast,150ms) ease",
        outline: "none",
        position: "relative"
      });
      setProps(this.btn, {
        "-webkit-backdrop-filter": "blur(var(--qws-blur, 8px))",
        "-webkit-tap-highlight-color": "transparent"
      });
      this.bellWrap.className = "qws-bell-wrap";
      style(this.bellWrap, {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "6px",
        height: "100%"
      });
    }
    applyToolbarLook(toolbar) {
      const refBtn = toolbar?.querySelector("button.chakra-button");
      if (!refBtn) return;
      this.btn.className = refBtn.className;
      this.btn.removeAttribute("style");
      this.btn.removeAttribute("data-focus-visible-added");
      const refInner = refBtn.querySelector("div");
      if (refInner) {
        this.bellWrap.className = refInner.className;
        this.bellWrap.removeAttribute("style");
      }
      style(this.bellWrap, {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        height: "100%"
      });
      style(this.btn, { position: "relative" });
    }
    findAnchorBlockFromCanvas(c) {
      try {
        const tabbable = c.closest("span[tabindex]");
        if (tabbable && tabbable.parentElement) return tabbable.parentElement;
        let cur = c;
        while (cur && cur.parentElement) {
          const p = cur.parentElement;
          const cs = getComputedStyle(p);
          if (cs.display.includes("flex") && p.children.length <= 3) return p;
          cur = p;
        }
        return null;
      } catch {
        return null;
      }
    }
    insertLeftOf(block, el2) {
      const parent = block.parentElement;
      if (!parent) return;
      if (!block.isConnected || !parent.isConnected) return;
      const cs = getComputedStyle(parent);
      const isFlex = cs.display.includes("flex");
      const dir = cs.flexDirection || "row";
      try {
        if (isFlex && dir.startsWith("row") && dir.endsWith("reverse")) {
          if (el2 !== block.nextSibling) parent.insertBefore(el2, block.nextSibling);
        } else {
          parent.insertBefore(el2, block);
        }
      } catch {
      }
    }
    attachLeftOfTargetCanvas() {
      try {
        const toolbar = this.findToolbarContainer();
        if (toolbar && toolbar.isConnected) {
          this.applyToolbarLook(toolbar);
          if (this.slot.parentElement !== toolbar || this.slot.nextElementSibling) {
            toolbar.appendChild(this.slot);
          }
          return;
        }
        const canvas = this.findTargetCanvas();
        const block = canvas ? this.findAnchorBlockFromCanvas(canvas) : null;
        if (!block || !block.parentElement || !block.isConnected) {
          let fixed = document.getElementById("qws-notifier-fallback");
          if (!fixed) {
            fixed = document.createElement("div");
            fixed.id = "qws-notifier-fallback";
            style(fixed, {
              position: "fixed",
              zIndex: "var(--chakra-zIndices-PresentableOverlay, 5100)",
              top: "calc(10px + var(--sait, 0px))",
              right: "calc(10px + var(--sair, 0px))"
            });
            document.body.appendChild(fixed);
          }
          this.applyFallbackButtonStyles();
          if (!fixed.contains(this.slot)) fixed.appendChild(this.slot);
          return;
        }
        this.applyFallbackButtonStyles();
        if (this.slot.parentElement !== block.parentElement || this.slot.nextElementSibling !== block && block.previousElementSibling !== this.slot) {
          this.insertLeftOf(block, this.slot);
        }
      } catch {
      }
    }
    observeDomForRelocation() {
      try {
        this.mo?.disconnect();
        this.mo = new MutationObserver(() => this.attachLeftOfTargetCanvas());
        this.mo.observe(document.body, { childList: true, subtree: true });
        this.attachLeftOfTargetCanvas();
      } catch {
      }
    }
  };
  async function renderOverlay() {
    const overlay = new OverlayBarebone();
    const unsubPurch = await NotifierService.onPurchasesChangeNow((p) => overlay.setPurchases(p));
    const unsubShops = await NotifierService.onShopsChangeNow((s) => overlay.setShops(s));
    const unsubState = await NotifierService.onChangeNow(() => overlay.notifyStateUpdated());
    const unsubRules = await NotifierService.onRulesChangeNow((rules) => overlay.setRules(rules));
    window.__qws_cleanup_notifier = () => {
      try {
        unsubShops();
      } catch {
      }
      try {
        unsubPurch();
      } catch {
      }
      try {
        unsubState();
      } catch {
      }
      try {
        unsubRules();
      } catch {
      }
      try {
        overlay.destroy();
      } catch {
      }
    };
  }

  // src/utils/shopUtility.ts
  var SHOP_TYPES = ["plant", "egg", "tool", "decor"];
  var BTN_CLASS = "romann-buyall-btn";
  var STYLE_ID = "tm-buyall-css";
  var ITEM_SELECTOR = "div.McFlex.css-1kkwxjt";
  var LIST_SELECTOR = "div.McFlex.css-1lfov12";
  var ROW_SELECTOR = "div.McFlex.css-b9riu6";
  var INDEX_ATTR = "data-tm-shop-index";
  var RESCAN_MS = 20;
  var SHOP_ATOMS = {
    plant: Atoms.shop.seedShop,
    egg: Atoms.shop.eggShop,
    tool: Atoms.shop.toolShop,
    decor: Atoms.shop.decorShop
  };
  var MODAL_TO_SHOP_TYPE = {
    seedShop: "plant",
    eggShop: "egg",
    toolShop: "tool",
    decorShop: "decor"
  };
  var shopInventoryCache = {};
  var shopInventoryLengths = {};
  var shopInventoryInitStarted = false;
  var shopInventoryUnsubs = {};
  async function detectShopFromActiveModal() {
    try {
      const modalId = await Atoms.ui.activeModal.get();
      console.log("[TM][BuyAll] activeModal =", modalId);
      if (typeof modalId !== "string" || !modalId) return null;
      const shop = MODAL_TO_SHOP_TYPE[modalId] ?? null;
      console.log("[TM][BuyAll] mapped modal -> shop =", { modalId, shop });
      return shop;
    } catch (error) {
      console.warn("[TM][BuyAll] failed to read active modal", error);
      return null;
    }
  }
  function extractInventoryId(shop, entry) {
    if (!entry) return null;
    if (shop === "plant") return entry?.species ? String(entry.species) : null;
    if (shop === "egg") return entry?.eggId ? String(entry.eggId) : null;
    if (shop === "tool") return entry?.toolId ? String(entry.toolId) : null;
    if (shop === "decor") return entry?.decorId ? String(entry.decorId) : null;
    return null;
  }
  function extractInventoryName(shop, entry) {
    if (!entry) return null;
    if (shop === "plant") return entry?.species ? String(entry.species) : null;
    if (shop === "egg") return entry?.eggId ? String(entry.eggId) : null;
    if (shop === "tool") return entry?.toolId ? String(entry.toolId) : null;
    if (shop === "decor") return entry?.decorId ? String(entry.decorId) : null;
    return null;
  }
  function normalizeInventory(shop, data) {
    const rawInventory = Array.isArray(data?.inventory) ? data.inventory : [];
    const normalized = [];
    for (const entry of rawInventory) {
      const id = extractInventoryId(shop, entry);
      if (!id) continue;
      normalized.push({ id, name: extractInventoryName(shop, entry), raw: entry });
    }
    return normalized;
  }
  function updateShopInventoryCache(shop, data) {
    const normalized = normalizeInventory(shop, data);
    shopInventoryCache[shop] = normalized;
    shopInventoryLengths[shop] = normalized.length;
  }
  async function initShopInventoryWatchers() {
    for (const shop of SHOP_TYPES) {
      const atom = SHOP_ATOMS[shop];
      console.log(await atom.get());
      if (!atom) continue;
      if (!shopInventoryInitStarted) return;
      try {
        updateShopInventoryCache(shop, await atom.get());
      } catch (error) {
        console.warn(`[TM] buyAll failed to fetch ${shop} inventory`, error);
      }
      if (!shopInventoryInitStarted) return;
      try {
        const unsub = await atom.onChange((next) => {
          updateShopInventoryCache(shop, next);
        });
        if (!shopInventoryInitStarted) {
          try {
            unsub();
          } catch (error) {
            console.warn(`[TM] buyAll failed to cancel stale ${shop} inventory watcher`, error);
          }
          return;
        }
        shopInventoryUnsubs[shop] = () => {
          try {
            unsub();
          } catch (err) {
            console.warn(`[TM] buyAll failed to unsubscribe ${shop} inventory`, err);
          }
        };
      } catch (error) {
        console.warn(`[TM] buyAll failed to subscribe to ${shop} inventory`, error);
      }
    }
  }
  function ensureShopInventories() {
    if (shopInventoryInitStarted) return;
    shopInventoryInitStarted = true;
    void initShopInventoryWatchers().catch((error) => {
      console.warn("[TM] buyAll inventory init error", error);
    });
  }
  function getInventoryEntry(shop, index) {
    const list = shopInventoryCache[shop];
    if (!list || index < 0 || index >= list.length) return null;
    return list[index] ?? null;
  }
  var PURCHASE_FNS = {
    plant: (id) => PlayerService.purchaseSeed(id),
    egg: (id) => PlayerService.purchaseEgg(id),
    tool: (id) => PlayerService.purchaseTool(id),
    decor: (id) => PlayerService.purchaseDecor(id)
  };
  function incrementShopPurchaseStat(shop) {
    switch (shop) {
      case "plant":
        StatsService.incrementShopStat("seedsBought");
        break;
      case "decor":
        StatsService.incrementShopStat("decorBought");
        break;
      case "egg":
        StatsService.incrementShopStat("eggsBought");
        break;
      case "tool":
        StatsService.incrementShopStat("toolsBought");
        break;
      default:
        break;
    }
  }
  async function purchaseRemainingItems(shop, itemId, remaining) {
    if (!shop || !itemId) return;
    const purchase = PURCHASE_FNS[shop];
    if (!purchase) return;
    const totalToBuy = typeof remaining === "number" ? Math.max(0, Math.floor(remaining)) : 0;
    if (totalToBuy <= 0) return;
    for (let bought = 0; bought < totalToBuy; bought += 1) {
      try {
        await purchase(itemId);
        incrementShopPurchaseStat(shop);
      } catch (error) {
        console.warn("[TM] buyAll purchase failed", { shop, itemId, attempt: bought + 1, error });
        break;
      }
    }
  }
  function parseCompactNumber(s) {
    if (!s) return void 0;
    const txt = s.replace(/\u00A0|\u202F/g, " ").trim();
    const re = /(\d{1,3}(?:[ \u00A0\u202F.,]\d{3})+|\d+(?:[.,]\d+)?)(\s*[kKmMbBtT])?/g;
    let m;
    let lastNum = null;
    let lastSuf = null;
    while (m = re.exec(txt)) {
      lastNum = m[1];
      lastSuf = (m[2] || "").trim().toUpperCase() || null;
    }
    if (!lastNum) return void 0;
    if (lastSuf) {
      const base = Number(lastNum.replace(/[ \u00A0\u202F]/g, "").replace(",", "."));
      if (!Number.isFinite(base)) return void 0;
      const mult = lastSuf === "K" ? 1e3 : lastSuf === "M" ? 1e6 : lastSuf === "B" ? 1e9 : lastSuf === "T" ? 1e12 : 1;
      return Math.round(base * mult);
    }
    const hasThousandsSep = /[ \u00A0\u202F.,]\d{3}/.test(lastNum);
    if (hasThousandsSep) {
      const val = Number(lastNum.replace(/[ \u00A0\u202F.,]/g, ""));
      return Number.isFinite(val) ? val : void 0;
    } else {
      const val = Number(lastNum.replace(",", "."));
      return Number.isFinite(val) ? Math.round(val) : void 0;
    }
  }
  var lastShops = null;
  var lastPurchases = null;
  var shopsSubStarted = false;
  var purchasesSubStarted = false;
  function purchasedCountForId2(id, purchases) {
    if (!purchases) return 0;
    const [type, raw] = String(id).split(":");
    const section = type === "Seed" ? purchases.seed : type === "Egg" ? purchases.egg : type === "Tool" ? purchases.tool : purchases.decor;
    if (!section || !section.purchases) return 0;
    const n = section.purchases[raw];
    return typeof n === "number" && n > 0 ? n : 0;
  }
  function toNotifierItemId(shop, itemId) {
    if (!shop || !itemId) return null;
    const raw = String(itemId);
    switch (shop) {
      case "plant":
        return `Seed:${raw}`;
      case "egg":
        return `Egg:${raw}`;
      case "tool":
        return `Tool:${raw}`;
      case "decor":
        return `Decor:${raw}`;
      default:
        return null;
    }
  }
  function ensureNotifierSnapshots() {
    if (!shopsSubStarted) {
      shopsSubStarted = true;
      NotifierService.onShopsChangeNow((snap) => {
        lastShops = snap;
      }).catch((err) => {
        shopsSubStarted = false;
        console.warn("[TM] buyAll notifier shops subscription failed", err);
      });
    }
    if (!purchasesSubStarted) {
      purchasesSubStarted = true;
      NotifierService.onPurchasesChangeNow((snap) => {
        lastPurchases = snap;
      }).catch((err) => {
        purchasesSubStarted = false;
        console.warn("[TM] buyAll notifier purchases subscription failed", err);
      });
    }
  }
  function extractInitialStock(shop, rawId) {
    if (!shop || !rawId || !lastShops) {
      return { initialStock: null };
    }
    const byShop = shop === "plant" ? lastShops.seed?.inventory ?? [] : shop === "egg" ? lastShops.egg?.inventory ?? [] : shop === "tool" ? lastShops.tool?.inventory ?? [] : lastShops.decor?.inventory ?? [];
    const match = byShop.find((entry) => {
      if (!entry) return false;
      if (shop === "plant") return String(entry.species) === rawId;
      if (shop === "egg") return String(entry.eggId) === rawId;
      if (shop === "tool") return String(entry.toolId) === rawId;
      return String(entry.decorId) === rawId;
    });
    if (!match) return { initialStock: null };
    const initial = Number(match.initialStock);
    const normalized = Number.isFinite(initial) ? initial : null;
    return { initialStock: normalized };
  }
  function getRemainingDetails(shop, itemId) {
    const notifierItemId = toNotifierItemId(shop, itemId);
    if (!notifierItemId) {
      return { notifierItemId: null, initialStock: null, purchased: null, remaining: null };
    }
    const rawId = notifierItemId.split(":")[1] ?? null;
    const { initialStock } = extractInitialStock(shop, rawId);
    if (initialStock == null) {
      return { notifierItemId, initialStock, purchased: null, remaining: null };
    }
    const purchased = purchasedCountForId2(notifierItemId, lastPurchases);
    const remaining = Math.max(0, initialStock - purchased);
    return { notifierItemId, initialStock, purchased, remaining };
  }
  function isItemDisabled(itemEl) {
    if (!itemEl) return false;
    return !!itemEl.querySelector(".chakra-text.css-1ox18rb");
  }
  function getListItems(listRoot) {
    const direct = listRoot.querySelectorAll(`:scope > ${ITEM_SELECTOR}`);
    if (direct.length) return Array.from(direct);
    return Array.from(listRoot.querySelectorAll(ITEM_SELECTOR));
  }
  function parsePriceFromButton(btn) {
    if (!btn) return void 0;
    const label2 = btn.querySelector(".css-1uduba2");
    const raw = (label2?.innerText ?? btn.textContent ?? "").trim();
    return parseCompactNumber(raw);
  }
  function findRowForItem(itemEl) {
    const bySelector = itemEl.querySelector(ROW_SELECTOR);
    if (bySelector) return bySelector;
    const any = Array.from(itemEl.querySelectorAll("div")).find((d) => d.querySelectorAll("button.chakra-button").length >= 2);
    return any ?? null;
  }
  function ensureGlobalStyles() {
    if (document.getElementById(STYLE_ID)) return;
    const css = `
    .${BTN_CLASS}{
      background: var(--chakra-colors-Blue-Magic, #0067B4) !important;
      border-color: var(--chakra-colors-Blue-Dark, #264093) !important;
      color: #fff !important;
      border-width: 2px;
      border-radius: 5px;
      text-transform: uppercase;
      height: 40px;
      padding-inline: 24px;
      padding-top: 12px;
      padding-bottom: 12px;
      width: 100%;
    }
    .${BTN_CLASS}:hover{
      background: var(--chakra-colors-Blue-Light, #48ADF4) !important;
      border-color: var(--chakra-colors-Blue-Magic, #0067B4) !important;
    }
    .${BTN_CLASS}:focus-visible{
      outline: transparent solid 2px;
      outline-offset: 2px;
      box-shadow: var(--chakra-ring-offset-shadow, 0 0 #0000),
                  var(--chakra-ring-shadow, 0 0 #0000),
                  0 0 0 3px var(--chakra-ring-color, rgba(66,153,225,0.6));
    }
    /* \xC9tat disabled : couleurs/gris EXACTES demand\xE9es + blocage du hover */
    .${BTN_CLASS}[disabled],
    .${BTN_CLASS}[aria-disabled="true"]{
      background: var(--chakra-colors-Neutral-Grey) !important;
      border-color: var(--chakra-colors-Neutral-EarlGrey) !important;
      color: var(--chakra-colors-Neutral-EarlGrey) !important;
      opacity: 0.7 !important;
      cursor: not-allowed !important;
      box-shadow: none !important;
      pointer-events: none; /* pour l\u2019aria-disabled \xE9ventuel */
    }
    .${BTN_CLASS}[disabled]:hover,
    .${BTN_CLASS}[disabled]:focus,
    .${BTN_CLASS}[aria-disabled="true"]:hover,
    .${BTN_CLASS}[aria-disabled="true"]:focus{
      background: var(--chakra-colors-Neutral-Grey) !important;
      border-color: var(--chakra-colors-Neutral-EarlGrey) !important;
      color: var(--chakra-colors-Neutral-EarlGrey) !important;
      box-shadow: none !important;
    }
  `.trim();
    const style2 = document.createElement("style");
    style2.id = STYLE_ID;
    style2.textContent = css;
    document.head.appendChild(style2);
  }
  function createButton2(templateBtn) {
    const btn = document.createElement("button");
    btn.type = "button";
    if (templateBtn?.className) {
      const classes = `${templateBtn.className} ${BTN_CLASS}`.replace(new RegExp(`\\b${BTN_CLASS}\\b`, "g"), "").trim();
      btn.className = `${classes} ${BTN_CLASS}`.trim();
    } else {
      btn.className = `chakra-button ${BTN_CLASS}`;
    }
    const flex = document.createElement("div");
    flex.className = "McFlex css-1fxg3mj";
    const label2 = document.createElement("span");
    label2.className = "css-1uduba2";
    label2.textContent = "Buy all";
    flex.appendChild(label2);
    btn.appendChild(flex);
    btn.addEventListener("click", async (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      if (btn.disabled) return;
      const itemEl = btn.closest(ITEM_SELECTOR);
      const listRoot = itemEl?.closest(LIST_SELECTOR) || document.body;
      const items = getListItems(listRoot);
      const total = items.length;
      const attrIndex = itemEl?.getAttribute(INDEX_ATTR);
      let idx0 = attrIndex != null && attrIndex !== "" ? Number.parseInt(attrIndex, 10) : -1;
      if (!Number.isFinite(idx0) || idx0 < 0) {
        idx0 = itemEl ? items.indexOf(itemEl) : -1;
      }
      const idx1 = idx0 >= 0 ? idx0 + 1 : -1;
      const shop = await detectShopFromActiveModal();
      let itemId = null;
      let itemName = null;
      let reason = "none";
      let coinParsed;
      let creditParsed;
      if (shop && itemEl) {
        const row = findRowForItem(itemEl);
        if (row) {
          const me = btn;
          const coinBtn = me.previousElementSibling;
          const creditBtn = me.nextElementSibling;
          coinParsed = parsePriceFromButton(coinBtn);
          creditParsed = parsePriceFromButton(creditBtn);
          const inventoryEntry = idx0 >= 0 ? getInventoryEntry(shop, idx0) : null;
          if (inventoryEntry) {
            itemId = inventoryEntry.id;
            itemName = inventoryEntry.name ?? inventoryEntry.id;
            reason = "inventory";
          } else if (idx0 >= 0 && typeof coinParsed === "number" && typeof creditParsed === "number") {
            reason = "index";
          }
        }
      }
      const remainingDetails = getRemainingDetails(shop ?? null, itemId);
      void purchaseRemainingItems(shop, itemId, remainingDetails.remaining);
      window.dispatchEvent(new CustomEvent("tm:buyAll", {
        detail: {
          index1: idx1,
          index0: idx0,
          total,
          shopType: shop,
          itemId,
          itemName,
          reason,
          coin: coinParsed,
          credit: creditParsed,
          element: itemEl,
          remaining: remainingDetails.remaining,
          notifierItemId: remainingDetails.notifierItemId
        }
      }));
    });
    return btn;
  }
  function insertIntoItem(itemEl) {
    const listRoot = itemEl.closest(LIST_SELECTOR);
    if (listRoot && !itemEl.hasAttribute(INDEX_ATTR)) {
      const items = getListItems(listRoot);
      const idx = items.indexOf(itemEl);
      if (idx >= 0) {
        itemEl.setAttribute(INDEX_ATTR, String(idx));
      }
    }
    const row = itemEl.querySelector(ROW_SELECTOR) || Array.from(itemEl.querySelectorAll("div")).find((d) => d.querySelectorAll("button.chakra-button").length >= 2);
    if (!row) return;
    const btns = row.querySelectorAll("button.chakra-button");
    if (btns.length < 2) return;
    let middle = row.querySelector(`button.${BTN_CLASS}`);
    if (!middle) {
      middle = createButton2(btns[0]);
      row.insertBefore(middle, btns[1]);
    }
    const disabled = isItemDisabled(itemEl);
    middle.disabled = disabled;
    middle.setAttribute("aria-disabled", disabled ? "true" : "false");
  }
  function scan(root = document) {
    root.querySelectorAll(ITEM_SELECTOR).forEach(insertIntoItem);
  }
  var observer = null;
  var intervalId = null;
  function setupBuyAll() {
    ensureGlobalStyles();
    ensureNotifierSnapshots();
    ensureShopInventories();
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => scan());
    } else {
      scan();
    }
    observer = new MutationObserver((mutations) => {
      for (const m of mutations) {
        for (const n of m.addedNodes) {
          if (!(n instanceof Element)) continue;
          if (n.matches(ITEM_SELECTOR)) insertIntoItem(n);
          n.querySelectorAll?.(ITEM_SELECTOR).forEach(insertIntoItem);
        }
      }
    });
    const startObserver = () => observer.observe(document.body, { childList: true, subtree: true });
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", startObserver);
    else startObserver();
    startRescan();
  }
  function startRescan() {
    if (intervalId != null) return;
    intervalId = window.setInterval(() => scan(), RESCAN_MS);
  }
  function stopRescan() {
    if (intervalId != null) {
      window.clearInterval(intervalId);
      intervalId = null;
    }
  }
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) stopRescan();
    else if (observer) startRescan();
  });
  var DEFAULTS2 = {
    containerSelector: ".McFlex.css-1lfov12",
    itemSelector: ".McFlex.css-1kkwxjt",
    flagSelector: ".chakra-text.css-pyjzrq"
  };
  function startReorderObserver(options = {}) {
    if (!isBrowser2()) {
      return {
        stop() {
        },
        runOnce() {
        },
        isRunning() {
          return false;
        }
      };
    }
    const CONTAINER_SEL = options.containerSelector ?? DEFAULTS2.containerSelector;
    const ITEM_SEL = options.itemSelector ?? DEFAULTS2.itemSelector;
    const FLAG_SEL = options.flagSelector ?? DEFAULTS2.flagSelector;
    const ROOT = options.root ?? document;
    const OBSERVE_HISTORY = options.observeHistory ?? true;
    const PREFER_DIRECT = options.preferDirectChildren ?? false;
    const logger = typeof options.log === "function" ? options.log : options.log ? (...args) => console.debug("[ReorderObserver]", ...args) : () => {
    };
    let running = true;
    let pending = false;
    function processAll() {
      if (!running || pending) return;
      pending = true;
      requestAnimationFrame(() => {
        try {
          const containers = queryAll(ROOT, CONTAINER_SEL);
          for (const c of containers) {
            reorderContainer(c, ITEM_SEL, FLAG_SEL, PREFER_DIRECT);
          }
        } finally {
          pending = false;
        }
      });
    }
    const observeTarget = ROOT.documentElement ?? ROOT;
    const mo = new MutationObserver(processAll);
    mo.observe(observeTarget, { childList: true, subtree: true });
    processAll();
    let unhookHistory = null;
    if (OBSERVE_HISTORY) {
      const { unhook } = hookHistory2(processAll);
      unhookHistory = unhook;
    }
    const controller = {
      stop() {
        if (!running) return;
        running = false;
        mo.disconnect();
        unhookHistory?.();
        unhookHistory = null;
        logger("Stopped.");
      },
      runOnce() {
        processAll();
      },
      isRunning() {
        return running;
      }
    };
    return controller;
  }
  function isBrowser2() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function queryAll(root, selector) {
    return Array.from(root.querySelectorAll(selector));
  }
  function supportsScope() {
    try {
      document.querySelector(":scope");
      return true;
    } catch {
      return false;
    }
  }
  function childrenOrDescendants(container, itemSel) {
    if (supportsScope()) {
      const direct = Array.from(container.querySelectorAll(`:scope > ${itemSel}`));
      if (direct.length > 0) return direct;
    }
    return Array.from(container.querySelectorAll(itemSel));
  }
  function reorderContainer(container, itemSel, flagSel, preferDirectChildren) {
    const items = preferDirectChildren ? Array.from(container.children).filter((n) => n instanceof Element && n.matches(itemSel)) : childrenOrDescendants(container, itemSel);
    if (items.length === 0) return;
    const withFlag = [];
    const withoutFlag = [];
    for (const el2 of items) {
      (el2.querySelector(flagSel) ? withFlag : withoutFlag).push(el2);
    }
    if (withFlag.length === 0) return;
    let seenRest = false;
    for (const el2 of items) {
      const flagged = !!el2.querySelector(flagSel);
      if (!flagged) seenRest = true;
      else if (seenRest) {
        const frag = document.createDocumentFragment();
        for (const e of withFlag) frag.appendChild(e);
        for (const e of withoutFlag) frag.appendChild(e);
        container.appendChild(frag);
        return;
      }
    }
  }
  function hookHistory2(onNavigate) {
    const origPush = history.pushState?.bind(history);
    const origReplace = history.replaceState?.bind(history);
    function wrap(fn) {
      if (!fn) return fn;
      const wrapped = function(...args) {
        const ret = fn.apply(this, args);
        onNavigate();
        return ret;
      };
      return wrapped;
    }
    const onPop = () => onNavigate();
    if (origPush) history.pushState = wrap(origPush);
    if (origReplace) history.replaceState = wrap(origReplace);
    window.addEventListener("popstate", onPop);
    return {
      unhook() {
        if (origPush) history.pushState = origPush;
        if (origReplace) history.replaceState = origReplace;
        window.removeEventListener("popstate", onPop);
      }
    };
  }

  // src/utils/calculators.ts
  var key = (s) => String(s ?? "").trim();
  function resolveSpeciesKey(species) {
    const wanted = key(species).toLowerCase();
    if (!wanted) return null;
    for (const k of Object.keys(plantCatalog)) {
      if (k.toLowerCase() === wanted) return k;
    }
    return null;
  }
  function findAnySellPriceNode(obj) {
    if (!obj || typeof obj !== "object") return null;
    if (typeof obj.baseSellPrice === "number" && Number.isFinite(obj.baseSellPrice)) {
      return obj.baseSellPrice;
    }
    for (const k of ["produce", "crop", "item", "items", "data"]) {
      if (obj[k]) {
        const v = findAnySellPriceNode(obj[k]);
        if (v != null) return v;
      }
    }
    try {
      const seen = /* @__PURE__ */ new Set();
      const stack = [obj];
      while (stack.length) {
        const cur = stack.pop();
        if (!cur || typeof cur !== "object" || seen.has(cur)) continue;
        seen.add(cur);
        if (typeof cur.baseSellPrice === "number") {
          const v = cur.baseSellPrice;
          if (Number.isFinite(v)) return v;
        }
        for (const v of Object.values(cur)) if (v && typeof v === "object") stack.push(v);
      }
    } catch {
    }
    return null;
  }
  function defaultGetBasePrice(species) {
    const spKey = resolveSpeciesKey(species);
    if (!spKey) return null;
    const node = plantCatalog[spKey];
    const cands = [
      node?.produce?.baseSellPrice,
      node?.crop?.baseSellPrice,
      node?.item?.baseSellPrice,
      node?.items?.Produce?.baseSellPrice
    ].filter((v) => typeof v === "number" && Number.isFinite(v));
    if (cands.length) return cands[0];
    return findAnySellPriceNode(node);
  }
  function applyRounding(v, mode = "round") {
    switch (mode) {
      case "floor":
        return Math.floor(v);
      case "ceil":
        return Math.ceil(v);
      case "none":
        return v;
      case "round":
      default:
        return Math.round(v);
    }
  }
  function friendBonusMultiplier2(playersInRoom) {
    if (!Number.isFinite(playersInRoom)) return 1;
    const n = Math.max(1, Math.min(6, Math.floor(playersInRoom)));
    return 1 + (n - 1) * 0.1;
  }
  var COLOR_MULT = {
    Gold: 25,
    Rainbow: 50
  };
  var WEATHER_MULT = {
    Wet: 2,
    Chilled: 2,
    Frozen: 10
  };
  var TIME_MULT = {
    Dawnlit: 2,
    Dawnbound: 3,
    Amberlit: 5,
    Amberbound: 6
  };
  var WEATHER_TIME_COMBO = {
    "Wet+Dawnlit": 3,
    "Chilled+Dawnlit": 3,
    "Wet+Dawnbound": 4,
    "Chilled+Dawnbound": 4,
    "Wet+Amberlit": 6,
    "Chilled+Amberlit": 6,
    "Wet+Amberbound": 7,
    "Chilled+Amberbound": 7,
    "Frozen+Dawnlit": 11,
    "Frozen+Dawnbound": 12,
    "Frozen+Amberlit": 14,
    "Frozen+Amberbound": 15
  };
  function isColor(m) {
    return m === "Gold" || m === "Rainbow";
  }
  function isWeather(m) {
    return m === "Wet" || m === "Chilled" || m === "Frozen";
  }
  function isTime(m) {
    return m === "Dawnlit" || m === "Dawnbound" || m === "Amberlit" || m === "Amberbound";
  }
  function normalizeMutationName(m) {
    const s = key(m).toLowerCase();
    if (!s) return "";
    if (s === "amberglow" || s === "ambershine" || s === "amberlight") return "Amberlit";
    if (s === "dawn" || s === "dawnlight") return "Dawnlit";
    if (s === "gold") return "Gold";
    if (s === "rainbow") return "Rainbow";
    if (s === "wet") return "Wet";
    if (s === "chilled") return "Chilled";
    if (s === "frozen") return "Frozen";
    if (s === "dawnlit") return "Dawnlit";
    if (s === "dawnbound") return "Dawnbound";
    if (s === "amberlit") return "Amberlit";
    if (s === "dawncharged" || s === "dawnradiant" || s === "dawn-radiant" || s === "dawn charged") return "Dawnbound";
    if (s === "amberbound" || s === "ambercharged" || s === "amberradiant" || s === "amber-radiant" || s === "amber charged") return "Amberbound";
    return m;
  }
  function computeColorMultiplier(mutations) {
    if (!Array.isArray(mutations)) return 1;
    let best = 1;
    for (const raw of mutations) {
      const m = normalizeMutationName(raw);
      if (isColor(m)) {
        const mult = COLOR_MULT[m];
        if (mult > best) best = mult;
      }
    }
    return best;
  }
  function pickWeather(mutations) {
    if (!Array.isArray(mutations)) return null;
    let pick = null;
    for (const raw of mutations) {
      const m = normalizeMutationName(raw);
      if (isWeather(m)) {
        if (pick == null) {
          pick = m;
          continue;
        }
        if (WEATHER_MULT[m] > WEATHER_MULT[pick]) pick = m;
      }
    }
    return pick;
  }
  function pickTime(mutations) {
    if (!Array.isArray(mutations)) return null;
    let pick = null;
    for (const raw of mutations) {
      const m = normalizeMutationName(raw);
      if (isTime(m)) {
        if (pick == null) {
          pick = m;
          continue;
        }
        if (TIME_MULT[m] > TIME_MULT[pick]) pick = m;
      }
    }
    return pick;
  }
  function computeWeatherTimeMultiplier(weather2, time) {
    if (!weather2 && !time) return 1;
    if (weather2 && !time) return WEATHER_MULT[weather2];
    if (!weather2 && time) return TIME_MULT[time];
    const k = `${weather2}+${time}`;
    const combo = WEATHER_TIME_COMBO[k];
    if (typeof combo === "number") return combo;
    return Math.max(WEATHER_MULT[weather2], TIME_MULT[time]);
  }
  function mutationsMultiplier(mutations) {
    const color = computeColorMultiplier(mutations);
    const weather2 = pickWeather(mutations);
    const time = pickTime(mutations);
    const wt = computeWeatherTimeMultiplier(weather2, time);
    return color * wt;
  }
  function estimateProduceValue(species, scale, mutations, opts) {
    const getBase = opts?.getBasePrice ?? defaultGetBasePrice;
    const sXform = opts?.scaleTransform ?? ((_, s) => s);
    const round = opts?.rounding ?? "round";
    const base = getBase(species);
    if (!(Number.isFinite(base) && base > 0)) return 0;
    const sc = Number(scale);
    if (!Number.isFinite(sc) || sc <= 0) return 0;
    const effScale = sXform(species, sc);
    if (!Number.isFinite(effScale) || effScale <= 0) return 0;
    const mutMult = mutationsMultiplier(mutations);
    const friendsMult = friendBonusMultiplier2(opts?.friendPlayers);
    const pre = base * effScale * mutMult * friendsMult;
    const out = Math.max(0, applyRounding(pre, round));
    return out;
  }
  function valueFromInventoryProduce(item, opts, playersInRoom) {
    if (!item || item.itemType !== "Produce") return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    return estimateProduceValue(item.species, item.scale, item.mutations, merged);
  }
  function valueFromGardenSlot(slot, opts, playersInRoom) {
    if (!slot) return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    return estimateProduceValue(slot.species, slot.targetScale, slot.mutations, merged);
  }
  function valueFromGardenPlant(plant, opts, playersInRoom) {
    if (!plant || plant.objectType !== "plant" || !Array.isArray(plant.slots)) return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    let sum = 0;
    for (const s of plant.slots) sum += valueFromGardenSlot(s, merged);
    return sum;
  }
  function sumInventoryValue(items, opts, playersInRoom) {
    if (!Array.isArray(items)) return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    let sum = 0;
    for (const it of items) {
      if (it?.itemType === "Produce") {
        sum += valueFromInventoryProduce(it, merged);
      }
    }
    return sum;
  }
  function sumGardenValue(garden2, opts, playersInRoom) {
    if (!garden2 || typeof garden2 !== "object") return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    let sum = 0;
    for (const k of Object.keys(garden2)) {
      const p = garden2[k];
      if (p?.objectType === "plant") {
        sum += valueFromGardenPlant(p, merged);
      }
    }
    return sum;
  }
  var DefaultPricing = Object.freeze({
    getBasePrice: defaultGetBasePrice,
    rounding: "round"
  });

  // src/utils/cropPrice.ts
  var isPlantObject2 = (o) => !!o && o.objectType === "plant";
  var defaultOrder2 = (n) => Array.from({ length: n }, (_, i) => i);
  var clamp2 = (n, min, max) => Math.max(min, Math.min(max, n));
  function startCropPriceWatcherViaGardenObject() {
    let cur = null;
    let players = void 0;
    let sortedIdx = null;
    let selectedIdx = null;
    let lastPrice = null;
    const listeners5 = /* @__PURE__ */ new Set();
    const notify2 = () => {
      for (const fn of listeners5) try {
        fn();
      } catch {
      }
    };
    let scheduled = false;
    const scheduleRecomputeAndNotify = () => {
      if (scheduled) return;
      scheduled = true;
      requestAnimationFrame(() => {
        scheduled = false;
        recomputeAndNotify();
      });
    };
    function getOrder() {
      const n = Array.isArray(cur?.slots) ? cur.slots.length : 0;
      if (!n) return [];
      return Array.isArray(sortedIdx) && sortedIdx.length === n ? sortedIdx : defaultOrder2(n);
    }
    function selectedOrderedPosition() {
      if (!isPlantObject2(cur)) return 0;
      const slots = cur.slots ?? [];
      const n = Array.isArray(slots) ? slots.length : 0;
      if (!n) return 0;
      const raw = Number.isFinite(selectedIdx) ? selectedIdx : 0;
      const clampedRaw = clamp2(raw, 0, n - 1);
      const ord = getOrder();
      const pos = ord.indexOf(clampedRaw);
      return pos >= 0 ? pos : 0;
    }
    function getOrderedSlots() {
      if (!isPlantObject2(cur)) return [];
      const slots = Array.isArray(cur.slots) ? cur.slots : [];
      const ord = getOrder();
      const out = [];
      for (const i of ord) if (slots[i] != null) out.push(slots[i]);
      return out;
    }
    function computeSelectedSlotPrice() {
      if (!isPlantObject2(cur)) return null;
      const ordered = getOrderedSlots();
      if (!ordered.length) return null;
      const pos = selectedOrderedPosition();
      const slot = ordered[clamp2(pos, 0, ordered.length - 1)];
      const val = valueFromGardenSlot(slot, DefaultPricing, players);
      return Number.isFinite(val) && val > 0 ? val : null;
    }
    function computeWholePlantPrice() {
      if (!isPlantObject2(cur)) return null;
      const v = valueFromGardenPlant(cur, DefaultPricing, players);
      return Number.isFinite(v) && v > 0 ? v : null;
    }
    function recomputeAndNotify() {
      const slotVal = computeSelectedSlotPrice();
      const next = slotVal ?? computeWholePlantPrice() ?? null;
      if (next !== lastPrice) {
        lastPrice = next;
        notify2();
      }
    }
    (async () => {
      try {
        cur = await myCurrentGardenObject.get();
      } catch {
      }
      try {
        players = await numPlayers.get();
      } catch {
      }
      try {
        const v = await myCurrentSortedGrowSlotIndices.get();
        sortedIdx = Array.isArray(v) ? v.slice() : null;
      } catch {
      }
      try {
        selectedIdx = await myCurrentGrowSlotIndex.get();
      } catch {
      }
      numPlayers.onChange((n) => {
        players = n;
      });
      myCurrentSortedGrowSlotIndices.onChange((v) => {
        sortedIdx = Array.isArray(v) ? v.slice() : null;
      });
      myCurrentGardenObject.onChange((v) => {
        cur = v;
        scheduleRecomputeAndNotify();
      });
      myCurrentGrowSlotIndex.onChange((idx) => {
        selectedIdx = Number.isFinite(idx) ? idx : 0;
        scheduleRecomputeAndNotify();
      });
      recomputeAndNotify();
    })();
    return {
      get() {
        return lastPrice;
      },
      onChange(cb) {
        listeners5.add(cb);
        return () => listeners5.delete(cb);
      },
      stop() {
        listeners5.clear();
      }
    };
  }

  // src/utils/cropValues.ts
  function getQpmGlobal() {
    return readSharedGlobal("QPM");
  }
  function getQpmSizeSpan(inner) {
    const QPM = getQpmGlobal();
    if (!QPM) return null;
    return inner.querySelector("span.qpm-crop-size");
  }
  var DEFAULTS3 = {
    rootSelector: ".McFlex.css-fsggty",
    innerSelector: ".McFlex.css-1l3zq7, .McFlex.css-11dqzw",
    markerClass: "tm-crop-price"
  };
  var OMA_SEL = ".McFlex.css-1l3zq7, .McFlex.css-11dqzw";
  var ICON_CLASS = "tm-crop-price-icon";
  var LABEL_CLASS = "tm-crop-price-label";
  var LOCK_TEXT_SELECTOR = ":scope > .chakra-text.css-1uvlb8k";
  var LOCK_EMOJI = "\u{1F512}";
  var LOCK_BORDER_STYLE = "2px solid rgb(188, 53, 215)";
  var LOCK_BORDER_RADIUS = "15px";
  var TOOLTIP_ROOT_CLASS = "css-qnqsp4";
  var LOCK_ICON_CLASS = "tm-locker-tooltip-lock-icon";
  var DATASET_KEY_COLOR = "tmLockerOriginalColor";
  var DATASET_KEY_DISPLAY = "tmLockerOriginalDisplay";
  var DATASET_KEY_ALIGN = "tmLockerOriginalAlign";
  var DATASET_KEY_TEXT = "tmLockerOriginalHtml";
  var DATASET_KEY_BORDER = "tmLockerOriginalBorder";
  var DATASET_KEY_BORDER_RADIUS = "tmLockerOriginalBorderRadius";
  var DATASET_KEY_POSITION = "tmLockerOriginalPosition";
  var DATASET_KEY_OVERFLOW = "tmLockerOriginalOverflow";
  var LOCK_PREFIX_REGEX = new RegExp(`^${LOCK_EMOJI}(?:\\u00A0|\\s|&nbsp;)*`);
  var PRICE_FALLBACK = "\u2014";
  var nfUS = new Intl.NumberFormat("en-US");
  var formatCoins = (value) => value == null ? PRICE_FALLBACK : nfUS.format(Math.max(0, Math.round(value)));
  var hasDOM = typeof window !== "undefined" && typeof document !== "undefined";
  function queryAll2(root, sel) {
    return Array.from(root.querySelectorAll(sel));
  }
  function createLogger(option) {
    if (typeof option === "function") return option;
    if (option) return (...args) => console.debug("[AppendCropPrice/GO]", ...args);
    return () => {
    };
  }
  function forEachInner(root, selectors, callback) {
    queryAll2(root, selectors.rootSelector).forEach((rootEl) => {
      queryAll2(rootEl, selectors.innerSelector).forEach(callback);
    });
  }
  function updatePanels(root, selectors, markerClass, text, locked) {
    forEachInner(root, selectors, (inner) => {
      if (shouldSkipInner(inner, markerClass)) {
        removeMarker(inner, markerClass);
        updateLockEmoji(inner, false);
        return;
      }
      updateLockEmoji(inner, locked);
      ensureSpanAtEnd(inner, text, markerClass);
    });
  }
  function getLockerHarvestAllowed() {
    try {
      return lockerService.getCurrentSlotSnapshot().harvestAllowed ?? null;
    } catch {
      return null;
    }
  }
  function subscribeLocker(handler) {
    try {
      return lockerService.onSlotInfoChange(handler);
    } catch {
      return null;
    }
  }
  function startCropValuesObserverFromGardenAtom(options = {}) {
    if (!hasDOM) {
      return { stop() {
      }, runOnce() {
      }, isRunning: () => false };
    }
    const selectors = {
      rootSelector: options.rootSelector ?? DEFAULTS3.rootSelector,
      innerSelector: options.innerSelector ?? DEFAULTS3.innerSelector
    };
    const markerClass = options.markerClass ?? DEFAULTS3.markerClass;
    const root = options.root ?? document;
    const logger = createLogger(options.log);
    const priceWatcher = startCropPriceWatcherViaGardenObject();
    const shouldWaitForLocker = lockerService.getState().enabled;
    let running = true;
    let lockerHarvestAllowed = getLockerHarvestAllowed();
    let lockerReady = !shouldWaitForLocker;
    let lastRenderedValue = void 0;
    let lastRenderedLocked = void 0;
    let needsRepositionRender = false;
    let qpmObserver = null;
    const render = () => {
      if (!running) return;
      if (!lockerReady) return;
      const value = priceWatcher.get();
      const locked = lockerHarvestAllowed === false;
      if (value === lastRenderedValue && locked === lastRenderedLocked && !needsRepositionRender) {
        return;
      }
      lastRenderedValue = value;
      lastRenderedLocked = locked;
      needsRepositionRender = false;
      updatePanels(root, selectors, markerClass, formatCoins(value), locked);
      logger("render", { value, locked });
    };
    let lockerReadyTimeout = null;
    const clearLockerReadyTimeout = () => {
      if (lockerReadyTimeout == null) return;
      if (typeof globalThis !== "undefined" && typeof globalThis.clearTimeout === "function") {
        globalThis.clearTimeout(lockerReadyTimeout);
      }
      lockerReadyTimeout = null;
    };
    const startLockerReadyTimeout = () => {
      if (!shouldWaitForLocker || lockerReady || lockerReadyTimeout != null) return;
      if (typeof globalThis === "undefined" || typeof globalThis.setTimeout !== "function") return;
      lockerReadyTimeout = globalThis.setTimeout(() => {
        lockerReadyTimeout = null;
        if (!lockerReady) {
          lockerReady = true;
          render();
        }
      }, 500);
    };
    startLockerReadyTimeout();
    const startQpmObserver = () => {
      if (qpmObserver) return;
      if (typeof MutationObserver === "undefined") return;
      const target = document.body ?? document.documentElement ?? document;
      if (!target) return;
      qpmObserver = new MutationObserver((mutations) => {
        let found = false;
        for (const mutation of mutations) {
          for (const node of Array.from(mutation.addedNodes)) {
            if (!(node instanceof Element)) continue;
            if (node.classList.contains("qpm-crop-size")) {
              found = true;
              break;
            }
            if (node.querySelector(".qpm-crop-size")) {
              found = true;
              break;
            }
          }
          if (found) break;
        }
        if (found) {
          needsRepositionRender = true;
          render();
        }
      });
      qpmObserver.observe(target, { childList: true, subtree: true });
    };
    const stopQpmObserver = () => {
      if (!qpmObserver) return;
      try {
        qpmObserver.disconnect();
      } catch {
      }
      qpmObserver = null;
    };
    startQpmObserver();
    const lockerOff = subscribeLocker((event) => {
      lockerHarvestAllowed = event.harvestAllowed ?? null;
      clearLockerReadyTimeout();
      if (!lockerReady && shouldWaitForLocker) {
        lockerReady = true;
      }
      render();
    });
    if (shouldWaitForLocker && lockerOff == null) {
      clearLockerReadyTimeout();
      lockerReady = true;
    }
    render();
    const off = priceWatcher.onChange(render);
    return {
      stop() {
        if (!running) return;
        running = false;
        clearLockerReadyTimeout();
        stopQpmObserver();
        off?.();
        if (typeof lockerOff === "function") {
          try {
            lockerOff();
          } catch {
          }
        }
        priceWatcher.stop();
        logger("stopped");
      },
      runOnce() {
        render();
      },
      isRunning() {
        return running;
      }
    };
  }
  function shouldSkipInner(inner, markerClass) {
    if (!(inner instanceof Element)) return false;
    if (!inner.matches(OMA_SEL)) return false;
    const realChildren = getRealElementChildren(inner, markerClass);
    return realChildren.length === 1;
  }
  function getRealElementChildren(inner, markerClass) {
    const children = Array.from(inner.children);
    return children.filter(
      (el2) => !(el2.tagName === "SPAN" && el2.classList.contains(markerClass))
    );
  }
  function removeMarker(inner, markerClass) {
    const markers = inner.querySelectorAll(`:scope > span.${CSS.escape(markerClass)}`);
    markers.forEach((m) => m.remove());
  }
  function cleanupLegacyLockIcons() {
    if (typeof document === "undefined") return;
    const all = document.querySelectorAll(`span.${LOCK_ICON_CLASS}`);
    all.forEach((icon) => {
      if (!icon.closest(`.${TOOLTIP_ROOT_CLASS}`)) {
        icon.remove();
      }
    });
  }
  function getTooltipRoot(inner) {
    return inner.closest(`.${TOOLTIP_ROOT_CLASS}`);
  }
  function updateLockEmoji(inner, locked) {
    if (!(inner instanceof HTMLElement)) return;
    inner.querySelectorAll(":scope > span.tm-locker-lock-emoji").forEach((node) => node.remove());
    cleanupLegacyLockIcons();
    const textTarget = inner.querySelector(LOCK_TEXT_SELECTOR) ?? inner.querySelector(":scope > .chakra-text");
    const tooltipRoot = getTooltipRoot(inner);
    const outerContainer = inner.closest(".css-502lyi");
    if (outerContainer && outerContainer !== tooltipRoot) {
      restoreTooltipStyles(outerContainer);
      removeLockIcon(outerContainer);
    }
    if (!locked) {
      if (textTarget) {
        restoreTextContent(textTarget);
        restoreTextStyles(textTarget);
      }
      if (tooltipRoot) {
        restoreTooltipStyles(tooltipRoot);
        removeLockIcon(tooltipRoot);
      }
      return;
    }
    if (textTarget) {
      restoreTextContent(textTarget);
    }
    if (tooltipRoot) {
      storeOriginalTooltipStyles(tooltipRoot);
      applyLockedTooltipStyles(tooltipRoot);
      ensureLockIcon(tooltipRoot);
    }
  }
  function restoreTextStyles(textTarget) {
    restoreStyleFromDataset(textTarget, DATASET_KEY_COLOR, "color");
    restoreStyleFromDataset(textTarget, DATASET_KEY_DISPLAY, "display");
    restoreStyleFromDataset(textTarget, DATASET_KEY_ALIGN, "align-items");
  }
  function restoreTextContent(textTarget) {
    const originalHtml = textTarget.dataset[DATASET_KEY_TEXT];
    if (originalHtml !== void 0) {
      textTarget.innerHTML = originalHtml;
      delete textTarget.dataset[DATASET_KEY_TEXT];
      return;
    }
    const currentHtml = textTarget.innerHTML;
    const sanitizedHtml = stripLockPrefix(currentHtml);
    if (sanitizedHtml !== currentHtml) {
      textTarget.innerHTML = sanitizedHtml;
    }
  }
  function restoreStyleFromDataset(el2, datasetKey, cssProperty) {
    const datasetMap = el2.dataset;
    const originalValue = datasetMap[datasetKey];
    if (originalValue === void 0) return;
    if (originalValue) {
      el2.style.setProperty(cssProperty, originalValue);
    } else {
      el2.style.removeProperty(cssProperty);
    }
    delete datasetMap[datasetKey];
  }
  function storeOriginalTooltipStyles(tooltip) {
    if (tooltip.dataset[DATASET_KEY_BORDER] === void 0) {
      tooltip.dataset[DATASET_KEY_BORDER] = tooltip.style.border ?? "";
    }
    if (tooltip.dataset[DATASET_KEY_BORDER_RADIUS] === void 0) {
      tooltip.dataset[DATASET_KEY_BORDER_RADIUS] = tooltip.style.borderRadius ?? "";
    }
    if (tooltip.dataset[DATASET_KEY_OVERFLOW] === void 0) {
      tooltip.dataset[DATASET_KEY_OVERFLOW] = tooltip.style.overflow ?? "";
    }
  }
  function applyLockedTooltipStyles(tooltip) {
    tooltip.style.border = LOCK_BORDER_STYLE;
    tooltip.style.borderRadius = LOCK_BORDER_RADIUS;
    tooltip.style.overflow = "visible";
    const computedPosition = typeof window !== "undefined" ? window.getComputedStyle(tooltip).position : tooltip.style.position || "static";
    if (computedPosition === "static") {
      if (tooltip.dataset[DATASET_KEY_POSITION] === void 0) {
        tooltip.dataset[DATASET_KEY_POSITION] = tooltip.style.position ?? "";
      }
      tooltip.style.position = "relative";
    }
  }
  function restoreTooltipStyles(tooltip) {
    const originalBorder = tooltip.dataset[DATASET_KEY_BORDER];
    if (originalBorder !== void 0) {
      if (originalBorder) {
        tooltip.style.border = originalBorder;
      } else {
        tooltip.style.removeProperty("border");
      }
      delete tooltip.dataset[DATASET_KEY_BORDER];
    } else {
      tooltip.style.removeProperty("border");
    }
    const originalBorderRadius = tooltip.dataset[DATASET_KEY_BORDER_RADIUS];
    if (originalBorderRadius !== void 0) {
      if (originalBorderRadius) {
        tooltip.style.borderRadius = originalBorderRadius;
      } else {
        tooltip.style.removeProperty("border-radius");
      }
      delete tooltip.dataset[DATASET_KEY_BORDER_RADIUS];
    } else {
      tooltip.style.removeProperty("border-radius");
    }
    const originalOverflow = tooltip.dataset[DATASET_KEY_OVERFLOW];
    if (originalOverflow !== void 0) {
      if (originalOverflow) {
        tooltip.style.overflow = originalOverflow;
      } else {
        tooltip.style.removeProperty("overflow");
      }
      delete tooltip.dataset[DATASET_KEY_OVERFLOW];
    } else {
      tooltip.style.removeProperty("overflow");
    }
    const originalPosition = tooltip.dataset[DATASET_KEY_POSITION];
    if (originalPosition !== void 0) {
      if (originalPosition) {
        tooltip.style.position = originalPosition;
      } else {
        tooltip.style.removeProperty("position");
      }
      delete tooltip.dataset[DATASET_KEY_POSITION];
    } else if (tooltip.style.position === "relative") {
      tooltip.style.removeProperty("position");
    }
  }
  function ensureLockIcon(tooltip) {
    const icons = tooltip.querySelectorAll(`:scope > span.${LOCK_ICON_CLASS}`);
    icons.forEach((node, idx) => {
      if (idx > 0) node.remove();
    });
    let icon = icons[0] ?? null;
    if (!icon) {
      icon = document.createElement("span");
      icon.className = LOCK_ICON_CLASS;
      tooltip.append(icon);
    }
    icon.textContent = LOCK_EMOJI;
    icon.style.position = "absolute";
    icon.style.top = "0";
    icon.style.right = "0";
    icon.style.left = "";
    icon.style.transform = "translate(50%, -50%)";
    icon.style.fontSize = "18px";
    icon.style.padding = "2px 8px";
    icon.style.borderRadius = "999px";
    icon.style.border = "none";
    icon.style.background = "transparent";
    icon.style.color = "white";
    icon.style.pointerEvents = "none";
    icon.style.userSelect = "none";
    icon.style.zIndex = "1";
  }
  function removeLockIcon(tooltip) {
    tooltip.querySelectorAll(`:scope > span.${LOCK_ICON_CLASS}`).forEach((node) => node.remove());
  }
  function stripLockPrefix(content) {
    return content.replace(LOCK_PREFIX_REGEX, "");
  }
  function ensureSpanAtEnd(inner, text, markerClass) {
    const spans = Array.from(
      inner.querySelectorAll(`:scope > span.${CSS.escape(markerClass)}`)
    );
    let span = spans[0] ?? null;
    for (let i = 1; i < spans.length; i++) spans[i].remove();
    if (!span) {
      span = document.createElement("span");
      span.className = markerClass;
    }
    span.style.display = "block";
    span.style.marginTop = "6px";
    span.style.fontWeight = "700";
    span.style.color = "#FFD84D";
    span.style.fontSize = "14px";
    let icon = span.querySelector(`:scope > span.${ICON_CLASS}`);
    if (!icon) {
      icon = document.createElement("span");
      icon.className = ICON_CLASS;
      icon.setAttribute("aria-hidden", "true");
      icon.style.width = "18px";
      icon.style.height = "18px";
      icon.style.display = "inline-block";
      icon.style.verticalAlign = "middle";
      icon.style.marginRight = "6px";
      icon.style.userSelect = "none";
      icon.style.pointerEvents = "none";
      icon.style.backgroundSize = "contain";
      icon.style.backgroundRepeat = "no-repeat";
      icon.style.backgroundPosition = "center";
      span.insertBefore(icon, span.firstChild);
    }
    const bg = `url("${coin.img64}")`;
    if (icon.style.backgroundImage !== bg) {
      icon.style.backgroundImage = bg;
    }
    let label2 = span.querySelector(`:scope > span.${LABEL_CLASS}`);
    if (!label2) {
      label2 = document.createElement("span");
      label2.className = LABEL_CLASS;
      label2.style.display = "inline";
      span.appendChild(label2);
    }
    if (label2.textContent !== text) {
      label2.textContent = text;
    }
    const sizeSpan = getQpmSizeSpan(inner);
    if (sizeSpan) {
      const next = sizeSpan.nextElementSibling;
      if (next !== span) {
        inner.insertBefore(span, next);
      }
      return;
    }
    if (inner.lastElementChild !== span) {
      inner.appendChild(span);
    }
  }

  // src/utils/version.ts
  var REPO_OWNER = "Ariedam64";
  var REPO_NAME = "MagicGarden-modMenu";
  var REPO_BRANCH = "main";
  var SCRIPT_FILE_PATH = "quinoa-ws.min.user.js";
  var RAW_BASE_URL = `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}`;
  var COMMITS_API_URL = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/commits/${REPO_BRANCH}`;
  async function fetchTextWithFetch(url, options) {
    const response = await fetch(url, { cache: "no-store", ...options });
    if (!response.ok) {
      throw new Error(`Failed to load remote resource: ${response.status} ${response.statusText}`);
    }
    return await response.text();
  }
  async function fetchTextWithGM(url, options) {
    return new Promise((resolve2, reject) => {
      const xhr = typeof GM_xmlhttpRequest === "function" ? GM_xmlhttpRequest : typeof GM !== "undefined" && typeof GM.xmlHttpRequest === "function" ? GM.xmlHttpRequest : null;
      if (!xhr) return reject(new Error("GM_xmlhttpRequest not available"));
      xhr({
        method: "GET",
        url,
        headers: options?.headers,
        onload: (res) => {
          if (res.status >= 200 && res.status < 300) resolve2(res.responseText);
          else reject(new Error(`GM_xhr failed: ${res.status}`));
        },
        onerror: (e) => reject(e)
      });
    });
  }
  async function fetchText(url, options) {
    const preferGM = isDiscordSurface();
    const hasGM = typeof GM_xmlhttpRequest === "function" || typeof GM !== "undefined" && typeof GM.xmlHttpRequest === "function";
    if (preferGM && hasGM) {
      return await fetchTextWithGM(url, options);
    }
    try {
      return await fetchTextWithFetch(url, options);
    } catch (error) {
      if (hasGM) {
        return await fetchTextWithGM(url, options);
      }
      throw error;
    }
  }
  async function fetchLatestCommitSha() {
    try {
      const responseText = await fetchText(COMMITS_API_URL, {
        headers: { Accept: "application/vnd.github+json" }
      });
      const data = JSON.parse(responseText);
      if (data && typeof data.sha === "string" && data.sha.trim().length > 0) {
        return data.sha.trim();
      }
    } catch (error) {
      console.warn("[MagicGarden] Failed to resolve latest commit SHA:", error);
    }
    return null;
  }
  async function fetchScriptSource() {
    const commitSha = await fetchLatestCommitSha();
    const scriptUrl = commitSha ? `${RAW_BASE_URL}/${commitSha}/${SCRIPT_FILE_PATH}` : `${RAW_BASE_URL}/refs/heads/${REPO_BRANCH}/${SCRIPT_FILE_PATH}?t=${Date.now()}`;
    return await fetchText(scriptUrl);
  }
  async function fetchRemoteVersion() {
    try {
      const scriptSource = await fetchScriptSource();
      const meta = extractUserscriptMetadata(scriptSource);
      if (!meta) {
        throw new Error("Metadata block not found in remote script");
      }
      const version = meta.get("version")?.[0];
      const download = meta.get("downloadurl")?.[0] ?? meta.get("updateurl")?.[0];
      return {
        version,
        download
      };
    } catch (error) {
      console.error("Unable to retrieve remote version:", error);
      return null;
    }
  }
  function extractUserscriptMetadata(source) {
    const headerMatch = source.match(/\/\/ ==UserScript==([\s\S]*?)\/\/ ==\/UserScript==/);
    if (!headerMatch) {
      return null;
    }
    const metaBlock = headerMatch[1];
    const entries = metaBlock.matchAll(/^\/\/\s*@([^\s]+)\s+(.+)$/gm);
    const meta = /* @__PURE__ */ new Map();
    for (const [, rawKey, rawValue] of entries) {
      const key2 = rawKey.trim().toLowerCase();
      const value = rawValue.trim();
      if (!key2) continue;
      const current = meta.get(key2);
      if (current) {
        current.push(value);
      } else {
        meta.set(key2, [value]);
      }
    }
    return meta;
  }
  function getLocalVersion() {
    if (typeof GM_info !== "undefined" && GM_info?.script?.version) {
      return GM_info.script.version;
    }
    return void 0;
  }

  // src/core/dom.ts
  var ready = new Promise((res) => {
    if (document.readyState !== "loading") res();
    else addEventListener("DOMContentLoaded", () => res(), { once: true });
  });
  function addStyle(css) {
    const s = document.createElement("style");
    s.textContent = css;
    document.head.appendChild(s);
    return s;
  }
  function toPredicate(selOrFn) {
    if (typeof selOrFn === "function") return selOrFn;
    if (typeof selOrFn === "string") return (el2) => el2.matches?.(selOrFn) ?? false;
    throw new Error("Selector or predicate required");
  }
  function onAdded(selOrFn, cb, { root = document, callForExisting = true } = {}) {
    const pred = toPredicate(selOrFn);
    const seen = /* @__PURE__ */ new WeakSet();
    const consider = (el2) => {
      if (seen.has(el2)) return;
      if (pred(el2)) {
        seen.add(el2);
        cb(el2);
      }
    };
    if (callForExisting && "querySelectorAll" in root) {
      root.querySelectorAll("*").forEach(consider);
    }
    const obs = new MutationObserver((muts) => {
      for (const m of muts) for (const n of Array.from(m.addedNodes)) {
        if (n.nodeType !== 1) continue;
        const el2 = n;
        consider(el2);
        el2.querySelectorAll?.("*").forEach(consider);
      }
    });
    obs.observe(root, { childList: true, subtree: true });
    return { disconnect: () => obs.disconnect() };
  }

  // src/utils/petPanelEnhancer.ts
  var PANEL_SELECTOR = ".css-1rszi55";
  var FEED_BUTTON_CLASS = "tm-feed-from-inventory-btn";
  var FEED_ROW_CLASS = "tm-feed-from-inventory-row";
  var started = false;
  function startPetPanelEnhancer() {
    if (started) return;
    started = true;
    if (typeof document === "undefined") {
      return;
    }
    onAdded(PANEL_SELECTOR, (node) => {
      if (!(node instanceof HTMLElement)) return;
      enhancePanel(node);
    });
  }
  function enhancePanel(root) {
    try {
      ensureFeedButton(root);
    } catch (err) {
      console.warn("[PetPanel] Failed to inject feed button", err);
    }
  }
  function ensureFeedButton(root) {
    if (root.querySelector(`.${FEED_BUTTON_CLASS}`)) return;
    const templateBtn = root.querySelector("button.chakra-button");
    const btn = createStyledButton(templateBtn, "INSTANT FEED");
    btn.classList.add(FEED_BUTTON_CLASS);
    btn.setAttribute("aria-label", "Feed pet from inventory");
    btn.title = "Feed pet from inventory";
    btn.style.width = "100%";
    btn.style.minWidth = "100%";
    btn.style.alignContent = "center";
    btn.style.alignItems = "center";
    btn.style.padding = "6px 14px";
    btn.style.fontSize = "13px";
    btn.style.border = "2px solid #FFC83D";
    btn.style.color = "rgb(205 200 193)";
    btn.style.borderRadius = "10px";
    btn.style.height = "40px";
    btn.addEventListener("click", () => {
      void handleFeedClick(btn);
    });
    const row = document.createElement("div");
    row.classList.add("McFlex", FEED_ROW_CLASS);
    row.style.marginTop = "8px";
    row.style.justifyContent = "center";
    row.style.width = "100%";
    row.style.flexDirection = "column";
    row.style.alignItems = "stretch";
    row.style.gap = "8px";
    row.appendChild(btn);
    const feedFromInventoryBtn = createStyledButton(
      templateBtn,
      "FEED FROM INVENTORY"
    );
    feedFromInventoryBtn.style.width = "100%";
    feedFromInventoryBtn.style.minWidth = "100%";
    feedFromInventoryBtn.style.alignContent = "center";
    feedFromInventoryBtn.style.alignItems = "center";
    feedFromInventoryBtn.style.marginTop = "8px";
    feedFromInventoryBtn.style.padding = "6px 14px";
    feedFromInventoryBtn.style.fontSize = "13px";
    feedFromInventoryBtn.style.border = "2px solid #BA5E1E";
    feedFromInventoryBtn.style.color = "rgb(205 200 193)";
    feedFromInventoryBtn.style.borderRadius = "10px";
    feedFromInventoryBtn.style.height = "40px";
    row.appendChild(feedFromInventoryBtn);
    feedFromInventoryBtn.addEventListener("click", () => {
      void handleInventoryPreviewClick(feedFromInventoryBtn);
    });
    const actions = root.querySelector(".McFlex.css-cabebk");
    const abilities = root.querySelector(".McFlex.css-1hd05pq");
    if (actions && abilities && abilities.parentElement === actions.parentElement) {
      abilities.parentElement.insertBefore(row, abilities);
    } else if (actions?.parentElement) {
      actions.parentElement.insertBefore(row, actions.nextSibling);
    } else {
      root.appendChild(row);
    }
  }
  function createStyledButton(template, label2) {
    const btn = document.createElement("button");
    btn.type = "button";
    if (template?.className) {
      btn.className = template.className;
    } else {
      btn.className = "chakra-button";
    }
    const wrapper = document.createElement("div");
    wrapper.className = template?.firstElementChild instanceof HTMLElement ? template.firstElementChild.className : "McFlex";
    const textEl = document.createElement("p");
    const templateText = template?.querySelector(".chakra-text");
    textEl.className = templateText instanceof HTMLElement ? templateText.className : "chakra-text";
    textEl.textContent = label2;
    wrapper.appendChild(textEl);
    btn.appendChild(wrapper);
    return btn;
  }
  async function handleFeedClick(btn) {
    const prevDisabled = btn.disabled;
    btn.disabled = true;
    try {
      const petId = await getExpandedPetId();
      if (!petId) {
        await toastSimple("Feed from inventory", "No expanded pet detected.", "error");
        return;
      }
      const pet = await findPetById2(petId);
      if (!pet) {
        await toastSimple("Feed from inventory", "Unable to resolve expanded pet.", "error");
        return;
      }
      const species = String(pet?.slot?.petSpecies || "");
      const compatibleList = PetsService.getCompatibleCropsForSpecies(species) ?? [];
      const compatible = new Set(compatibleList.map((item) => String(item || "")));
      if (!compatible.size) {
        await toastSimple("Feed from inventory", "No compatible crops for this pet.", "info");
        return;
      }
      const inventory = await PlayerService.getCropInventoryState();
      const items = Array.isArray(inventory) ? inventory : [];
      const favoriteSet = await PlayerService.getFavoriteIdSet().catch(() => /* @__PURE__ */ new Set());
      const chosen = items.find((item) => {
        const speciesId = String(item?.species || "");
        if (!speciesId || !compatible.has(speciesId)) return false;
        const id = String(item?.id || "");
        return id && !favoriteSet.has(id);
      });
      const chosenId = String(chosen?.id || "");
      if (!chosenId) {
        await toastSimple(
          "Feed from inventory",
          "No compatible crops in inventory (excluding favorites).",
          "info"
        );
        return;
      }
      const previousHungerPct = getHungerPctForPet(pet);
      await PlayerService.feedPet(petId, chosenId);
      const hungerPct = await waitForHungerIncrease(petId, previousHungerPct, {
        initialDelay: 150
      });
      const hungerSuffix = hungerPct != null ? ` Hunger: ${formatHungerPct(hungerPct)}%.` : "";
      const cropName = String(chosen?.species || "crop");
      const petLabel = pet?.slot?.name || species || petId;
      await toastSimple(
        "Feed from inventory",
        `Fed ${petLabel} with ${cropName}.${hungerSuffix}`,
        "success"
      );
    } catch (err) {
      console.error("[Pet panel] Failed to feed pet from inventory", err);
      await toastSimple(
        "Feed from inventory",
        err instanceof Error ? err.message : "Failed to feed pet.",
        "error"
      );
    } finally {
      btn.disabled = prevDisabled;
    }
  }
  async function handleInventoryPreviewClick(btn) {
    const prevDisabled = btn.disabled;
    let shouldCloseInventory = false;
    btn.disabled = true;
    try {
      const petId = await getExpandedPetId();
      if (!petId) {
        await toastSimple("Feed from inventory", "No expanded pet detected.", "error");
        return;
      }
      const pet = await findPetById2(petId);
      if (!pet) {
        await toastSimple("Feed from inventory", "Unable to resolve expanded pet.", "error");
        return;
      }
      const species = String(pet?.slot?.petSpecies || "");
      let lastKnownHungerPct = getHungerPctForPet(pet);
      const allowed = await getAllowedCrops(petId, species);
      if (!allowed.size) {
        await toastSimple("Feed from inventory", "No compatible crops for this pet.", "info");
        return;
      }
      const inventory = await PlayerService.getCropInventoryState();
      const items = Array.isArray(inventory) ? inventory : [];
      const favoriteSet = await PlayerService.getFavoriteIdSet().catch(() => /* @__PURE__ */ new Set());
      const filtered = items.filter((item) => {
        const speciesId = String(item?.species || "");
        if (!speciesId || !allowed.has(speciesId)) return false;
        const id = String(item?.id || "");
        return id && !favoriteSet.has(id);
      });
      if (!filtered.length) {
        await toastSimple("Feed from inventory", "No compatible crops in inventory.", "info");
        return;
      }
      const computeFavoritedIds = (items2) => {
        const allowedIds = /* @__PURE__ */ new Set();
        for (const item of items2) {
          const id = String(item?.id || "");
          if (id) allowedIds.add(id);
        }
        return Array.from(favoriteSet).filter((id) => allowedIds.has(id));
      };
      await clearHandSelection().catch(() => {
      });
      let visibleItems = filtered.slice();
      let favoritedItemIds = computeFavoritedIds(visibleItems);
      await fakeInventoryShow({ items: visibleItems, favoritedItemIds }, { open: true });
      const label2 = pet?.slot?.name || species || petId;
      await toastSimple(
        "Feed from inventory",
        `Showing ${visibleItems.length} compatible crop(s) for ${label2}. Select a crop to feed it immediately.`,
        "info"
      );
      while (true) {
        const selectedIndex = await waitForFakeInventorySelection(2e4);
        if (selectedIndex == null) {
          await toastSimple("Feed from inventory", "No crop selected.", "info");
          break;
        }
        if (selectedIndex < 0 || selectedIndex >= visibleItems.length) {
          await toastSimple("Feed from inventory", "Invalid crop selection.", "error");
          await clearHandSelection().catch(() => {
          });
          continue;
        }
        const chosen = visibleItems[selectedIndex];
        const chosenId = String(chosen?.id || "");
        if (!chosenId) {
          await toastSimple("Feed from inventory", "Invalid crop selection.", "error");
          await clearHandSelection().catch(() => {
          });
          continue;
        }
        const hungerPctBeforeFeed = lastKnownHungerPct;
        await PlayerService.feedPet(petId, chosenId);
        const hungerPct = await waitForHungerIncrease(petId, hungerPctBeforeFeed, {
          initialDelay: 200
        });
        if (hungerPct != null) {
          lastKnownHungerPct = hungerPct;
        }
        const hungerSuffix = hungerPct != null ? ` Hunger: ${formatHungerPct(hungerPct)}%.` : "";
        const cropName = String(chosen?.species || "crop");
        const petLabel = pet?.slot?.name || species || petId;
        await toastSimple(
          "Feed from inventory",
          `Fed ${petLabel} with ${cropName}.${hungerSuffix}`,
          "success"
        );
        const hungerFull = hungerPct != null && hungerPct >= 99.9;
        if (hungerFull) {
          shouldCloseInventory = true;
          try {
            await closeInventoryPanel();
          } catch {
          }
          break;
        }
        let invItems = null;
        try {
          const nextInventory = await PlayerService.getCropInventoryState();
          invItems = Array.isArray(nextInventory) ? nextInventory : null;
        } catch {
          invItems = null;
        }
        let nextVisible = invItems?.filter((item) => {
          const speciesId = String(item?.species || "");
          if (!speciesId || !allowed.has(speciesId)) return false;
          const id = String(item?.id || "");
          return id && !favoriteSet.has(id);
        }) ?? null;
        const removeChosenLocally = () => visibleItems.filter((item) => String(item?.id || "") !== chosenId);
        if (!nextVisible) {
          nextVisible = removeChosenLocally();
        } else {
          const stillContainsChosen = nextVisible.some(
            (item) => String(item?.id || "") === chosenId
          );
          if (stillContainsChosen) {
            nextVisible = removeChosenLocally();
          }
        }
        visibleItems = nextVisible;
        if (!visibleItems.length) {
          await toastSimple("Feed from inventory", "No compatible crops in inventory.", "info");
          shouldCloseInventory = true;
          try {
            await closeInventoryPanel();
          } catch {
          }
          break;
        }
        favoritedItemIds = computeFavoritedIds(visibleItems);
        await fakeInventoryShow({ items: visibleItems, favoritedItemIds }, { open: false });
        await clearHandSelection().catch(() => {
        });
      }
    } catch (err) {
      console.error("[Pet panel] Failed to handle inventory feed", err);
      await toastSimple(
        "Feed from inventory",
        err instanceof Error ? err.message : "Failed to feed pet from inventory.",
        "error"
      );
    } finally {
      try {
        await clearHandSelection();
      } catch {
      }
      if (shouldCloseInventory) {
        try {
          await closeInventoryPanel();
        } catch {
        }
      }
      btn.disabled = prevDisabled;
    }
  }
  async function getExpandedPetId() {
    try {
      const raw = await Atoms.pets.expandedPetSlotId.get();
      const id = typeof raw === "string" ? raw.trim() : "";
      return id.length ? id : null;
    } catch {
      return null;
    }
  }
  async function findPetById2(petId) {
    try {
      const list = await PetsService.getPets();
      const arr = Array.isArray(list) ? list : [];
      return arr.find((p) => String(p?.slot?.id || "") === petId) ?? null;
    } catch (err) {
      console.warn("[Pet panel] Failed to fetch pets", err);
      return null;
    }
  }
  async function getAllowedCrops(petId, species) {
    const defaults = PetsService.getCompatibleCropsForSpecies(species) ?? [];
    return new Set(defaults);
  }
  function formatHungerPct(pct) {
    if (!Number.isFinite(pct)) return "";
    const clamped = Math.max(0, Math.min(100, pct));
    const rounded = Math.round(clamped * 10) / 10;
    return Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
  }
  var HUNGER_EPSILON = 0.05;
  var HUNGER_TIMEOUT_MS = 4e3;
  var HUNGER_POLL_INTERVAL_MS = 120;
  function isPetInfo(value) {
    if (!value || typeof value !== "object") return false;
    const slot = value.slot;
    return !!slot && typeof slot === "object";
  }
  function getHungerPctForPet(pet) {
    if (!isPetInfo(pet)) return null;
    try {
      const hungerPct = PetsService.getHungerPctFor(pet);
      return typeof hungerPct === "number" && Number.isFinite(hungerPct) ? hungerPct : null;
    } catch {
      return null;
    }
  }
  async function getPetHungerPct(petId) {
    try {
      const updatedPet = await findPetById2(petId);
      return getHungerPctForPet(updatedPet);
    } catch {
      return null;
    }
  }
  async function waitForHungerIncrease(petId, previousPct, options = {}) {
    const { initialDelay = 0, timeout = HUNGER_TIMEOUT_MS, interval = HUNGER_POLL_INTERVAL_MS } = options;
    if (initialDelay > 0) {
      await delay3(initialDelay);
    }
    const start = typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now();
    let lastResult = null;
    while (true) {
      const pct = await getPetHungerPct(petId);
      if (pct != null) {
        lastResult = pct;
        if (previousPct == null || pct >= Math.min(100, previousPct + HUNGER_EPSILON) || pct >= 99.9) {
          return pct;
        }
      }
      const now2 = typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now();
      if (now2 - start >= timeout) {
        return lastResult;
      }
      if (interval > 0) {
        await delay3(interval);
      }
    }
  }
  function delay3(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  async function waitForFakeInventorySelection(timeoutMs = 2e4) {
    const start = performance.now();
    while (performance.now() - start < timeoutMs) {
      try {
        const modalVal = await Atoms.ui.activeModal.get();
        if (!isInventoryOpen(modalVal)) return null;
      } catch {
        return null;
      }
      try {
        const value = await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.get();
        if (typeof value === "number" && Number.isInteger(value) && value >= 0) {
          return value;
        }
      } catch {
      }
      await new Promise((resolve2) => setTimeout(resolve2, 80));
    }
    return null;
  }

  // src/utils/inventorySelectionLogger.ts
  var started2 = false;
  var cachedItems = [];
  var currentIndex = null;
  var lastLoggedQuantity = void 0;
  var desiredButtonQuantity = null;
  var buttonDiscoveryObserver = null;
  var buttonVisibilityObserver = null;
  function getActionButton() {
    if (typeof document === "undefined") return null;
    const primaryButton = document.querySelector(
      "button.chakra-button.css-w004xu"
    );
    if (primaryButton) return primaryButton;
    const growButtons = Array.from(
      document.querySelectorAll(
        "button.chakra-button.css-35ruvm"
      )
    );
    return growButtons.find(
      (button) => (button.textContent ?? "").includes("Grow")
    ) ?? null;
  }
  function applyQuantityToButton(button, quantity) {
    const quantityContainer = button.querySelector(".css-telpzl");
    const readButtonLabel = () => {
      const clone = button.cloneNode(true);
      clone.querySelectorAll(".css-telpzl").forEach((element) => element.remove());
      return (clone.textContent ?? "").replace(/\s+/g, " ").trim();
    };
    const ensureBaseLabel = () => {
      const existing = button.dataset.baseLabel ?? "";
      const lastQuantity = button.dataset.lastQuantity;
      const currentLabel = readButtonLabel();
      const normalizedCurrentLabel = (() => {
        if (!currentLabel) return "";
        if (lastQuantity && lastQuantity.length > 0) {
          const withSpace = ` \xD7${lastQuantity}`;
          if (currentLabel.endsWith(withSpace)) {
            return currentLabel.slice(0, -withSpace.length).replace(/\s+$/, "");
          }
          const withoutSpace = `\xD7${lastQuantity}`;
          if (currentLabel.endsWith(withoutSpace)) {
            return currentLabel.slice(0, -withoutSpace.length).replace(/\s+$/, "");
          }
        }
        return currentLabel;
      })();
      if (normalizedCurrentLabel && normalizedCurrentLabel !== existing) {
        button.dataset.baseLabel = normalizedCurrentLabel;
        return normalizedCurrentLabel;
      }
      if (!existing && normalizedCurrentLabel) {
        button.dataset.baseLabel = normalizedCurrentLabel;
        return normalizedCurrentLabel;
      }
      return existing;
    };
    const setButtonLabel = (label2) => {
      const contentNode = Array.from(button.childNodes).find((node) => {
        if (quantityContainer && node === quantityContainer) return false;
        const text = node.textContent ?? "";
        return text.trim().length > 0;
      });
      if (contentNode) {
        contentNode.textContent = label2;
        return;
      }
      const referenceNode = quantityContainer ?? button.firstChild;
      button.insertBefore(document.createTextNode(label2), referenceNode ?? null);
    };
    const baseLabel = ensureBaseLabel();
    if (quantityContainer) {
      quantityContainer.textContent = "";
      quantityContainer.style.marginLeft = "";
      quantityContainer.style.display = "none";
    }
    if (quantity == null) {
      button.dataset.lastQuantity = "";
      setButtonLabel(baseLabel);
      return;
    }
    const labelWithQuantity = baseLabel ? `${baseLabel} \xD7${quantity}` : `\xD7${quantity}`;
    button.dataset.lastQuantity = String(quantity);
    setButtonLabel(labelWithQuantity);
  }
  function ensureButtonVisibilityObserver(button) {
    if (typeof IntersectionObserver === "undefined") return;
    if (!buttonVisibilityObserver) {
      buttonVisibilityObserver = new IntersectionObserver((entries) => {
        entries.filter((entry) => entry.isIntersecting).forEach((entry) => {
          applyQuantityToButton(entry.target, desiredButtonQuantity);
        });
      });
    } else {
      buttonVisibilityObserver.disconnect();
    }
    buttonVisibilityObserver.observe(button);
  }
  function ensureButtonDiscoveryObserver() {
    if (typeof document === "undefined") return;
    if (buttonDiscoveryObserver || typeof MutationObserver === "undefined") return;
    const target = document.body;
    if (!target) return;
    buttonDiscoveryObserver = new MutationObserver(() => {
      const button = getActionButton();
      if (!button) return;
      ensureButtonVisibilityObserver(button);
      applyQuantityToButton(button, desiredButtonQuantity);
    });
    buttonDiscoveryObserver.observe(target, { childList: true, subtree: true });
  }
  function updateButtonQuantity(quantity) {
    if (typeof document === "undefined") return;
    desiredButtonQuantity = quantity;
    const button = getActionButton();
    if (!button) {
      ensureButtonDiscoveryObserver();
      return;
    }
    ensureButtonVisibilityObserver(button);
    applyQuantityToButton(button, quantity);
  }
  function normalizeItems(snapshot) {
    if (!snapshot || !Array.isArray(snapshot.items)) return [];
    return snapshot.items.slice();
  }
  function extractQuantity(index) {
    if (index == null || index < 0 || index >= cachedItems.length) return null;
    const raw = cachedItems[index];
    if (!raw) return null;
    const qty = Number(raw.quantity);
    return Number.isFinite(qty) ? qty : null;
  }
  function logQuantity(force = false) {
    if (currentIndex == null) {
      updateButtonQuantity(null);
      lastLoggedQuantity = null;
      return;
    }
    const qty = extractQuantity(currentIndex);
    if (!force && qty === lastLoggedQuantity) return;
    updateButtonQuantity(qty);
    lastLoggedQuantity = qty;
  }
  async function readInventory() {
    try {
      return await Atoms.inventory.myInventory.get();
    } catch (error) {
      return null;
    }
  }
  async function readSelectedIndex() {
    try {
      const value = await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.get();
      return typeof value === "number" ? value : null;
    } catch (error) {
      return null;
    }
  }
  async function startSelectedInventoryQuantityLogger() {
    if (started2) return;
    started2 = true;
    cachedItems = normalizeItems(await readInventory());
    currentIndex = await readSelectedIndex();
    logQuantity(true);
    try {
      await Atoms.inventory.myInventory.onChange((next) => {
        cachedItems = normalizeItems(next);
        logQuantity();
      });
    } catch (error) {
    }
    try {
      await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.onChange((next) => {
        if (typeof next === "number") {
          currentIndex = next;
        } else {
          currentIndex = null;
        }
        lastLoggedQuantity = null;
        logQuantity(true);
      });
    } catch (error) {
    }
  }

  // src/utils/checkModal.ts
  var DEFAULTS4 = {
    intervalMs: 6e4,
    log: false
  };
  var normalize = (s) => (s || "").replace(/\s+/g, " ").trim();
  var reGameUpdate = /game\s*update\s+ava?ilab?le/i;
  var reDailyBread = /your\s+daily\s+bread/i;
  var log = (enabled, ...args) => {
    if (enabled) console.log("[checkModal]", ...args);
  };
  var reloadScheduled = false;
  var schedulePageReload = (doLog) => {
    if (reloadScheduled) return;
    reloadScheduled = true;
    log(doLog, "Game Update: \u267B\uFE0F rechargement de la page dans un instant...");
    pageWindow.setTimeout(() => {
      log(doLog, "Game Update: \u{1F504} rechargement maintenant.");
      pageWindow.location.reload();
    }, 500);
  };
  var isVisible = (el2) => {
    if (!el2 || !(el2 instanceof HTMLElement)) return false;
    const rect = el2.getBoundingClientRect();
    if (rect.width <= 0 || rect.height <= 0) return false;
    const cs = getComputedStyle(el2);
    if (cs.display === "none" || cs.visibility === "hidden" || parseFloat(cs.opacity) === 0) return false;
    let cur = el2;
    while (cur) {
      const cs2 = getComputedStyle(cur);
      if (cs2.display === "none" || cs2.visibility === "hidden") return false;
      cur = cur.parentElement;
    }
    return true;
  };
  function findGameUpdateModal() {
    const sections = document.querySelectorAll(
      'section.chakra-modal__content[role="dialog"], section.chakra-modal__content[role="alertdialog"]'
    );
    for (const sec of sections) {
      const header = sec.querySelector("header.chakra-modal__header");
      const txt = normalize(header?.textContent || sec.textContent || "");
      if (reGameUpdate.test(txt)) return sec;
    }
    return null;
  }
  function findBreadModal() {
    const sections = document.querySelectorAll(
      'section.chakra-modal__content[role="dialog"], section.chakra-modal__content[role="alertdialog"]'
    );
    for (const sec of sections) {
      const txt = normalize(sec.textContent || "");
      if (!reDailyBread.test(txt)) continue;
      let btn = sec.querySelector("button.chakra-button.css-1o32am8");
      if (!btn) {
        const candidates = sec.querySelectorAll("button");
        btn = Array.from(candidates).find((b) => /claim/i.test(normalize(b.textContent))) ?? null;
      }
      if (btn) return { section: sec, button: btn };
    }
    return null;
  }
  var clickedBreadButtons = /* @__PURE__ */ new WeakSet();
  function clickBreadIfVisible(btn, doLog) {
    if (clickedBreadButtons.has(btn)) {
      log(doLog, "Bread: bouton d\xE9j\xE0 cliqu\xE9 (guard).");
      return false;
    }
    const ariaDisabled = btn.getAttribute("aria-disabled");
    if (btn.disabled || ariaDisabled === "true") {
      log(doLog, "Bread: bouton d\xE9sactiv\xE9.");
      return false;
    }
    if (!isVisible(btn)) {
      log(doLog, "Bread: bouton non visible.");
      return false;
    }
    btn.click();
    clickedBreadButtons.add(btn);
    log(doLog, "Bread: \u2705 click() envoy\xE9.");
    return true;
  }
  function checkOnce(opts) {
    const { log: doLog } = { ...DEFAULTS4, ...opts };
    const gameUpdateSec = findGameUpdateModal();
    const gameUpdateFound = !!gameUpdateSec;
    if (gameUpdateFound) {
      log(doLog, "Game Update: \u2705 d\xE9tect\xE9.", gameUpdateSec);
      schedulePageReload(doLog);
    }
    const found = findBreadModal();
    const breadFound = !!found;
    let breadClicked = false;
    if (found) {
      log(doLog, "Daily Bread: \u2705 d\xE9tect\xE9.", found.section);
      breadClicked = clickBreadIfVisible(found.button, doLog);
    }
    if (!gameUpdateFound && !breadFound) log(doLog, "Rien d\xE9tect\xE9 pour l\u2019instant.");
    return { gameUpdateFound, breadFound, breadClicked };
  }
  function startModalObserver(options) {
    const { intervalMs, log: doLog } = { ...DEFAULTS4, ...options };
    let stopped = false;
    const tick = () => {
      if (stopped) return { gameUpdateFound: false, breadFound: false, breadClicked: false };
      return checkOnce({ log: doLog });
    };
    tick();
    const timer = pageWindow.setInterval(tick, intervalMs);
    const stop2 = () => {
      if (stopped) return;
      stopped = true;
      pageWindow.clearInterval(timer);
      log(doLog, "\u23F9\uFE0F Observateur arr\xEAt\xE9.");
    };
    log(doLog, `\u25B6\uFE0F Observateur d\xE9marr\xE9 (intervalle: ${intervalMs} ms).`);
    return { stop: stop2, tick };
  }
  var exposed = {
    startModalObserver,
    checkOnce,
    findGameUpdateModal,
    findBreadModal
  };
  shareGlobal("CheckModal", exposed);

  // src/utils/petCalcul.ts
  var SEC_PER_HOUR = 3600;
  var XP_STRENGTH_MAX = 30;
  var BASE_STRENGTH_FLOOR = 30;
  var getCatalogEntry = (species) => {
    if (!species) return null;
    const entry = petCatalog[species];
    return entry ?? null;
  };
  var getMutationEntry = (mutation) => {
    if (!mutation) return null;
    const entry = mutationCatalog[mutation];
    return entry ?? null;
  };
  var getTargetScale = (pet) => {
    const raw = pet?.targetScale;
    return typeof raw === "number" && Number.isFinite(raw) ? raw : 1;
  };
  var getXp = (pet) => {
    const raw = pet?.xp;
    return typeof raw === "number" && Number.isFinite(raw) ? Math.max(0, raw) : 0;
  };
  var getPetMaxStrength = (pet) => {
    const entry = getCatalogEntry(pet?.petSpecies ?? "");
    if (!entry) return 0;
    const maxScale = typeof entry.maxScale === "number" && entry.maxScale > 1 ? entry.maxScale : 1;
    const targetScale = getTargetScale(pet);
    const ratio = maxScale > 1 ? (targetScale - 1) / (maxScale - 1) : 0;
    const raw = ratio * 20 + 80;
    const strength = Math.floor(Number.isFinite(raw) ? raw : 0);
    return Math.max(strength, 0);
  };
  var getBaseStrength = (maxStrength) => {
    const base = maxStrength - BASE_STRENGTH_FLOOR;
    return Math.max(base, 0);
  };
  var getPetStrength = (pet) => {
    const entry = getCatalogEntry(pet?.petSpecies ?? "");
    if (!entry) return 0;
    const hoursToMature = typeof entry.hoursToMature === "number" && entry.hoursToMature > 0 ? entry.hoursToMature : 1;
    const maxStrength = getPetMaxStrength(pet);
    if (maxStrength <= 0) return 0;
    const xpRate = getXp(pet) / (hoursToMature * SEC_PER_HOUR);
    const xpComponent = Math.min(Math.floor(xpRate * XP_STRENGTH_MAX), XP_STRENGTH_MAX);
    const baseStrength = getBaseStrength(maxStrength);
    const strength = Math.min(baseStrength + xpComponent, maxStrength);
    return Math.max(strength, 0);
  };
  var getPetCoinMultiplier = (pet) => {
    const mutations = Array.isArray(pet?.mutations) ? pet.mutations : [];
    return mutations.reduce((acc, mutation) => {
      const entry = getMutationEntry(mutation);
      const multiplier = entry?.coinMultiplier;
      if (typeof multiplier === "number" && Number.isFinite(multiplier) && multiplier > 0) {
        return acc * multiplier;
      }
      return acc;
    }, 1);
  };
  var getPetValue = (pet) => {
    const entry = getCatalogEntry(pet?.petSpecies ?? "");
    if (!entry) return 0;
    const maturitySellPrice = typeof entry.maturitySellPrice === "number" ? entry.maturitySellPrice : 0;
    const maxStrength = getPetMaxStrength(pet);
    if (maxStrength <= 0) return 0;
    const strength = getPetStrength(pet);
    const targetScale = getTargetScale(pet);
    const coinMultiplier = getPetCoinMultiplier(pet);
    const raw = maturitySellPrice * (strength / maxStrength) * targetScale * coinMultiplier;
    if (!Number.isFinite(raw)) return 0;
    return Math.round(Math.max(raw, 0));
  };
  var getPetInfo = (pet) => ({
    value: getPetValue(pet),
    strength: getPetStrength(pet),
    maxStrength: getPetMaxStrength(pet),
    coinMultiplier: getPetCoinMultiplier(pet)
  });

  // src/utils/inventoryValue.ts
  var INVENTORY_VALUE_CATEGORIES = [
    {
      itemType: "Seed",
      identifierKey: "species",
      resolveCoinPrice: (identifier) => {
        if (!identifier) return null;
        const entry = plantCatalog[identifier];
        const price = entry?.seed?.coinPrice;
        return getFiniteNumber(price);
      },
      logKey: "seeds",
      emptyLogMessage: "[InventorySorting] Aucune seed trouv\xE9e dans l'inventaire pour le calcul de valeur.",
      createEntry: (identifier, quantity, coinPrice, value) => ({
        species: identifier,
        quantity,
        coinPrice,
        value
      })
    },
    {
      itemType: "Tool",
      identifierKey: "toolId",
      resolveCoinPrice: (identifier) => {
        if (!identifier) return null;
        const entry = toolCatalog[identifier];
        const price = entry?.coinPrice;
        return getFiniteNumber(price);
      },
      logKey: "tools",
      emptyLogMessage: "[InventorySorting] Aucun tool trouv\xE9 dans l'inventaire pour le calcul de valeur.",
      createEntry: (identifier, quantity, coinPrice, value) => ({
        toolId: identifier,
        quantity,
        coinPrice,
        value
      })
    },
    {
      itemType: "Egg",
      identifierKey: "eggId",
      resolveCoinPrice: (identifier) => {
        if (!identifier) return null;
        const entry = eggCatalog[identifier];
        const price = entry?.coinPrice;
        return getFiniteNumber(price);
      },
      logKey: "eggs",
      emptyLogMessage: "[InventorySorting] Aucun egg trouv\xE9 dans l'inventaire pour le calcul de valeur.",
      createEntry: (identifier, quantity, coinPrice, value) => ({
        eggId: identifier,
        quantity,
        coinPrice,
        value
      })
    },
    {
      itemType: "Decor",
      identifierKey: "decorId",
      resolveCoinPrice: (identifier) => {
        if (!identifier) return null;
        const entry = decorCatalog[identifier];
        const price = entry?.coinPrice;
        return getFiniteNumber(price);
      },
      logKey: "decors",
      emptyLogMessage: "[InventorySorting] Aucun decor trouv\xE9 dans l'inventaire pour le calcul de valeur.",
      createEntry: (identifier, quantity, coinPrice, value) => ({
        decorId: identifier,
        quantity,
        coinPrice,
        value
      })
    }
  ];
  var currentSnapshot = null;
  var watcherPromise = null;
  var unsubscribe = null;
  var computeCounter = 0;
  var listeners3 = /* @__PURE__ */ new Set();
  function getFiniteNumber(value) {
    if (typeof value === "number") {
      return Number.isFinite(value) ? value : null;
    }
    if (typeof value === "string" && value.trim()) {
      const parsed = Number(value);
      return Number.isFinite(parsed) ? parsed : null;
    }
    return null;
  }
  function extractItems(inventory) {
    if (!inventory || typeof inventory !== "object") return null;
    const items = inventory.items;
    if (!Array.isArray(items)) return [];
    return items;
  }
  function toNormalizedIdentifier(raw) {
    if (typeof raw === "string") {
      const trimmed = raw.trim();
      return trimmed ? trimmed : null;
    }
    if (typeof raw === "number") {
      return Number.isFinite(raw) ? String(raw) : null;
    }
    return null;
  }
  function getInventoryValueCategoryByItemType(itemType) {
    return INVENTORY_VALUE_CATEGORIES.find((config) => config.itemType === itemType);
  }
  function computeInventoryItemValue(item, context = {}) {
    if (!item || typeof item !== "object") return null;
    const rawType = typeof item?.itemType === "string" ? item.itemType.trim() : "";
    if (!rawType) return null;
    switch (rawType) {
      case "Pet": {
        const info = getPetInfo(item);
        const value = info.value;
        return typeof value === "number" && Number.isFinite(value) ? value : null;
      }
      case "Plant": {
        const slots = Array.isArray(item?.slots) ? item.slots : [];
        const playersInRoom = context.playersInRoom ?? void 0;
        let total = 0;
        for (const slot of slots) {
          const slotSpecies = typeof slot?.species === "string" ? slot.species : null;
          const rawTarget = slot?.targetScale;
          const target = Number.isFinite(rawTarget) ? rawTarget : Number(rawTarget);
          const targetScale = Number.isFinite(target) ? target : null;
          const mutations = Array.isArray(slot?.mutations) ? slot.mutations.filter((m) => typeof m === "string") : [];
          if (!slotSpecies || targetScale == null) continue;
          const value = estimateProduceValue(slotSpecies, targetScale, mutations, {
            friendPlayers: playersInRoom
          });
          if (typeof value === "number" && Number.isFinite(value)) {
            total += value;
          }
        }
        return total;
      }
      case "Produce": {
        const playersInRoom = context.playersInRoom ?? void 0;
        const value = valueFromInventoryProduce(item, void 0, playersInRoom);
        return typeof value === "number" && Number.isFinite(value) ? value : null;
      }
      default: {
        const category = getInventoryValueCategoryByItemType(rawType);
        if (!category) return null;
        const identifier = toNormalizedIdentifier(item?.[category.identifierKey]);
        const quantity = getFiniteNumber(item?.quantity);
        const coinPrice = category.resolveCoinPrice(identifier);
        if (quantity == null || coinPrice == null) return null;
        const value = coinPrice * quantity;
        return Number.isFinite(value) ? value : null;
      }
    }
  }
  function computePetValues(items) {
    const pets = items.filter((item) => {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      return type === "Pet";
    });
    const entries = pets.map((pet) => {
      const info = getPetInfo(pet);
      const id = typeof pet?.id === "string" ? pet.id : null;
      const name = typeof pet?.name === "string" && pet.name.trim() ? pet.name : null;
      const species = typeof pet?.petSpecies === "string" ? pet.petSpecies : null;
      return {
        id,
        name,
        petSpecies: species,
        value: info.value,
        strength: info.strength,
        maxStrength: info.maxStrength,
        coinMultiplier: info.coinMultiplier
      };
    });
    const totalValue = entries.reduce(
      (acc, entry) => acc + (Number.isFinite(entry.value) ? entry.value : 0),
      0
    );
    return { totalValue, pets: entries };
  }
  function computePlantValues(items, playersInRoom) {
    const plants = items.filter((item) => {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      return type === "Plant";
    });
    const entries = plants.map((plant) => {
      const id = typeof plant?.id === "string" ? plant.id : null;
      const species = typeof plant?.species === "string" ? plant.species : null;
      const plantedAt = Number.isFinite(plant?.plantedAt) ? plant.plantedAt : null;
      const maturedAt = Number.isFinite(plant?.maturedAt) ? plant.maturedAt : null;
      const slots = Array.isArray(plant?.slots) ? plant.slots : [];
      const slotEntries = slots.map((slot) => {
        const slotSpecies = typeof slot?.species === "string" ? slot.species : null;
        const targetScaleRaw = slot?.targetScale;
        const targetScale = Number.isFinite(targetScaleRaw) ? targetScaleRaw : Number(targetScaleRaw);
        const scaleValue = Number.isFinite(targetScale) ? targetScale : null;
        const mutations = Array.isArray(slot?.mutations) ? slot.mutations.filter((m) => typeof m === "string") : [];
        const value2 = slotSpecies && scaleValue != null ? estimateProduceValue(slotSpecies, scaleValue, mutations, {
          friendPlayers: playersInRoom
        }) : 0;
        return {
          species: slotSpecies,
          targetScale: scaleValue,
          mutations,
          value: value2
        };
      });
      const value = slotEntries.reduce(
        (acc, entry) => acc + (Number.isFinite(entry.value) ? entry.value : 0),
        0
      );
      return {
        id,
        species,
        plantedAt,
        maturedAt,
        value,
        slots: slotEntries
      };
    });
    const totalValue = entries.reduce(
      (acc, entry) => acc + (Number.isFinite(entry.value) ? entry.value : 0),
      0
    );
    return {
      totalValue,
      playersInRoom: Number.isFinite(playersInRoom) ? playersInRoom : null,
      plants: entries
    };
  }
  function computeCropValues(items, playersInRoom) {
    const crops = items.filter((item) => {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      return type === "Produce";
    });
    const entries = crops.map((crop) => {
      const id = typeof crop?.id === "string" ? crop.id : null;
      const species = typeof crop?.species === "string" ? crop.species : null;
      const rawScale = crop?.scale;
      const scale = Number.isFinite(rawScale) ? rawScale : Number(rawScale);
      const scaleValue = Number.isFinite(scale) ? scale : null;
      const mutations = Array.isArray(crop?.mutations) ? crop.mutations.filter((m) => typeof m === "string") : [];
      const value = valueFromInventoryProduce(crop, void 0, playersInRoom);
      return {
        id,
        species,
        scale: scaleValue,
        mutations,
        value
      };
    });
    const totalValue = entries.reduce(
      (acc, entry) => acc + (Number.isFinite(entry.value) ? entry.value : 0),
      0
    );
    return { totalValue, crops: entries };
  }
  function computeMiscValues(items) {
    const aggregated = {
      seeds: { totalValue: 0, items: [] },
      tools: { totalValue: 0, items: [] },
      eggs: { totalValue: 0, items: [] },
      decors: { totalValue: 0, items: [] }
    };
    for (const config of INVENTORY_VALUE_CATEGORIES) {
      const filteredItems = items.filter((item) => {
        const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
        return type === config.itemType;
      });
      const entries = filteredItems.map((item) => {
        const rawIdentifier = item?.[config.identifierKey];
        const identifier = toNormalizedIdentifier(rawIdentifier);
        const rawQuantity = item?.quantity;
        const quantity = getFiniteNumber(rawQuantity);
        const coinPrice = config.resolveCoinPrice(identifier);
        const value = quantity != null && coinPrice != null ? coinPrice * quantity : null;
        return config.createEntry(identifier, quantity, coinPrice, value);
      });
      const totalValue = entries.reduce((acc, entry) => {
        const entryValue = entry.value;
        return typeof entryValue === "number" && Number.isFinite(entryValue) ? acc + entryValue : acc;
      }, 0);
      aggregated[config.logKey] = { totalValue, items: entries };
    }
    return aggregated;
  }
  async function resolvePlayersInRoom() {
    try {
      const rawPlayers = await Atoms.server.numPlayers.get();
      return Number.isFinite(rawPlayers) ? rawPlayers : void 0;
    } catch {
      return void 0;
    }
  }
  async function computeSnapshotFromInventory(inventory) {
    const items = extractItems(inventory);
    if (items === null) return null;
    const safeItems = items ?? [];
    const playersInRoom = await resolvePlayersInRoom();
    return {
      pets: computePetValues(safeItems),
      plants: computePlantValues(safeItems, playersInRoom),
      crops: computeCropValues(safeItems, playersInRoom),
      misc: computeMiscValues(safeItems)
    };
  }
  function notifyListeners(snapshot) {
    for (const listener of listeners3) {
      try {
        listener(snapshot);
      } catch (error) {
        console.warn("[InventoryValue] Listener error", error);
      }
    }
  }
  async function refreshSnapshot(nextInventory) {
    const computeId = ++computeCounter;
    try {
      const snapshot = await computeSnapshotFromInventory(nextInventory);
      if (computeId !== computeCounter) return;
      currentSnapshot = snapshot;
      notifyListeners(currentSnapshot);
    } catch (error) {
      if (computeId !== computeCounter) return;
      currentSnapshot = null;
      console.warn("[InventoryValue] Impossible de calculer la valeur de l'inventaire", error);
    }
  }
  async function ensureInventoryValueWatcher() {
    if (watcherPromise) return watcherPromise;
    watcherPromise = (async () => {
      try {
        const inventory = await Atoms.inventory.myInventory.get();
        await refreshSnapshot(inventory);
      } catch (error) {
        currentSnapshot = null;
        console.warn("[InventoryValue] Impossible de r\xE9cup\xE9rer l'inventaire initial", error);
      }
      try {
        unsubscribe = await Atoms.inventory.myInventory.onChange((next) => {
          void refreshSnapshot(next);
        });
      } catch (error) {
        console.warn("[InventoryValue] Impossible de s'abonner \xE0 myInventory", error);
      }
    })();
    return watcherPromise;
  }
  function getInventoryValueSnapshot() {
    return currentSnapshot;
  }
  function onInventoryValueChange(listener) {
    listeners3.add(listener);
    return () => {
      listeners3.delete(listener);
    };
  }

  // src/utils/inventorySorting.ts
  var DEFAULTS5 = {
    // Updated to new Inventory root grid container (game UI update)
    gridSelector: "div.McGrid.css-1kv58ap",
    filtersBlockSelector: ".McGrid.css-o1vp12",
    closeButtonSelector: "button.css-vuqwsg",
    checkboxSelector: "label.chakra-checkbox.css-1v6h4z7",
    checkboxLabelSelector: ".chakra-checkbox__label",
    injectDarkStyles: true
  };
  var INVENTORY_SEARCH_INPUT_SELECTOR = "input.chakra-input.css-8e1l1i";
  var BASE_SORT = ["alpha", "qty", "rarity", "value"];
  var ORDER = [
    "none",
    "alpha",
    "qty",
    "rarity",
    "value",
    "size",
    "mutations",
    "strength"
  ];
  var SORT_STORAGE_KEY = "mg-mod.inventory.sortKey";
  var SORT_KEY_SET = new Set(ORDER);
  var SORT_DIRECTION_STORAGE_KEY = "mg-mod.inventory.sortDirection";
  var SORT_DIRECTION_SET = /* @__PURE__ */ new Set(["asc", "desc"]);
  var DEFAULT_DIRECTION_LABEL = "Order:";
  var DIRECTION_LABELS_DEFAULT = {
    asc: "Ascending",
    desc: "Descending"
  };
  var getPetAbilityDisplayName = (abilityId) => {
    if (typeof abilityId !== "string") return null;
    const trimmedId = abilityId.trim();
    if (!trimmedId) return null;
    const ability = petAbilities[trimmedId] ?? null;
    const name = ability?.name;
    if (typeof name !== "string") return null;
    const trimmedName = name.trim();
    return trimmedName ? trimmedName : null;
  };
  var INVENTORY_VALUE_VISIBILITY_STORAGE_KEY = "mg-mod.inventory.showValues";
  var loadPersistedInventoryValueVisibility = () => {
    if (typeof window === "undefined") return null;
    try {
      const stored = window.localStorage?.getItem(INVENTORY_VALUE_VISIBILITY_STORAGE_KEY) ?? null;
      if (stored === "1") return true;
      if (stored === "0") return false;
      return null;
    } catch (error) {
      console.warn(
        "[InventorySorting] Impossible de lire la pr\xE9f\xE9rence d'affichage des valeurs d'inventaire",
        error
      );
      return null;
    }
  };
  var persistInventoryValueVisibility = (visible) => {
    if (typeof window === "undefined") return;
    try {
      window.localStorage?.setItem(INVENTORY_VALUE_VISIBILITY_STORAGE_KEY, visible ? "1" : "0");
    } catch (error) {
      console.warn(
        "[InventorySorting] Impossible de sauvegarder la pr\xE9f\xE9rence d'affichage des valeurs d'inventaire",
        error
      );
    }
  };
  var shouldDisplayInventoryValues = true;
  var setShouldDisplayInventoryValues = (visible) => {
    shouldDisplayInventoryValues = visible;
  };
  var getShouldDisplayInventoryValues = () => shouldDisplayInventoryValues;
  var DEFAULT_DIRECTION_BY_SORT_KEY = {
    none: "asc",
    alpha: "asc",
    qty: "desc",
    rarity: "asc",
    value: "desc",
    size: "desc",
    mutations: "desc",
    strength: "desc"
  };
  var DIRECTION_ORDER = ["asc", "desc"];
  var isPersistedSortKey = (value) => typeof value === "string" && SORT_KEY_SET.has(value);
  var isPersistedSortDirection = (value) => typeof value === "string" && SORT_DIRECTION_SET.has(value);
  var loadPersistedSortKey = () => {
    if (typeof window === "undefined") return null;
    try {
      const stored = window.localStorage?.getItem(SORT_STORAGE_KEY) ?? null;
      return isPersistedSortKey(stored) ? stored : null;
    } catch (error) {
      console.warn("[InventorySorting] Impossible de lire la valeur de tri persist\xE9e", error);
      return null;
    }
  };
  var persistSortKey = (value) => {
    if (typeof window === "undefined") return;
    try {
      window.localStorage?.setItem(SORT_STORAGE_KEY, value);
    } catch (error) {
      console.warn("[InventorySorting] Impossible de sauvegarder la valeur de tri", error);
    }
  };
  var loadPersistedSortDirection = () => {
    if (typeof window === "undefined") return null;
    try {
      const stored = window.localStorage?.getItem(SORT_DIRECTION_STORAGE_KEY) ?? null;
      return isPersistedSortDirection(stored) ? stored : null;
    } catch (error) {
      console.warn("[InventorySorting] Impossible de lire l'ordre de tri persist\xE9", error);
      return null;
    }
  };
  var persistSortDirection = (value) => {
    if (typeof window === "undefined") return;
    try {
      window.localStorage?.setItem(SORT_DIRECTION_STORAGE_KEY, value);
    } catch (error) {
      console.warn("[InventorySorting] Impossible de sauvegarder l'ordre de tri", error);
    }
  };
  var MAP_EXTRA_BY_FILTER_DEFAULT = {
    // seed/tool/ decor = tri de base
    seed: [],
    tool: [],
    decor: [],
    // crop/plant = base + size/mutations
    crop: ["size", "mutations"],
    produce: ["size", "mutations"],
    plant: [],
    // pet = base + size/mutations/strength
    pet: ["mutations", "strength"]
  };
  var FILTER_CONTEXT_ITEM_TYPES_CACHE = /* @__PURE__ */ new Map();
  var FILTER_CONTEXT_LISTENERS = /* @__PURE__ */ new Set();
  var addFilterContextListener = (listener) => {
    FILTER_CONTEXT_LISTENERS.add(listener);
    return () => {
      FILTER_CONTEXT_LISTENERS.delete(listener);
    };
  };
  var notifyFilterContextListeners = (contextKey) => {
    FILTER_CONTEXT_LISTENERS.forEach((listener) => {
      try {
        listener(contextKey);
      } catch (error) {
        console.warn("[InventorySorting] Listener de contexte de filtre en erreur", error);
      }
    });
  };
  var LABEL_BY_VALUE_DEFAULT = {
    none: "None",
    alpha: "A\u2013Z",
    qty: "Quantity",
    rarity: "Rarity",
    value: "Values",
    size: "Size",
    mutations: "Mutations",
    strength: "Strength"
  };
  var INVENTORY_BASE_INDEX_DATASET_KEY = "tmInventoryBaseIndex";
  var INVENTORY_ITEMS_CONTAINER_SELECTOR = ".McFlex.css-zo8r2v";
  var INVENTORY_VALUE_CONTAINER_SELECTOR = ".McFlex.css-1p00rng";
  var INVENTORY_VALUE_ELEMENT_CLASS = "tm-inventory-item-value";
  var INVENTORY_VALUE_TEXT_CLASS = `${INVENTORY_VALUE_ELEMENT_CLASS}__text`;
  var INVENTORY_VALUE_DATASET_KEY = "tmInventoryValue";
  var FILTERED_VALUE_LOADING = "\u2026";
  var FILTERED_VALUE_UNKNOWN = "\u2014";
  var VALUE_SUMMARY_ICON_CLASS = "tm-value-toggle__summary-icon";
  var VALUE_SUMMARY_TEXT_CLASS = "tm-value-toggle__summary-text";
  var VALUE_SUMMARY_ICON_SRC = (() => {
    const src = coin?.img64 ?? "";
    if (typeof src !== "string" || !src) {
      return "";
    }
    return src.startsWith("data:") ? src : `data:image/png;base64,${src}`;
  })();
  function createDomSnapshot(entries) {
    return entries.map((entry) => entry.wrapper);
  }
  function haveDomEntriesChanged(previous, nextEntries) {
    if (!previous) return true;
    if (previous.length !== nextEntries.length) return true;
    for (let i = 0; i < nextEntries.length; i++) {
      if (previous[i] !== nextEntries[i].wrapper) {
        return true;
      }
    }
    return false;
  }
  var debounce = (fn, wait = 120) => {
    let t;
    return (...args) => {
      if (t) window.clearTimeout(t);
      t = window.setTimeout(() => fn(...args), wait);
    };
  };
  function isVisible2(el2) {
    if (!el2 || !document.contains(el2)) return false;
    const r = el2.getBoundingClientRect();
    const cs = getComputedStyle(el2);
    if (cs.display === "none" || cs.visibility === "hidden" || cs.opacity === "0") return false;
    return r.width > 0 && r.height > 0;
  }
  var labelIsChecked = (el2) => el2.matches("[data-checked]") || !!el2.querySelector("[data-checked]");
  var normalize2 = (s) => (s ?? "").trim().toLowerCase();
  var createFilterContextKey = (filters, search) => {
    const normalizedFilters = filters.map((value) => normalize2(value)).filter((value) => value && value !== "all");
    normalizedFilters.sort();
    const normalizedSearch = normalize2(search);
    return `${normalizedFilters.join("|")}::${normalizedSearch}`;
  };
  var areSetsEqual = (a, b) => {
    if (a === b) return true;
    if (!a || !b || a.size !== b.size) return false;
    for (const value of a) {
      if (!b.has(value)) return false;
    }
    return true;
  };
  var getCachedItemTypesForKey = (contextKey) => {
    return FILTER_CONTEXT_ITEM_TYPES_CACHE.get(contextKey) ?? null;
  };
  var getCachedItemTypesForContext = (filters, search) => {
    const key2 = createFilterContextKey(filters, search);
    return getCachedItemTypesForKey(key2);
  };
  var setCachedItemTypesForKey = (contextKey, types) => {
    const normalizedTypes = /* @__PURE__ */ new Set();
    types.forEach((type) => {
      const normalizedType = normalize2(type);
      if (normalizedType) {
        normalizedTypes.add(normalizedType);
      }
    });
    const previous = FILTER_CONTEXT_ITEM_TYPES_CACHE.get(contextKey) ?? null;
    if (previous && areSetsEqual(previous, normalizedTypes)) {
      return;
    }
    FILTER_CONTEXT_ITEM_TYPES_CACHE.set(contextKey, normalizedTypes);
    notifyFilterContextListeners(contextKey);
  };
  var getInventorySearchInput = (grid) => {
    if (!grid) return null;
    const input = grid.querySelector(INVENTORY_SEARCH_INPUT_SELECTOR);
    return input ?? null;
  };
  var getInventorySearchQuery = (grid) => {
    const input = getInventorySearchInput(grid);
    return typeof input?.value === "string" ? input.value : "";
  };
  var getNormalizedInventorySearchQuery = (grid) => normalize2(getInventorySearchQuery(grid));
  var logFilteredInventorySearchResults = async (grid, filters, searchQuery) => {
    if (!grid) return;
    try {
      const inventory = await Atoms.inventory.myInventory.get();
      if (!inventory || typeof inventory !== "object") {
        console.log("[InventorySorting] Inventaire introuvable pour le log de recherche.");
        return;
      }
      const items = Array.isArray(inventory.items) ? inventory.items : [];
      const { filteredItems } = filterInventoryItems(items, filters, searchQuery);
      const container = getInventoryItemsContainer(grid);
      const entries = container ? getInventoryDomEntries(container) : [];
      console.log("[InventorySorting] R\xE9sultats filtr\xE9s (recherche) :", filteredItems);
      console.log(
        "[InventorySorting] Nombre d'\xE9l\xE9ments DOM pour la recherche :",
        entries.length
      );
    } catch (error) {
      console.warn(
        "[InventorySorting] Impossible de journaliser les r\xE9sultats filtr\xE9s de la recherche",
        error
      );
    }
  };
  var RARITY_ORDER = [
    rarity.Common,
    rarity.Uncommon,
    rarity.Rare,
    rarity.Legendary,
    rarity.Mythic,
    rarity.Divine,
    rarity.Celestial
  ].filter(Boolean);
  var RARITY_RANK = (() => {
    const entries = /* @__PURE__ */ new Map();
    RARITY_ORDER.forEach((label2, index) => {
      const key2 = normalize2(label2);
      if (key2) {
        entries.set(key2, index);
      }
    });
    const mythicIndex = entries.get(normalize2(rarity.Mythic));
    if (typeof mythicIndex === "number") {
      entries.set(normalize2("Mythic"), mythicIndex);
    }
    return entries;
  })();
  var getRarityRank = (value) => {
    const key2 = normalize2(value);
    if (!key2) return RARITY_ORDER.length;
    return RARITY_RANK.get(key2) ?? RARITY_ORDER.length;
  };
  var SPECIES_FIELDS = [
    "species",
    "seedSpecies",
    "plantSpecies",
    "cropSpecies",
    "baseSpecies",
    "seedKey"
  ];
  var normalizeSpeciesKey3 = (value) => value.toLowerCase().replace(/['`]/g, "").replace(/\s+/g, "").replace(/-/g, "").replace(/(seed|plant|baby|fruit|crop)$/i, "");
  var MAX_SCALE_BY_SPECIES3 = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const register = (key2, value) => {
      if (typeof key2 !== "string") return;
      const normalized = normalizeSpeciesKey3(key2.trim());
      if (!normalized || map2.has(normalized)) return;
      map2.set(normalized, value);
    };
    for (const [species, entry] of Object.entries(plantCatalog)) {
      const maxScale = Number(entry?.crop?.maxScale);
      if (!Number.isFinite(maxScale) || maxScale <= 0) continue;
      register(species, maxScale);
      register(entry?.seed?.name, maxScale);
      register(entry?.plant?.name, maxScale);
      register(entry?.crop?.name, maxScale);
    }
    return map2;
  })();
  var lookupMaxScale3 = (species) => {
    if (typeof species !== "string") return null;
    const normalized = normalizeSpeciesKey3(species.trim());
    if (!normalized) return null;
    const value = MAX_SCALE_BY_SPECIES3.get(normalized);
    return typeof value === "number" && Number.isFinite(value) && value > 0 ? value : null;
  };
  var clampNumber2 = (value, min, max) => Math.max(min, Math.min(max, value));
  var scaleToPercent = (scale, maxScale) => {
    if (!Number.isFinite(scale)) return 50;
    const MIN_PERCENT = 50;
    const MAX_PERCENT = 100;
    const MIN_SCALE = 1;
    const safeScale = Math.max(MIN_SCALE, scale);
    if (typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > MIN_SCALE) {
      const limited2 = Math.min(maxScale, safeScale);
      const ratio2 = (limited2 - MIN_SCALE) / (maxScale - MIN_SCALE);
      const pct2 = MIN_PERCENT + ratio2 * (MAX_PERCENT - MIN_PERCENT);
      return clampNumber2(Math.round(pct2), MIN_PERCENT, MAX_PERCENT);
    }
    const FALLBACK_MAX_SCALE = 2;
    const limited = Math.min(FALLBACK_MAX_SCALE, safeScale);
    const ratio = (limited - MIN_SCALE) / (FALLBACK_MAX_SCALE - MIN_SCALE);
    const pct = MIN_PERCENT + ratio * (MAX_PERCENT - MIN_PERCENT);
    return clampNumber2(Math.round(pct), MIN_PERCENT, MAX_PERCENT);
  };
  var collectSpeciesCandidates = (source, out) => {
    if (!source || typeof source !== "object") return;
    for (const field of SPECIES_FIELDS) {
      const raw = source[field];
      if (typeof raw === "string") {
        const value = raw.trim();
        if (value) out.add(value);
      }
    }
  };
  var computeSizePercentFromScale = (speciesCandidates, scale) => {
    if (!Number.isFinite(scale)) return null;
    let maxScale = null;
    for (const candidate of speciesCandidates) {
      maxScale = lookupMaxScale3(candidate);
      if (maxScale != null) break;
    }
    return scaleToPercent(scale, maxScale);
  };
  var getInventoryItemSizePercent = (item) => {
    if (!item || typeof item !== "object") return null;
    const candidates = /* @__PURE__ */ new Set();
    collectSpeciesCandidates(item, candidates);
    collectSpeciesCandidates(item.item, candidates);
    collectSpeciesCandidates(item.data, candidates);
    const rawType = typeof item.itemType === "string" ? item.itemType : "";
    const type = rawType.trim();
    if (type === "Crop" || type === "Produce") {
      const scale = Number(item.scale);
      return computeSizePercentFromScale(candidates, scale);
    }
    return null;
  };
  var collectMutations = (source, out) => {
    if (!source || typeof source !== "object") return;
    const rawMutations = source.mutations;
    if (Array.isArray(rawMutations)) {
      for (const mutation of rawMutations) {
        if (typeof mutation === "string" && mutation.trim()) {
          out.push(mutation.trim());
        }
      }
    }
    const slots = source.slots;
    if (Array.isArray(slots)) {
      for (const slot of slots) {
        collectMutations(slot, out);
      }
    }
  };
  var getInventoryItemMutations = (item) => {
    if (!item || typeof item !== "object") return [];
    const mutations = [];
    collectMutations(item, mutations);
    collectMutations(item.item, mutations);
    collectMutations(item.data, mutations);
    return mutations;
  };
  var FILTER_LABEL_TO_ITEM_TYPES = {
    crop: ["Produce"],
    crops: ["Produce"],
    produce: ["Produce"],
    seed: ["Seed"],
    seeds: ["Seed"],
    plant: ["Plant"],
    plants: ["Plant"],
    pet: ["Pet"],
    pets: ["Pet"],
    tool: ["Tool"],
    tools: ["Tool"],
    decor: ["Decor"],
    decors: ["Decor"],
    decoration: ["Decor"],
    decorations: ["Decor"],
    egg: ["Egg"],
    eggs: ["Egg"]
  };
  var ITEM_TYPE_TO_FILTER_KEYS = (() => {
    const mapping = /* @__PURE__ */ new Map();
    for (const [filterKey, itemTypes] of Object.entries(FILTER_LABEL_TO_ITEM_TYPES)) {
      for (const itemType of itemTypes) {
        const normalizedType = normalize2(itemType);
        if (!normalizedType) continue;
        const set2 = mapping.get(normalizedType) ?? /* @__PURE__ */ new Set();
        set2.add(filterKey);
        mapping.set(normalizedType, set2);
      }
    }
    const result = {};
    mapping.forEach((value, key2) => {
      result[key2] = Array.from(value);
    });
    return result;
  })();
  var getExtrasForFilterKey = (filterKey, mapExtraByFilter) => {
    if (!filterKey) return [];
    const direct = mapExtraByFilter[filterKey];
    if (Array.isArray(direct) && direct.length) {
      return direct;
    }
    if (filterKey.endsWith("s")) {
      const singular = filterKey.slice(0, -1);
      if (singular) {
        const singularMatch = mapExtraByFilter[singular];
        if (Array.isArray(singularMatch) && singularMatch.length) {
          return singularMatch;
        }
      }
    }
    return [];
  };
  var getExtrasForItemType = (itemType, mapExtraByFilter) => {
    const normalizedType = normalize2(itemType);
    if (!normalizedType) return [];
    const extras = /* @__PURE__ */ new Set();
    const direct = mapExtraByFilter[normalizedType];
    if (Array.isArray(direct)) {
      direct.forEach((value) => extras.add(value));
    }
    const relatedFilterKeys = ITEM_TYPE_TO_FILTER_KEYS[normalizedType] ?? [];
    for (const filterKey of relatedFilterKeys) {
      const values = mapExtraByFilter[filterKey];
      if (Array.isArray(values)) {
        values.forEach((value) => extras.add(value));
      }
    }
    return Array.from(extras);
  };
  function filterLabelToItemTypes(filter) {
    const key2 = normalize2(filter);
    if (!key2 || key2 === "all") return [];
    const mapped = FILTER_LABEL_TO_ITEM_TYPES[key2];
    if (mapped) return mapped;
    const singular = key2.endsWith("s") ? key2.slice(0, -1) : key2;
    if (!singular) return [];
    const itemType = singular.charAt(0).toUpperCase() + singular.slice(1);
    return itemType ? [itemType] : [];
  }
  function inventoryItemMatchesSearchQuery(item, normalizedQuery) {
    if (!normalizedQuery) return true;
    const visited = /* @__PURE__ */ new Set();
    const matchesValue = (value) => {
      if (value == null) return false;
      if (typeof value === "string") {
        return normalize2(value).includes(normalizedQuery);
      }
      if (typeof value === "number" || typeof value === "boolean") {
        return normalize2(String(value)).includes(normalizedQuery);
      }
      if (Array.isArray(value)) {
        for (const entry of value) {
          if (matchesValue(entry)) {
            return true;
          }
        }
        return false;
      }
      if (typeof value === "object") {
        if (visited.has(value)) {
          return false;
        }
        visited.add(value);
        for (const [key2, entry] of Object.entries(value)) {
          if (key2 === "itemType") {
            continue;
          }
          if (key2 === "abilities") {
            if (Array.isArray(entry)) {
              for (const abilityId of entry) {
                const abilityName = getPetAbilityDisplayName(abilityId);
                if (abilityName && matchesValue(abilityName)) {
                  return true;
                }
              }
            }
            continue;
          }
          if (matchesValue(entry)) {
            return true;
          }
        }
      }
      return false;
    };
    const abilityNames = Array.isArray(item?.abilities) ? item.abilities.map((abilityId) => getPetAbilityDisplayName(abilityId)).filter((name) => typeof name === "string" && !!name) : [];
    const candidates = [
      getInventoryItemName(item),
      typeof item?.species === "string" ? item.species : null,
      typeof item?.seedSpecies === "string" ? item.seedSpecies : null,
      typeof item?.plantSpecies === "string" ? item.plantSpecies : null,
      typeof item?.petSpecies === "string" ? item.petSpecies : null,
      typeof item?.eggId === "string" ? item.eggId : null,
      typeof item?.decorId === "string" ? item.decorId : null,
      typeof item?.toolId === "string" ? item.toolId : null,
      typeof item?.id === "string" ? item.id : null,
      ...abilityNames
    ];
    for (const candidate of candidates) {
      if (matchesValue(candidate)) {
        return true;
      }
    }
    return matchesValue(item);
  }
  function attachItemValues(items) {
    const snapshot = getInventoryValueSnapshot();
    const playersInRoom = snapshot?.plants?.playersInRoom ?? null;
    for (const item of items) {
      if (!item || typeof item !== "object") continue;
      const value = computeInventoryItemValue(item, { playersInRoom });
      item.value = value ?? null;
    }
  }
  function filterInventoryItems(items, filters, searchQuery) {
    const normalizedFilters = filters.map((f) => normalize2(f)).filter(Boolean);
    const itemTypes = /* @__PURE__ */ new Set();
    let recognized = false;
    for (const filter of normalizedFilters) {
      const mappedTypes = filterLabelToItemTypes(filter);
      if (mappedTypes.length) {
        recognized = true;
        for (const type of mappedTypes) {
          if (type) itemTypes.add(type);
        }
      }
    }
    const keepAll = !recognized;
    const filteredByType = keepAll ? items.slice() : items.filter((item) => {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      return type ? itemTypes.has(type) : false;
    });
    const normalizedSearch = normalize2(searchQuery);
    const filteredItems = normalizedSearch ? filteredByType.filter((item) => inventoryItemMatchesSearchQuery(item, normalizedSearch)) : filteredByType;
    attachItemValues(filteredItems);
    const detectedItemTypes = /* @__PURE__ */ new Set();
    for (const item of filteredItems) {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      if (type) {
        detectedItemTypes.add(type);
      }
    }
    const contextKey = createFilterContextKey(filters, normalizedSearch);
    setCachedItemTypesForKey(contextKey, detectedItemTypes);
    return { filteredItems, keepAll, itemTypes, detectedItemTypes };
  }
  function getInventoryItemsContainer(grid) {
    return grid.querySelector(INVENTORY_ITEMS_CONTAINER_SELECTOR) || document.querySelector(INVENTORY_ITEMS_CONTAINER_SELECTOR);
  }
  function getInventoryDomEntries(container) {
    const entries = [];
    const children = Array.from(container.children);
    for (const child of children) {
      if (!(child instanceof HTMLElement)) continue;
      if (child.matches(".css-vmnhaw")) {
        entries.push({ wrapper: child, card: child });
        continue;
      }
      const card = child.querySelector(".css-vmnhaw");
      if (card instanceof HTMLElement) {
        entries.push({ wrapper: child, card });
      }
    }
    return entries;
  }
  var INVENTORY_COMPACT_VALUE_UNITS = [
    { threshold: 1e12, suffix: "T" },
    { threshold: 1e9, suffix: "B" },
    { threshold: 1e6, suffix: "M" },
    { threshold: 1e3, suffix: "K" }
  ];
  var INVENTORY_FULL_VALUE_FORMATTER = typeof Intl !== "undefined" && typeof Intl.NumberFormat === "function" ? new Intl.NumberFormat(void 0, { maximumFractionDigits: 2, minimumFractionDigits: 0 }) : null;
  var formatInventoryItemCompactValue = (value) => {
    const abs = Math.abs(value);
    for (const { threshold, suffix } of INVENTORY_COMPACT_VALUE_UNITS) {
      if (abs >= threshold) {
        const scaled = value / threshold;
        const formatted = scaled.toFixed(1).replace(/\.0$/, "");
        return `${formatted}${suffix}`;
      }
    }
    return INVENTORY_FULL_VALUE_FORMATTER ? INVENTORY_FULL_VALUE_FORMATTER.format(value) : String(value);
  };
  var formatInventoryItemFullValue = (value) => INVENTORY_FULL_VALUE_FORMATTER ? INVENTORY_FULL_VALUE_FORMATTER.format(value) : String(value);
  var getInventoryItemValue = (item) => {
    if (!item || typeof item !== "object") return null;
    const raw = item.value;
    if (typeof raw === "number" && Number.isFinite(raw)) return raw;
    if (typeof raw === "string" && raw.trim()) {
      const parsed = Number(raw);
      return Number.isFinite(parsed) ? parsed : null;
    }
    return null;
  };
  var getValueSummaryElement = (wrap) => {
    if (!wrap) return null;
    const summary = wrap.__valueSummary ?? null;
    return summary ?? wrap.querySelector(".tm-value-toggle__summary");
  };
  var ensureValueSummaryContent = (summary) => {
    if (!summary.style.gap) {
      summary.style.gap = "0.25rem";
    }
    if (VALUE_SUMMARY_ICON_SRC) {
      let iconEl = summary.querySelector(`.${VALUE_SUMMARY_ICON_CLASS}`);
      if (!iconEl) {
        iconEl = document.createElement("img");
        iconEl.className = VALUE_SUMMARY_ICON_CLASS;
        iconEl.alt = "";
        iconEl.decoding = "async";
        iconEl.src = VALUE_SUMMARY_ICON_SRC;
        Object.assign(iconEl.style, {
          width: "1.2rem",
          height: "1.2rem",
          flexShrink: "0",
          objectFit: "contain"
        });
        summary.insertBefore(iconEl, summary.firstChild);
      } else if (iconEl.src !== VALUE_SUMMARY_ICON_SRC) {
        iconEl.src = VALUE_SUMMARY_ICON_SRC;
      }
    }
    let textEl = summary.querySelector(`.${VALUE_SUMMARY_TEXT_CLASS}`);
    if (!textEl) {
      textEl = document.createElement("span");
      textEl.className = VALUE_SUMMARY_TEXT_CLASS;
      textEl.style.fontWeight = "700";
      textEl.style.color = "inherit";
      summary.appendChild(textEl);
    }
    return textEl;
  };
  var setValueSummaryText = (summary, text, title) => {
    if (!summary) return;
    const textEl = ensureValueSummaryContent(summary);
    textEl.textContent = text;
    if (title) {
      summary.title = title;
    } else {
      summary.removeAttribute("title");
    }
  };
  async function updateFilteredInventoryValueSummary(wrap, filters, searchQuery) {
    if (!wrap) return;
    const summary = getValueSummaryElement(wrap);
    if (!summary) return;
    const token = Symbol("value-summary");
    wrap.__valueSummaryToken = token;
    setValueSummaryText(summary, FILTERED_VALUE_LOADING);
    try {
      const inventory = await Atoms.inventory.myInventory.get();
      if (wrap.__valueSummaryToken !== token) {
        return;
      }
      if (!inventory || typeof inventory !== "object") {
        setValueSummaryText(summary, FILTERED_VALUE_UNKNOWN);
        return;
      }
      const items = Array.isArray(inventory.items) ? inventory.items : [];
      const { filteredItems } = filterInventoryItems(items, filters, searchQuery);
      if (!filteredItems.length) {
        setValueSummaryText(summary, "0", "0");
        return;
      }
      let totalValue = 0;
      let hasValue = false;
      for (const item of filteredItems) {
        const value = getInventoryItemValue(item);
        if (typeof value === "number" && Number.isFinite(value)) {
          totalValue += value;
          hasValue = true;
        }
      }
      if (!hasValue) {
        setValueSummaryText(summary, FILTERED_VALUE_UNKNOWN);
        return;
      }
      const compact = formatInventoryItemCompactValue(totalValue);
      const full = formatInventoryItemFullValue(totalValue);
      setValueSummaryText(summary, compact, full);
    } catch (error) {
      console.warn("[InventorySorting] Impossible de calculer la valeur filtr\xE9e", error);
      if (wrap.__valueSummaryToken !== token) {
        return;
      }
      setValueSummaryText(summary, FILTERED_VALUE_UNKNOWN);
    }
  }
  function updateInventoryCardValue(card, rawValue) {
    const container = card.querySelector(INVENTORY_VALUE_CONTAINER_SELECTOR);
    const existing = card.dataset[INVENTORY_VALUE_DATASET_KEY];
    if (!container) {
      if (existing != null) {
        delete card.dataset[INVENTORY_VALUE_DATASET_KEY];
      }
      return;
    }
    const currentEl = container.querySelector(`.${INVENTORY_VALUE_ELEMENT_CLASS}`);
    if (!getShouldDisplayInventoryValues()) {
      if (currentEl?.parentElement) {
        currentEl.parentElement.removeChild(currentEl);
      }
      if (existing != null) {
        delete card.dataset[INVENTORY_VALUE_DATASET_KEY];
      }
      return;
    }
    if (typeof rawValue !== "number" || !Number.isFinite(rawValue)) {
      if (currentEl?.parentElement) {
        currentEl.parentElement.removeChild(currentEl);
      }
      if (existing != null) {
        delete card.dataset[INVENTORY_VALUE_DATASET_KEY];
      }
      return;
    }
    const compactValue = formatInventoryItemCompactValue(rawValue);
    const fullValue = formatInventoryItemFullValue(rawValue);
    let target = currentEl;
    if (!target) {
      target = document.createElement("div");
      target.className = INVENTORY_VALUE_ELEMENT_CLASS;
    }
    Object.assign(target.style, {
      fontSynthesis: "none",
      WebkitFontSmoothing: "antialiased",
      WebkitTextSizeAdjust: "100%",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "flex-start",
      gap: "0.15rem",
      marginTop: "3px",
      fontFamily: 'var(--chakra-fonts-body, "GreyCliff CF", sans-serif)',
      fontWeight: "700",
      fontSize: "0.65rem",
      lineHeight: "1",
      textTransform: "none",
      color: "var(--chakra-colors-Yellow-Magic, #F3D32B)"
    });
    let textEl = target.querySelector(`.${INVENTORY_VALUE_TEXT_CLASS}`);
    if (!textEl) {
      target.textContent = "";
      textEl = document.createElement("span");
      textEl.className = INVENTORY_VALUE_TEXT_CLASS;
      textEl.style.display = "inline-flex";
      textEl.style.alignItems = "center";
      textEl.style.color = "inherit";
      target.appendChild(textEl);
    }
    textEl.textContent = compactValue;
    target.title = fullValue;
    card.dataset[INVENTORY_VALUE_DATASET_KEY] = String(rawValue);
    if (target.parentElement !== container || target !== container.lastElementChild) {
      container.appendChild(target);
    }
  }
  function assignBaseIndexesToEntries(entries) {
    entries.forEach((entry, index) => {
      entry.wrapper.dataset[INVENTORY_BASE_INDEX_DATASET_KEY] = String(index);
      entry.card.dataset[INVENTORY_BASE_INDEX_DATASET_KEY] = String(index);
    });
  }
  function readBaseIndex(entry) {
    const raw = entry.wrapper.dataset[INVENTORY_BASE_INDEX_DATASET_KEY] ?? entry.card.dataset[INVENTORY_BASE_INDEX_DATASET_KEY];
    if (raw == null) return null;
    const value = Number(raw);
    return Number.isFinite(value) ? value : null;
  }
  var stringOrEmpty = (value) => typeof value === "string" ? value.trim() : "";
  var pickNestedString = (source, path) => {
    let current = source;
    for (const key2 of path) {
      if (!current || typeof current !== "object") {
        return "";
      }
      current = current[key2];
    }
    return stringOrEmpty(current);
  };
  var pickFirstNestedString = (source, paths) => {
    for (const path of paths) {
      const value = pickNestedString(source, path);
      if (value) return value;
    }
    return "";
  };
  var plantCatalogEntry = (identifier) => plantCatalog[identifier];
  var petCatalogEntry = (identifier) => petCatalog[identifier];
  var eggCatalogEntry = (identifier) => eggCatalog[identifier];
  var toolCatalogEntry = (identifier) => toolCatalog[identifier];
  var decorCatalogEntry = (identifier) => decorCatalog[identifier];
  var SEED_NAME_PATHS = [
    ["seed", "name"],
    ["plant", "name"],
    ["crop", "name"]
  ];
  var SEED_RARITY_PATHS = [
    ["seed", "rarity"],
    ["crop", "rarity"],
    ["plant", "rarity"]
  ];
  var CROP_NAME_PATHS = [
    ["crop", "name"],
    ["plant", "name"],
    ["seed", "name"]
  ];
  var CROP_RARITY_PATHS = [
    ["crop", "rarity"],
    ["plant", "rarity"],
    ["seed", "rarity"]
  ];
  var PLANT_NAME_PATHS = [
    ["plant", "name"],
    ["crop", "name"],
    ["seed", "name"]
  ];
  var PLANT_RARITY_PATHS = [
    ["plant", "rarity"],
    ["crop", "rarity"],
    ["seed", "rarity"]
  ];
  var createPlantLookup = (identifierField, namePaths, rarityPaths) => ({
    identifierField,
    getEntry: plantCatalogEntry,
    getNamePaths: namePaths,
    getRarityPaths: rarityPaths
  });
  var CATALOG_LOOKUPS = {
    Seed: createPlantLookup("species", SEED_NAME_PATHS, SEED_RARITY_PATHS),
    Crop: createPlantLookup("species", CROP_NAME_PATHS, CROP_RARITY_PATHS),
    Produce: createPlantLookup("species", CROP_NAME_PATHS, CROP_RARITY_PATHS),
    Plant: createPlantLookup("species", PLANT_NAME_PATHS, PLANT_RARITY_PATHS),
    Pet: {
      identifierField: "petSpecies",
      getEntry: petCatalogEntry,
      getNamePaths: [["name"]],
      getRarityPaths: [["rarity"]]
    },
    Egg: {
      identifierField: "eggId",
      getEntry: eggCatalogEntry,
      getNamePaths: [["name"]],
      getRarityPaths: [["rarity"]]
    },
    Tool: {
      identifierField: "toolId",
      getEntry: toolCatalogEntry,
      getNamePaths: [["name"]],
      getRarityPaths: [["rarity"]]
    },
    Decor: {
      identifierField: "decorId",
      getEntry: decorCatalogEntry,
      getNamePaths: [["name"]],
      getRarityPaths: [["rarity"]]
    }
  };
  var getCatalogLookup = (type) => CATALOG_LOOKUPS[type] ?? null;
  var getInventoryItemName = (item) => {
    if (!item || typeof item !== "object") return "";
    const type = stringOrEmpty(item.itemType);
    const lookup = getCatalogLookup(type);
    if (lookup) {
      const identifier = readNestedStringField(item, lookup.identifierField) ?? "";
      if (identifier) {
        const entry = lookup.getEntry(identifier);
        const catalogName = lookup.getNamePaths ? pickFirstNestedString(entry, lookup.getNamePaths) : "";
        if (catalogName) {
          return catalogName;
        }
        return identifier;
      }
    }
    const fallbackName = stringOrEmpty(item.name);
    if (fallbackName) return fallbackName;
    const fallbackId = stringOrEmpty(item.id);
    if (fallbackId) return fallbackId;
    return type;
  };
  var QUANTITY_ONE_TYPES = /* @__PURE__ */ new Set(["Produce", "Crop", "Plant", "Pet"]);
  var getInventoryItemQuantity = (item) => {
    if (!item || typeof item !== "object") return 0;
    const rawType = typeof item.itemType === "string" ? item.itemType : "";
    const type = rawType.trim();
    if (QUANTITY_ONE_TYPES.has(type)) {
      return 1;
    }
    const rawQuantity = item.quantity;
    const quantity = Number(rawQuantity);
    if (Number.isFinite(quantity) && quantity >= 0) {
      return quantity;
    }
    return 0;
  };
  var getInventoryItemRarity = (item) => {
    if (!item || typeof item !== "object") return "";
    const type = stringOrEmpty(item.itemType);
    const lookup = getCatalogLookup(type);
    if (!lookup || !lookup.getRarityPaths?.length) {
      return "";
    }
    const identifier = readNestedStringField(item, lookup.identifierField) ?? "";
    if (!identifier) return "";
    const entry = lookup.getEntry(identifier);
    return pickFirstNestedString(entry, lookup.getRarityPaths);
  };
  var readNestedValue = (item, field, parser) => {
    if (!item || typeof item !== "object") return null;
    const sources = [item, item.item, item.data];
    for (const source of sources) {
      if (!source || typeof source !== "object") continue;
      const raw = source[field];
      const parsed = parser(raw);
      if (parsed != null) return parsed;
    }
    return null;
  };
  var readNestedStringField = (item, field) => readNestedValue(item, field, (value) => {
    if (typeof value !== "string") return null;
    const trimmed = value.trim();
    return trimmed ? trimmed : null;
  });
  var readNestedNumberField = (item, field) => readNestedValue(item, field, (value) => {
    if (typeof value === "number" && Number.isFinite(value)) return value;
    if (typeof value === "string" && value.trim()) {
      const parsed = Number(value);
      return Number.isFinite(parsed) ? parsed : null;
    }
    return null;
  });
  var PET_STATS_BY_SPECIES = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const register = (key2, maxScale, hoursToMature) => {
      if (typeof key2 !== "string") return;
      const normalized = normalizeSpeciesKey3(key2);
      if (!normalized || map2.has(normalized)) return;
      map2.set(normalized, { maxScale, hoursToMature });
    };
    for (const [species, entry] of Object.entries(petCatalog)) {
      const maxScale = Number(entry?.maxScale);
      const hoursToMature = Number(entry?.hoursToMature);
      if (!Number.isFinite(maxScale) || maxScale <= 1) continue;
      if (!Number.isFinite(hoursToMature) || hoursToMature <= 0) continue;
      register(species, maxScale, hoursToMature);
      register(entry?.name, maxScale, hoursToMature);
    }
    return map2;
  })();
  var lookupPetStats = (species) => {
    if (typeof species !== "string") return null;
    const normalized = normalizeSpeciesKey3(species);
    if (!normalized) return null;
    return PET_STATS_BY_SPECIES.get(normalized) ?? null;
  };
  var getPetStrength2 = (item) => {
    if (!item || typeof item !== "object") return null;
    const rawType = typeof item.itemType === "string" ? item.itemType : "";
    const type = rawType.trim();
    if (type !== "Pet") return null;
    const rawXp = readNestedNumberField(item, "xp");
    const xp = typeof rawXp === "number" && Number.isFinite(rawXp) ? rawXp : 0;
    const rawTargetScale = readNestedNumberField(item, "targetScale");
    const targetScale = typeof rawTargetScale === "number" && Number.isFinite(rawTargetScale) ? rawTargetScale : 1;
    const speciesCandidates = /* @__PURE__ */ new Set();
    const maybePetSpecies = readNestedStringField(item, "petSpecies");
    if (maybePetSpecies) speciesCandidates.add(maybePetSpecies);
    const maybeSpecies = readNestedStringField(item, "species");
    if (maybeSpecies) speciesCandidates.add(maybeSpecies);
    const maybeName = readNestedStringField(item, "name");
    if (maybeName) speciesCandidates.add(maybeName);
    let stats = null;
    for (const candidate of speciesCandidates) {
      stats = lookupPetStats(candidate);
      if (stats) break;
    }
    if (!stats) return null;
    const { maxScale, hoursToMature } = stats;
    if (!Number.isFinite(maxScale) || maxScale <= 1) return null;
    if (!Number.isFinite(hoursToMature) || hoursToMature <= 0) return null;
    const safeXp = Math.max(0, xp);
    const xpDenominator = hoursToMature * 3600;
    const xpComponent = xpDenominator > 0 ? Math.min(Math.floor(safeXp / xpDenominator * 30), 30) : 0;
    const minScale = 1;
    const clampedScale = clampNumber2(targetScale, minScale, maxScale);
    const scaleDenominator = maxScale - minScale;
    const scaleComponent = scaleDenominator > 0 ? Math.floor((clampedScale - minScale) / scaleDenominator * 20 + 80) : 80;
    const combined = xpComponent + scaleComponent - 30;
    return clampNumber2(combined, 0, 100);
  };
  var compareByNameThenTypeThenId = (a, b) => {
    const nameA = getInventoryItemName(a);
    const nameB = getInventoryItemName(b);
    if (nameA && nameB) {
      const cmp = nameA.localeCompare(nameB, void 0, { sensitivity: "base" });
      if (cmp !== 0) return cmp;
    }
    if (!nameA && nameB) return 1;
    if (nameA && !nameB) return -1;
    const typeA = typeof a?.itemType === "string" ? a.itemType : "";
    const typeB = typeof b?.itemType === "string" ? b.itemType : "";
    const typeCmp = typeA.localeCompare(typeB, void 0, { sensitivity: "base" });
    if (typeCmp !== 0) return typeCmp;
    const idA = typeof a.id === "string" ? a.id : "";
    const idB = typeof b.id === "string" ? b.id : "";
    return idA.localeCompare(idB, void 0, { sensitivity: "base" });
  };
  function sortInventoryItems(items, sortKey, direction) {
    const sorted = items.slice();
    const isDesc = direction === "desc";
    switch (sortKey) {
      case "alpha":
        sorted.sort((a, b) => {
          const cmp = compareByNameThenTypeThenId(a, b);
          return isDesc ? -cmp : cmp;
        });
        break;
      case "qty":
        sorted.sort((a, b) => {
          const qtyA = getInventoryItemQuantity(a);
          const qtyB = getInventoryItemQuantity(b);
          if (qtyA !== qtyB) {
            const cmp = qtyA - qtyB;
            return isDesc ? -cmp : cmp;
          }
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "rarity":
        sorted.sort((a, b) => {
          const rarityA = getInventoryItemRarity(a);
          const rarityB = getInventoryItemRarity(b);
          const rankA = getRarityRank(rarityA);
          const rankB = getRarityRank(rarityB);
          if (rankA !== rankB) {
            const cmp = rankA - rankB;
            return isDesc ? -cmp : cmp;
          }
          const cmpRarity = rarityA.localeCompare(rarityB, void 0, { sensitivity: "base" });
          if (cmpRarity !== 0) return cmpRarity;
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "value":
        sorted.sort((a, b) => {
          const rawValueA = a?.value;
          const rawValueB = b?.value;
          const hasA = typeof rawValueA === "number" && Number.isFinite(rawValueA);
          const hasB = typeof rawValueB === "number" && Number.isFinite(rawValueB);
          if (hasA && hasB && rawValueA !== rawValueB) {
            const cmp = rawValueA - rawValueB;
            return isDesc ? -cmp : cmp;
          }
          if (hasA && !hasB) return isDesc ? -1 : 1;
          if (!hasA && hasB) return isDesc ? 1 : -1;
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "size":
        sorted.sort((a, b) => {
          const sizeA = getInventoryItemSizePercent(a);
          const sizeB = getInventoryItemSizePercent(b);
          const hasA = typeof sizeA === "number" && Number.isFinite(sizeA);
          const hasB = typeof sizeB === "number" && Number.isFinite(sizeB);
          if (hasA && hasB && sizeA !== sizeB) {
            const cmp = sizeA - sizeB;
            return isDesc ? -cmp : cmp;
          }
          if (hasA && !hasB) return isDesc ? -1 : 1;
          if (!hasA && hasB) return isDesc ? 1 : -1;
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "mutations":
        sorted.sort((a, b) => {
          const mutationsA = getInventoryItemMutations(a);
          const mutationsB = getInventoryItemMutations(b);
          const countA = mutationsA.length;
          const countB = mutationsB.length;
          if (countA !== countB) {
            const cmp = countA - countB;
            return isDesc ? -cmp : cmp;
          }
          if (countA > 0 && countB > 0) {
            const labelA = mutationsA.slice().sort((x, y) => x.localeCompare(y, void 0, { sensitivity: "base" })).join("\0");
            const labelB = mutationsB.slice().sort((x, y) => x.localeCompare(y, void 0, { sensitivity: "base" })).join("\0");
            const cmp = labelA.localeCompare(labelB, void 0, { sensitivity: "base" });
            if (cmp !== 0) return cmp;
          }
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "strength":
        sorted.sort((a, b) => {
          const strengthA = getPetStrength2(a);
          const strengthB = getPetStrength2(b);
          const hasA = typeof strengthA === "number" && Number.isFinite(strengthA);
          const hasB = typeof strengthB === "number" && Number.isFinite(strengthB);
          if (hasA && hasB && strengthA !== strengthB) {
            const cmp = strengthA - strengthB;
            return isDesc ? -cmp : cmp;
          }
          if (hasA && !hasB) return isDesc ? -1 : 1;
          if (!hasA && hasB) return isDesc ? 1 : -1;
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      default:
        break;
    }
    return sorted;
  }
  async function logInventoryForFilters(filters, sortKey, direction, searchQuery) {
    try {
      const inventory = await Atoms.inventory.myInventory.get();
      if (!inventory || typeof inventory !== "object") {
        console.log("[InventorySorting] Inventaire introuvable pour le log des filtres.");
        return;
      }
      const items = Array.isArray(inventory.items) ? inventory.items : [];
      const { filteredItems, keepAll, itemTypes } = filterInventoryItems(items, filters, searchQuery);
      const resolvedDirection = sortKey ? (direction && DIRECTION_ORDER.includes(direction) ? direction : DEFAULT_DIRECTION_BY_SORT_KEY[sortKey]) ?? "asc" : direction && DIRECTION_ORDER.includes(direction) ? direction : "asc";
      const itemsForLog = sortKey ? sortInventoryItems(filteredItems, sortKey, resolvedDirection) : filteredItems.slice();
      const descriptor = keepAll ? "toutes cat\xE9gories" : `types: ${Array.from(itemTypes).join(", ") || "(aucun)"}`;
      const sortDescriptor = sortKey ? `tri: ${sortKey} (${resolvedDirection})` : "tri: (non sp\xE9cifi\xE9)";
      const searchDescriptor = searchQuery ? `recherche: "${searchQuery}"` : "recherche: (vide)";
      console.log(
        `[InventorySorting] myInventory filtr\xE9 (${descriptor}, ${sortDescriptor}, ${searchDescriptor}).`
      );
    } catch (error) {
      console.warn("[InventorySorting] Impossible de r\xE9cup\xE9rer myInventory pour le log", error);
    }
  }
  function createDefaultApplySorting(cfg) {
    const stateByGrid = /* @__PURE__ */ new WeakMap();
    const ensureState = async (grid, filters, entries, searchQuery) => {
      const filtersKey = JSON.stringify({ filters });
      const state2 = stateByGrid.get(grid);
      const hasAllBaseIndexes = entries.every((e) => readBaseIndex(e) != null);
      const searchChanged = state2 ? state2.searchQuery !== searchQuery : false;
      const entryCountChanged = state2 ? state2.entryCount !== entries.length : false;
      const filtersChanged = state2 ? state2.filtersKey !== filtersKey : false;
      const baseLengthChanged = state2 ? state2.baseItems.length !== entries.length : false;
      const needsRebuild = !state2 || filtersChanged || entryCountChanged || baseLengthChanged || !hasAllBaseIndexes || searchChanged;
      if (state2 && !needsRebuild) {
        state2.entryByBaseIndex.clear();
        for (const entry of entries) {
          const baseIndex = readBaseIndex(entry);
          if (baseIndex != null) {
            state2.entryByBaseIndex.set(baseIndex, entry);
          }
        }
        state2.filtersKey = filtersKey;
        state2.searchQuery = searchQuery;
        state2.entryCount = entries.length;
        return state2;
      }
      try {
        const inventory = await Atoms.inventory.myInventory.get();
        if (!inventory || typeof inventory !== "object") {
          console.log("[InventorySorting] Inventaire introuvable pour le tri DOM.");
          return null;
        }
        const items = Array.isArray(inventory.items) ? inventory.items : [];
        const { filteredItems } = filterInventoryItems(items, filters, searchQuery);
        if (filteredItems.length !== entries.length) {
          console.warn(
            `[InventorySorting] Nombre d'\xE9l\xE9ments filtr\xE9s (${filteredItems.length}) diff\xE9rent du DOM (${entries.length}). R\xE9organisation annul\xE9e.`
          );
          return null;
        }
        assignBaseIndexesToEntries(entries);
        const newState = {
          filtersKey,
          searchQuery,
          entryCount: entries.length,
          baseItems: filteredItems.slice(),
          entryByBaseIndex: /* @__PURE__ */ new Map()
        };
        entries.forEach((entry, index) => {
          newState.entryByBaseIndex.set(index, entry);
        });
        stateByGrid.set(grid, newState);
        return newState;
      } catch (error) {
        console.warn("[InventorySorting] Impossible de r\xE9cup\xE9rer myInventory pour le tri DOM", error);
        return null;
      }
    };
    return async (grid, sortKey, direction) => {
      if (typeof document === "undefined") return;
      const container = getInventoryItemsContainer(grid);
      if (!container) return;
      const entries = getInventoryDomEntries(container);
      if (!entries.length) return;
      const filters = getActiveFiltersFromGrid(
        grid,
        cfg.checkboxSelector,
        cfg.checkboxLabelSelector
      );
      const searchQuery = getNormalizedInventorySearchQuery(grid);
      const state2 = await ensureState(grid, filters, entries, searchQuery);
      if (!state2) return;
      const baseIndexByItem = /* @__PURE__ */ new Map();
      state2.baseItems.forEach((item, index) => {
        baseIndexByItem.set(item, index);
      });
      const effectiveDirection = direction && DIRECTION_ORDER.includes(direction) ? direction : DEFAULT_DIRECTION_BY_SORT_KEY[sortKey] ?? "asc";
      const desiredItems = !sortKey || sortKey === "none" ? state2.baseItems.slice() : sortInventoryItems(state2.baseItems, sortKey, effectiveDirection);
      const desiredEntries = [];
      const usedEntries = /* @__PURE__ */ new Set();
      for (const item of desiredItems) {
        const baseIndex = baseIndexByItem.get(item);
        if (baseIndex == null) continue;
        const entry = state2.entryByBaseIndex.get(baseIndex);
        if (!entry || usedEntries.has(entry)) continue;
        const value = getInventoryItemValue(item);
        updateInventoryCardValue(entry.card, value);
        desiredEntries.push(entry);
        usedEntries.add(entry);
      }
      if (desiredEntries.length !== entries.length) {
        console.warn(
          `[InventorySorting] Impossible de r\xE9ordonner l'inventaire : correspondances insuffisantes (${desiredEntries.length}/${entries.length}).`
        );
        return;
      }
      const fragment = document.createDocumentFragment();
      desiredEntries.forEach((entry) => {
        fragment.appendChild(entry.wrapper);
      });
      container.appendChild(fragment);
      state2.entryByBaseIndex.clear();
      desiredEntries.forEach((entry) => {
        const baseIndex = readBaseIndex(entry);
        if (baseIndex != null) {
          state2.entryByBaseIndex.set(baseIndex, entry);
        }
      });
    };
  }
  function getActiveFiltersFromGrid(grid, checkboxSelector, checkboxLabelSelector) {
    return Array.from(grid.querySelectorAll(checkboxSelector)).filter(labelIsChecked).map(
      (lbl) => (lbl.querySelector(checkboxLabelSelector)?.textContent ?? "").trim()
    ).filter(Boolean);
  }
  function computeSortOptions(activeFilters, labelByValue = LABEL_BY_VALUE_DEFAULT, mapExtraByFilter = MAP_EXTRA_BY_FILTER_DEFAULT, searchQuery = "") {
    const normalizedFilters = activeFilters.map((value) => (value ?? "").trim().toLowerCase()).filter(Boolean);
    const normalizedSearch = normalize2(searchQuery);
    const intersectSets = (sets) => {
      if (!sets.length) return null;
      let intersection = new Set(sets[0]);
      for (let i = 1; i < sets.length; i++) {
        const current = sets[i];
        intersection = new Set([...intersection].filter((value) => current.has(value)));
      }
      return intersection;
    };
    const filterSets = normalizedFilters.map(
      (filterKey) => /* @__PURE__ */ new Set([...BASE_SORT, ...getExtrasForFilterKey(filterKey, mapExtraByFilter)])
    );
    const detectedItemTypes = getCachedItemTypesForContext(activeFilters, normalizedSearch);
    const typeSets = [];
    if (detectedItemTypes && detectedItemTypes.size) {
      detectedItemTypes.forEach((itemType) => {
        const extras = getExtrasForItemType(itemType, mapExtraByFilter);
        typeSets.push(/* @__PURE__ */ new Set([...BASE_SORT, ...extras]));
      });
    }
    const allowedFromFilters = intersectSets(filterSets);
    const allowedFromTypes = intersectSets(typeSets);
    let allowed = null;
    if (allowedFromFilters && allowedFromTypes) {
      allowed = new Set([...allowedFromFilters].filter((value) => allowedFromTypes.has(value)));
    } else if (allowedFromFilters) {
      allowed = new Set(allowedFromFilters);
    } else if (allowedFromTypes) {
      allowed = new Set(allowedFromTypes);
    }
    if (!allowed || !allowed.size) {
      allowed = new Set(BASE_SORT);
    }
    const values = ORDER.filter((value) => value === "none" || allowed.has(value));
    return values.map((value) => ({ value, label: labelByValue[value] || value }));
  }
  function isMacOsPlatform() {
    if (typeof navigator === "undefined") return false;
    const nav = navigator;
    const platform = nav.userAgentData?.platform || nav.platform || "";
    if (platform && /mac/i.test(platform)) {
      return true;
    }
    const userAgent = typeof nav.userAgent === "string" ? nav.userAgent : "";
    return /mac os x/i.test(userAgent);
  }
  function shouldUseCustomSelectStyles() {
    return !isMacOsPlatform();
  }
  function injectDarkSelectStyles(id = "inv-sort-dark-styles") {
    if (document.getElementById(id)) return;
    const css = `
    .tm-sort-select {
      color: #e7eef7 !important;
      background-color: rgba(17,17,17,0.98) !important;
      border: 1px solid rgba(255,255,255,0.25) !important;
      outline: none !important;
      -webkit-appearance: none;
      appearance: none;
      color-scheme: dark;
      padding-right: 28px !important;
    }
    .tm-sort-select:focus { box-shadow: 0 0 0 2px rgba(122,162,255,.35); }
    .tm-sort-select option { color: #e7eef7; background-color: #111; }
    .tm-sort-select option:checked { background-color: #222; }
    .tm-sort-select option:hover   { background-color: #1a1a1a; }
    .tm-select-wrap { position: relative; display: inline-flex; align-items: center; }
    .tm-select-arrow {
      position: absolute; right: 10px; top: 50%;
      transform: translateY(-50%);
      pointer-events: none; display: inline-flex; align-items: center; justify-content: center;
    }
    .tm-select-arrow svg { display: block; }
  `;
    const style2 = document.createElement("style");
    style2.id = id;
    style2.textContent = css;
    document.head.appendChild(style2);
  }
  function createSortingBar(useCustomSelectStyles) {
    const wrap = document.createElement("div");
    wrap.className = "tm-sort-wrap";
    Object.assign(wrap.style, {
      display: "block",
      width: "100%",
      margin: "0",
      padding: "0",
      position: "relative",
      flex: "0 0 auto",
      minHeight: "0",
      contain: "layout style"
    });
    const bar = document.createElement("div");
    bar.className = "tm-sorting-bar";
    Object.assign(bar.style, {
      display: "flex",
      alignItems: "center",
      flexWrap: "wrap",
      gap: "8px",
      marginTop: "10px",
      paddingTop: "8px",
      borderTop: "1px solid rgba(255,255,255,0.12)",
      width: "100%",
      boxSizing: "border-box",
      position: "relative",
      flex: "0 0 auto",
      height: "auto",
      minHeight: "0",
      maxHeight: "none",
      alignSelf: "stretch"
    });
    const label2 = document.createElement("span");
    label2.textContent = "Sort by:";
    Object.assign(label2.style, { font: "inherit", opacity: "0.8", flex: "0 0 auto" });
    const selectWrap = document.createElement("div");
    selectWrap.className = "tm-select-wrap";
    const select2 = document.createElement("select");
    select2.className = "tm-sort-select tm-sort-select--key";
    if (useCustomSelectStyles) {
      Object.assign(select2.style, {
        padding: "6px 10px",
        border: "1px solid rgba(255,255,255,0.25)",
        borderRadius: "6px",
        background: "rgba(17,17,17,0.98)",
        color: "#e7eef7",
        cursor: "pointer",
        flex: "0 0 auto",
        width: "auto",
        outline: "none",
        appearance: "none"
      });
      select2.style.setProperty("-webkit-appearance", "none");
    }
    const arrow = document.createElement("span");
    arrow.className = "tm-select-arrow";
    arrow.innerHTML = `
    <svg width="12" height="8" viewBox="0 0 12 8" aria-hidden="true">
      <path d="M1 1l5 5 5-5" stroke="white" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  `;
    if (useCustomSelectStyles) {
      selectWrap.append(select2, arrow);
    } else {
      selectWrap.append(select2);
    }
    bar.append(label2, selectWrap);
    const directionLabel = document.createElement("span");
    directionLabel.className = "tm-direction-label";
    directionLabel.textContent = DEFAULT_DIRECTION_LABEL;
    Object.assign(directionLabel.style, {
      font: "inherit",
      opacity: "0.8",
      flex: "0 0 auto"
    });
    const directionWrap = document.createElement("div");
    directionWrap.className = "tm-select-wrap";
    const directionSelect = document.createElement("select");
    directionSelect.className = "tm-sort-select tm-direction-select";
    const canStyleDirectionSelect = useCustomSelectStyles && !isMacOsPlatform();
    if (canStyleDirectionSelect) {
      Object.assign(directionSelect.style, {
        padding: "6px 10px",
        border: "1px solid rgba(255,255,255,0.25)",
        borderRadius: "6px",
        background: "rgba(17,17,17,0.98)",
        color: "#e7eef7",
        cursor: "pointer",
        flex: "0 0 auto",
        width: "auto",
        outline: "none",
        appearance: "none"
      });
      directionSelect.style.setProperty("-webkit-appearance", "none");
    }
    const directionArrow = document.createElement("span");
    directionArrow.className = "tm-select-arrow";
    directionArrow.innerHTML = `
    <svg width="12" height="8" viewBox="0 0 12 8" aria-hidden="true">
      <path d="M1 1l5 5 5-5" stroke="white" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  `;
    if (canStyleDirectionSelect) {
      directionWrap.append(directionSelect, directionArrow);
    } else {
      directionWrap.append(directionSelect);
    }
    bar.append(directionLabel, directionWrap);
    const divider = document.createElement("span");
    divider.className = "tm-value-toggle__divider";
    Object.assign(divider.style, {
      alignSelf: "stretch",
      width: "1px",
      minHeight: "24px",
      background: "rgba(255,255,255,0.15)",
      flex: "0 0 auto",
      opacity: "0.5"
    });
    const valueToggleLabel = document.createElement("label");
    valueToggleLabel.className = "tm-value-toggle";
    Object.assign(valueToggleLabel.style, {
      display: "inline-flex",
      alignItems: "center",
      gap: "8px",
      font: "inherit",
      opacity: "0.9",
      cursor: "pointer",
      flex: "0 0 auto"
    });
    const valueToggleControl = document.createElement("span");
    valueToggleControl.className = "tm-value-toggle__control";
    Object.assign(valueToggleControl.style, {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "36px",
      height: "20px",
      flex: "0 0 auto"
    });
    const valueToggleInput = document.createElement("input");
    valueToggleInput.type = "checkbox";
    valueToggleInput.className = "tm-value-toggle__checkbox";
    Object.assign(valueToggleInput.style, {
      position: "absolute",
      inset: "0",
      margin: "0",
      opacity: "0",
      cursor: "pointer"
    });
    const switchTrack = document.createElement("span");
    switchTrack.className = "tm-value-toggle__switch";
    Object.assign(switchTrack.style, {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "flex-start",
      width: "100%",
      height: "100%",
      borderRadius: "999px",
      background: "rgba(255,255,255,0.25)",
      transition: "background 120ms ease",
      padding: "2px",
      boxSizing: "border-box"
    });
    const switchThumb = document.createElement("span");
    switchThumb.className = "tm-value-toggle__thumb";
    Object.assign(switchThumb.style, {
      width: "16px",
      height: "16px",
      borderRadius: "50%",
      background: "#111",
      boxShadow: "0 1px 3px rgba(0,0,0,0.35)",
      transform: "translateX(0)",
      transition: "transform 120ms ease, background 120ms ease"
    });
    switchTrack.appendChild(switchThumb);
    valueToggleControl.append(valueToggleInput, switchTrack);
    const valueToggleText = document.createElement("span");
    valueToggleText.className = "tm-value-toggle__label";
    valueToggleText.textContent = "Show values";
    Object.assign(valueToggleText.style, {
      font: "inherit",
      color: "inherit"
    });
    valueToggleLabel.append(valueToggleControl, valueToggleText);
    const valueSummaryText = document.createElement("span");
    valueSummaryText.className = "tm-value-toggle__summary";
    Object.assign(valueSummaryText.style, {
      font: "inherit",
      color: "var(--chakra-colors-Yellow-Magic, #F3D32B)",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "flex-end",
      flex: "1 1 auto",
      whiteSpace: "nowrap",
      marginLeft: "auto",
      textAlign: "right",
      gap: "0.25rem"
    });
    setValueSummaryText(valueSummaryText, FILTERED_VALUE_LOADING);
    bar.append(divider, valueToggleLabel, valueSummaryText);
    const syncValueToggleVisual = (checked) => {
      switchTrack.style.background = checked ? "var(--chakra-colors-Yellow-Magic, #F3D32B)" : "rgba(255,255,255,0.25)";
      switchThumb.style.transform = checked ? "translateX(16px)" : "translateX(0)";
      valueToggleLabel.setAttribute("data-checked", checked ? "true" : "false");
      valueToggleLabel.setAttribute("role", "switch");
      valueToggleLabel.setAttribute("aria-checked", checked ? "true" : "false");
    };
    valueToggleInput.addEventListener("change", () => {
      syncValueToggleVisual(valueToggleInput.checked);
    });
    wrap.__syncValueToggle = syncValueToggleVisual;
    syncValueToggleVisual(valueToggleInput.checked);
    wrap.appendChild(bar);
    return {
      wrap,
      bar,
      select: select2,
      directionSelect,
      directionLabel,
      valueToggleInput,
      valueToggleLabel,
      valueSummary: valueSummaryText
    };
  }
  function ensureSortingBar(grid, cfg, useCustomSelectStyles, labelByValue, directionLabelText, onChange, showValues, onToggleValues) {
    const filtersBlock = grid.querySelector(cfg.filtersBlockSelector);
    if (!filtersBlock) return null;
    const closeBtn = null;
    let wrap = filtersBlock.querySelector(":scope > .tm-sort-wrap");
    let select2;
    let directionSelect;
    let directionLabelEl = null;
    let valueToggleInput = null;
    let valueSummaryEl = null;
    if (!wrap) {
      const ui = createSortingBar(useCustomSelectStyles);
      wrap = ui.wrap;
      select2 = ui.select;
      directionSelect = ui.directionSelect;
      directionLabelEl = ui.directionLabel;
      valueToggleInput = ui.valueToggleInput;
      valueSummaryEl = ui.valueSummary;
      wrap.__grid = grid;
      wrap.__valueSummary = valueSummaryEl ?? null;
      wrap.style.gridColumn = "1 / -1";
      filtersBlock.appendChild(wrap);
      if (directionLabelEl) {
        directionLabelEl.textContent = directionLabelText;
      }
      if (valueToggleInput) {
        valueToggleInput.checked = showValues;
        valueToggleInput.addEventListener("change", () => {
          const nextVisible = valueToggleInput ? valueToggleInput.checked : false;
          wrap.__showValues = nextVisible;
          onToggleValues(nextVisible);
        });
      }
      select2.addEventListener("change", () => {
        const value = select2.value;
        wrap.__prevValue = value;
        const direction = directionSelect?.value || "asc";
        const currentGrid = wrap.__grid;
        const activeFilters = currentGrid ? getActiveFiltersFromGrid(
          currentGrid,
          cfg.checkboxSelector,
          cfg.checkboxLabelSelector
        ) : [];
        const searchQuery = getNormalizedInventorySearchQuery(currentGrid);
        console.log("[InventorySorting] Tri s\xE9lectionn\xE9 :", value);
        void logInventoryForFilters(activeFilters, value, direction, searchQuery);
        onChange(value, direction, activeFilters, searchQuery);
      });
      directionSelect.addEventListener("change", () => {
        const direction = directionSelect.value;
        wrap.__prevDirection = direction;
        const value = select2?.value || "none";
        const currentGrid = wrap.__grid;
        const activeFilters = currentGrid ? getActiveFiltersFromGrid(
          currentGrid,
          cfg.checkboxSelector,
          cfg.checkboxLabelSelector
        ) : [];
        const searchQuery = getNormalizedInventorySearchQuery(currentGrid);
        console.log("[InventorySorting] Ordre de tri s\xE9lectionn\xE9 :", direction);
        void logInventoryForFilters(activeFilters, value, direction, searchQuery);
        onChange(value, direction, activeFilters, searchQuery);
      });
    } else {
      const maybeSelect = wrap.querySelector("select.tm-sort-select--key");
      const maybeDirectionSelect = wrap.querySelector("select.tm-direction-select");
      if (!maybeSelect || !maybeDirectionSelect) return null;
      select2 = maybeSelect;
      directionSelect = maybeDirectionSelect;
      directionLabelEl = wrap.querySelector(".tm-direction-label");
      valueToggleInput = wrap.querySelector('label.tm-value-toggle input[type="checkbox"]');
      valueSummaryEl = wrap.querySelector(".tm-value-toggle__summary");
      wrap.__valueSummary = valueSummaryEl ?? null;
      if (directionLabelEl) {
        directionLabelEl.textContent = directionLabelText;
      }
      if (wrap.parentElement !== filtersBlock) {
        wrap.style.gridColumn = "1 / -1";
        filtersBlock.appendChild(wrap);
      } else {
        wrap.style.gridColumn = "1 / -1";
      }
    }
    if (valueToggleInput) {
      valueToggleInput.checked = showValues;
    }
    const syncValueToggle = wrap.__syncValueToggle;
    if (syncValueToggle) {
      syncValueToggle(valueToggleInput?.checked ?? showValues);
    }
    wrap.__grid = grid;
    wrap.__showValues = valueToggleInput?.checked ?? showValues;
    return { wrap, select: select2, directionSelect, valueToggleInput, valueSummary: valueSummaryEl };
  }
  function renderSelectOptions(select2, options, prevValue) {
    const prev = prevValue ?? select2.value;
    select2.innerHTML = "";
    for (const opt of options) {
      const o = document.createElement("option");
      o.value = opt.value;
      o.textContent = opt.label;
      select2.appendChild(o);
    }
    if (options.some((o) => o.value === "none")) {
      select2.value = "none";
    }
    if (prev && options.some((o) => o.value === prev) && prev !== "none") {
      select2.value = prev;
    }
  }
  function renderDirectionOptions(select2, labels, prevValue) {
    const prev = prevValue ?? select2.value ?? null;
    select2.innerHTML = "";
    for (const value of DIRECTION_ORDER) {
      const option = document.createElement("option");
      option.value = value;
      option.textContent = labels[value] ?? value;
      select2.appendChild(option);
    }
    if (prev && DIRECTION_ORDER.includes(prev)) {
      select2.value = prev;
    } else {
      select2.value = DIRECTION_ORDER[0];
    }
  }
  function attachInventorySorting(userConfig = {}) {
    const cfg = {
      ...DEFAULTS5,
      ...userConfig
    };
    const mapExtraByFilter = { ...MAP_EXTRA_BY_FILTER_DEFAULT, ...cfg.mapExtraByFilter || {} };
    const labelByValue = { ...LABEL_BY_VALUE_DEFAULT, ...cfg.labelByValue || {} };
    const directionLabelText = cfg.directionLabel ?? DEFAULT_DIRECTION_LABEL;
    const directionLabelByValue = {
      ...DIRECTION_LABELS_DEFAULT,
      ...cfg.directionLabelByValue || {}
    };
    const defaultDirectionBySortKey = {
      ...DEFAULT_DIRECTION_BY_SORT_KEY,
      ...cfg.defaultDirectionBySortKey || {}
    };
    const useCustomSelectStyles = shouldUseCustomSelectStyles();
    if (cfg.injectDarkStyles && useCustomSelectStyles) injectDarkSelectStyles();
    const applySorting = cfg.applySorting ?? createDefaultApplySorting(cfg);
    let showInventoryValues = loadPersistedInventoryValueVisibility() ?? true;
    setShouldDisplayInventoryValues(showInventoryValues);
    let grid = null;
    let currentWrap = null;
    let currentSelect = null;
    let currentDirectionSelect = null;
    let currentValueToggle = null;
    let stopValueSummaryListener = null;
    let lastLoggedFilters = null;
    let lastAppliedFiltersKey = null;
    let lastAppliedSortKey = null;
    let lastAppliedDirection = null;
    let shouldEnsureInventoryValueWatcherOnNextVisible = true;
    let lastSortedDomSnapshot = null;
    let lastComputedFilterContextKey = null;
    let stopFilterContextListener = null;
    let lastRenderedInventoryEntryCount = null;
    const updateDomSnapshotForGrid = (target) => {
      if (!target) {
        lastSortedDomSnapshot = null;
        return;
      }
      const container = getInventoryItemsContainer(target);
      if (!container) {
        lastSortedDomSnapshot = null;
        return;
      }
      const entries = getInventoryDomEntries(container);
      lastSortedDomSnapshot = createDomSnapshot(entries);
    };
    const applySortingWithSnapshot = (target, sortKey, direction) => Promise.resolve(applySorting(target, sortKey, direction)).then(() => {
      updateDomSnapshotForGrid(target);
    });
    const obs = new MutationObserver((muts) => {
      const relevant = muts.some(
        (m) => m.type === "attributes" ? ["data-checked", "style", "class", "hidden", "aria-hidden"].includes(m.attributeName || "") : m.type === "childList"
      );
      if (relevant) refresh();
    });
    const setGrid = (next) => {
      if (grid === next) return;
      obs.disconnect();
      grid = next;
      lastLoggedFilters = null;
      lastAppliedFiltersKey = null;
      lastAppliedSortKey = null;
      lastSortedDomSnapshot = null;
      lastComputedFilterContextKey = null;
      lastRenderedInventoryEntryCount = null;
      shouldEnsureInventoryValueWatcherOnNextVisible = true;
      if (!grid && stopValueSummaryListener) {
        stopValueSummaryListener();
        stopValueSummaryListener = null;
      }
      if (!grid && stopFilterContextListener) {
        stopFilterContextListener();
        stopFilterContextListener = null;
      }
      if (grid) {
        obs.observe(grid, {
          subtree: true,
          childList: true,
          attributes: true,
          attributeFilter: ["data-checked", "style", "class", "hidden", "aria-hidden"]
        });
      }
    };
    const bodyObserver = new MutationObserver(() => {
      const hasCurrent = !!(grid && document.contains(grid));
      if (!hasCurrent && grid) {
        setGrid(null);
      }
      const current = hasCurrent ? grid : null;
      const next = document.querySelector(cfg.gridSelector);
      if (next !== current) {
        setGrid(next);
        if (next) {
          update();
        }
      }
    });
    const resolveGrid = () => {
      if (grid && document.contains(grid)) return grid;
      const next = document.querySelector(cfg.gridSelector);
      if (next !== grid) {
        setGrid(next);
      }
      return grid && document.contains(grid) ? grid : null;
    };
    const applyCurrentSorting = () => {
      const targetGrid = resolveGrid();
      if (!targetGrid) return;
      const sortKey = currentSelect?.value ?? "none";
      const fallbackDirection = defaultDirectionBySortKey[sortKey] ?? DEFAULT_DIRECTION_BY_SORT_KEY[sortKey] ?? "asc";
      const direction = currentDirectionSelect?.value ?? fallbackDirection;
      void applySortingWithSnapshot(targetGrid, sortKey, direction);
    };
    const update = () => {
      const targetGrid = resolveGrid();
      if (!targetGrid || !isVisible2(targetGrid)) {
        shouldEnsureInventoryValueWatcherOnNextVisible = true;
        return;
      }
      setShouldDisplayInventoryValues(showInventoryValues);
      if (shouldEnsureInventoryValueWatcherOnNextVisible) {
        shouldEnsureInventoryValueWatcherOnNextVisible = false;
        void ensureInventoryValueWatcher().catch((error) => {
          console.warn(
            "[InventorySorting] Impossible d'initialiser la surveillance de la valeur de l'inventaire",
            error
          );
        });
      }
      const mount = ensureSortingBar(
        targetGrid,
        cfg,
        useCustomSelectStyles,
        labelByValue,
        directionLabelText,
        (value, direction, filters, searchQuery) => {
          lastAppliedSortKey = value;
          lastAppliedDirection = direction;
          const filtersKey = JSON.stringify({ filters: filters ?? [], search: searchQuery ?? "" });
          lastAppliedFiltersKey = filtersKey;
          persistSortKey(value);
          persistSortDirection(direction);
          cfg.onSortChange?.(value, direction);
          void applySortingWithSnapshot(targetGrid, value, direction);
        },
        showInventoryValues,
        (visible) => {
          showInventoryValues = visible;
          setShouldDisplayInventoryValues(visible);
          persistInventoryValueVisibility(visible);
          if (currentValueToggle) {
            currentValueToggle.checked = visible;
          }
          applyCurrentSorting();
        }
      );
      if (!mount) return;
      currentWrap = mount.wrap;
      currentSelect = mount.select;
      currentDirectionSelect = mount.directionSelect;
      currentValueToggle = mount.valueToggleInput ?? null;
      if (!stopValueSummaryListener) {
        stopValueSummaryListener = onInventoryValueChange(() => {
          const sourceGrid = resolveGrid();
          if (!sourceGrid || !currentWrap) return;
          const filtersForSummary = getActiveFiltersFromGrid(
            sourceGrid,
            cfg.checkboxSelector,
            cfg.checkboxLabelSelector
          );
          const searchForSummary = getNormalizedInventorySearchQuery(sourceGrid);
          void updateFilteredInventoryValueSummary(
            currentWrap,
            filtersForSummary,
            searchForSummary
          );
        });
      }
      const activeFilters = getActiveFiltersFromGrid(
        targetGrid,
        cfg.checkboxSelector,
        cfg.checkboxLabelSelector
      );
      const container = getInventoryItemsContainer(targetGrid);
      const currentEntries = container ? getInventoryDomEntries(container) : [];
      const inventoryEntryCountChanged = lastRenderedInventoryEntryCount === null || lastRenderedInventoryEntryCount !== currentEntries.length;
      const shouldRenderSelectOptions = inventoryEntryCountChanged || !currentSelect?.options?.length;
      const shouldRenderDirectionOptions = inventoryEntryCountChanged || !currentDirectionSelect?.options?.length;
      const domChangedSinceLastSort = haveDomEntriesChanged(lastSortedDomSnapshot, currentEntries);
      const currentDomSnapshot = createDomSnapshot(currentEntries);
      const searchQueryForGrid = getNormalizedInventorySearchQuery(targetGrid);
      lastComputedFilterContextKey = createFilterContextKey(activeFilters, searchQueryForGrid);
      if (!stopFilterContextListener) {
        stopFilterContextListener = addFilterContextListener((contextKey) => {
          if (contextKey === lastComputedFilterContextKey) {
            setTimeout(refresh, 0);
          }
        });
      }
      void updateFilteredInventoryValueSummary(currentWrap, activeFilters, searchQueryForGrid);
      const serializedFilters = JSON.stringify({
        filters: activeFilters,
        search: searchQueryForGrid
      });
      const filtersChanged = serializedFilters !== lastAppliedFiltersKey;
      if (serializedFilters !== lastLoggedFilters) {
        lastLoggedFilters = serializedFilters;
        console.log("[InventorySorting] Filtres actifs :", activeFilters);
        const currentSortKey = currentSelect?.value ?? void 0;
        const currentDirection = currentDirectionSelect?.value ?? void 0;
        void logInventoryForFilters(
          activeFilters,
          currentSortKey,
          currentDirection,
          searchQueryForGrid
        );
      }
      const options = computeSortOptions(
        activeFilters,
        labelByValue,
        mapExtraByFilter,
        searchQueryForGrid
      );
      const wrapPrevValue = typeof currentWrap.__prevValue === "string" ? currentWrap.__prevValue : null;
      const persistedSortKey = loadPersistedSortKey();
      const preferredValue = (wrapPrevValue && options.some((o) => o.value === wrapPrevValue) ? wrapPrevValue : null) || (persistedSortKey && options.some((o) => o.value === persistedSortKey) ? persistedSortKey : null);
      if (shouldRenderSelectOptions) {
        renderSelectOptions(currentSelect, options, preferredValue);
        lastRenderedInventoryEntryCount = currentEntries.length;
      }
      currentWrap.__prevValue = currentSelect.value;
      const appliedSortKey = currentSelect.value;
      const wrapPrevDirection = typeof currentWrap.__prevDirection === "string" ? currentWrap.__prevDirection : null;
      const persistedDirection = loadPersistedSortDirection();
      const fallbackDirection = defaultDirectionBySortKey[appliedSortKey] ?? DEFAULT_DIRECTION_BY_SORT_KEY[appliedSortKey] ?? "asc";
      const preferredDirection = (wrapPrevDirection && DIRECTION_ORDER.includes(wrapPrevDirection) ? wrapPrevDirection : null) || (persistedDirection && DIRECTION_ORDER.includes(persistedDirection) ? persistedDirection : null) || fallbackDirection;
      let appliedDirection;
      if (currentDirectionSelect) {
        if (shouldRenderDirectionOptions) {
          renderDirectionOptions(currentDirectionSelect, directionLabelByValue, preferredDirection);
        }
        if (preferredDirection && DIRECTION_ORDER.includes(preferredDirection) && currentDirectionSelect.value !== preferredDirection) {
          currentDirectionSelect.value = preferredDirection;
        }
        appliedDirection = currentDirectionSelect.value;
        if (!DIRECTION_ORDER.includes(appliedDirection)) {
          appliedDirection = fallbackDirection;
          currentDirectionSelect.value = fallbackDirection;
        }
        currentWrap.__prevDirection = appliedDirection;
      } else {
        appliedDirection = fallbackDirection;
      }
      const sortChanged = appliedSortKey !== lastAppliedSortKey || appliedDirection !== lastAppliedDirection;
      const shouldApplySorting = sortChanged || filtersChanged && domChangedSinceLastSort;
      if (shouldApplySorting) {
        lastAppliedSortKey = appliedSortKey;
        lastAppliedDirection = appliedDirection;
        lastAppliedFiltersKey = serializedFilters;
        persistSortKey(appliedSortKey);
        persistSortDirection(appliedDirection);
        cfg.onSortChange?.(appliedSortKey, appliedDirection);
        void applySortingWithSnapshot(targetGrid, appliedSortKey, appliedDirection);
      } else {
        if (filtersChanged) {
          lastAppliedFiltersKey = serializedFilters;
          console.log(
            "[InventorySorting] Filtres modifi\xE9s mais la liste DOM est inchang\xE9e, tri non r\xE9appliqu\xE9."
          );
        }
        lastSortedDomSnapshot = currentDomSnapshot;
      }
    };
    const refresh = debounce(update, 120);
    const changeHandler = (e) => {
      const target = e.target;
      if (!target) return;
      const within = target.closest(cfg.gridSelector);
      const currentGrid = resolveGrid();
      if (e.type === "input" && target instanceof HTMLInputElement && target.matches(INVENTORY_SEARCH_INPUT_SELECTOR) && within && within === currentGrid) {
        console.log("[InventorySorting] Texte de recherche modifi\xE9 :", target.value);
        const activeFilters = getActiveFiltersFromGrid(
          currentGrid,
          cfg.checkboxSelector,
          cfg.checkboxLabelSelector
        );
        const normalizedSearch = getNormalizedInventorySearchQuery(currentGrid);
        void logFilteredInventorySearchResults(currentGrid, activeFilters, normalizedSearch);
      }
      if (within && within === currentGrid) {
        setTimeout(refresh, 0);
      }
    };
    const startObservers = () => {
      const root = document.body || document.documentElement;
      if (root) {
        bodyObserver.observe(root, { childList: true, subtree: true });
      }
      setGrid(document.querySelector(cfg.gridSelector));
      document.addEventListener("change", changeHandler, true);
      document.addEventListener("input", changeHandler, true);
      update();
    };
    startObservers();
    return {
      destroy() {
        obs.disconnect();
        bodyObserver.disconnect();
        document.removeEventListener("change", changeHandler, true);
        document.removeEventListener("input", changeHandler, true);
        if (stopValueSummaryListener) {
          stopValueSummaryListener();
          stopValueSummaryListener = null;
        }
        if (stopFilterContextListener) {
          stopFilterContextListener();
          stopFilterContextListener = null;
        }
        if (currentWrap && currentWrap.parentElement) {
          currentWrap.parentElement.removeChild(currentWrap);
        }
        currentWrap = null;
        currentSelect = null;
        currentDirectionSelect = null;
        currentValueToggle = null;
        grid = null;
        lastLoggedFilters = null;
        lastAppliedFiltersKey = null;
        lastAppliedSortKey = null;
        lastAppliedDirection = null;
        shouldEnsureInventoryValueWatcherOnNextVisible = true;
        lastSortedDomSnapshot = null;
      },
      update,
      getActiveFilters() {
        const targetGrid = resolveGrid();
        if (!targetGrid) return [];
        return getActiveFiltersFromGrid(targetGrid, cfg.checkboxSelector, cfg.checkboxLabelSelector);
      },
      getCurrentSortKey() {
        return currentSelect?.value ?? null;
      },
      getCurrentSortDirection() {
        return currentDirectionSelect?.value ?? null;
      },
      setSortKey(k) {
        if (!currentSelect) return;
        currentSelect.value = k;
        currentWrap.__prevValue = k;
        const targetGrid = resolveGrid();
        if (targetGrid) {
          const filtersForLog = getActiveFiltersFromGrid(
            targetGrid,
            cfg.checkboxSelector,
            cfg.checkboxLabelSelector
          );
          const searchQuery = getNormalizedInventorySearchQuery(targetGrid);
          const filtersKey = JSON.stringify({ filters: filtersForLog, search: searchQuery });
          console.log("[InventorySorting] Tri s\xE9lectionn\xE9 (programmatique) :", k);
          const directionToApply = currentDirectionSelect?.value ?? defaultDirectionBySortKey[k] ?? DEFAULT_DIRECTION_BY_SORT_KEY[k] ?? "asc";
          if (currentDirectionSelect) {
            currentDirectionSelect.value = directionToApply;
            currentWrap.__prevDirection = directionToApply;
          }
          void logInventoryForFilters(filtersForLog, k, directionToApply, searchQuery);
          lastAppliedFiltersKey = filtersKey;
          lastAppliedSortKey = k;
          lastAppliedDirection = directionToApply;
          persistSortKey(k);
          persistSortDirection(directionToApply);
          cfg.onSortChange?.(k, directionToApply);
          setShouldDisplayInventoryValues(showInventoryValues);
          void applySortingWithSnapshot(targetGrid, k, directionToApply);
        }
      },
      setSortDirection(direction) {
        if (!currentDirectionSelect) return;
        currentDirectionSelect.value = direction;
        currentWrap.__prevDirection = direction;
        const targetGrid = resolveGrid();
        const sortKey = currentSelect?.value ?? "none";
        if (targetGrid) {
          const filtersForLog = getActiveFiltersFromGrid(
            targetGrid,
            cfg.checkboxSelector,
            cfg.checkboxLabelSelector
          );
          const searchQuery = getNormalizedInventorySearchQuery(targetGrid);
          const filtersKey = JSON.stringify({ filters: filtersForLog, search: searchQuery });
          console.log("[InventorySorting] Ordre de tri s\xE9lectionn\xE9 (programmatique) :", direction);
          void logInventoryForFilters(filtersForLog, sortKey, direction, searchQuery);
          lastAppliedFiltersKey = filtersKey;
          lastAppliedSortKey = sortKey;
          lastAppliedDirection = direction;
          persistSortKey(sortKey);
          persistSortDirection(direction);
          cfg.onSortChange?.(sortKey, direction);
          setShouldDisplayInventoryValues(showInventoryValues);
          void applySortingWithSnapshot(targetGrid, sortKey, direction);
        }
      },
      getSortOptions() {
        const targetGrid = resolveGrid();
        const filters = targetGrid ? getActiveFiltersFromGrid(targetGrid, cfg.checkboxSelector, cfg.checkboxLabelSelector) : [];
        const search = getNormalizedInventorySearchQuery(targetGrid);
        return computeSortOptions(filters, labelByValue, mapExtraByFilter, search);
      },
      getGrid() {
        return resolveGrid();
      }
    };
  }
  function startInventorySortingObserver(options = {}) {
    if (typeof window === "undefined" || typeof document === "undefined") {
      return {
        stop() {
        },
        refresh() {
        },
        getController() {
          return null;
        }
      };
    }
    const { waitForGrid = true, log: log2, ...config } = options;
    const cfg = config;
    let controller = null;
    let observer2 = null;
    let readyListener = null;
    const logger = typeof log2 === "function" ? log2 : log2 ? (...args) => console.debug("[InventorySorting]", ...args) : () => {
    };
    const attachIfPossible = () => {
      if (controller) return controller;
      if (waitForGrid) {
        const selector = cfg.gridSelector ?? DEFAULTS5.gridSelector;
        if (!document.querySelector(selector)) {
          return null;
        }
      }
      controller = attachInventorySorting(cfg);
      logger("attached");
      return controller;
    };
    const ensureObserver = () => {
      if (controller || observer2 || !waitForGrid) return;
      const target = document.body || document.documentElement;
      if (!target) return;
      observer2 = new MutationObserver(() => {
        if (attachIfPossible()) {
          observer2?.disconnect();
          observer2 = null;
          logger("attached via mutation");
        }
      });
      observer2.observe(target, { childList: true, subtree: true });
    };
    const start = () => {
      if (!attachIfPossible()) {
        ensureObserver();
      }
    };
    if (document.readyState === "loading") {
      readyListener = () => {
        readyListener = null;
        start();
      };
      document.addEventListener("DOMContentLoaded", readyListener, { once: true });
    } else {
      start();
    }
    return {
      stop() {
        if (readyListener) {
          document.removeEventListener("DOMContentLoaded", readyListener);
          readyListener = null;
        }
        observer2?.disconnect();
        observer2 = null;
        controller?.destroy();
        controller = null;
      },
      refresh() {
        if (controller) {
          controller.update();
        } else {
          start();
        }
      },
      getController() {
        return controller;
      }
    };
  }

  // src/services/activityLogHistory.ts
  var HISTORY_STORAGE_KEY = "activityLog.history";
  var HISTORY_LIMIT = 500;
  function normalizeEntry(raw) {
    if (!raw || typeof raw !== "object") return null;
    const ts = Number(raw.timestamp);
    if (!Number.isFinite(ts)) return null;
    const parameters = (() => {
      const p = raw.parameters;
      if (!p || typeof p !== "object") return p;
      const petId = typeof p?.pet?.id === "string" ? p.pet.id : null;
      if (petId && !p.petId) {
        return { ...p, petId };
      }
      return p;
    })();
    const action2 = typeof raw.action === "string" && raw.action.trim() ? String(raw.action) : null;
    const entry = {
      ...raw,
      timestamp: ts,
      parameters
    };
    if (action2 !== null) entry.action = action2;
    return entry;
  }
  function normalizeList(logs) {
    const out = [];
    if (!Array.isArray(logs)) return out;
    for (const raw of logs) {
      const norm3 = normalizeEntry(raw);
      if (norm3) out.push(norm3);
    }
    return out;
  }
  function stableStringify(value) {
    const seen = /* @__PURE__ */ new WeakSet();
    const walk = (val) => {
      if (val === null) return null;
      if (typeof val !== "object") return val;
      if (seen.has(val)) return "__CYCLE__";
      seen.add(val);
      if (Array.isArray(val)) return val.map(walk);
      const obj = {};
      const keys = Object.keys(val).sort();
      for (const k of keys) obj[k] = walk(val[k]);
      return obj;
    };
    try {
      return JSON.stringify(walk(value));
    } catch {
      return "";
    }
  }
  function entryIdentity(entry) {
    const p = entry?.parameters;
    const candidates = [
      p?.id,
      p?.pet?.id,
      p?.petId,
      p?.playerId,
      p?.userId,
      p?.objectId,
      p?.slotId,
      p?.itemId,
      p?.cropId,
      p?.seedId,
      p?.decorId,
      p?.toolId,
      p?.targetId,
      p?.abilityId
    ];
    for (const c of candidates) {
      if (typeof c === "string" && c.trim()) return c;
    }
    return null;
  }
  function entryKey(entry) {
    const ts = Number(entry.timestamp);
    const action2 = typeof entry.action === "string" ? entry.action : "";
    const identity = entryIdentity(entry) ?? "__noid__";
    const tsPart = Number.isFinite(ts) ? String(ts) : `t:${stableStringify({ timestamp: entry.timestamp ?? null })}`;
    return `${tsPart}|${action2}|${identity}`;
  }
  function entriesEqual(a, b) {
    return stableStringify(a) === stableStringify(b);
  }
  function loadHistory() {
    try {
      const parsed = readAriesPath(HISTORY_STORAGE_KEY);
      if (!Array.isArray(parsed)) return [];
      const out = [];
      for (const item of parsed) {
        const norm3 = normalizeEntry(item);
        if (norm3) out.push(norm3);
      }
      return out;
    } catch {
      return [];
    }
  }
  function saveHistory(entries) {
    const sorted = entries.slice().sort((a, b) => Number(a.timestamp || 0) - Number(b.timestamp || 0));
    if (sorted.length > HISTORY_LIMIT) {
      sorted.splice(0, sorted.length - HISTORY_LIMIT);
    }
    try {
      writeAriesPath(HISTORY_STORAGE_KEY, sorted);
    } catch {
    }
  }
  function diffSnapshots(prev, next) {
    const prevBuckets = /* @__PURE__ */ new Map();
    const bucketPush = (k, entry) => {
      const arr = prevBuckets.get(k);
      if (arr) arr.push(entry);
      else prevBuckets.set(k, [entry]);
    };
    for (const entry of prev) bucketPush(entryKey(entry), entry);
    const added = [];
    const updated = [];
    for (const entry of next) {
      const key2 = entryKey(entry);
      const bucket = prevBuckets.get(key2);
      const prevEntry = bucket?.shift();
      if (!prevEntry) {
        added.push(entry);
      } else if (!entriesEqual(prevEntry, entry)) {
        updated.push(entry);
      }
      if (bucket && bucket.length === 0) prevBuckets.delete(key2);
    }
    return { added, updated };
  }
  function syncHistory(prevSnapshot, nextSnapshot) {
    const history2 = loadHistory();
    const { added, updated } = diffSnapshots(prevSnapshot, nextSnapshot);
    if (!added.length && !updated.length) return history2;
    const map2 = /* @__PURE__ */ new Map();
    for (const h of history2) map2.set(entryKey(h), h);
    let changed = false;
    const upsert = (entry) => {
      const key2 = entryKey(entry);
      const cur = map2.get(key2);
      if (!cur || !entriesEqual(cur, entry)) {
        map2.set(key2, entry);
        changed = true;
      }
    };
    updated.forEach(upsert);
    added.forEach(upsert);
    if (!changed) return history2;
    const merged = Array.from(map2.values());
    saveHistory(merged);
    return merged;
  }
  async function reopenFakeActivityLogFromHistory() {
    try {
      const history2 = loadHistory();
      await fakeActivityLogShow(history2, { open: true });
    } catch {
    }
  }
  async function startActivityLogHistoryWatcher() {
    const stops = [];
    let lastSnapshot = [];
    const ingest = async (logs, prev) => {
      try {
        const prevSnapshot = typeof prev !== "undefined" ? normalizeList(prev) : lastSnapshot;
        const nextSnapshot = normalizeList(logs);
        syncHistory(prevSnapshot, nextSnapshot);
        lastSnapshot = nextSnapshot;
      } catch {
      }
    };
    try {
      const initial = normalizeList(await myActivityLog.get());
      await ingest(initial);
    } catch {
    }
    try {
      const unsub = await myActivityLog.onChange((next, prev) => {
        void ingest(next, prev);
      });
      stops.push(() => {
        try {
          unsub();
        } catch {
        }
      });
    } catch {
    }
    let lastModal = null;
    try {
      const cur = await Atoms.ui.activeModal.get();
      lastModal = cur ?? null;
    } catch {
    }
    const onModalChange = async (modalId) => {
      const cur = modalId ?? null;
      if (cur === ACTIVITY_LOG_MODAL_ID && lastModal !== ACTIVITY_LOG_MODAL_ID) {
        await reopenFakeActivityLogFromHistory();
      }
      lastModal = cur;
    };
    try {
      const unsubModal = await Atoms.ui.activeModal.onChange(onModalChange);
      stops.push(() => {
        try {
          unsubModal();
        } catch {
        }
      });
    } catch {
    }
    return async () => {
      for (const stop2 of stops) {
        try {
          await stop2();
        } catch {
        }
      }
    };
  }

  // src/utils/activityLogFilter.ts
  var FILTER_STORAGE_KEY = "activityLog.filter";
  var STYLE_ID2 = "mg-activity-log-filter-style";
  var ROOT_FLAG_ATTR = "data-mg-activity-log-filter-ready";
  var WRAPPER_CLASS = "mg-activity-log-filter";
  var BUTTON_CLASS = "mg-activity-log-filter-btn";
  var ACTIVE_CLASS = "is-active";
  var ACTION_ORDER = [
    "all",
    "found",
    "buy",
    "sell",
    "harvest",
    "plant",
    "feed",
    "hatch",
    "water",
    "boost",
    "remove",
    "other"
  ];
  var ACTION_LABELS = {
    all: "All",
    found: "Finds",
    buy: "Purchases",
    sell: "Sold",
    harvest: "Harvests",
    plant: "Planted",
    feed: "Feed",
    hatch: "Hatch",
    water: "Water",
    boost: "Boosts",
    remove: "Remove",
    other: "Other"
  };
  var ACTION_MAP = {
    purchaseDecor: "buy",
    purchaseSeed: "buy",
    purchaseEgg: "buy",
    purchaseTool: "buy",
    waterPlant: "water",
    plantSeed: "plant",
    plantGardenPlant: "plant",
    potPlant: "plant",
    removeGardenObject: "remove",
    harvest: "harvest",
    feedPet: "feed",
    plantEgg: "hatch",
    hatchEgg: "hatch",
    instaGrow: "boost",
    customRestock: "boost",
    spinSlotMachine: "boost",
    sellAllCrops: "sell",
    sellPet: "sell",
    logItems: "boost",
    mutationPotion: "boost",
    ProduceScaleBoost: "boost",
    ProduceScaleBoostII: "boost",
    DoubleHarvest: "boost",
    DoubleHatch: "boost",
    ProduceEater: "boost",
    SellBoostI: "boost",
    SellBoostII: "boost",
    SellBoostIII: "boost",
    SellBoostIV: "boost",
    ProduceRefund: "boost",
    PlantGrowthBoost: "boost",
    PlantGrowthBoostII: "boost",
    HungerRestore: "boost",
    HungerRestoreII: "boost",
    GoldGranter: "boost",
    RainbowGranter: "boost",
    RainDance: "boost",
    PetXpBoost: "boost",
    PetXpBoostII: "boost",
    EggGrowthBoost: "boost",
    EggGrowthBoostII_NEW: "boost",
    EggGrowthBoostII: "boost",
    PetAgeBoost: "boost",
    PetAgeBoostII: "boost",
    CoinFinderI: "boost",
    CoinFinderII: "boost",
    CoinFinderIII: "boost",
    SeedFinderI: "boost",
    SeedFinderII: "boost",
    SeedFinderIII: "boost",
    SeedFinderIV: "boost",
    PetHatchSizeBoost: "boost",
    PetHatchSizeBoostII: "boost",
    MoonKisser: "boost",
    DawnKisser: "boost",
    PetRefund: "boost",
    PetRefundII: "boost"
  };
  var ACTION_MAP_LOWER = Object.fromEntries(
    Object.entries(ACTION_MAP).map(([k, v]) => [k.toLowerCase(), v])
  );
  var PATTERNS = [
    { key: "found", re: /\bfound\b/i },
    { key: "buy", re: /\b(bought|purchas(e|ed))\b/i },
    { key: "sell", re: /\bsold\b/i },
    { key: "harvest", re: /harvest/i },
    { key: "water", re: /water(ed)?/i },
    { key: "plant", re: /planted/i },
    { key: "feed", re: /\bfed\b/i },
    { key: "hatch", re: /\bhatched?\b/i },
    { key: "remove", re: /\b(remove|removed|delete)\b/i },
    { key: "boost", re: /\b(boost|potion|refund|granter|growth|restock|spin)\b/i }
  ];
  var started3 = false;
  var activeFilter = loadPersistedFilter() ?? "all";
  function startActivityLogFilter() {
    if (started3 || typeof document === "undefined") return;
    started3 = true;
    ensureStyles();
    onAdded(
      (el2) => el2 instanceof HTMLElement && el2.matches("p.chakra-text") && /activity\s*log/i.test(el2.textContent || ""),
      (titleEl) => {
        const root = titleEl.closest("div.McGrid");
        if (!root || root.hasAttribute(ROOT_FLAG_ATTR)) return;
        const header = root.querySelector("div.McFlex.css-2tfeb0") ?? titleEl.closest("div.McFlex");
        const content = root.querySelector("div.McFlex.css-iek5kf") ?? root.querySelectorAll("div.McFlex")[1] ?? null;
        if (!header || !content) return;
        root.setAttribute(ROOT_FLAG_ATTR, "1");
        injectFilter(header, content);
      },
      { callForExisting: true }
    );
  }
  function injectFilter(header, content) {
    const wrapper = document.createElement("div");
    wrapper.className = WRAPPER_CLASS;
    wrapper.style.width = "100%";
    wrapper.style.boxSizing = "border-box";
    wrapper.style.gridColumn = "1 / -1";
    wrapper.style.alignSelf = "start";
    wrapper.style.justifyContent = "flex-start";
    wrapper.style.flex = "0 0 auto";
    wrapper.style.minHeight = "auto";
    const label2 = document.createElement("span");
    label2.textContent = "Filter by action:";
    label2.className = `${WRAPPER_CLASS}__label`;
    const buttons = document.createElement("div");
    buttons.className = `${WRAPPER_CLASS}__buttons`;
    buttons.style.flex = "1 1 100%";
    buttons.style.minWidth = "0";
    buttons.style.alignItems = "center";
    wrapper.append(label2, buttons);
    content.insertBefore(wrapper, content.firstChild);
    const entriesContainer = content.querySelector("div.McFlex.css-173k61n") ?? content.querySelector("div.McFlex") ?? content;
    const renderButtons = (counts) => {
      const actions = mergeActions(Array.from(counts.keys()));
      if (!actions.includes("all")) actions.unshift("all");
      buttons.innerHTML = "";
      for (const action2 of actions) {
        const count = counts.get(action2) ?? 0;
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = `${BUTTON_CLASS}${action2 === activeFilter ? ` ${ACTIVE_CLASS}` : ""}`;
        btn.textContent = `${getActionLabel(action2)}${count ? ` (${count})` : ""}`;
        btn.dataset.action = action2;
        btn.addEventListener("click", () => {
          activeFilter = action2;
          persistFilter(action2);
          updateButtons(buttons);
          applyFilter(entriesContainer, activeFilter);
        });
        buttons.appendChild(btn);
      }
    };
    const refresh = () => {
      const counts = /* @__PURE__ */ new Map();
      for (const entry of getEntryElements(entriesContainer)) {
        const action2 = classifyEntry(entry);
        counts.set(action2, (counts.get(action2) ?? 0) + 1);
      }
      renderButtons(counts);
      if (!counts.has(activeFilter) && activeFilter !== "all") {
        activeFilter = "all";
        persistFilter(activeFilter);
        updateButtons(buttons);
      }
      applyFilter(entriesContainer, activeFilter);
    };
    const obs = new MutationObserver(() => refresh());
    obs.observe(entriesContainer, { childList: true, subtree: true });
    refresh();
    const cleanup2 = () => obs.disconnect();
    const onRemoved = () => cleanup2();
    wrapper.addEventListener("DOMNodeRemovedFromDocument", onRemoved, { once: true });
  }
  function classifyEntry(entry) {
    const preset = entry.dataset.action || entry.getAttribute("data-action") || entry.getAttribute("data-activity") || entry.dataset.mgAction;
    if (preset && typeof preset === "string") {
      const trimmed = preset.trim();
      if (trimmed) {
        const normalized = normalizeAction(trimmed);
        entry.dataset.mgAction = normalized;
        return normalized;
      }
    }
    const text = (entry.textContent || "").trim();
    for (const { key: key2, re } of PATTERNS) {
      if (re.test(text)) {
        entry.dataset.mgAction = key2;
        return key2;
      }
    }
    entry.dataset.mgAction = "other";
    return "other";
  }
  function normalizeAction(raw) {
    const lowered = raw.toLowerCase();
    if (ACTION_MAP[raw]) return ACTION_MAP[raw];
    if (ACTION_MAP_LOWER[lowered]) return ACTION_MAP_LOWER[lowered];
    for (const { key: key2, re } of PATTERNS) {
      if (re.test(lowered)) return key2;
    }
    return lowered || "other";
  }
  function getEntryElements(container) {
    const candidates = Array.from(container.children).filter((child) => child instanceof HTMLElement);
    return candidates.filter((child) => {
      if (child.classList.contains(WRAPPER_CLASS)) return false;
      const text = child.textContent || "";
      return /\bago\b/i.test(text) || child.querySelector("p.chakra-text");
    });
  }
  function mergeActions(actions) {
    const seen = /* @__PURE__ */ new Set();
    const ordered = [];
    for (const k of ACTION_ORDER) {
      if (k === "all") continue;
      if (actions.includes(k) && !seen.has(k)) {
        seen.add(k);
        ordered.push(k);
      }
    }
    for (const a of actions) {
      if (a === "all") continue;
      if (!seen.has(a)) {
        seen.add(a);
        ordered.push(a);
      }
    }
    return ordered;
  }
  function applyFilter(container, filter) {
    for (const entry of getEntryElements(container)) {
      const action2 = entry.dataset.mgAction ?? classifyEntry(entry);
      const visible = filter === "all" || action2 === filter;
      entry.style.display = visible ? "" : "none";
    }
  }
  function updateButtons(buttons) {
    buttons.querySelectorAll(`.${BUTTON_CLASS}`).forEach((btn) => {
      if (!(btn instanceof HTMLButtonElement)) return;
      const action2 = btn.dataset.action;
      btn.classList.toggle(ACTIVE_CLASS, action2 === activeFilter);
    });
  }
  function getActionLabel(action2) {
    return ACTION_LABELS[action2] ?? action2.replace(/[_-]+/g, " ").replace(/\b\w/g, (m) => m.toUpperCase());
  }
  function loadPersistedFilter() {
    try {
      const stored = readAriesPath(FILTER_STORAGE_KEY);
      return stored || null;
    } catch {
      return null;
    }
  }
  function persistFilter(value) {
    try {
      writeAriesPath(FILTER_STORAGE_KEY, String(value));
    } catch {
    }
  }
  function ensureStyles() {
    if (document.getElementById(STYLE_ID2)) return;
    const css = `
.${WRAPPER_CLASS}{
  display:flex;
  align-items:center;
  gap:8px;
  padding:8px 10px;
  margin:8px 0 10px 0;
  border-radius:12px;
  background:linear-gradient(180deg, #f7e8d4, #f1dcc1);
  border:1px solid #d7b989;
  box-shadow:inset 0 1px 0 rgba(255,255,255,0.45), 0 6px 14px rgba(120,70,34,0.22);
  flex-wrap:wrap;
  max-width:100%;
  box-sizing:border-box;
}
.${WRAPPER_CLASS}__label{
  font-size:12px;
  letter-spacing:0.03em;
  text-transform:uppercase;
  opacity:0.85;
  font-weight:700;
  color:#7b4b2b;
}
.${WRAPPER_CLASS}__buttons{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  flex:1 1 100%;
  min-width:0;
}
.${BUTTON_CLASS}{
  border:1px solid #caa56f;
  background:linear-gradient(180deg, #ffe9c8, #f6d7aa);
  color:#5c3416;
  border-radius:999px;
  padding:4px 10px;
  font-size:12px;
  cursor:pointer;
  transition:background 120ms ease, border-color 120ms ease, transform 120ms ease;
  white-space:nowrap;
}
.${BUTTON_CLASS}:hover{
  background:linear-gradient(180deg, #ffe2b2, #f3c98d);
  border-color:#d7b989;
}
.${BUTTON_CLASS}.${ACTIVE_CLASS}{
  background:linear-gradient(180deg, #ffcd82, #f3b05e);
  border-color:#e3a23d;
  box-shadow:0 0 0 1px rgba(227,162,61,0.35), 0 4px 10px rgba(158,94,32,0.25);
  transform:translateY(-1px);
}
`;
    const s = addStyle(css);
    s.id = STYLE_ID2;
  }

  // src/utils/sellCropsLock.ts
  var CONTAINER_SELECTOR = ".css-vmnhaw";
  var LOCK_ICON_CLASS2 = "tm-sell-crops-lock";
  var DATA_BORDER = "tmSellLockBorder";
  var DATA_RADIUS = "tmSellLockRadius";
  var DATA_POSITION = "tmSellLockPosition";
  var DATA_PADDING = "tmSellLockPadding";
  var DATA_BOX = "tmSellLockBox";
  var DATA_SHADOW = "tmSellLockShadow";
  var DATA_OVERFLOW = "tmSellLockOverflow";
  function startSellCropsLockWatcher() {
    if (typeof window === "undefined" || typeof document === "undefined") {
      return { stop() {
      } };
    }
    let bonusFromMultiplier = null;
    let bonusFromPlayers = friendBonusPercentFromPlayers(1);
    let running = true;
    const disposables = [];
    const resolveCurrentBonus = () => bonusFromMultiplier ?? bonusFromPlayers ?? 0;
    const applyLockState = (locked) => {
      const containers = Array.from(
        document.querySelectorAll(CONTAINER_SELECTOR)
      );
      containers.forEach((wrap) => setContainerLocked(wrap, locked));
    };
    const recompute = () => {
      if (!running) return;
      const requiredPct = lockerRestrictionsService.getRequiredPercent();
      const current = resolveCurrentBonus();
      const locked = requiredPct > 0 && !(Number.isFinite(current) && current + 1e-4 >= requiredPct);
      applyLockState(locked);
    };
    const observeDom = () => {
      const mo = new MutationObserver(() => recompute());
      mo.observe(document.documentElement, { childList: true, subtree: true });
      disposables.push(() => mo.disconnect());
    };
    const subscribeAtoms = async () => {
      try {
        const initial = await Atoms.server.friendBonusMultiplier.get();
        bonusFromMultiplier = friendBonusPercentFromMultiplier(initial);
      } catch {
      }
      try {
        const unsub = await Atoms.server.friendBonusMultiplier.onChange((next) => {
          bonusFromMultiplier = friendBonusPercentFromMultiplier(next);
          recompute();
        });
        if (typeof unsub === "function") disposables.push(unsub);
      } catch {
      }
      try {
        const initialPlayers = await Atoms.server.numPlayers.get();
        bonusFromPlayers = friendBonusPercentFromPlayers(initialPlayers);
      } catch {
      }
      try {
        const unsubPlayers = await Atoms.server.numPlayers.onChange((next) => {
          bonusFromPlayers = friendBonusPercentFromPlayers(next);
          recompute();
        });
        if (typeof unsubPlayers === "function") disposables.push(unsubPlayers);
      } catch {
      }
    };
    observeDom();
    disposables.push(lockerRestrictionsService.subscribe(() => recompute()));
    void subscribeAtoms();
    recompute();
    return {
      stop() {
        running = false;
        disposables.splice(0).forEach((fn) => {
          try {
            fn();
          } catch {
          }
        });
        applyLockState(false);
      }
    };
  }
  function setContainerLocked(container, locked) {
    if (!container) return;
    const sellButton = findSellButton(container);
    if (!sellButton) {
      restoreContainerStyles(container);
      removeLockIcon2(container);
      return;
    }
    if (!locked) {
      restoreContainerStyles(container);
      removeLockIcon2(container);
      return;
    }
    storeOriginalStyle(container, DATA_BORDER, "border");
    storeOriginalStyle(container, DATA_RADIUS, "borderRadius");
    storeOriginalStyle(container, DATA_POSITION, "position");
    storeOriginalStyle(container, DATA_PADDING, "padding");
    storeOriginalStyle(container, DATA_BOX, "boxSizing");
    storeOriginalStyle(container, DATA_SHADOW, "boxShadow");
    storeOriginalStyle(container, DATA_OVERFLOW, "overflow");
    container.style.border = "none";
    container.style.borderRadius = "";
    container.style.padding = "";
    container.style.boxSizing = "";
    container.style.boxShadow = "none";
    container.style.overflow = "";
    const computedPos = window.getComputedStyle(container).position;
    if (computedPos === "static") {
      container.style.position = "relative";
    }
    container.style.zIndex = "1000";
    ensureLockIcon2(container);
  }
  function storeOriginalStyle(el2, key2, cssProperty) {
    const data = el2.dataset;
    if (data[key2] !== void 0) return;
    data[key2] = el2.style[cssProperty];
  }
  function restoreContainerStyles(el2) {
    restoreStyle(el2, DATA_BORDER, "border");
    restoreStyle(el2, DATA_RADIUS, "borderRadius");
    restoreStyle(el2, DATA_POSITION, "position");
    restoreStyle(el2, DATA_PADDING, "padding");
    restoreStyle(el2, DATA_BOX, "boxSizing");
    restoreStyle(el2, DATA_SHADOW, "boxShadow");
    restoreStyle(el2, DATA_OVERFLOW, "overflow");
  }
  function restoreStyle(el2, key2, cssProperty) {
    const data = el2.dataset;
    if (data[key2] === void 0) return;
    const value = data[key2];
    if (value) {
      el2.style.setProperty(camelToKebab(cssProperty), value);
    } else {
      el2.style.removeProperty(camelToKebab(cssProperty));
    }
    delete data[key2];
  }
  function camelToKebab(str) {
    return str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);
  }
  function ensureLockIcon2(btn) {
    const existing = btn.querySelector(`span.${LOCK_ICON_CLASS2}`);
    if (existing) return;
    const icon = document.createElement("span");
    icon.className = LOCK_ICON_CLASS2;
    icon.textContent = "\u{1F512}";
    icon.style.position = "absolute";
    icon.style.top = "-4px";
    icon.style.right = "-4px";
    icon.style.fontSize = "16px";
    icon.style.pointerEvents = "none";
    icon.style.userSelect = "none";
    icon.style.zIndex = "2";
    btn.appendChild(icon);
  }
  function removeLockIcon2(btn) {
    btn.querySelectorAll(`span.${LOCK_ICON_CLASS2}`).forEach((node) => node.remove());
  }
  function findSellButton(container) {
    const btn = container.querySelector("button");
    if (!btn) return null;
    const text = (btn.textContent || "").trim();
    return /sell\s*crops/i.test(text) ? btn : null;
  }

  // src/utils/eggHatchLockIndicator.ts
  var CONTAINER_SELECTOR2 = ".css-502lyi";
  var LOCK_CLASS = "tm-egg-lock";
  var BORDER_COLOR = "rgb(188, 53, 215)";
  var DATA_BORDER2 = "tmEggLockBorder";
  var DATA_RADIUS2 = "tmEggLockRadius";
  var DATA_POSITION2 = "tmEggLockPosition";
  var DATA_OVERFLOW2 = "tmEggLockOverflow";
  function startEggHatchLockIndicator() {
    if (typeof window === "undefined" || typeof document === "undefined") {
      return { stop() {
      } };
    }
    let running = true;
    let currentEggId = null;
    const disposables = [];
    const isEggLocked = () => lockerRestrictionsService.isEggLocked(currentEggId);
    const applyLockState = () => {
      if (!running) return;
      const locked = isEggLocked();
      const containers = Array.from(document.querySelectorAll(CONTAINER_SELECTOR2));
      containers.forEach((el2) => {
        if (!containsEggLabel(el2)) {
          restore(el2);
          return;
        }
        setLocked(el2, locked);
      });
    };
    const observeDom = () => {
      const mo = new MutationObserver(() => applyLockState());
      mo.observe(document.documentElement, { childList: true, subtree: true });
      disposables.push(() => mo.disconnect());
    };
    const subscribeAtoms = async () => {
      try {
        const initial = await Atoms.data.myCurrentGardenObject.get();
        currentEggId = extractEggId2(initial);
      } catch {
      }
      try {
        const unsub = await Atoms.data.myCurrentGardenObject.onChange((next) => {
          currentEggId = extractEggId2(next);
          applyLockState();
        });
        if (typeof unsub === "function") disposables.push(unsub);
      } catch {
      }
      const unsubLocker = lockerRestrictionsService.subscribe(() => applyLockState());
      disposables.push(unsubLocker);
    };
    observeDom();
    void subscribeAtoms();
    applyLockState();
    return {
      stop() {
        running = false;
        disposables.splice(0).forEach((fn) => {
          try {
            fn();
          } catch {
          }
        });
        const containers = Array.from(document.querySelectorAll(CONTAINER_SELECTOR2));
        containers.forEach(restore);
      }
    };
  }
  function containsEggLabel(el2) {
    const text = (el2.textContent || "").toLowerCase();
    return text.includes("egg");
  }
  function setLocked(el2, locked) {
    if (!locked) {
      restore(el2);
      return;
    }
    storeStyle(el2, DATA_BORDER2, "border");
    storeStyle(el2, DATA_RADIUS2, "borderRadius");
    storeStyle(el2, DATA_POSITION2, "position");
    storeStyle(el2, DATA_OVERFLOW2, "overflow");
    el2.style.border = `3px solid ${BORDER_COLOR}`;
    el2.style.borderRadius = "16px";
    el2.style.overflow = "visible";
    const pos = window.getComputedStyle(el2).position;
    if (pos === "static") {
      el2.style.position = "relative";
    }
    ensureLockIcon3(el2);
  }
  function restore(el2) {
    restoreStyle2(el2, DATA_BORDER2, "border");
    restoreStyle2(el2, DATA_RADIUS2, "borderRadius");
    restoreStyle2(el2, DATA_POSITION2, "position");
    restoreStyle2(el2, DATA_OVERFLOW2, "overflow");
    removeLockIcon3(el2);
  }
  function storeStyle(el2, key2, cssProperty) {
    const data = el2.dataset;
    if (data[key2] !== void 0) return;
    data[key2] = el2.style[cssProperty];
  }
  function restoreStyle2(el2, key2, cssProperty) {
    const data = el2.dataset;
    if (data[key2] === void 0) return;
    const value = data[key2];
    if (value) {
      el2.style.setProperty(camelToKebab2(cssProperty), value);
    } else {
      el2.style.removeProperty(camelToKebab2(cssProperty));
    }
    delete data[key2];
  }
  function camelToKebab2(str) {
    return str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);
  }
  function ensureLockIcon3(el2) {
    const existing = el2.querySelector(`span.${LOCK_CLASS}`);
    if (existing) return;
    const icon = document.createElement("span");
    icon.className = LOCK_CLASS;
    icon.textContent = "\u{1F512}";
    icon.style.position = "absolute";
    icon.style.top = "-8px";
    icon.style.right = "-8px";
    icon.style.fontSize = "16px";
    icon.style.pointerEvents = "none";
    icon.style.userSelect = "none";
    icon.style.zIndex = "2";
    el2.appendChild(icon);
  }
  function removeLockIcon3(el2) {
    el2.querySelectorAll(`span.${LOCK_CLASS}`).forEach((node) => node.remove());
  }
  function extractEggId2(obj) {
    if (!obj || typeof obj !== "object") return null;
    if (obj.objectType !== "egg") return null;
    const eggId = obj.eggId;
    return typeof eggId === "string" && eggId ? eggId : null;
  }

  // src/utils/decorPickupLockIndicator.ts
  var CONTAINER_SELECTOR3 = ".css-502lyi";
  var LOCK_CLASS2 = "tm-decor-lock";
  var BORDER_COLOR2 = "rgb(188, 53, 215)";
  var DATA_BORDER3 = "tmDecorLockBorder";
  var DATA_RADIUS3 = "tmDecorLockRadius";
  var DATA_POSITION3 = "tmDecorLockPosition";
  var DATA_OVERFLOW3 = "tmDecorLockOverflow";
  var DECOR_LABELS = (() => {
    const labels = /* @__PURE__ */ new Set();
    try {
      Object.entries(decorCatalog).forEach(([decorId, entry]) => {
        if (decorId) labels.add(decorId.toLowerCase());
        const name = entry?.name;
        if (typeof name === "string" && name) {
          labels.add(name.toLowerCase());
        }
      });
    } catch {
    }
    return Array.from(labels).filter(Boolean);
  })();
  function startDecorPickupLockIndicator() {
    if (typeof window === "undefined" || typeof document === "undefined") {
      return { stop() {
      } };
    }
    let running = true;
    const disposables = [];
    const isLocked = () => lockerRestrictionsService.isDecorPickupLocked();
    const applyLockState = () => {
      if (!running) return;
      const locked = isLocked();
      const containers = Array.from(document.querySelectorAll(CONTAINER_SELECTOR3));
      containers.forEach((el2) => {
        if (!looksLikeDecorItem(el2)) {
          restore2(el2);
          return;
        }
        setLocked2(el2, locked);
      });
    };
    const observeDom = () => {
      const mo = new MutationObserver(() => applyLockState());
      mo.observe(document.documentElement, { childList: true, subtree: true });
      disposables.push(() => mo.disconnect());
    };
    const subscribeLocker2 = () => {
      const unsub = lockerRestrictionsService.subscribe(() => applyLockState());
      disposables.push(unsub);
    };
    observeDom();
    subscribeLocker2();
    applyLockState();
    return {
      stop() {
        running = false;
        disposables.splice(0).forEach((fn) => {
          try {
            fn();
          } catch {
          }
        });
        const containers = Array.from(document.querySelectorAll(CONTAINER_SELECTOR3));
        containers.forEach(restore2);
      }
    };
  }
  function looksLikeDecorItem(el2) {
    const text = (el2.textContent || "").toLowerCase();
    if (!text) return false;
    if (!el2.querySelector("canvas")) return false;
    return DECOR_LABELS.some((label2) => label2 && text.includes(label2));
  }
  function setLocked2(el2, locked) {
    if (!locked) {
      restore2(el2);
      return;
    }
    storeStyle2(el2, DATA_BORDER3, "border");
    storeStyle2(el2, DATA_RADIUS3, "borderRadius");
    storeStyle2(el2, DATA_POSITION3, "position");
    storeStyle2(el2, DATA_OVERFLOW3, "overflow");
    el2.style.border = `3px solid ${BORDER_COLOR2}`;
    el2.style.borderRadius = "16px";
    el2.style.overflow = "visible";
    const pos = window.getComputedStyle(el2).position;
    if (pos === "static") {
      el2.style.position = "relative";
    }
    ensureLockIcon4(el2);
  }
  function restore2(el2) {
    restoreStyle3(el2, DATA_BORDER3, "border");
    restoreStyle3(el2, DATA_RADIUS3, "borderRadius");
    restoreStyle3(el2, DATA_POSITION3, "position");
    restoreStyle3(el2, DATA_OVERFLOW3, "overflow");
    removeLockIcon4(el2);
  }
  function storeStyle2(el2, key2, cssProperty) {
    const data = el2.dataset;
    if (data[key2] !== void 0) return;
    data[key2] = el2.style[cssProperty];
  }
  function restoreStyle3(el2, key2, cssProperty) {
    const data = el2.dataset;
    if (data[key2] === void 0) return;
    const value = data[key2];
    if (value) {
      el2.style.setProperty(camelToKebab3(cssProperty), value);
    } else {
      el2.style.removeProperty(camelToKebab3(cssProperty));
    }
    delete data[key2];
  }
  function camelToKebab3(str) {
    return str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);
  }
  function ensureLockIcon4(el2) {
    const existing = el2.querySelector(`span.${LOCK_CLASS2}`);
    if (existing) return;
    const icon = document.createElement("span");
    icon.className = LOCK_CLASS2;
    icon.textContent = "\u{1F512}";
    icon.style.position = "absolute";
    icon.style.top = "-8px";
    icon.style.right = "-8px";
    icon.style.fontSize = "16px";
    icon.style.pointerEvents = "none";
    icon.style.userSelect = "none";
    icon.style.zIndex = "2";
    el2.appendChild(icon);
  }
  function removeLockIcon4(el2) {
    el2.querySelectorAll(`span.${LOCK_CLASS2}`).forEach((node) => node.remove());
  }

  // src/ui/hud.ts
  function mountHUD(opts) {
    const HUD_POS_PATH = "hud.pos";
    const HUD_COLLAPSED_PATH = "hud.collapsed";
    const HUD_HIDDEN_PATH = "hud.hidden";
    const HUD_WIN_PATH = (id) => `hud.windows.${id}`;
    const MARGIN = 8;
    const Z_BASE = 2e6;
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => mountHUD(opts), { once: true });
      return;
    }
    const css = `
  :root{
    --qws-bg:        #0f1318;
    --qws-panel:     #111823cc;
    --qws-border:    #ffffff22;
    --qws-border-2:  #ffffff14;
    --qws-accent:    #7aa2ff;
    --qws-text:      #e7eef7;
    --qws-text-dim:  #b9c3cf;
    --qws-blur:      8px;
    --qws-shadow:    0 10px 36px rgba(0,0,0,.45);
  }

  /* ---------- HUD floating box ---------- */
  .qws2{
    position:fixed; right:16px; bottom:16px; z-index:${Z_BASE};
    font:12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color:var(--qws-text);
    background:var(--qws-panel);
    border:1px solid var(--qws-border);
    border-radius:12px;
    padding:10px 12px;
    box-shadow:var(--qws-shadow);
    backdrop-filter:blur(var(--qws-blur));
    min-width:160px;
    display:flex; flex-direction:column; gap:8px;
  }


  .qws2 .btn{
    cursor:pointer;
    border-radius:10px;
    border:1px solid var(--qws-border);
    padding:6px 10px;
    background:linear-gradient(180deg, #ffffff12, #ffffff06);
    color:#fff;
    transition:transform .1s ease, background .18s ease, border-color .18s ease;
    width:auto !important;
    margin-bottom:0 !important;
  }

  .qws2.hidden{ display:none }
  .qws2 .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .qws2 .col{ display:flex; flex-direction:column; gap:4px }
  .qws2 .title{ font-weight:700; letter-spacing:.2px }
  .qws2 .sp{ flex:1 }

  .qws2 .pill{
    display:inline-flex; align-items:center; gap:6px;
    padding:4px 8px; border-radius:999px;
    border:1px solid #ffffff26;
    background:rgba(255,255,255,.06);
    color:var(--qws-text);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.08);
  }
  .qws2 .ok{   background:rgba(36, 161, 72, .20);  border-color:#48d17066 }
  .qws2 .warn{ background:rgba(241, 194, 27, .18); border-color:#ffd65c66 }
  .qws2 .bad{  background:rgba(218, 30, 40, .20);  border-color:#ff7c8666 }

  .qws2 .btn{
    cursor:pointer; border-radius:10px; border:1px solid var(--qws-border);
    padding:6px 10px;
    background:linear-gradient(180deg, #ffffff12, #ffffff06);
    color:#fff;
    transition:transform .1s ease, background .18s ease, border-color .18s ease;
  }
  .qws2 .btn:hover{ background:linear-gradient(180deg, #ffffff18, #ffffff0a); border-color:#ffffff44 }
  .qws2 .btn:active{ transform:translateY(1px) }
  .qws2 .drag{ cursor:move; opacity:.9 }

  .qws2 .mini{ display:none }
  .qws2.min .mini{ display:inline-flex }
  .qws2.min .body{ display:none }

  /* Launcher always shown */
  .qws-launch{ margin-top:4px; border-top:1px solid var(--qws-border); padding-top:6px; display:block }
  .qws-launch .launch-item{ display:flex; align-items:center; gap:8px; margin:4px 0 }
  .qws-launch .launch-item .name{ flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
  .qws-launch .launch-item .btn.active{
    background:linear-gradient(180deg, rgba(122,162,255,.28), rgba(122,162,255,.12));
    border-color:#9db7ff66;
  }

  /* ---------- Windows ---------- */
  .qws-win{
    position:fixed; z-index:${Z_BASE + 1}; min-width:260px; max-width:900px; max-height:90vh; overflow:auto;
    background:var(--qws-panel); color:var(--qws-text);
    border:1px solid var(--qws-border); border-radius:12px;
    box-shadow:var(--qws-shadow); backdrop-filter:blur(var(--qws-blur));
  }
  .qws-win .w-head{
    display:flex; align-items:center; gap:8px; padding:10px 12px;
    border-bottom:1px solid var(--qws-border); cursor:move;
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    border-top-left-radius:12px; border-top-right-radius:12px;
  }
  .qws-win .w-title{ font-weight:700 }
  .qws-win .sp{ flex:1 }
  .qws-win .w-btn{
    cursor:pointer; border-radius:10px; border:1px solid var(--qws-border);
    padding:4px 8px; background:linear-gradient(180deg, #ffffff12, #ffffff06); color:#fff;
  }
  .qws-win .w-btn:hover{ background:linear-gradient(180deg, #ffffff18, #ffffff0a); border-color:#ffffff44 }
  .qws-win .w-body{ padding:12px }

  /* Inputs inside windows */
  .qws-win input[type="text"], .qws-win input[type="number"]{
    width:120px; padding:8px 10px; border-radius:10px;
    border:1px solid var(--qws-border); background:rgba(0,0,0,.42); color:#fff;
    box-shadow:inset 0 1px 0 rgba(255,255,255,.06);
  }
  .qws-win .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:6px 0 }
  `;
    const st = document.createElement("style");
    st.textContent = css;
    (document.documentElement || document.body).appendChild(st);
    const box = document.createElement("div");
    box.className = "qws2";
    box.innerHTML = `
    <div class="row drag">
      <div class="title">Arie's Mod</div>
      <div class="sp"></div>
      <span id="qws2-status-mini" class="pill warn mini">\u2026</span>
      <button id="qws2-min" class="btn" title="Minimize/Expand">\u2013</button>
      <button id="qws2-hide" class="btn" title="Hide">\u2715</button>
    </div>

    <!-- Status & store side-by-side (no mode label) -->
    <div class="row" style="margin:2px 0 2px 0;">
      <span id="qws2-status" class="pill warn">status</span>
      <span id="qws2-version" class="pill warn">\u2026</span>
    </div>

    <div class="body">
      <div id="qws-launch" class="qws-launch"></div>
    </div>
  `;
    (document.documentElement || document.body).appendChild(box);
    const setHUDHidden = (hidden) => {
      box.classList.toggle("hidden", hidden);
      try {
        writeAriesPath(HUD_HIDDEN_PATH, hidden);
      } catch {
      }
      return hidden;
    };
    const toggleHUDHidden = () => setHUDHidden(!box.classList.contains("hidden"));
    let insertDown = false;
    let insertUsedAsModifier = false;
    const KEY_TOGGLE = "gui.toggle";
    const KEY_DRAG = "gui.drag";
    const downCodes = /* @__PURE__ */ new Set();
    let toggleHotkey = getKeybind(KEY_TOGGLE);
    let dragHotkey = getKeybind(KEY_DRAG);
    let dragActive = false;
    const codeEquals = (expected, actual) => {
      if (expected === actual) return true;
      if ((expected === "AltLeft" || expected === "AltRight") && (actual === "AltLeft" || actual === "AltRight")) return true;
      if ((expected === "ControlLeft" || expected === "ControlRight") && (actual === "ControlLeft" || actual === "ControlRight")) return true;
      if ((expected === "ShiftLeft" || expected === "ShiftRight") && (actual === "ShiftLeft" || actual === "ShiftRight")) return true;
      if ((expected === "MetaLeft" || expected === "MetaRight") && (actual === "MetaLeft" || actual === "MetaRight")) return true;
      return false;
    };
    const isCodePressed = (code) => {
      for (const pressed of downCodes) {
        if (codeEquals(code, pressed)) return true;
      }
      return false;
    };
    const matchesHotkey = (e, hk) => {
      if (!hk) return false;
      if (!!hk.ctrl !== e.ctrlKey) return false;
      if (!!hk.shift !== e.shiftKey) return false;
      if (!!hk.alt !== e.altKey) return false;
      if (!!hk.meta !== e.metaKey) return false;
      return codeEquals(hk.code, e.code);
    };
    const updateDragState = () => {
      if (!dragHotkey) {
        dragActive = false;
        return;
      }
      const altDown = isCodePressed("AltLeft");
      const ctrlDown = isCodePressed("ControlLeft");
      const shiftDown = isCodePressed("ShiftLeft");
      const metaDown = isCodePressed("MetaLeft");
      if (!!dragHotkey.alt !== altDown) {
        dragActive = false;
        return;
      }
      if (!!dragHotkey.ctrl !== ctrlDown) {
        dragActive = false;
        return;
      }
      if (!!dragHotkey.shift !== shiftDown) {
        dragActive = false;
        return;
      }
      if (!!dragHotkey.meta !== metaDown) {
        dragActive = false;
        return;
      }
      dragActive = isCodePressed(dragHotkey.code);
    };
    updateDragState();
    const isInsertKey = (e) => e.code === "Insert" || e.key === "Insert";
    const isModifierActive = (e) => {
      if (dragHotkey && dragActive) return true;
      const alt = "altKey" in e && e.altKey;
      const ctrl = "ctrlKey" in e && e.ctrlKey;
      const meta = "metaKey" in e && e.metaKey;
      const shift = "shiftKey" in e && e.shiftKey;
      const insertModifier = insertDown && !alt && !ctrl && !meta;
      if (insertModifier && !shift) insertUsedAsModifier = true;
      return insertModifier && !shift;
    };
    const onInsertKey = (e) => {
      if (!isInsertKey(e)) return;
      if (e.type === "keydown") {
        if (!insertDown) insertUsedAsModifier = false;
        insertDown = true;
        return;
      }
      const target = e.target;
      const editing = !!target && (target.isContentEditable || /^(input|textarea|select)$/i.test(target.tagName));
      const usedAsModifier = insertUsedAsModifier;
      insertDown = false;
      insertUsedAsModifier = false;
      if (!usedAsModifier && !editing) {
        e.preventDefault();
        toggleHUDHidden();
      }
    };
    window.addEventListener("keydown", onInsertKey, true);
    window.addEventListener("keyup", onInsertKey, true);
    window.addEventListener("blur", () => {
      insertDown = false;
      insertUsedAsModifier = false;
      downCodes.clear();
      updateDragState();
    }, true);
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState !== "visible") {
        insertDown = false;
        insertUsedAsModifier = false;
        downCodes.clear();
        updateDragState();
      }
    });
    function clampRect(el2) {
      const rect = el2.getBoundingClientRect();
      const vw = window.innerWidth, vh = window.innerHeight;
      let r = parseFloat(getComputedStyle(el2).right) || vw - rect.right;
      let b = parseFloat(getComputedStyle(el2).bottom) || vh - rect.bottom;
      const maxRight = Math.max(MARGIN, vw - rect.width - MARGIN);
      const maxBottom = Math.max(MARGIN, vh - rect.height - MARGIN);
      r = Math.min(Math.max(r, MARGIN), maxRight);
      b = Math.min(Math.max(b, MARGIN), maxBottom);
      el2.style.right = r + "px";
      el2.style.bottom = b + "px";
    }
    function ensureOnScreen(el2) {
      clampRect(el2);
      const rect = el2.getBoundingClientRect();
      const head = el2.querySelector(".w-head");
      const hrect = head?.getBoundingClientRect() || rect;
      const vw = window.innerWidth, vh = window.innerHeight;
      const M = MARGIN;
      let r = parseFloat(getComputedStyle(el2).right);
      if (Number.isNaN(r)) r = vw - rect.right;
      let b = parseFloat(getComputedStyle(el2).bottom);
      if (Number.isNaN(b)) b = vh - rect.bottom;
      const maxRight = Math.max(M, vw - rect.width - M);
      const maxBottom = Math.max(M, vh - rect.height - M);
      if (hrect.top < M) {
        const delta = M - hrect.top;
        b = Math.max(M, Math.min(maxBottom, b - delta));
      }
      if (rect.left < M) {
        const deltaL = M - rect.left;
        r = Math.max(M, Math.min(maxRight, r - deltaL));
      }
      el2.style.right = r + "px";
      el2.style.bottom = b + "px";
    }
    function resetWinPosDefault(el2) {
      el2.style.right = "16px";
      el2.style.bottom = "16px";
      ensureOnScreen(el2);
    }
    function withTopLocked(el2, mutate) {
      const before = el2.getBoundingClientRect();
      const vh = window.innerHeight;
      let b = parseFloat(getComputedStyle(el2).bottom);
      if (Number.isNaN(b)) b = vh - before.bottom;
      mutate();
      requestAnimationFrame(() => {
        const after = el2.getBoundingClientRect();
        const deltaTop = after.top - before.top;
        let newBottom = b + deltaTop;
        const maxBottom = Math.max(MARGIN, vh - after.height - MARGIN);
        newBottom = Math.min(Math.max(MARGIN, newBottom), maxBottom);
        el2.style.bottom = newBottom + "px";
        ensureOnScreen(el2);
      });
    }
    function saveHUDPos() {
      try {
        const r = parseFloat(box.style.right) || 16;
        const b = parseFloat(box.style.bottom) || 16;
        writeAriesPath(HUD_POS_PATH, { r, b });
      } catch {
      }
    }
    try {
      const pos = readAriesPath(HUD_POS_PATH);
      if (pos && typeof pos.r === "number" && typeof pos.b === "number") {
        box.style.right = pos.r + "px";
        box.style.bottom = pos.b + "px";
      }
      const collapsed = readAriesPath(HUD_COLLAPSED_PATH);
      if (collapsed === true || collapsed === "1" || collapsed === 1) {
        box.classList.add("min");
        const btnMin0 = box.querySelector("#qws2-min");
        if (btnMin0) btnMin0.textContent = "+";
      }
      const hidden = readAriesPath(HUD_HIDDEN_PATH);
      if (hidden === true || hidden === "1" || hidden === 1) box.classList.add("hidden");
      requestAnimationFrame(() => clampRect(box));
      window.addEventListener("resize", () => clampRect(box));
    } catch {
    }
    const header = box.querySelector(".drag");
    const btnMin = box.querySelector("#qws2-min");
    const btnHide = box.querySelector("#qws2-hide");
    const sMini = box.querySelector("#qws2-status-mini");
    const sFull = box.querySelector("#qws2-status");
    const sVersion = box.querySelector("#qws2-version");
    const launch = box.querySelector("#qws-launch");
    if (!header || !btnMin || !btnHide || !sMini || !sFull || !sVersion || !launch) {
      console.warn("[QuinoaWS] HUD elements missing, abort init");
      return;
    }
    const launchEl = launch;
    const updateHideButtonTitle = () => {
      const pieces = [];
      if (toggleHotkey) {
        const label2 = getKeybindLabel(KEY_TOGGLE);
        if (label2 && label2 !== "\u2014") pieces.push(label2);
      }
      pieces.push("Insert");
      btnHide.title = pieces.length ? `Hide (${pieces.join(" / ")})` : "Hide";
    };
    updateHideButtonTitle();
    onKeybindChange(KEY_TOGGLE, (hk) => {
      toggleHotkey = hk;
      updateHideButtonTitle();
    });
    onKeybindChange(KEY_DRAG, (hk) => {
      dragHotkey = hk;
      updateDragState();
    });
    (function makeDraggable2() {
      let sx = 0, sy = 0, or = 0, ob = 0, down = false;
      header.addEventListener("mousedown", (e) => {
        down = true;
        sx = e.clientX;
        sy = e.clientY;
        const rect = box.getBoundingClientRect();
        or = parseFloat(getComputedStyle(box).right) || window.innerWidth - rect.right;
        ob = parseFloat(getComputedStyle(box).bottom) || window.innerHeight - rect.bottom;
        document.body.style.userSelect = "none";
      });
      window.addEventListener("mousemove", (e) => {
        if (!down) return;
        const dx = e.clientX - sx;
        const dy = e.clientY - sy;
        let r = or - dx;
        let b = ob - dy;
        const rect = box.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        const maxRight = Math.max(MARGIN, vw - rect.width - MARGIN);
        const maxBottom = Math.max(MARGIN, vh - rect.height - MARGIN);
        r = Math.min(Math.max(r, MARGIN), maxRight);
        b = Math.min(Math.max(b, MARGIN), maxBottom);
        box.style.right = r + "px";
        box.style.bottom = b + "px";
      });
      window.addEventListener("mouseup", () => {
        if (!down) return;
        down = false;
        document.body.style.userSelect = "";
        saveHUDPos();
      });
    })();
    btnMin.onclick = () => {
      withTopLocked(box, () => {
        box.classList.toggle("min");
        btnMin.textContent = box.classList.contains("min") ? "+" : "-";
        try {
          writeAriesPath(HUD_COLLAPSED_PATH, box.classList.contains("min"));
        } catch {
        }
      });
    };
    btnHide.onclick = () => {
      setHUDHidden(true);
    };
    window.addEventListener(
      "keydown",
      (e) => {
        downCodes.add(e.code);
        updateDragState();
        const t = e.target;
        const editing = !!t && (t.isContentEditable || /^(input|textarea|select)$/i.test(t.tagName));
        if (editing) return;
        if (e.repeat) return;
        if (matchesHotkey(e, toggleHotkey)) {
          if (insertDown && !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
            insertUsedAsModifier = true;
          }
          e.preventDefault();
          toggleHUDHidden();
        }
      },
      true
    );
    window.addEventListener(
      "keyup",
      (e) => {
        downCodes.delete(e.code);
        updateDragState();
      },
      true
    );
    const windows = /* @__PURE__ */ new Map();
    let cascade = 0;
    function openWindow(id, title, render) {
      if (windows.has(id)) {
        const w = windows.get(id);
        w.el.style.display = "";
        bumpZ(w.el);
        setLaunchState(id, true);
        return;
      }
      const win = document.createElement("div");
      win.className = "qws-win";
      win.innerHTML = `
      <div class="w-head">
        <div class="w-title"></div>
        <div class="sp"></div>
        <button class="w-btn" data-act="min" title="Minimize/Expand">\u2013</button>
        <button class="w-btn" data-act="close" title="Close">\u2715</button>
      </div>
      <div class="w-body"></div>
    `;
      (document.documentElement || document.body).appendChild(win);
      const head = win.querySelector(".w-head");
      const titleEl = win.querySelector(".w-title");
      const btnMin2 = win.querySelector('[data-act="min"]');
      const btnClose = win.querySelector('[data-act="close"]');
      const body = win.querySelector(".w-body");
      titleEl.textContent = title;
      const offset = cascade++ % 5 * 24;
      win.style.right = 16 + offset + "px";
      win.style.bottom = 16 + offset + "px";
      clampRect(win);
      bumpZ(win);
      (function dragWin() {
        let sx = 0, sy = 0, or = 0, ob = 0, down = false;
        head.addEventListener("mousedown", (e) => {
          const t = e.target;
          if (t.closest(".w-btn")) return;
          down = true;
          sx = e.clientX;
          sy = e.clientY;
          const rect = win.getBoundingClientRect();
          or = parseFloat(getComputedStyle(win).right) || window.innerWidth - rect.right;
          ob = parseFloat(getComputedStyle(win).bottom) || window.innerHeight - rect.bottom;
          document.body.style.userSelect = "none";
          bumpZ(win);
        });
        window.addEventListener("mousemove", (e) => {
          if (!down) return;
          const dx = e.clientX - sx;
          const dy = e.clientY - sy;
          let r = or - dx;
          let b = ob - dy;
          const rect = win.getBoundingClientRect();
          const vw = window.innerWidth, vh = window.innerHeight;
          const maxRight = Math.max(MARGIN, vw - rect.width - MARGIN);
          const maxBottom = Math.max(MARGIN, vh - rect.height - MARGIN);
          r = Math.min(Math.max(r, MARGIN), maxRight);
          b = Math.min(Math.max(b, MARGIN), maxBottom);
          win.style.right = r + "px";
          win.style.bottom = b + "px";
        });
        window.addEventListener("mouseup", () => {
          down = false;
          document.body.style.userSelect = "";
          saveWinPos(id, win);
        });
      })();
      btnMin2.onclick = () => {
        withTopLocked(win, () => {
          const hidden = body.style.display === "none";
          body.style.display = hidden ? "" : "none";
          btnMin2.textContent = hidden ? "\u2013" : "+";
        });
      };
      btnClose.onclick = () => {
        win.style.display = "none";
        setLaunchState(id, false);
      };
      patchInputsKeyTrap(win);
      try {
        render(body);
      } catch (e) {
        body.textContent = String(e);
      }
      saveWinPos(id, win);
      windows.set(id, { id, el: win, head, body });
      setLaunchState(id, true);
    }
    function isShown(el2) {
      return el2.style.display !== "none";
    }
    function toggleWindow(id, title, render) {
      const existing = windows.get(id);
      if (!existing) {
        openWindow(id, title, (root) => {
          const el2 = root.closest(".qws-win");
          if (el2) restoreWinPos(id, el2);
          render(root);
        });
        return true;
      } else {
        if (isShown(existing.el)) {
          existing.el.style.display = "none";
          setLaunchState(id, false);
          return false;
        } else {
          existing.el.style.display = "";
          bumpZ(existing.el);
          ensureOnScreen(existing.el);
          setLaunchState(id, true);
          return true;
        }
      }
    }
    function bumpZ(el2) {
      let maxZ = Z_BASE + 1;
      windows.forEach((w) => {
        const z = parseInt(getComputedStyle(w.el).zIndex || String(Z_BASE + 1), 10);
        if (z > maxZ) maxZ = z;
      });
      el2.style.zIndex = String(maxZ + 1);
    }
    function saveWinPos(id, el2) {
      try {
        const r = parseFloat(el2.style.right) || 16;
        const b = parseFloat(el2.style.bottom) || 16;
        writeAriesPath(HUD_WIN_PATH(id), { r, b });
      } catch {
      }
    }
    function restoreWinPos(id, el2) {
      try {
        const pos = readAriesPath(HUD_WIN_PATH(id));
        if (pos && typeof pos.r === "number") el2.style.right = pos.r + "px";
        if (pos && typeof pos.b === "number") el2.style.bottom = pos.b + "px";
        ensureOnScreen(el2);
      } catch {
      }
    }
    window.addEventListener("resize", () => {
      windows.forEach((w) => ensureOnScreen(w.el));
    });
    function enableAltDragAnywhere() {
      let st2 = null;
      const pickRoot = (node) => {
        const el2 = node;
        if (!el2) return null;
        return el2.closest?.(".qws-win, .qws2") || null;
      };
      const onDown = (e) => {
        if (!isModifierActive(e) || e.button !== 0) return;
        const root = pickRoot(e.target);
        if (!root || root.style.display === "none") return;
        const rect = root.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        let or = parseFloat(getComputedStyle(root).right);
        let ob = parseFloat(getComputedStyle(root).bottom);
        if (Number.isNaN(or)) or = vw - rect.right;
        if (Number.isNaN(ob)) ob = vh - rect.bottom;
        st2 = { el: root, sx: e.clientX, sy: e.clientY, or, ob };
        document.body.style.userSelect = "none";
        bumpZ(root);
        e.preventDefault();
        e.stopPropagation();
      };
      const onMove = (e) => {
        if (!st2) return;
        const dx = e.clientX - st2.sx;
        const dy = e.clientY - st2.sy;
        let r = st2.or - dx;
        let b = st2.ob - dy;
        const rect = st2.el.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        const maxRight = Math.max(MARGIN, vw - rect.width - MARGIN);
        const maxBottom = Math.max(MARGIN, vh - rect.height - MARGIN);
        r = Math.min(Math.max(r, MARGIN), maxRight);
        b = Math.min(Math.max(b, MARGIN), maxBottom);
        st2.el.style.right = `${r}px`;
        st2.el.style.bottom = `${b}px`;
      };
      const stopDrag = () => {
        if (!st2) return;
        document.body.style.userSelect = "";
        clampRect(st2.el);
        const el2 = st2.el;
        let saved = false;
        windows.forEach((w) => {
          if (w.el === el2 && !saved) {
            saveWinPos(w.id, el2);
            saved = true;
          }
        });
        if (!saved && el2 === box) saveHUDPos();
        st2 = null;
      };
      const onUp = () => stopDrag();
      const onKeyUp = (e) => {
        if (!dragHotkey) {
          stopDrag();
          return;
        }
        if (matchesHotkey(e, dragHotkey) || !dragActive) {
          stopDrag();
        }
      };
      window.addEventListener("mousedown", onDown, true);
      window.addEventListener("mousemove", onMove, true);
      window.addEventListener("mouseup", onUp, true);
      window.addEventListener("keyup", onKeyUp, true);
    }
    function patchInputsKeyTrap(scope) {
      const isEditable = (el2) => {
        if (!el2 || !(el2 instanceof HTMLElement)) return false;
        if (el2 instanceof HTMLTextAreaElement) return true;
        if (el2 instanceof HTMLInputElement) {
          const t = (el2.type || "").toLowerCase();
          return t === "text" || t === "number" || t === "search";
        }
        return el2.isContentEditable === true;
      };
      const handler = (ev) => {
        const target = ev.target;
        const active = document.activeElement;
        const inScope = (node) => !!(node && (scope.contains(node) || node.closest?.(".qws-win") || node.closest?.(".qws2")));
        if (!(inScope(target) && isEditable(target) || inScope(active) && isEditable(active))) return;
        ev.stopPropagation();
        ev.stopImmediatePropagation?.();
      };
      const types = ["keydown", "keypress", "keyup"];
      types.forEach((t) => {
        window.addEventListener(t, handler, { capture: true });
        document.addEventListener(t, handler, { capture: true });
        scope.addEventListener(t, handler, { capture: true });
      });
      return () => {
        types.forEach((t) => {
          window.removeEventListener(t, handler, { capture: true });
          document.removeEventListener(t, handler, { capture: true });
          scope.removeEventListener(t, handler, { capture: true });
        });
      };
    }
    const registry2 = [];
    const launchButtons = /* @__PURE__ */ new Map();
    function setLaunchState(id, open) {
      const btn = launchButtons.get(id);
      if (!btn) return;
      btn.textContent = open ? "Close" : "Open";
      btn.dataset.open = open ? "1" : "0";
      if (open) btn.classList.add("active");
      else btn.classList.remove("active");
    }
    function register(id, title, render) {
      registry2.push({ id, title, render });
      addLaunchItem(id, title, render);
    }
    function addLaunchItem(id, title, render) {
      const item = document.createElement("div");
      item.className = "launch-item";
      item.innerHTML = `<div class="name">${escapeHtml2(title)}</div>`;
      const openBtn = document.createElement("button");
      openBtn.className = "btn";
      openBtn.textContent = "Open";
      openBtn.dataset.open = "0";
      launchButtons.set(id, openBtn);
      openBtn.onclick = () => {
        const w = windows.get(id);
        if (w && w.el.style.display !== "none") {
          w.el.style.display = "none";
          setLaunchState(id, false);
        } else {
          openWindow(id, title, (root) => {
            const el2 = root.closest(".qws-win");
            if (el2) restoreWinPos(id, el2);
            render(root);
          });
          setLaunchState(id, true);
        }
      };
      item.appendChild(openBtn);
      launch.appendChild(item);
    }
    try {
      opts?.onRegister?.(register);
    } catch {
    }
    patchInputsKeyTrap(box);
    enableAltDragAnywhere();
    (function initVersionBadge() {
      const setBadge = (text, cls) => {
        sVersion.textContent = text;
        tag(sVersion, cls);
      };
      const setDownloadTarget = (url) => {
        if (url) {
          sVersion.dataset.download = url;
          sVersion.style.cursor = "pointer";
          sVersion.title = `Download the new version`;
        } else {
          delete sVersion.dataset.download;
          sVersion.style.removeProperty("cursor");
          sVersion.removeAttribute("title");
        }
      };
      setBadge("checking\u2026", "warn");
      setDownloadTarget(null);
      const openDownloadLink = (url) => {
        const shouldUseGM = isDiscordSurface();
        const gmObject = globalThis.GM;
        const gmOpen = typeof GM_openInTab === "function" ? GM_openInTab : typeof gmObject?.openInTab === "function" ? gmObject.openInTab.bind(gmObject) : null;
        if (shouldUseGM && gmOpen) {
          try {
            gmOpen(url, { active: true, setParent: true });
            return;
          } catch (error) {
            console.warn("[MagicGarden] GM_openInTab failed, falling back to window.open", error);
          }
        }
        window.open(url, "_blank", "noopener,noreferrer");
      };
      sVersion.addEventListener("click", () => {
        const url = sVersion.dataset.download;
        if (url) {
          openDownloadLink(url);
        }
      });
      (async () => {
        const localVersion = getLocalVersion();
        try {
          const remoteData = await fetchRemoteVersion();
          const remoteVersion = remoteData?.version?.trim();
          if (!remoteVersion) {
            if (localVersion) {
              setBadge(localVersion, "warn");
            } else {
              setBadge("version inconnue", "warn");
            }
            return;
          }
          if (!localVersion) {
            setBadge(remoteVersion, "warn");
            setDownloadTarget(remoteData?.download || null);
            return;
          }
          if (localVersion === remoteVersion) {
            setBadge(localVersion, "ok");
            setDownloadTarget(null);
            return;
          }
          setBadge(`${localVersion} \u2192 ${remoteVersion}`, "warn");
          setDownloadTarget(remoteData?.download || null);
        } catch (error) {
          console.error("[MagicGarden] Failed to check version:", error);
          if (localVersion) {
            setBadge(localVersion, "warn");
          } else {
            setBadge("Unknown", "warn");
          }
        }
      })();
    })();
    (async () => {
      try {
        await ensureStore();
      } catch {
      }
    })();
    setInterval(() => {
      const wsStatus = getWSStatus();
      const storeStatus = getStoreStatus();
      const isStoreMissing = storeStatus.message === "store none";
      const isWsMissing = wsStatus.level === "bad";
      const level = isStoreMissing && isWsMissing ? "bad" : wsStatus.level === "ok" && storeStatus.level === "ok" ? "ok" : "warn";
      const summary = `${wsStatus.message}, ${storeStatus.message}`;
      sFull.textContent = "status";
      sFull.title = summary;
      tag(sFull, level);
      const miniText = level === "ok" ? "OK" : level === "warn" ? "WARN" : "ISSUES";
      sMini.textContent = miniText;
      sMini.title = summary;
      tag(sMini, level);
    }, 800);
    function getOpenPageWS() {
      for (let i = 0; i < sockets.length; i++) {
        if (sockets[i].readyState === NativeWS.OPEN) return sockets[i];
      }
      throw new Error("no page ws");
    }
    function getWSStatus() {
      try {
        getOpenPageWS();
        return { level: "ok", message: "ws open" };
      } catch {
        const viaWorker = !!window.__QWS_workerFound || workerFound;
        if (viaWorker) {
          return { level: "ok", message: "ws via worker" };
        }
        return { level: "bad", message: "ws none" };
      }
    }
    function getStoreStatus() {
      try {
        const captured = isStoreCaptured();
        const info = getCapturedInfo();
        if (captured) {
          return { level: "ok", message: `store ${info.via || "ready"}` };
        }
        if (info.via === "polyfill" || info.polyfill) {
          return { level: "warn", message: "store polyfill" };
        }
        return { level: "bad", message: "store none" };
      } catch {
        return { level: "bad", message: "store error" };
      }
    }
    function tag(el2, cls) {
      el2.classList.remove("ok", "warn", "bad");
      if (cls) el2.classList.add(cls);
    }
    function escapeHtml2(s) {
      return s.replace(/[&<>"']/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[m]);
    }
  }
  function initWatchers() {
    installShopKeybindsOnce();
    installSellKeybindsOnce();
    installGameKeybindsOnce();
    (async () => {
      try {
        setTeamsForHotkeys(PetsService.getTeams());
      } catch {
      }
      try {
        await PetsService.onTeamsChangeNow((teams) => {
          try {
            setTeamsForHotkeys(teams);
          } catch {
          }
        });
      } catch {
      }
      try {
        installPetTeamHotkeysOnce(async (teamId) => {
          try {
            await PetsService.useTeam(teamId);
          } catch (e) {
            console.warn("[Pets] hotkey useTeam failed:", e);
          }
        });
      } catch {
      }
      await PetsService.startAbilityLogsWatcher();
      await startActivityLogHistoryWatcher();
      startActivityLogFilter();
      await renderOverlay();
      setupBuyAll();
      startReorderObserver();
      startSellCropsLockWatcher();
      startCropValuesObserverFromGardenAtom();
      startInjectSellAllPets();
      startEggHatchLockIndicator();
      startDecorPickupLockIndicator();
      startPetPanelEnhancer();
      startSelectedInventoryQuantityLogger();
      startInventorySortingObserver();
      startModalObserver({ intervalMs: 6e4, log: false });
    })();
  }

  // src/ui/menus/debug-data-shared.ts
  function setBtnLabel(btn, text) {
    const label2 = btn.querySelector(".label");
    if (label2) label2.textContent = text;
    else btn.textContent = text;
  }
  function toast(msg, type = "warn") {
    try {
      window.toastSimple?.(msg, "", type);
    } catch {
    }
  }
  function createTwoColumns(view) {
    const columns = document.createElement("div");
    columns.className = "dd-debug-columns";
    view.appendChild(columns);
    const leftCol = document.createElement("div");
    leftCol.className = "dd-debug-column";
    const rightCol = document.createElement("div");
    rightCol.className = "dd-debug-column";
    columns.append(leftCol, rightCol);
    return { columns, leftCol, rightCol };
  }
  function copy(text) {
    const str = String(text ?? "");
    if (!str.length) return;
    const fallback = () => {
      const ta = document.createElement("textarea");
      ta.value = str;
      ta.setAttribute("readonly", "true");
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      ta.style.opacity = "0";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      let ok = false;
      try {
        ok = document.execCommand("copy");
      } catch {
      }
      document.body.removeChild(ta);
      try {
        window.toastSimple?.(ok ? "Copied" : "Copy failed", "", ok ? "success" : "error");
      } catch {
      }
    };
    if (window.isSecureContext && navigator.clipboard?.writeText) {
      navigator.clipboard.writeText(str).then(() => {
        try {
          window.toastSimple?.("Copied", "", "success");
        } catch {
        }
      }).catch(fallback);
    } else {
      fallback();
    }
  }
  function safeRegex(q) {
    try {
      return new RegExp(q, "i");
    } catch {
      return /.*/i;
    }
  }
  function stylePre(pre) {
    pre.style.maxHeight = "260px";
    pre.style.overflow = "auto";
    pre.style.background = "#0b1016";
    pre.style.border = "1px solid #ffffff18";
    pre.style.borderRadius = "12px";
    pre.style.padding = "12px";
    pre.style.margin = "6px 0 0";
    pre.style.fontSize = "12px";
    pre.style.lineHeight = "1.5";
    pre.style.color = "#dbe4ff";
    pre.style.boxShadow = "inset 0 1px 0 rgba(255,255,255,.04)";
  }

  // src/ui/menus/debug-data-audio.ts
  function renderAudioPlayerTab(view, ui) {
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const { leftCol, rightCol } = createTwoColumns(view);
    let infoList = [];
    let groupEntries = [];
    let visibleSounds = [];
    const overviewCard = ui.card("\u{1F3A7} Audio player", {
      tone: "muted",
      subtitle: "Inspect detected sounds, auto groups and Howler status."
    });
    leftCol.appendChild(overviewCard.root);
    const summary = document.createElement("div");
    summary.className = "dd-audio-summary";
    const summarySounds = document.createElement("div");
    const summaryGroups = document.createElement("div");
    const summarySources = document.createElement("div");
    summary.append(summarySounds, summaryGroups, summarySources);
    const volumeLine = document.createElement("div");
    volumeLine.className = "dd-audio-volume";
    const finalLine = document.createElement("div");
    finalLine.className = "dd-audio-volume";
    const overviewError = ui.errorBar();
    const actionsRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const btnScan = ui.btn("Rescan sounds", {
      icon: "\u{1F504}",
      variant: "primary",
      onClick: () => {
        void refreshAll({ rescan: true });
      }
    });
    const btnRefresh = ui.btn("Refresh snapshot", {
      icon: "\u{1F501}",
      onClick: () => {
        void refreshAll();
      }
    });
    const btnCopyJson = ui.btn("Copy JSON", {
      icon: "\u{1F4CB}",
      onClick: () => copy(audioPlayer.exportJSON())
    });
    actionsRow.append(btnScan, btnRefresh, btnCopyJson);
    overviewCard.body.append(summary, volumeLine, finalLine, overviewError.el, actionsRow);
    const groupsCard = ui.card("\u{1F39B}\uFE0F Groups", {
      tone: "muted",
      subtitle: "Browse auto-generated groups and play random variations."
    });
    leftCol.appendChild(groupsCard.root);
    const groupToolbar = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const groupFilter = ui.inputText("filter groups (regex)", "");
    groupFilter.classList.add("dd-grow");
    const btnGroupClear = ui.btn("Clear", {
      icon: "\u{1F9F9}",
      onClick: () => {
        groupFilter.value = "";
        renderGroups();
        groupFilter.focus();
      }
    });
    groupToolbar.append(groupFilter, btnGroupClear);
    const groupInfo = document.createElement("p");
    groupInfo.className = "dd-card-description";
    groupInfo.style.margin = "0";
    const groupList = document.createElement("div");
    groupList.className = "dd-audio-list";
    const groupEmpty = document.createElement("div");
    groupEmpty.className = "dd-audio-empty";
    groupEmpty.textContent = "No groups match the current filter.";
    groupsCard.body.append(groupToolbar, groupInfo, groupList, groupEmpty);
    const soundsCard = ui.card("\u{1F509} Sounds", {
      tone: "muted",
      subtitle: "Inspect detected files and trigger playback."
    });
    rightCol.appendChild(soundsCard.root);
    const soundToolbar = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const soundFilter = ui.inputText("filter sounds (regex)", "");
    soundFilter.classList.add("dd-grow");
    const btnSoundClear = ui.btn("Clear", {
      icon: "\u{1F9F9}",
      onClick: () => {
        soundFilter.value = "";
        renderSounds();
        soundFilter.focus();
      }
    });
    const btnCopyVisible = ui.btn("Copy visible URLs", {
      icon: "\u{1F4CB}",
      onClick: () => {
        if (!visibleSounds.length) return;
        copy(visibleSounds.map((s) => s.url).join("\n"));
      }
    });
    soundToolbar.append(soundFilter, btnSoundClear, btnCopyVisible);
    const soundInfo = document.createElement("p");
    soundInfo.className = "dd-card-description";
    soundInfo.style.margin = "0";
    const soundList = document.createElement("div");
    soundList.className = "dd-audio-list";
    const soundEmpty = document.createElement("div");
    soundEmpty.className = "dd-audio-empty";
    soundEmpty.textContent = "No sounds match the current filter.";
    soundsCard.body.append(soundToolbar, soundInfo, soundList, soundEmpty);
    groupFilter.addEventListener("input", () => renderGroups());
    groupFilter.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        renderGroups();
      }
    });
    soundFilter.addEventListener("input", () => renderSounds());
    soundFilter.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        renderSounds();
      }
    });
    let busy = false;
    function labelForSound(info) {
      return info.logicalName || info.name || fileNameFromUrl(info.url);
    }
    function fileNameFromUrl(url) {
      try {
        return new URL(url, location.href).pathname.split("/").pop() || url;
      } catch {
        return url;
      }
    }
    function formatNumber(value, digits = 3) {
      return value == null || Number.isNaN(value) || !Number.isFinite(value) ? "\u2014" : value.toFixed(digits);
    }
    function setButtonEnabled(btn, enabled) {
      const setter = btn.setEnabled;
      if (typeof setter === "function") setter(enabled);
      else btn.disabled = !enabled;
    }
    const scanLabel = btnScan.querySelector(".label");
    const defaultScanText = scanLabel?.textContent ?? "Rescan sounds";
    function setScanButtonLoading(loading) {
      setButtonEnabled(btnScan, !loading);
      if (scanLabel) scanLabel.textContent = loading ? "Scanning\u2026" : defaultScanText;
    }
    function refreshData() {
      infoList = audioPlayer.info().slice().sort((a, b) => labelForSound(a).localeCompare(labelForSound(b)));
      groupEntries = Object.entries(audioPlayer.groups()).sort((a, b) => a[0].localeCompare(b[0]));
    }
    function updateOverview() {
      const sources = /* @__PURE__ */ new Set();
      infoList.forEach((info) => {
        (info.sources || "").split(",").map((s) => s.trim()).filter(Boolean).forEach((src) => sources.add(src));
      });
      const vol = audioPlayer.getGameSfxVolume();
      const howlerGlobal = window?.Howler;
      let howlerMaster = null;
      try {
        if (howlerGlobal && typeof howlerGlobal.volume === "function") {
          const val = howlerGlobal.volume();
          if (typeof val === "number" && Number.isFinite(val)) howlerMaster = val;
        }
      } catch {
      }
      const howlerCount = Array.isArray(howlerGlobal?._howls) ? howlerGlobal._howls.length : 0;
      summarySounds.innerHTML = `<strong>${infoList.length}</strong> sounds detected`;
      summaryGroups.innerHTML = `<strong>${groupEntries.length}</strong> auto groups`;
      summarySources.innerHTML = `<strong>${sources.size}</strong> unique source tags`;
      volumeLine.textContent = `Atom raw: ${formatNumber(vol.raw)} (clamped ${formatNumber(vol.clamped)})`;
      let suffix = "";
      if (howlerMaster != null) {
        suffix = ` \xB7 Howler master ${formatNumber(howlerMaster)}`;
        if (howlerCount) suffix += ` (${howlerCount} howl${howlerCount === 1 ? "" : "s"})`;
      } else if (howlerCount) {
        suffix = ` \xB7 ${howlerCount} howl${howlerCount === 1 ? "" : "s"} registered`;
      }
      finalLine.textContent = `Final output volume: ${formatNumber(vol.vol)}${suffix}`;
    }
    function renderGroups() {
      const rx = safeRegex(groupFilter.value.trim() || ".*");
      const infoByUrl = new Map(infoList.map((info) => [info.url, info]));
      groupList.innerHTML = "";
      let visible = 0;
      const matches = (value) => !!value && rx.test(value);
      for (const [name, urls] of groupEntries) {
        const include = matches(name) || urls.some((url) => {
          const info = infoByUrl.get(url);
          return matches(url) || matches(info?.logicalName) || matches(info?.name);
        });
        if (!include) continue;
        visible++;
        const sampleUrl = urls[0] || "";
        const sampleInfo = infoByUrl.get(sampleUrl);
        const row = document.createElement("div");
        row.className = "dd-audio-row";
        const infoWrap = document.createElement("div");
        infoWrap.className = "dd-audio-row__info";
        const title = document.createElement("div");
        title.className = "dd-audio-row__title";
        title.textContent = name;
        const meta = document.createElement("div");
        meta.className = "dd-audio-meta";
        const parts = [];
        parts.push(`${urls.length} variation${urls.length === 1 ? "" : "s"}`);
        if (sampleInfo?.name) parts.push(`Sample: ${sampleInfo.name}`);
        if (sampleInfo?.sources) parts.push(`Sources: ${sampleInfo.sources}`);
        meta.textContent = parts.join(" \u2022 ");
        const urlEl = document.createElement("div");
        urlEl.className = "dd-audio-url";
        urlEl.textContent = sampleUrl || "(no sample)";
        infoWrap.append(title, meta, urlEl);
        row.appendChild(infoWrap);
        const actions = ui.flexRow({ gap: 6, wrap: false, align: "center" });
        actions.className = "dd-audio-actions";
        const playBtn = ui.btn("Play", {
          icon: "\u25B6\uFE0F",
          size: "sm",
          onClick: () => {
            audioPlayer.playGroup(name, { random: true });
          }
        });
        const copyBtn = ui.btn("Copy URLs", {
          icon: "\u{1F4CB}",
          size: "sm",
          onClick: () => copy(urls.join("\n"))
        });
        const openBtn = sampleUrl ? ui.btn("Open", {
          icon: "\u{1F517}",
          size: "sm",
          onClick: () => {
            try {
              window.open(sampleUrl, "_blank", "noopener,noreferrer");
            } catch {
            }
          }
        }) : null;
        actions.append(playBtn, copyBtn);
        if (openBtn) actions.append(openBtn);
        row.appendChild(actions);
        groupList.appendChild(row);
      }
      groupInfo.textContent = groupEntries.length ? `${visible} / ${groupEntries.length} groups shown.` : "No groups have been detected yet. Run a rescan to populate the cache.";
      groupList.style.display = visible ? "" : "none";
      groupEmpty.textContent = groupEntries.length ? "No groups match the current filter." : "No groups detected yet. Run a rescan to populate the cache.";
      groupEmpty.style.display = visible ? "none" : "block";
      setButtonEnabled(btnGroupClear, groupFilter.value.trim().length > 0);
    }
    function renderSounds() {
      const rx = safeRegex(soundFilter.value.trim() || ".*");
      visibleSounds = [];
      soundList.innerHTML = "";
      const matches = (value) => !!value && rx.test(value);
      for (const info of infoList) {
        if (!(matches(info.logicalName) || matches(info.name) || matches(info.sources) || matches(info.url))) continue;
        visibleSounds.push(info);
        const row = document.createElement("div");
        row.className = "dd-audio-row";
        const infoWrap = document.createElement("div");
        infoWrap.className = "dd-audio-row__info";
        const title = document.createElement("div");
        title.className = "dd-audio-row__title";
        title.textContent = labelForSound(info);
        const meta = document.createElement("div");
        meta.className = "dd-audio-meta";
        const parts = [];
        if (info.name && info.name !== info.logicalName) parts.push(`File: ${info.name}`);
        if (info.logicalName) parts.push(`Logical: ${info.logicalName}`);
        if (info.sources) parts.push(`Sources: ${info.sources}`);
        meta.textContent = parts.join(" \u2022 ");
        const urlEl = document.createElement("div");
        urlEl.className = "dd-audio-url";
        urlEl.textContent = info.url;
        infoWrap.append(title, meta, urlEl);
        row.appendChild(infoWrap);
        const actions = ui.flexRow({ gap: 6, wrap: false, align: "center" });
        actions.className = "dd-audio-actions";
        const playBtn = ui.btn("Play", {
          icon: "\u25B6\uFE0F",
          size: "sm",
          onClick: () => {
            audioPlayer.playUrl(info.url);
          }
        });
        const copyBtn = ui.btn("Copy", {
          icon: "\u{1F4CB}",
          size: "sm",
          onClick: () => copy(info.url)
        });
        const openBtn = ui.btn("Open", {
          icon: "\u{1F517}",
          size: "sm",
          onClick: () => {
            try {
              window.open(info.url, "_blank", "noopener,noreferrer");
            } catch {
            }
          }
        });
        actions.append(playBtn, copyBtn, openBtn);
        row.appendChild(actions);
        soundList.appendChild(row);
      }
      soundInfo.textContent = infoList.length ? `${visibleSounds.length} / ${infoList.length} sounds shown.` : "No sounds have been detected yet. Run a rescan to populate the cache.";
      soundList.style.display = visibleSounds.length ? "" : "none";
      soundEmpty.textContent = infoList.length ? "No sounds match the current filter." : "No sounds detected yet. Run a rescan to populate the cache.";
      soundEmpty.style.display = visibleSounds.length ? "none" : "block";
      setButtonEnabled(btnCopyVisible, visibleSounds.length > 0);
      setButtonEnabled(btnSoundClear, soundFilter.value.trim().length > 0);
    }
    async function refreshAll(opts = {}) {
      if (busy) return;
      busy = true;
      const { rescan = false } = opts;
      overviewError.clear();
      if (rescan) setScanButtonLoading(true);
      else setButtonEnabled(btnScan, false);
      setButtonEnabled(btnRefresh, false);
      let scanError = null;
      try {
        if (rescan) {
          try {
            await audioPlayer.scan();
          } catch (err) {
            scanError = err;
          }
        }
        refreshData();
        updateOverview();
        renderGroups();
        renderSounds();
        if (scanError) {
          const message = scanError instanceof Error ? scanError.message : String(scanError);
          overviewError.show(`Scan failed: ${message}`);
          console.error("[debug] audio scan failed", scanError);
        }
      } finally {
        if (rescan) setScanButtonLoading(false);
        else setButtonEnabled(btnScan, true);
        setButtonEnabled(btnRefresh, true);
        busy = false;
      }
    }
    void refreshAll();
  }

  // src/ui/menus/debug-data-jotai.ts
  function renderJotaiTab(view, ui) {
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const { leftCol, rightCol } = createTwoColumns(view);
    {
      const card = ui.card("\u{1F5C4}\uFE0F Capture store", {
        tone: "muted",
        subtitle: "Initialize the Jotai store so atoms can be inspected."
      });
      leftCol.appendChild(card.root);
      const status = document.createElement("span");
      status.className = "dd-status-chip";
      const refreshStatus = () => {
        const captured = isStoreCaptured();
        status.textContent = captured ? "Store captured" : "Store not captured";
        status.classList.toggle("is-ok", captured);
        status.classList.toggle("is-warn", !captured);
      };
      refreshStatus();
      const actions = ui.flexRow({ gap: 10, align: "center", wrap: true });
      const btnCap = ui.btn("Capture store", {
        variant: "primary",
        icon: "\u23FA",
        onClick: async () => {
          try {
            await ensureStore();
          } catch {
          }
          refreshStatus();
        }
      });
      actions.append(btnCap, status);
      card.body.appendChild(actions);
    }
    {
      const card = ui.card("\u{1F50D} Explore atoms", {
        tone: "muted",
        subtitle: "Filter labels using a regular expression."
      });
      leftCol.appendChild(card.root);
      const queryRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
      const q = ui.inputText("regex label (ex: position|health)", "");
      q.classList.add("dd-grow");
      const btnList = ui.btn("List", { icon: "\u{1F4C4}", onClick: () => doList() });
      const btnCopy = ui.btn("Copy", { icon: "\u{1F4CB}", onClick: () => copy(pre.textContent || "") });
      queryRow.append(q, btnList, btnCopy);
      const pre = document.createElement("pre");
      stylePre(pre);
      pre.style.minHeight = "140px";
      async function doList() {
        const raw = q.value.trim();
        const rx = safeRegex(raw || ".*");
        const all = findAtomsByLabel(/.*/);
        const atoms = all.filter((a) => rx.test(String(a?.debugLabel || a?.label || "")));
        const labels = atoms.map((a) => String(a?.debugLabel || a?.label || "<?>"));
        pre.textContent = labels.join("\n");
      }
      card.body.append(queryRow, pre);
    }
    {
      const card = ui.card("\u{1F9ED} Inspect an atom", {
        tone: "muted",
        subtitle: "Get the current value or subscribe to updates."
      });
      rightCol.appendChild(card.root);
      const controls = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
      const q = ui.inputText("atom label (ex: positionAtom)", "");
      q.classList.add("dd-grow");
      const pre = document.createElement("pre");
      stylePre(pre);
      pre.style.minHeight = "160px";
      let unsubRef = null;
      const btnGet = ui.btn("Get", {
        icon: "\u{1F441}",
        onClick: async () => {
          const atom = getAtomByLabel(q.value.trim());
          if (!atom) {
            pre.textContent = `Atom "${q.value}" not found`;
            return;
          }
          try {
            setText(pre, await jGet(atom));
          } catch (e) {
            setText(pre, e?.message || String(e));
          }
        }
      });
      const btnSub = ui.btn("Subscribe", {
        icon: "\u{1F514}",
        onClick: async () => {
          const label2 = q.value.trim();
          if (!label2) return;
          const atom = getAtomByLabel(label2);
          if (!atom) {
            pre.textContent = `Atom "${label2}" not found`;
            return;
          }
          if (unsubRef) {
            unsubRef();
            unsubRef = null;
            btnSub.textContent = "Subscribe";
            return;
          }
          unsubRef = await jSub(atom, async () => {
            try {
              setText(pre, await jGet(atom));
            } catch {
            }
          });
          btnSub.textContent = "Unsubscribe";
        }
      });
      const btnCopy = ui.btn("Copy", { icon: "\u{1F4CB}", onClick: () => copy(pre.textContent || "") });
      controls.append(q, btnGet, btnSub, btnCopy);
      const note = document.createElement("p");
      note.className = "dd-inline-note";
      note.textContent = "Tip: subscriptions keep the value updated after each mutation.";
      card.body.append(controls, note, pre);
    }
    {
      const card = ui.card("\u270F\uFE0F Update an atom", {
        tone: "muted",
        subtitle: "Publish a new value (JSON)."
      });
      rightCol.appendChild(card.root);
      const controls = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
      const q = ui.inputText("atom label (ex: activeModalAtom)", "");
      q.classList.add("dd-grow");
      const ta = document.createElement("textarea");
      ta.className = "qmm-input dd-textarea";
      ta.placeholder = `JSON or text value, e.g. inventory or { "x": 1, "y": 2 }`;
      const btnSet = ui.btn("Set", {
        icon: "\u2705",
        variant: "primary",
        onClick: async () => {
          const label2 = q.value.trim();
          if (!label2) {
            toast("Enter an atom label");
            return;
          }
          try {
            await ensureStore();
          } catch (e) {
            toast(e?.message || "Unable to capture store");
            return;
          }
          if (!isStoreCaptured()) {
            toast('Store not captured. Use "Capture store" first.');
            return;
          }
          const atom = getAtomByLabel(label2);
          if (!atom) {
            toast(`Atom "${label2}" not found`);
            return;
          }
          const raw = ta.value;
          const trimmed = raw.trim();
          let val = raw;
          let fallback = false;
          if (trimmed) {
            try {
              val = JSON.parse(trimmed);
            } catch {
              fallback = true;
            }
          } else {
            val = "";
          }
          try {
            await jSet(atom, val);
            toast(fallback ? "Set OK (raw text)" : "Set OK");
          } catch (e) {
            toast(e?.message || "Set failed");
          }
        }
      });
      const btnCopy = ui.btn("Copy JSON", { icon: "\u{1F4CB}", onClick: () => copy(ta.value) });
      controls.append(q, btnSet, btnCopy);
      card.body.append(controls, ta);
    }
    function setText(el2, v) {
      el2.textContent = typeof v === "string" ? v : JSON.stringify(v, null, 2);
    }
  }

  // src/services/debug-data.ts
  var fmtTime = (ms) => {
    const d = new Date(ms);
    const pad = (n, s = 2) => String(n).padStart(s, "0");
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}.${String(d.getMilliseconds()).padStart(3, "0")}`;
  };
  var escapeLite = (s) => s.replace(/[<>&]/g, (m) => ({ "<": "&lt;", ">": "&gt;", "&": "&amp;" })[m]);
  var FrameBuffer = class {
    constructor(max = 2e3) {
      this.max = max;
      __publicField(this, "arr", []);
    }
    push(f) {
      this.arr.push(f);
      if (this.arr.length > this.max) this.arr.splice(0, this.arr.length - this.max);
    }
    toArray() {
      return this.arr.slice();
    }
    clear() {
      this.arr.length = 0;
    }
  };
  var registry = /* @__PURE__ */ new Map();
  function getWSInfos() {
    return Array.from(registry.values());
  }
  function getWSStatusText() {
    const anyOpen = sockets.some((ws) => ws.readyState === WebSocket.OPEN);
    const viaW = workerFound ? "worker" : "page/auto";
    return `status: ${anyOpen ? "OPEN" : "none"} \u2022 mode: ${viaW}`;
  }
  var HOOKED_CTOR_FLAG = Symbol.for("qmm.wsCtorHooked");
  var WS_PATCHED_SEND = Symbol.for("qmm.wsPatchedSend");
  var hookedOnce = false;
  function installWSHookIfNeeded(onFrame) {
    const Ctor = window.WebSocket;
    if (!Ctor[HOOKED_CTOR_FLAG]) {
      const ProxyCtor = new Proxy(Ctor, {
        construct(target, args, newTarget) {
          const ws = Reflect.construct(target, args, newTarget);
          try {
            trackSocket(ws, "new", onFrame);
          } catch (err) {
          }
          return ws;
        }
      });
      ProxyCtor[HOOKED_CTOR_FLAG] = true;
      window.WebSocket = ProxyCtor;
    }
    sockets.forEach((ws) => {
      try {
        trackSocket(ws, "existing", onFrame);
      } catch (err) {
      }
    });
    if (!hookedOnce) {
      hookedOnce = true;
    } else {
    }
  }
  function trackSocket(ws, why, onFrame) {
    if (registry.has(ws)) {
      return;
    }
    const id = `WS#${1 + registry.size} (${label(ws.readyState)})`;
    const info = { ws, id, listeners: [] };
    if (!sockets.includes(ws)) sockets.push(ws);
    setQWS?.(ws, why);
    const onMsg = (ev) => {
      let text = "";
      try {
        text = typeof ev.data === "string" ? ev.data : JSON.stringify(ev.data);
      } catch {
        text = String(ev.data);
      }
      onFrame({ t: Date.now(), dir: "in", text, ws });
    };
    ws.addEventListener("message", onMsg);
    info.listeners.push(() => ws.removeEventListener("message", onMsg));
    const onOpen = () => {
      info.id = info.id.replace(/\(.*\)/, `(${label(ws.readyState)})`);
    };
    const onClose = () => {
      info.id = info.id.replace(/\(.*\)/, `(${label(ws.readyState)})`);
    };
    ws.addEventListener("open", onOpen);
    ws.addEventListener("close", onClose);
    info.listeners.push(() => ws.removeEventListener("open", onOpen));
    info.listeners.push(() => ws.removeEventListener("close", onClose));
    if (!ws[WS_PATCHED_SEND]) {
      const orig = ws.send.bind(ws);
      info.sendOrig = orig;
      ws[WS_PATCHED_SEND] = true;
      ws.send = (data) => {
        try {
          const text = typeof data === "string" ? data : JSON.stringify(data);
          onFrame({ t: Date.now(), dir: "out", text, ws });
        } catch {
          onFrame({ t: Date.now(), dir: "out", text: String(data), ws });
        }
        return orig(data);
      };
    } else {
    }
    registry.set(ws, info);
  }

  // src/ui/menus/debug-data-live-atoms.ts
  function renderLiveAtomsTab(view, ui) {
    if (typeof view.__atoms_live_cleanup__ === "function") {
      try {
        view.__atoms_live_cleanup__();
      } catch {
      }
    }
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const entries = /* @__PURE__ */ new Map();
    const records = [];
    let recording = false;
    let selectedRecord = null;
    const { leftCol, rightCol } = createTwoColumns(view);
    const selectCard = ui.card("\u{1F9EA} Pick atoms", {
      tone: "muted",
      subtitle: "Filter labels with a regex then toggle atoms to monitor."
    });
    leftCol.appendChild(selectCard.root);
    const filterRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const filterInput = ui.inputText("regex label (ex: position|health)", "");
    filterInput.classList.add("dd-grow");
    const btnFilter = ui.btn("Refresh", { icon: "\u{1F50D}", onClick: () => refreshMatches() });
    filterRow.append(filterInput, btnFilter);
    const matchesWrap = document.createElement("div");
    matchesWrap.className = "dd-atom-list";
    const emptyMatches = document.createElement("p");
    emptyMatches.className = "dd-card-description";
    emptyMatches.textContent = "No atoms match the current filter.";
    emptyMatches.style.display = "none";
    const selectedInfo = document.createElement("p");
    selectedInfo.className = "dd-card-description";
    selectedInfo.style.marginTop = "8px";
    selectCard.body.append(filterRow, matchesWrap, emptyMatches, selectedInfo);
    filterInput.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        refreshMatches();
      }
    });
    const logCard = ui.card("\u{1F4E1} Live atom log", {
      tone: "muted",
      subtitle: "Start recording to capture updates for the selected atoms."
    });
    rightCol.appendChild(logCard.root);
    const controlsRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const btnRecord = ui.btn("Start recording", {
      variant: "primary",
      onClick: () => toggleRecording()
    });
    const btnClear = ui.btn("Clear log", {
      variant: "ghost",
      icon: "\u{1F9F9}",
      onClick: () => {
        records.length = 0;
        selectedRecord = null;
        renderRecords(false);
        updateDetails(null);
        updateControls();
      }
    });
    const btnCopyLog = ui.btn("Copy log", {
      variant: "ghost",
      icon: "\u{1F4CB}",
      onClick: () => copyLog()
    });
    controlsRow.append(btnRecord, btnClear, btnCopyLog);
    logCard.body.appendChild(controlsRow);
    const logWrap = document.createElement("div");
    logWrap.className = "dd-log";
    logWrap.style.fontFamily = "ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const logEmpty = document.createElement("div");
    logEmpty.className = "dd-log__empty";
    logEmpty.textContent = "No updates yet.";
    logWrap.appendChild(logEmpty);
    logCard.body.appendChild(logWrap);
    const detailHeader = document.createElement("p");
    detailHeader.className = "dd-card-description";
    detailHeader.textContent = "Select a log entry to inspect previous and next values.";
    const detailWrap = ui.flexRow({ gap: 12, wrap: true, fullWidth: true });
    const prevBox = document.createElement("div");
    prevBox.style.flex = "1 1 320px";
    const prevTitle = document.createElement("strong");
    prevTitle.textContent = "Previous";
    prevTitle.style.display = "block";
    prevTitle.style.marginBottom = "6px";
    const prevPre = document.createElement("pre");
    stylePre(prevPre);
    prevPre.style.minHeight = "140px";
    prevPre.textContent = "";
    prevBox.append(prevTitle, prevPre);
    const nextBox = document.createElement("div");
    nextBox.style.flex = "1 1 320px";
    const nextTitle = document.createElement("strong");
    nextTitle.textContent = "Next";
    nextTitle.style.display = "block";
    nextTitle.style.marginBottom = "6px";
    const nextPre = document.createElement("pre");
    stylePre(nextPre);
    nextPre.style.minHeight = "140px";
    nextPre.textContent = "";
    nextBox.append(nextTitle, nextPre);
    const historyBox = document.createElement("div");
    historyBox.style.flex = "1 1 100%";
    historyBox.style.minWidth = "0";
    const historyTitle = document.createElement("strong");
    historyTitle.textContent = "History";
    historyTitle.style.display = "block";
    historyTitle.style.marginBottom = "6px";
    const historyList = document.createElement("div");
    historyList.style.display = "flex";
    historyList.style.flexDirection = "column";
    historyList.style.gap = "10px";
    historyList.style.maxHeight = "320px";
    historyList.style.overflow = "auto";
    historyBox.append(historyTitle, historyList);
    detailWrap.append(prevBox, nextBox, historyBox);
    logCard.body.append(detailHeader, detailWrap);
    function refreshMatches() {
      const raw = filterInput.value.trim();
      const rx = safeRegex(raw || ".*");
      const atoms = findAtomsByLabel(rx);
      matchesWrap.innerHTML = "";
      emptyMatches.style.display = atoms.length ? "none" : "block";
      atoms.map((atom) => ({ atom, label: String(atom?.debugLabel || atom?.label || "<unknown>") })).sort((a, b) => a.label.localeCompare(b.label)).forEach(({ atom, label: label2 }) => {
        const row = document.createElement("label");
        row.className = "dd-atom-list__item";
        row.title = label2;
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = entries.has(label2);
        checkbox.className = "dd-atom-list__checkbox";
        const text = document.createElement("span");
        text.className = "dd-atom-list__label";
        text.textContent = label2;
        row.append(checkbox, text);
        checkbox.addEventListener("change", async () => {
          if (checkbox.checked) {
            const existing = entries.get(label2);
            if (existing) {
              existing.atom = atom;
            } else {
              entries.set(label2, { atom, lastValue: null, unsubscribe: null });
            }
            if (recording) {
              const ok = await attachEntry(label2);
              if (!ok) checkbox.checked = false;
            }
          } else {
            const existing = entries.get(label2);
            if (existing?.unsubscribe) {
              try {
                existing.unsubscribe();
              } catch {
              }
            }
            entries.delete(label2);
          }
          updateSelectedInfo();
          updateControls();
        });
        matchesWrap.appendChild(row);
        if (entries.has(label2)) {
          const existing = entries.get(label2);
          if (existing) existing.atom = atom;
        }
      });
      updateSelectedInfo();
    }
    function updateSelectedInfo() {
      const size = entries.size;
      selectedInfo.textContent = size ? `${size} atom${size > 1 ? "s" : ""} selected.` : "No atom selected.";
    }
    function updateControls() {
      setBtnLabel(btnRecord, recording ? "Stop recording" : "Start recording");
      btnRecord.classList.toggle("active", recording);
      btnRecord.disabled = !recording && !entries.size;
      btnClear.disabled = records.length === 0;
      btnCopyLog.disabled = records.length === 0;
    }
    function renderRecords(autoScroll = false) {
      logWrap.innerHTML = "";
      if (!records.length) {
        logWrap.appendChild(logEmpty);
        renderHistoryFor(null, null);
        return;
      }
      records.forEach((rec, idx) => {
        const row = document.createElement("div");
        row.className = "atoms-log-row";
        row.dataset.idx = String(idx);
        row.style.display = "grid";
        row.style.gridTemplateColumns = "minmax(120px, 160px) minmax(0, 1fr)";
        row.style.gap = "12px";
        row.style.padding = "10px 12px";
        row.style.margin = "4px 0";
        row.style.borderRadius = "12px";
        row.style.border = "1px solid rgba(255,255,255,.12)";
        const isSelected = selectedRecord === idx;
        row.style.background = isSelected ? "rgba(92,126,255,.16)" : "rgba(11,16,22,.85)";
        row.style.borderColor = isSelected ? "rgba(92,126,255,.42)" : "rgba(255,255,255,.12)";
        row.style.cursor = "pointer";
        row.addEventListener("mouseenter", () => {
          row.style.borderColor = "rgba(255,255,255,.28)";
        });
        row.addEventListener("mouseleave", () => {
          const sel = selectedRecord === idx;
          row.style.borderColor = sel ? "rgba(92,126,255,.42)" : "rgba(255,255,255,.12)";
        });
        const left = document.createElement("div");
        left.style.display = "flex";
        left.style.flexDirection = "column";
        left.style.gap = "2px";
        const lbl = document.createElement("strong");
        lbl.textContent = rec.label;
        const ts = document.createElement("span");
        ts.style.opacity = "0.7";
        ts.style.fontSize = "12px";
        ts.textContent = `${fmtTime(rec.timestamp)}${rec.type === "initial" ? " \u2022 initial" : ""}`;
        left.append(lbl, ts);
        const summary = document.createElement("div");
        summary.style.fontSize = "12px";
        summary.style.lineHeight = "1.45";
        summary.style.whiteSpace = "pre-wrap";
        const prefix = rec.type === "initial" ? "[initial] " : "";
        summary.textContent = prefix + summarizeValue(rec.next);
        row.append(left, summary);
        row.addEventListener("click", () => {
          selectedRecord = idx;
          renderRecords(false);
          updateDetails(rec);
        });
        logWrap.appendChild(row);
      });
      if (autoScroll) logWrap.scrollTop = logWrap.scrollHeight;
      if (selectedRecord != null && !records[selectedRecord]) {
        selectedRecord = records.length ? Math.min(selectedRecord, records.length - 1) : null;
      }
      if (selectedRecord != null) {
        renderHistoryFor(records[selectedRecord]?.label ?? null, selectedRecord);
      }
    }
    function updateDetails(rec) {
      if (!rec) {
        detailHeader.textContent = "Select a log entry to inspect previous and next values.";
        prevTitle.textContent = "Previous";
        prevPre.textContent = "";
        nextTitle.textContent = "Next";
        nextPre.textContent = "";
        renderHistoryFor(null, null);
        return;
      }
      const typeSuffix = rec.type === "initial" ? " (initial)" : "";
      detailHeader.textContent = `${rec.label} \u2014 ${fmtTime(rec.timestamp)}${typeSuffix}`;
      prevTitle.textContent = rec.type === "initial" ? "Previous (none)" : "Previous";
      prevPre.textContent = rec.type === "initial" ? "(no previous snapshot)" : stringify(rec.previous);
      nextTitle.textContent = rec.type === "initial" ? "Initial value" : "Next";
      nextPre.textContent = stringify(rec.next);
      renderHistoryFor(rec.label, selectedRecord);
    }
    function renderHistoryFor(label2, selectedIdx) {
      historyList.innerHTML = "";
      if (!label2) {
        const empty = document.createElement("p");
        empty.className = "dd-card-description";
        empty.textContent = "Select a log entry to inspect the value history.";
        historyList.appendChild(empty);
        return;
      }
      const relevant = records.map((rec, idx) => ({ rec, idx })).filter(({ rec }) => rec.label === label2);
      if (!relevant.length) {
        const empty = document.createElement("p");
        empty.className = "dd-card-description";
        empty.textContent = "No history recorded yet.";
        historyList.appendChild(empty);
        return;
      }
      relevant.forEach(({ rec, idx }, order) => {
        const item = document.createElement("div");
        item.style.display = "flex";
        item.style.flexDirection = "column";
        item.style.gap = "6px";
        item.style.padding = "10px 12px";
        item.style.borderRadius = "12px";
        item.style.border = "1px solid rgba(255,255,255,.12)";
        const isSelected = idx === selectedIdx;
        item.style.background = isSelected ? "rgba(92,126,255,.16)" : "rgba(11,16,22,.85)";
        item.style.borderColor = isSelected ? "rgba(92,126,255,.42)" : "rgba(255,255,255,.12)";
        item.style.cursor = "pointer";
        item.addEventListener("mouseenter", () => {
          if (!isSelected) item.style.borderColor = "rgba(255,255,255,.24)";
        });
        item.addEventListener("mouseleave", () => {
          item.style.borderColor = isSelected ? "rgba(92,126,255,.42)" : "rgba(255,255,255,.12)";
        });
        item.addEventListener("click", () => {
          selectedRecord = idx;
          renderRecords(false);
          updateDetails(records[selectedRecord]);
        });
        const head = document.createElement("div");
        head.style.display = "flex";
        head.style.alignItems = "center";
        head.style.justifyContent = "space-between";
        const meta = document.createElement("div");
        meta.style.display = "flex";
        meta.style.alignItems = "center";
        meta.style.gap = "8px";
        const orderBadge = document.createElement("span");
        orderBadge.textContent = `#${order + 1}`;
        orderBadge.style.fontSize = "11px";
        orderBadge.style.letterSpacing = ".04em";
        orderBadge.style.textTransform = "uppercase";
        orderBadge.style.padding = "2px 6px";
        orderBadge.style.borderRadius = "999px";
        orderBadge.style.background = "rgba(255,255,255,.08)";
        orderBadge.style.border = "1px solid rgba(255,255,255,.16)";
        const type = document.createElement("span");
        type.textContent = rec.type === "initial" ? "Initial" : "Update";
        type.style.fontSize = "11px";
        type.style.opacity = "0.75";
        type.style.textTransform = "uppercase";
        meta.append(orderBadge, type);
        const ts = document.createElement("span");
        ts.textContent = fmtTime(rec.timestamp);
        ts.style.fontSize = "12px";
        ts.style.opacity = "0.75";
        head.append(meta, ts);
        const val = document.createElement("pre");
        stylePre(val);
        val.style.margin = "0";
        val.textContent = stringify(rec.next);
        item.append(head, val);
        historyList.appendChild(item);
      });
    }
    async function toggleRecording() {
      if (recording) {
        stopRecording();
        return;
      }
      if (!entries.size) {
        toast("Select at least one atom");
        return;
      }
      try {
        await ensureStore();
      } catch (e) {
        toast(e?.message || "Unable to capture store");
        return;
      }
      recording = true;
      updateControls();
      for (const label2 of Array.from(entries.keys())) {
        const ok = await attachEntry(label2);
        if (!ok) entries.delete(label2);
      }
      if (!entries.size) {
        stopRecording();
      }
      updateSelectedInfo();
      updateControls();
    }
    function stopRecording() {
      if (!recording) return;
      recording = false;
      for (const entry of entries.values()) {
        if (entry.unsubscribe) {
          try {
            entry.unsubscribe();
          } catch {
          }
          entry.unsubscribe = null;
        }
      }
      updateControls();
    }
    async function attachEntry(label2) {
      const entry = entries.get(label2);
      if (!entry) return false;
      if (entry.unsubscribe) {
        try {
          entry.unsubscribe();
        } catch {
        }
        entry.unsubscribe = null;
      }
      try {
        const initialValue = snapshot(await jGet(entry.atom));
        entry.lastValue = initialValue;
        const unsub = await jSub(entry.atom, async () => {
          const previous = snapshot(entry.lastValue);
          let nextValue;
          try {
            nextValue = await jGet(entry.atom);
          } catch (err) {
            nextValue = err?.message || String(err);
          }
          const nextSnap = snapshot(nextValue);
          entry.lastValue = nextSnap;
          const rec = {
            label: label2,
            timestamp: Date.now(),
            previous,
            next: nextSnap,
            type: "update"
          };
          records.push(rec);
          if (selectedRecord == null) selectedRecord = records.length - 1;
          renderRecords(true);
          updateDetails(records[selectedRecord]);
          updateControls();
        });
        const initialRecord = {
          label: label2,
          timestamp: Date.now(),
          previous: null,
          next: snapshot(initialValue),
          type: "initial"
        };
        records.push(initialRecord);
        if (selectedRecord == null) selectedRecord = records.length - 1;
        renderRecords(true);
        updateDetails(records[selectedRecord]);
        entry.unsubscribe = () => {
          try {
            unsub();
          } catch {
          }
          ;
        };
        return true;
      } catch (err) {
        toast(err?.message || `Unable to subscribe to ${label2}`);
        entries.delete(label2);
        updateSelectedInfo();
        updateControls();
        return false;
      }
    }
    function copyLog() {
      if (!records.length) return;
      const text = records.map((rec) => {
        const prev = rec.previous == null ? "(no previous snapshot)" : stringify(rec.previous);
        const next = stringify(rec.next);
        const type = rec.type === "initial" ? "initial" : "update";
        return `[${fmtTime(rec.timestamp)}] ${rec.label} (${type})
previous: ${prev}
next: ${next}`;
      }).join("\n\n");
      copy(text);
    }
    function snapshot(value) {
      if (value == null) return value;
      try {
        if (typeof structuredClone === "function") return structuredClone(value);
      } catch {
      }
      try {
        return JSON.parse(JSON.stringify(value));
      } catch {
        return value;
      }
    }
    function stringify(value) {
      if (typeof value === "string") return value;
      try {
        return JSON.stringify(value, null, 2);
      } catch {
        return String(value);
      }
    }
    function summarizeValue(value) {
      const str = stringify(value).replace(/\s+/g, " ").trim();
      return str.length > 140 ? str.slice(0, 140) + "\u2026" : str;
    }
    refreshMatches();
    updateControls();
    view.__atoms_live_cleanup__ = () => {
      stopRecording();
      for (const entry of entries.values()) {
        if (entry.unsubscribe) {
          try {
            entry.unsubscribe();
          } catch {
          }
        }
      }
      entries.clear();
      records.length = 0;
      selectedRecord = null;
    };
  }

  // src/data/sprites.ts
  var SOURCE_LABELS = {
    tileRefsMap: "Map tiles",
    tileRefsPlants: "Plants",
    tileRefsTallPlants: "Tall plants",
    tileRefsSeeds: "Seeds",
    tileRefsItems: "Items",
    tileRefsAnimations: "Animations",
    tileRefsPets: "Pets",
    tileRefsMutations: "Mutations",
    tileRefsDecor: "Decor"
  };
  function formatDisplayName(key2) {
    const spaced = key2.replace(/_/g, " ").replace(/([a-z0-9])([A-Z])/g, "$1 $2").replace(/\s+/g, " ").trim();
    if (!spaced) return key2;
    return spaced.charAt(0).toUpperCase() + spaced.slice(1);
  }
  function buildEntries(config) {
    const map2 = /* @__PURE__ */ new Map();
    for (const { source, refs } of config.sources) {
      const sourceLabel = SOURCE_LABELS[source] ?? source;
      for (const [key2, value] of Object.entries(refs)) {
        if (typeof value !== "number" || Number.isNaN(value)) continue;
        const index = value > 0 ? value - 1 : value;
        const entry = {
          index,
          key: key2,
          source,
          sourceLabel,
          qualifiedName: `${source}.${key2}`,
          displayName: formatDisplayName(key2)
        };
        const current = map2.get(index);
        if (current) {
          current.push(entry);
        } else {
          map2.set(index, [entry]);
        }
      }
    }
    return map2;
  }
  var rawMatchers = [
    {
      id: "plants-tall",
      label: "Tall plants",
      test: (sheet) => sheet.includes("tall"),
      sources: [{ source: "tileRefsTallPlants", refs: tileRefsTallPlants }]
    },
    {
      id: "plants",
      label: "Plants",
      test: (sheet) => sheet.includes("plants"),
      sources: [{ source: "tileRefsPlants", refs: tileRefsPlants }]
    },
    {
      id: "mutations",
      label: "Mutations",
      test: (sheet) => sheet.includes("mutation"),
      sources: [{ source: "tileRefsMutations", refs: tileRefsMutations }]
    },
    {
      id: "seeds",
      label: "Seeds",
      test: (sheet) => sheet.includes("seed"),
      sources: [{ source: "tileRefsSeeds", refs: tileRefsSeeds }]
    },
    {
      id: "items",
      label: "Items",
      test: (sheet) => sheet.includes("item"),
      sources: [{ source: "tileRefsItems", refs: tileRefsItems }]
    },
    {
      id: "pets",
      label: "Pets",
      test: (sheet) => sheet.includes("pet"),
      sources: [{ source: "tileRefsPets", refs: tileRefsPets }]
    },
    {
      id: "decor",
      label: "Decor",
      test: (sheet) => sheet.includes("decor"),
      sources: [{ source: "tileRefsDecor", refs: tileRefsDecor }]
    },
    {
      id: "animations",
      label: "Animations",
      test: (sheet) => sheet.includes("anim"),
      sources: [{ source: "tileRefsAnimations", refs: tileRefsAnimations }]
    },
    {
      id: "map",
      label: "Map",
      test: (sheet) => sheet.includes("map"),
      sources: [{ source: "tileRefsMap", refs: tileRefsMap }]
    }
  ];
  var matchers = rawMatchers.map((config) => ({
    ...config,
    entries: buildEntries(config)
  }));
  var matchersBySource = /* @__PURE__ */ new Map();
  for (const matcher of matchers) {
    for (const { source } of matcher.sources) {
      const existing = matchersBySource.get(source);
      if (existing) existing.push(matcher);
      else matchersBySource.set(source, [matcher]);
    }
  }
  var fallbackEntries = (() => {
    const map2 = /* @__PURE__ */ new Map();
    for (const matcher of matchers) {
      for (const [index, entries] of matcher.entries) {
        const existing = map2.get(index);
        if (existing) {
          existing.push(...entries);
        } else {
          map2.set(index, [...entries]);
        }
      }
    }
    return map2;
  })();
  function normalizeSheet(sheet) {
    return sheet.toLowerCase();
  }
  function findTileRefMatch(sheet, index) {
    const normalized = normalizeSheet(sheet);
    for (const matcher of matchers) {
      if (!matcher.test(normalized)) continue;
      const entries = matcher.entries.get(index);
      if (entries?.length) {
        return {
          sheetId: matcher.id,
          sheetLabel: matcher.label,
          entries: [...entries]
        };
      }
    }
    const fallback = fallbackEntries.get(index);
    if (fallback?.length === 1) {
      const entry = fallback[0];
      const sourceMatchers = matchersBySource.get(entry.source);
      if (!sourceMatchers || sourceMatchers.some((m) => m.test(normalized))) {
        return {
          sheetId: entry.source,
          sheetLabel: entry.sourceLabel,
          entries: [...fallback]
        };
      }
    }
    return null;
  }

  // src/ui/menus/debug-data-sprites.ts
  var COLOR_FILTERS = ["None", "Gold", "Rainbow"];
  var CONDITION_MUTATION_KEYS = ["None", "Wet", "Chilled", "Frozen"];
  function debugAssetName(url) {
    const clean = url.split(/[?#]/)[0];
    const last = clean.split("/").filter(Boolean).pop() ?? clean;
    return last.replace(/\.[a-z0-9]+$/i, "");
  }
  function deriveAssetCategory(family, url) {
    const base = debugAssetName(url);
    const normalized = (family || "").toLowerCase();
    if (normalized === "tiles") return base;
    if (normalized === "cosmetics") {
      return base.split("_")[0] || base;
    }
    try {
      const trimmed = url.split(/[?#]/)[0].replace(/^https?:\/\/[^/]+\//, "");
      const segments = trimmed.split("/").filter(Boolean);
      if (segments.length >= 2) {
        return segments[1].split(".")[0] || base;
      }
    } catch {
    }
    return base;
  }
  var COSMETICS_EXPRESSION_CATEGORY = "expression";
  var COSMETICS_EXPRESSION_BASE_REGEX = /\/cosmetics\/mid_defaultblack\.png(?:$|\?)/i;
  function isExpressionCategoryName(name) {
    return (name ?? "").toLowerCase() === COSMETICS_EXPRESSION_CATEGORY;
  }
  function findExpressionBaseUrl(urls) {
    return urls.find((url) => COSMETICS_EXPRESSION_BASE_REGEX.test(url.split(/[?#]/)[0])) ?? null;
  }
  function formatExpressionDisplayName(url) {
    const raw = debugAssetName(url);
    const cleaned = raw.replace(/^Mid_DefaultBlack[_-]?/i, "").replace(/_/g, " ").trim();
    return cleaned || raw;
  }
  async function loadImageElement(url) {
    const response = await fetch(url, { credentials: "include" });
    if (!response.ok) {
      throw new Error(`Failed to load image ${url}: ${response.status}`);
    }
    const blob = await response.blob();
    const objectUrl = URL.createObjectURL(blob);
    try {
      return await new Promise((resolve2, reject) => {
        const img = new Image();
        img.onload = () => {
          URL.revokeObjectURL(objectUrl);
          resolve2(img);
        };
        img.onerror = (error) => {
          URL.revokeObjectURL(objectUrl);
          reject(error);
        };
        img.src = objectUrl;
      });
    } catch (error) {
      URL.revokeObjectURL(objectUrl);
      throw error;
    }
  }
  function imageToCanvas(img) {
    const canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("Failed to get 2D context for expression canvas");
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, 0, 0);
    return canvas;
  }
  async function loadCanvasFromUrl(url) {
    try {
      const img = await loadImageElement(url);
      return imageToCanvas(img);
    } catch (error) {
      console.error("[Sprites] Failed to load canvas for expression asset", { url, error });
      return null;
    }
  }
  function blendBaseAndOverlay(baseCanvas, overlayCanvas) {
    const width = baseCanvas?.width ?? overlayCanvas?.width ?? 1;
    const height = baseCanvas?.height ?? overlayCanvas?.height ?? 1;
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("Failed to get 2D context when blending canvases");
    ctx.imageSmoothingEnabled = false;
    if (baseCanvas) ctx.drawImage(baseCanvas, 0, 0, width, height);
    else if (overlayCanvas) ctx.drawImage(overlayCanvas, 0, 0, width, height);
    if (overlayCanvas) ctx.drawImage(overlayCanvas, 0, 0, width, height);
    return canvas;
  }
  function renderSpritesTab(view, ui) {
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const { leftCol, rightCol } = createTwoColumns(view);
    const explorerCard = ui.card("Sprite Explorer", {
      tone: "muted",
      subtitle: "Browse captured assets by manifest family."
    });
    leftCol.appendChild(explorerCard.root);
    const listCard = ui.card("Assets", {
      tone: "muted",
      subtitle: "Click an entry to open the file in a new tab."
    });
    rightCol.appendChild(listCard.root);
    const families = ["all", ...Array.from(new Set(Sprites.listFamilies().filter(Boolean))).sort()];
    let selectedFamily = "all";
    let selectedCategory = "all";
    const categoryCache = /* @__PURE__ */ new Map();
    const familySelect = ui.select({ width: "100%" });
    families.forEach((family) => {
      const option = document.createElement("option");
      option.value = family;
      option.textContent = family === "all" ? "All families" : family;
      familySelect.appendChild(option);
    });
    familySelect.value = selectedFamily;
    const categorySelect = ui.select({ width: "100%" });
    categorySelect.disabled = true;
    const controlsGrid = document.createElement("div");
    controlsGrid.className = "dd-sprite-control-grid";
    controlsGrid.append(
      createSelectControl("Asset family", familySelect),
      createSelectControl("Asset category", categorySelect)
    );
    explorerCard.body.appendChild(controlsGrid);
    const filterPanel = document.createElement("div");
    filterPanel.className = "dd-sprite-filter-panel";
    explorerCard.body.appendChild(filterPanel);
    const colorSegmentRow = document.createElement("div");
    const conditionSegmentRow = document.createElement("div");
    const lightingSegmentRow = document.createElement("div");
    filterPanel.append(colorSegmentRow, conditionSegmentRow, lightingSegmentRow);
    const COLOR_FILTERS_LIST = COLOR_FILTERS;
    const mutationLabelMap = tileRefsMutationLabels;
    const CONDITION_OPTIONS = CONDITION_MUTATION_KEYS.map((value) => ({
      value,
      label: value === "None" ? "None" : mutationLabelMap[value] ?? value
    }));
    const LIGHTING_DEFINITIONS = [
      { id: "None", key: "None", label: "None" },
      { id: "Dawnlit", key: "Dawnlit", label: mutationLabelMap["Dawnlit"] ?? "Dawnlit" },
      { id: "Ambershine", key: "Amberlit", label: mutationLabelMap["Amberlit"] ?? "Amberlit" },
      { id: "Dawncharged", key: "Dawnbound", label: mutationLabelMap["Dawnbound"] ?? "Dawnbound" },
      { id: "Ambercharged", key: "Amberbound", label: mutationLabelMap["Amberbound"] ?? "Amberbound" }
    ];
    const LIGHTING_OPTIONS = LIGHTING_DEFINITIONS.map((def) => ({
      value: def.id,
      label: def.label
    }));
    let colorFilter = "None";
    let conditionFilter = "None";
    let lightingFilter = "None";
    let lightingSelectionKey = "None";
    const categoryMatches = (keyword) => selectedFamily === "tiles" && selectedCategory.toLowerCase().includes(keyword);
    const renderSegment = (container, title, options, selected, onSelect) => {
      container.innerHTML = "";
      const heading = document.createElement("span");
      heading.className = "dd-sprite-filter-label";
      heading.textContent = title;
      const segment = document.createElement("div");
      segment.className = "dd-sprite-segmented";
      options.forEach(({ value, label: label2 }) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "dd-sprite-seg-btn";
        btn.textContent = label2;
        if (value === selected) btn.classList.add("is-active");
        btn.addEventListener("click", () => {
          onSelect(value);
          renderFilters();
          void updateList();
        });
        segment.append(btn);
      });
      container.append(heading, segment);
    };
    let currentTilesheetUrl = null;
    let currentTiles = [];
    let tileSheetActive = false;
    let visibleAssetUrls = [];
    let mutationIconsCache = null;
    const mutationIconsPromise = loadMutationIcons();
    const applyFiltersToCanvas = (canvas, filters = buildFilterQueue()) => {
      let result = canvas;
      for (const filterName of filters) {
        const filtered = Sprites.applyCanvasFilter(result, filterName);
        if (filtered) result = filtered;
      }
      return result;
    };
    const exportCard = ui.card("Export", {
      tone: "muted",
      subtitle: "Download the assets currently visible in the explorer."
    });
    leftCol.appendChild(exportCard.root);
    const exportBtn = ui.btn("Export visible assets", {
      variant: "primary",
      icon: "\u2B07",
      onClick: exportVisibleAssets
    });
    const exportStatus = document.createElement("span");
    exportStatus.className = "dd-sprite-stats";
    exportStatus.textContent = "Select assets to export.";
    const progressWrapper = document.createElement("div");
    progressWrapper.className = "dd-sprite-export-progress";
    const progressBar = document.createElement("div");
    progressBar.className = "dd-sprite-export-progress__bar";
    progressWrapper.append(progressBar);
    exportCard.body.append(exportBtn, exportStatus, progressWrapper);
    let exporting = false;
    const showProgress = (value) => {
      progressBar.style.width = `${value}%`;
      progressWrapper.style.opacity = value > 0 && value < 100 ? "1" : "0";
    };
    const getAssetExportBaseName = () => {
      const familyPart = selectedFamily === "all" ? "all" : selectedFamily || "assets";
      const categoryPart = selectedCategory && selectedCategory !== "all" ? `-${selectedCategory}` : "";
      const raw = `${familyPart}${categoryPart}`.replace(/[^a-z0-9_-]+/gi, "_");
      return raw || "assets";
    };
    const updateExportStatusText = () => {
      if (tileSheetActive) {
        exportStatus.textContent = currentTiles.length ? `${currentTiles.length} tiles ready to export.` : "Load a tilesheet to export.";
        return;
      }
      if (visibleAssetUrls.length) {
        exportStatus.textContent = `${visibleAssetUrls.length} assets ready to download.`;
        return;
      }
      exportStatus.textContent = "Select assets to export.";
    };
    function triggerDownload(blob, filename) {
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(a.href), 1e4);
    }
    async function downloadCanvasAsPng(canvas, filename) {
      const blob = await new Promise((resolve2, reject) => {
        canvas.toBlob((b) => {
          if (!b) {
            reject(new Error("canvas.toBlob returned null"));
            return;
          }
          resolve2(b);
        }, "image/png");
      });
      triggerDownload(blob, filename);
    }
    async function renderCosmeticsExpressionPreview(options) {
      const { previewArea: previewArea2, expressionUrls, baseUrl, baseCanvas } = options;
      previewArea2.innerHTML = "";
      previewArea2.classList.remove("dd-sprite-grid--tiles");
      const baseItem = document.createElement("div");
      baseItem.className = "dd-sprite-grid__item";
      if (baseCanvas || baseUrl) {
        const baseImg = document.createElement("img");
        baseImg.className = "dd-sprite-grid__img";
        baseImg.alt = "Mid Default Black base";
        baseImg.loading = "lazy";
        baseImg.referrerPolicy = "no-referrer";
        baseImg.src = baseCanvas ? baseCanvas.toDataURL() : baseUrl;
        baseItem.appendChild(baseImg);
      }
      const baseName = document.createElement("span");
      baseName.className = "dd-sprite-grid__name";
      baseName.textContent = "Mid Default Black (base)";
      const baseMeta = document.createElement("span");
      baseMeta.className = "dd-sprite-grid__meta";
      baseMeta.textContent = baseUrl ?? "Base asset missing (Mid_DefaultBlack)";
      baseItem.append(baseName, baseMeta);
      previewArea2.appendChild(baseItem);
      if (!expressionUrls.length) {
        const empty = document.createElement("div");
        empty.className = "dd-sprite-grid__empty";
        empty.textContent = "No expression assets recorded yet.";
        previewArea2.appendChild(empty);
        return;
      }
      const overlays = await Promise.all(expressionUrls.map(async (url) => ({
        url,
        overlayCanvas: await loadCanvasFromUrl(url)
      })));
      for (const { url, overlayCanvas } of overlays) {
        const displayName = formatExpressionDisplayName(url);
        if (!overlayCanvas) {
          const failItem = document.createElement("div");
          failItem.className = "dd-sprite-grid__item";
          const failLabel = document.createElement("span");
          failLabel.className = "dd-sprite-grid__name";
          failLabel.textContent = `${displayName} (failed to render)`;
          const failMeta = document.createElement("span");
          failMeta.className = "dd-sprite-grid__meta";
          failMeta.textContent = url;
          failItem.append(failLabel, failMeta);
          previewArea2.appendChild(failItem);
          continue;
        }
        const combined = blendBaseAndOverlay(baseCanvas, overlayCanvas);
        const item = document.createElement("a");
        item.className = "dd-sprite-grid__item";
        item.href = url;
        item.target = "_blank";
        item.rel = "noopener noreferrer";
        const img = document.createElement("img");
        img.className = "dd-sprite-grid__img";
        img.src = combined.toDataURL();
        img.alt = displayName;
        img.loading = "lazy";
        img.referrerPolicy = "no-referrer";
        const nameEl = document.createElement("span");
        nameEl.className = "dd-sprite-grid__name";
        nameEl.textContent = displayName;
        const meta = document.createElement("span");
        meta.className = "dd-sprite-grid__meta";
        meta.textContent = url;
        item.append(img, nameEl, meta);
        item.addEventListener("click", (event) => {
          event.preventDefault();
          event.stopPropagation();
          const downloadCanvas = overlayCanvas ?? combined;
          void downloadCanvasAsPng(downloadCanvas, `${debugAssetName(url)}.png`);
        });
        previewArea2.appendChild(item);
      }
    }
    async function downloadUrlAsset(url) {
      try {
        const resp = await fetch(url, { credentials: "include" });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const blob = await resp.blob();
        let name = debugAssetName(url);
        if (!/\.[a-z0-9]+$/i.test(name)) name += ".png";
        triggerDownload(blob, name);
      } catch (error) {
        console.error("[Sprites] Asset download failed", { url, error });
      }
    }
    async function exportVisibleAssets() {
      if (exporting) return;
      const hasTiles = tileSheetActive && Boolean(currentTilesheetUrl) && currentTiles.length > 0;
      const hasAssets = visibleAssetUrls.length > 0;
      if (!hasTiles && !hasAssets) {
        showProgress(0);
        exportStatus.textContent = "Select assets to export.";
        return;
      }
      exporting = true;
      exportBtn.disabled = true;
      showProgress(0);
      exportStatus.textContent = "Preparing export...";
      try {
        if (hasTiles) {
          const base = normalizeSheetBase(currentTilesheetUrl);
          const filters = buildFilterQueue();
          await Sprites.exportFilteredTileset({
            tiles: currentTiles,
            filters,
            baseName: base,
            onProgress: (processed, total) => {
              const percent = total ? Math.round(processed / total * 100) : 0;
              showProgress(percent);
              exportStatus.textContent = `Processing ${processed}/${total} tiles`;
            }
          });
        } else {
          const base = getAssetExportBaseName();
          await Sprites.exportAssets({
            urls: visibleAssetUrls,
            baseName: base,
            onProgress: (processed, total) => {
              const percent = total ? Math.round(processed / total * 100) : 0;
              showProgress(percent);
              exportStatus.textContent = `Processing ${processed}/${total} assets`;
            }
          });
        }
        showProgress(100);
        exportStatus.textContent = "Export ready \u2014 check your downloads.";
        setTimeout(() => showProgress(0), 1e3);
      } catch (error) {
        console.error("[Sprites] Export failed", error);
        exportStatus.textContent = "Export failed (see console).";
        showProgress(0);
      } finally {
        exporting = false;
        exportBtn.disabled = false;
      }
    }
    const renderFilters = () => {
      const showColor = categoryMatches("plant") || categoryMatches("pet");
      const showCondition = categoryMatches("plant");
      const showLighting = categoryMatches("plant");
      filterPanel.style.display = showColor ? "" : "none";
      colorSegmentRow.style.display = showColor ? "" : "none";
      conditionSegmentRow.style.display = showCondition ? "" : "none";
      lightingSegmentRow.style.display = showLighting ? "" : "none";
      renderSegment(
        colorSegmentRow,
        "Color",
        COLOR_FILTERS_LIST.map((value) => ({ value, label: value })),
        colorFilter,
        (value) => {
          colorFilter = value;
        }
      );
      renderSegment(conditionSegmentRow, "Weather", CONDITION_OPTIONS, conditionFilter, (value) => {
        conditionFilter = value;
      });
      renderSegment(lightingSegmentRow, "Lighting", LIGHTING_OPTIONS, lightingFilter, (value) => {
        lightingFilter = value;
        lightingSelectionKey = LIGHTING_DEFINITIONS.find((def) => def.id === value)?.key ?? value;
      });
    };
    const buildFilterQueue = () => {
      const queue = [];
      if (colorFilter !== "None") queue.push(colorFilter);
      if (colorFilter === "Gold" || colorFilter === "Rainbow") return queue;
      if (categoryMatches("plant")) {
        if (conditionFilter !== "None") queue.push(conditionFilter);
        if (lightingFilter !== "None") queue.push(lightingFilter);
      }
      return queue;
    };
    renderFilters();
    const stats = document.createElement("p");
    stats.className = "dd-sprite-stats";
    stats.textContent = "Select a family to inspect its assets.";
    explorerCard.body.appendChild(stats);
    const previewArea = document.createElement("div");
    previewArea.className = "dd-sprite-grid";
    listCard.body.appendChild(previewArea);
    const ensureCategories = (family) => {
      if (!categoryCache.has(family)) {
        const assets = Sprites.listAssetsForFamily(family);
        const categories = Array.from(new Set(assets.map((url) => deriveAssetCategory(family, url))));
        categories.sort();
        categoryCache.set(family, categories);
      }
      return categoryCache.get(family) ?? [];
    };
    const updateCategoryOptions = () => {
      if (selectedFamily === "all") {
        categorySelect.innerHTML = "";
        const option = document.createElement("option");
        option.value = "all";
        option.textContent = "All categories";
        categorySelect.appendChild(option);
        categorySelect.value = "all";
        categorySelect.disabled = true;
        selectedCategory = "all";
        return;
      }
      const familyHasGroups = selectedFamily === "tiles" || selectedFamily === "cosmetics";
      if (!familyHasGroups) {
        categorySelect.innerHTML = "";
        const option = document.createElement("option");
        option.value = "all";
        option.textContent = "All categories";
        categorySelect.appendChild(option);
        categorySelect.value = "all";
        categorySelect.disabled = true;
        selectedCategory = "all";
        return;
      }
      const categories = ensureCategories(selectedFamily);
      categorySelect.innerHTML = "";
      const allOption = document.createElement("option");
      allOption.value = "all";
      allOption.textContent = "All categories";
      categorySelect.appendChild(allOption);
      categories.forEach((category) => {
        const option = document.createElement("option");
        option.value = category;
        option.textContent = category;
        categorySelect.appendChild(option);
      });
      if (!categories.length) {
        categorySelect.disabled = true;
        selectedCategory = "all";
      } else {
        categorySelect.disabled = false;
        selectedCategory = categories.includes(selectedCategory) ? selectedCategory : "all";
        categorySelect.value = selectedCategory;
      }
    };
    const updateList = async () => {
      const filterQueue = buildFilterQueue();
      const familyAssets = selectedFamily === "all" ? Sprites.lists().all : Sprites.listAssetsForFamily(selectedFamily);
      let assets = familyAssets;
      if (selectedFamily !== "all" && selectedCategory !== "all") {
        assets = assets.filter(
          (url) => deriveAssetCategory(selectedFamily, url) === selectedCategory
        );
      }
      visibleAssetUrls = assets;
      previewArea.innerHTML = "";
      let tileCount = null;
      const isTileSheetView = selectedFamily === "tiles" && selectedCategory !== "all" && assets.length > 0;
      previewArea.classList.toggle("dd-sprite-grid--tiles", isTileSheetView);
      currentTilesheetUrl = null;
      currentTiles = [];
      tileSheetActive = isTileSheetView;
      const isCosmeticsExpressionCategory = selectedFamily === "cosmetics" && isExpressionCategoryName(selectedCategory);
      if (isCosmeticsExpressionCategory) {
        const expressionBaseUrl = findExpressionBaseUrl(familyAssets);
        const expressionBaseCanvas = expressionBaseUrl ? await loadCanvasFromUrl(expressionBaseUrl) : null;
        tileSheetActive = false;
        currentTilesheetUrl = null;
        currentTiles = [];
        previewArea.classList.remove("dd-sprite-grid--tiles");
        await renderCosmeticsExpressionPreview({
          previewArea,
          expressionUrls: assets,
          baseUrl: expressionBaseUrl,
          baseCanvas: expressionBaseCanvas
        });
        const baseLabel = expressionBaseUrl ? debugAssetName(expressionBaseUrl) : "Mid Default Black";
        stats.textContent = `${assets.length} expression overlays on ${baseLabel}`;
        updateExportStatusText();
        return;
      }
      if (isTileSheetView) {
        const sheetUrl = assets[0];
        const base = normalizeSheetBase(sheetUrl);
        const tiles = await loadTileSheet(base);
        currentTilesheetUrl = sheetUrl;
        currentTiles = tiles;
        tileCount = tiles.length;
        if (!tiles.length) {
          const empty = document.createElement("div");
          empty.className = "dd-sprite-grid__empty";
          empty.textContent = `No tiles could be sliced for ${debugAssetName(sheetUrl)} yet.`;
          previewArea.appendChild(empty);
        } else {
          tiles.forEach((tile) => {
            const item = document.createElement("a");
            item.className = "dd-sprite-grid__item";
            item.href = sheetUrl;
            item.target = "_blank";
            item.rel = "noopener noreferrer";
            const baseCanvas = Sprites.toCanvas(tile);
            const match = findTileRefMatch(tile.sheet, tile.index);
            const isPlantSheet = match?.sheetId === "plants";
            let displayCanvas = applyFiltersToCanvas(baseCanvas, filterQueue);
            if (isPlantSheet && filterQueue.length && mutationIconsCache && Object.keys(mutationIconsCache).length > 0) {
              const renderMutations = [];
              if (colorFilter !== "None") {
                renderMutations.push(colorFilter);
              }
              if (conditionFilter !== "None") {
                renderMutations.push(conditionFilter);
              }
              if (lightingFilter !== "None") {
                renderMutations.push(lightingFilter);
              }
              const mutated = Sprites.renderPlantWithMutationsNonTall({
                baseTile: tile,
                mutations: renderMutations,
                mutationIcons: mutationIconsCache
              });
              if (mutated) displayCanvas = mutated;
            }
            displayCanvas.className = "dd-sprite-grid__img";
            const name = document.createElement("span");
            name.className = "dd-sprite-grid__name";
            const displayNames = match?.entries.map((entry) => entry.displayName).filter(Boolean);
            if (displayNames && displayNames.length) {
              name.textContent = displayNames.join(", ");
            } else {
              name.textContent = `${debugAssetName(tile.url)} #${tile.index + 1}`;
            }
            const meta = document.createElement("span");
            meta.className = "dd-sprite-grid__meta";
            const sheetLabel = match?.sheetLabel ?? tile.sheet;
            meta.textContent = `${sheetLabel} (${tile.col},${tile.row})`;
            item.append(displayCanvas, name, meta);
            item.addEventListener("click", (ev) => {
              ev.preventDefault();
              ev.stopPropagation();
              const label2 = match?.sheetLabel ?? debugAssetName(tile.url);
              const tileName = `${label2}_#${String(tile.index + 1).padStart(3, "0")}.png`;
              void downloadCanvasAsPng(displayCanvas, tileName);
            });
            previewArea.appendChild(item);
          });
        }
      } else {
        if (!assets.length) {
          const empty = document.createElement("div");
          empty.className = "dd-sprite-grid__empty";
          empty.textContent = "No assets recorded for this selection yet.";
          previewArea.appendChild(empty);
        } else {
          assets.forEach((url) => {
            const item = document.createElement("a");
            item.className = "dd-sprite-grid__item";
            item.href = url;
            item.target = "_blank";
            item.rel = "noopener noreferrer";
            const img = document.createElement("img");
            img.className = "dd-sprite-grid__img";
            img.src = url;
            img.alt = debugAssetName(url);
            img.loading = "lazy";
            img.referrerPolicy = "no-referrer";
            const name = document.createElement("span");
            name.className = "dd-sprite-grid__name";
            name.textContent = debugAssetName(url);
            const meta = document.createElement("span");
            meta.className = "dd-sprite-grid__meta";
            meta.textContent = url;
            item.append(img, name, meta);
            previewArea.appendChild(item);
            item.addEventListener("click", (ev) => {
              ev.preventDefault();
              ev.stopPropagation();
              void downloadUrlAsset(url);
            });
          });
        }
      }
      const familyLabel = selectedFamily === "all" ? "all families" : `family "${selectedFamily}" (${familyAssets.length})`;
      const categoryLabel = selectedFamily === "all" || selectedCategory === "all" ? "all categories" : `category "${selectedCategory}"`;
      const summaryCount = tileCount !== null ? `${tileCount} tiles` : `${assets.length} assets`;
      stats.textContent = `${summaryCount} \xB7 ${familyLabel} \xB7 ${categoryLabel}`;
      updateExportStatusText();
    };
    familySelect.addEventListener("change", () => {
      selectedFamily = familySelect.value || "all";
      selectedCategory = "all";
      colorFilter = "None";
      conditionFilter = "None";
      lightingFilter = "None";
      updateCategoryOptions();
      renderFilters();
      void updateList();
    });
    categorySelect.addEventListener("change", () => {
      selectedCategory = categorySelect.value || "all";
      colorFilter = "None";
      conditionFilter = "None";
      lightingFilter = "None";
      renderFilters();
      void updateList();
    });
    updateCategoryOptions();
    void updateList();
    mutationIconsPromise.then((map2) => {
      mutationIconsCache = map2;
    }).catch(() => {
      mutationIconsCache = {};
    }).finally(() => {
      void updateList();
    });
  }
  function createSelectControl(labelText, select2) {
    const wrapper = document.createElement("label");
    wrapper.className = "dd-sprite-control";
    const label2 = document.createElement("span");
    label2.className = "dd-sprite-control__label";
    label2.textContent = labelText;
    wrapper.append(label2, select2);
    return wrapper;
  }
  async function loadMutationIcons() {
    const icons = {};
    const tiles = await loadTileSheet("mutations");
    const TILE_REF_TO_MUTATION_NAME = {
      Wet: "Wet",
      Chilled: "Chilled",
      Frozen: "Frozen",
      Dawnlit: "Dawnlit",
      Amberlit: "Ambershine",
      Dawnbound: "Dawncharged",
      Amberbound: "Ambercharged"
    };
    for (const [key2, rawIndex] of Object.entries(tileRefsMutations)) {
      if (typeof rawIndex !== "number") continue;
      const index = rawIndex > 0 ? rawIndex - 1 : rawIndex;
      const tile = tiles.find((t) => t.index === index);
      if (!tile) continue;
      icons[key2] = { tile };
      const logical = TILE_REF_TO_MUTATION_NAME[key2];
      if (logical) {
        icons[logical] = { tile };
      }
    }
    console.debug("[Sprites] mutationIcons loaded", {
      keys: Object.keys(icons)
    });
    return icons;
  }

  // src/ui/menus/debug-data-ws.ts
  function renderWSTab(view, ui) {
    if (typeof view.__ws_cleanup__ === "function") {
      try {
        view.__ws_cleanup__();
      } catch {
      }
    }
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const frames = new FrameBuffer(2e3);
    const framesMap = /* @__PURE__ */ new Map();
    let seq = 0;
    let paused = false;
    let autoScroll = true;
    let showIn = true;
    let showOut = true;
    let filterText = "";
    let onlyCurrentSocket = false;
    let replayToSource = false;
    let selectedId = null;
    let mutePatterns = [];
    const setSelectedRow = (fid) => {
      selectedId = fid;
      [...logWrap.querySelectorAll("[data-fid]")].forEach((row) => {
        row.classList.toggle("selected", String(fid || "") === row.dataset.fid);
      });
      if (fid != null) {
        const f = framesMap.get(fid);
        if (f) ta.value = f.text;
      }
    };
    const matchesMutes = (text) => mutePatterns.some((rx) => rx.test(text));
    const statusCard = ui.card("\u{1F4E1} Live traffic", {
      tone: "muted",
      subtitle: "Monitor, filter, and replay WebSocket frames."
    });
    view.appendChild(statusCard.root);
    const muteCard = ui.card("\u{1F649} Mutes (regex)", {
      tone: "muted",
      subtitle: "Hide unwanted messages."
    });
    view.appendChild(muteCard.root);
    const logCard = ui.card("\u{1F9FE} Frame log", { tone: "muted" });
    view.appendChild(logCard.root);
    const sendCard = ui.card("\u{1F4E4} Send a frame", {
      tone: "muted",
      subtitle: "Pick or compose a payload and send it."
    });
    view.appendChild(sendCard.root);
    const statusToolbar = document.createElement("div");
    statusToolbar.className = "dd-toolbar dd-toolbar--stretch";
    statusCard.body.appendChild(statusToolbar);
    const lblConn = document.createElement("span");
    lblConn.className = "dd-status-chip";
    const sel = ui.select({ width: "220px" });
    const btnPause = ui.btn("Pause", {
      variant: "secondary",
      onClick: () => {
        paused = !paused;
        setPauseLabel(paused ? "Resume" : "Pause");
        btnPause.classList.toggle("active", paused);
        btnPause.title = paused ? "Resume live updates" : "Pause live updates";
      }
    });
    const setPauseLabel = (text) => {
      const label2 = btnPause.querySelector(".label");
      if (label2) label2.textContent = text;
      else btnPause.textContent = text;
    };
    setPauseLabel("Pause");
    btnPause.title = "Suspend live updates";
    const btnClear = ui.btn("Clear", {
      variant: "ghost",
      icon: "\u{1F9F9}",
      onClick: () => {
        frames.clear();
        framesMap.clear();
        setSelectedRow(null);
        repaint(true);
      }
    });
    const btnCopy = ui.btn("Copy visible", {
      variant: "ghost",
      icon: "\u{1F4CB}",
      onClick: () => copyVisible()
    });
    statusToolbar.append(lblConn, sel, btnPause, btnClear, btnCopy);
    const filterToolbar = document.createElement("div");
    filterToolbar.className = "dd-toolbar dd-toolbar--stretch";
    statusCard.body.appendChild(filterToolbar);
    const inputFilter = ui.inputText("filter text (case-insensitive)", "");
    inputFilter.classList.add("dd-grow");
    inputFilter.addEventListener("input", () => {
      filterText = inputFilter.value.trim().toLowerCase();
      repaint(true);
    });
    const inToggle = ui.toggleChip("IN", { checked: true, icon: "\u2190", tooltip: "Show incoming messages" });
    inToggle.input.addEventListener("change", () => {
      showIn = inToggle.input.checked;
      repaint(true);
    });
    const outToggle = ui.toggleChip("OUT", { checked: true, icon: "\u2192", tooltip: "Show outgoing messages" });
    outToggle.input.addEventListener("change", () => {
      showOut = outToggle.input.checked;
      repaint(true);
    });
    const currentToggle = ui.toggleChip("Active socket", { checked: false, icon: "\u{1F3AF}", tooltip: "Limit to the selected socket" });
    currentToggle.input.addEventListener("change", () => {
      onlyCurrentSocket = currentToggle.input.checked;
      repaint(true);
    });
    const autoScrollToggle = ui.toggleChip("Auto-scroll", { checked: true, icon: "\u{1F4DC}", tooltip: "Keep the log aligned with the latest frames" });
    autoScrollToggle.input.addEventListener("change", () => {
      autoScroll = autoScrollToggle.input.checked;
    });
    filterToolbar.append(inputFilter, inToggle.root, outToggle.root, currentToggle.root, autoScrollToggle.root);
    const muteRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const muteInput = ui.inputText("add regex (e.g. ping|keepalive)", "");
    muteInput.classList.add("dd-grow");
    const btnAddMute = ui.btn("Add", {
      icon: "\u2795",
      onClick: () => {
        const raw = muteInput.value.trim();
        if (!raw) return;
        try {
          mutePatterns.push(new RegExp(raw, "i"));
          muteInput.value = "";
          repaintMutes();
          repaint(true);
        } catch {
        }
      }
    });
    muteRow.append(muteInput, btnAddMute);
    muteCard.body.appendChild(muteRow);
    const mutesWrap = document.createElement("div");
    mutesWrap.className = "dd-mute-chips";
    muteCard.body.appendChild(mutesWrap);
    function repaintMutes() {
      mutesWrap.innerHTML = "";
      mutePatterns.forEach((rx, i) => {
        const chip = ui.btn(`/${rx.source}/i \xD7`, {
          variant: "ghost",
          size: "sm",
          onClick: () => {
            mutePatterns.splice(i, 1);
            repaintMutes();
            repaint(true);
          }
        });
        mutesWrap.appendChild(chip);
      });
    }
    const logWrap = document.createElement("div");
    logWrap.className = "dd-log";
    logWrap.style.fontFamily = "ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    logWrap.style.fontSize = "12px";
    logWrap.style.lineHeight = "1.4";
    logWrap.style.userSelect = "text";
    const emptyState = document.createElement("div");
    emptyState.className = "dd-log__empty";
    emptyState.textContent = "No frames visible yet.";
    logWrap.appendChild(emptyState);
    logCard.body.appendChild(logWrap);
    const ta = document.createElement("textarea");
    ta.className = "qmm-input dd-textarea";
    ta.placeholder = `Select a frame or paste a payload here. Choose Text or JSON below.`;
    const sendControls = document.createElement("div");
    sendControls.className = "dd-send-controls";
    const asJson = ui.radioGroup(
      "ws-send-mode",
      [{ value: "text", label: "Text" }, { value: "json", label: "JSON" }],
      "text",
      () => {
      }
    );
    const replayToggle = ui.toggleChip("Use source WS", { checked: false, icon: "\u21A9" });
    replayToggle.input.addEventListener("change", () => {
      replayToSource = replayToggle.input.checked;
    });
    const btnSend = ui.btn("Send", { variant: "primary", icon: "\u{1F4E8}", onClick: () => doSend() });
    const btnCopyPayload = ui.btn("Copy payload", { variant: "ghost", icon: "\u{1F4CB}", onClick: () => copy(ta.value) });
    sendControls.append(asJson, replayToggle.root, btnSend, btnCopyPayload);
    sendCard.body.append(ta, sendControls);
    function refreshSocketPicker() {
      const wsArr = getWSInfos();
      sel.innerHTML = "";
      wsArr.forEach((info, idx) => {
        const op = document.createElement("option");
        op.value = String(idx);
        op.textContent = info.id + (info.ws === quinoaWS ? " \u2022 page" : "");
        sel.appendChild(op);
      });
      if (!sel.value && sel.options.length) sel.value = "0";
      updateStatus();
    }
    function currentWS() {
      const idx = Number(sel.value);
      const vals = getWSInfos();
      return Number.isFinite(idx) ? vals[idx]?.ws ?? null : null;
    }
    function updateStatus() {
      const text = getWSStatusText();
      lblConn.textContent = text;
      const low = text.toLowerCase();
      lblConn.classList.toggle("is-ok", /open|connected|ready/.test(low));
      lblConn.classList.toggle("is-warn", /closing|connecting|pending/.test(low));
    }
    function updateEmptyState() {
      const hasRows = logWrap.querySelector(".ws-row") != null;
      emptyState.style.display = hasRows ? "none" : "";
    }
    function passesFilters(f) {
      if (f.dir === "in" && !showIn || f.dir === "out" && !showOut) return false;
      if (filterText && !f.text.toLowerCase().includes(filterText)) return false;
      if (onlyCurrentSocket && f.ws && currentWS() && f.ws !== currentWS()) return false;
      if (matchesMutes(f.text)) return false;
      return true;
    }
    function rowActions(fid, f) {
      const acts = document.createElement("div");
      acts.className = "acts";
      const bCopy = document.createElement("button");
      bCopy.className = "qmm-btn";
      bCopy.textContent = "Copy";
      bCopy.onclick = (e) => {
        e.stopPropagation();
        copy(f.text);
      };
      const bToEd = document.createElement("button");
      bToEd.className = "qmm-btn";
      bToEd.textContent = "\u2192 Editor";
      bToEd.onclick = (e) => {
        e.stopPropagation();
        ta.value = f.text;
        setSelectedRow(fid);
      };
      const bReplay = document.createElement("button");
      bReplay.className = "qmm-btn";
      bReplay.textContent = "Replay";
      bReplay.title = "Send right away (to current WS or source WS if enabled)";
      bReplay.onclick = (e) => {
        e.stopPropagation();
        replayFrame(f);
      };
      acts.append(bCopy, bToEd, bReplay);
      return acts;
    }
    function buildRow(f) {
      const row = document.createElement("div");
      row.className = "ws-row";
      row.dataset.fid = String(f.id);
      const ts = document.createElement("div");
      ts.className = "ts";
      ts.textContent = fmtTime(f.t);
      const arrow = document.createElement("div");
      arrow.className = "arrow";
      arrow.textContent = f.dir === "in" ? "\u2190" : "\u2192";
      arrow.style.color = f.dir === "in" ? "#4bd17a" : "#8ab4ff";
      const body = document.createElement("div");
      body.className = "body";
      body.innerHTML = `<code>${escapeLite(f.text)}</code>`;
      const acts = rowActions(f.id, f);
      row.append(ts, arrow, body, acts);
      row.onclick = () => setSelectedRow(f.id);
      row.ondblclick = () => {
        ta.value = f.text;
        setSelectedRow(f.id);
      };
      return row;
    }
    function appendOne(f) {
      if (!passesFilters(f)) return;
      const row = buildRow(f);
      logWrap.appendChild(row);
      updateEmptyState();
      if (autoScroll) logWrap.scrollTop = logWrap.scrollHeight;
    }
    function repaint(_full = false) {
      logWrap.querySelectorAll(".ws-row").forEach((n) => n.remove());
      frames.toArray().forEach((f) => {
        if (passesFilters(f)) logWrap.appendChild(buildRow(f));
      });
      updateEmptyState();
      if (selectedId != null) setSelectedRow(selectedId);
      if (autoScroll) logWrap.scrollTop = logWrap.scrollHeight;
    }
    function copyVisible() {
      const lines = frames.toArray().filter((f) => passesFilters(f)).map((f) => `[${fmtTime(f.t)}] ${f.dir === "in" ? "<-" : "->"} ${f.text}`).join("\n");
      copy(lines);
    }
    function replayFrame(f) {
      const target = replayToSource && f.ws ? f.ws : currentWS();
      if (!target || target.readyState !== WebSocket.OPEN) return;
      const mode = asJson.querySelector('input[type="radio"]:checked')?.value || "text";
      if (mode === "json") {
        try {
          target.send(JSON.parse(f.text));
        } catch {
          target.send(f.text);
        }
      } else {
        target.send(f.text);
      }
    }
    function doSend() {
      const ws = currentWS();
      const wsAlt = selectedId != null && replayToSource ? framesMap.get(selectedId)?.ws ?? null : null;
      const target = (replayToSource ? wsAlt : ws) || ws;
      if (!target || target.readyState !== WebSocket.OPEN) return;
      const mode = asJson.querySelector('input[type="radio"]:checked')?.value || "text";
      if (mode === "json") {
        try {
          target.send(JSON.parse(ta.value));
        } catch {
          target.send(ta.value);
        }
      } else {
        target.send(ta.value);
      }
    }
    installWSHookIfNeeded((f) => {
      if (paused) return;
      const ex = { ...f, id: ++seq };
      frames.push(ex);
      framesMap.set(ex.id, ex);
      updateStatus();
      appendOne(ex);
    });
    refreshSocketPicker();
    repaint(true);
    const pollId = window.setInterval(() => {
      refreshSocketPicker();
    }, 1e3);
    view.__ws_cleanup__ = () => {
      window.clearInterval(pollId);
    };
  }

  // src/ui/menus/debug-data.ts
  var stylesInjected = false;
  function ensureStyles2() {
    if (stylesInjected) return;
    stylesInjected = true;
    const style2 = document.createElement("style");
    style2.id = "mg-debug-data-styles";
    style2.textContent = `
  .dd-debug-view{display:flex;flex-direction:column;gap:16px;}
  .dd-debug-columns{display:grid;gap:16px;grid-template-columns:repeat(2,minmax(320px,1fr));align-items:start;}
  @media (max-width:720px){.dd-debug-columns{grid-template-columns:minmax(0,1fr);}}
  .dd-debug-column{display:flex;flex-direction:column;gap:16px;min-width:0;}
  .dd-card-description{font-size:13px;opacity:.72;margin:0;}
  .dd-atom-list{display:flex;flex-direction:column;gap:4px;margin-top:8px;max-height:40vh;overflow:auto;padding-right:4px;}
  .dd-atom-list__item{display:flex;align-items:center;gap:8px;font-size:13px;padding:4px 6px;border-radius:8px;border:1px solid transparent;cursor:pointer;transition:background .12s ease,border-color .12s ease;}
  .dd-atom-list__item:hover{background:rgba(255,255,255,.06);border-color:rgba(255,255,255,.1);}
  .dd-atom-list__checkbox{accent-color:#5c7eff;}
  .dd-atom-list__label{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
  .dd-status-chip{display:inline-flex;align-items:center;gap:6px;padding:4px 12px;border-radius:999px;font-size:12px;font-weight:600;letter-spacing:.01em;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.14);color:#f5f7ff;}
  .dd-status-chip.is-ok{color:#49d389;background:rgba(73,211,137,.14);border-color:rgba(73,211,137,.32);}
  .dd-status-chip.is-warn{color:#ffb760;background:rgba(255,183,96,.12);border-color:rgba(255,183,96,.32);}
  .dd-toolbar{display:flex;flex-wrap:wrap;gap:10px;align-items:center;}
  .dd-toolbar--stretch{width:100%;}
  .dd-toolbar .qmm-input{min-width:160px;}
  .dd-toolbar .dd-grow{flex:1 1 220px;min-width:180px;}
  .dd-mute-chips{display:flex;flex-wrap:wrap;gap:6px;}
  .dd-log{position:relative;border:1px solid #ffffff18;border-radius:16px;background:#0b1016;padding:10px;max-height:48vh;overflow:auto;box-shadow:inset 0 1px 0 rgba(255,255,255,.04);}
  .dd-log__empty{padding:28px 12px;text-align:center;font-size:13px;opacity:.6;}
  .dd-log .ws-row{position:relative;display:grid;grid-template-columns:96px 20px minmax(0,1fr);gap:10px;padding:8px 12px;border-radius:12px;border:1px solid transparent;transition:background .15s ease,border-color .15s ease;align-items:start;margin:2px 0;}
  .dd-log .ws-row .ts{opacity:.76;font-size:12px;}
  .dd-log .ws-row .arrow{font-weight:600;}
  .dd-log .ws-row .body{white-space:pre-wrap;word-break:break-word;}
  .dd-log .ws-row .body code{font-family:inherit;font-size:12px;color:#dbe4ff;}
  .dd-log .ws-row .acts{position:absolute;top:6px;right:8px;display:flex;gap:6px;padding:4px 6px;background:rgba(13,18,25,.94);border:1px solid rgba(255,255,255,.18);border-radius:8px;opacity:0;visibility:hidden;transition:opacity .12s ease;z-index:1;}
  .dd-log .ws-row .acts .qmm-btn{padding:2px 6px;font-size:11px;}
  .dd-log .ws-row:hover .acts{opacity:1;visibility:visible;}
  .dd-log .ws-row:hover{background:rgba(255,255,255,.05);border-color:rgba(255,255,255,.18);}
  .dd-log .ws-row.selected{background:rgba(92,126,255,.16);border-color:rgba(92,126,255,.42);}
  .dd-send-controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;}
  .dd-send-controls .qmm-radio-group{display:flex;gap:10px;}
  .dd-textarea{min-height:140px;}
  .dd-inline-note{font-size:12px;opacity:.7;}
  .dd-log-filter-group{display:flex;flex-wrap:wrap;gap:6px;align-items:center;}
  .dd-script-log{position:relative;border:1px solid #ffffff18;border-radius:16px;background:#0b1016;max-height:48vh;overflow:auto;box-shadow:inset 0 1px 0 rgba(255,255,255,.04);}
  .dd-script-log__empty{padding:28px 12px;text-align:center;font-size:13px;opacity:.6;}
  .dd-script-log__row{display:grid;grid-template-columns:minmax(92px,96px) minmax(70px,90px) minmax(120px,160px) minmax(0,1fr);gap:12px;padding:12px 16px;border-bottom:1px solid rgba(255,255,255,.06);align-items:start;}
  .dd-script-log__row:last-child{border-bottom:none;}
  .dd-script-log__ts{font-size:12px;opacity:.7;font-family:var(--qmm-font-mono,monospace);}
  .dd-script-log__level{display:inline-flex;align-items:center;justify-content:center;padding:2px 8px;border-radius:999px;font-size:11px;font-weight:600;letter-spacing:.03em;text-transform:uppercase;min-width:58px;}
  .dd-script-log__level.is-debug{background:rgba(138,180,255,.14);color:#8ab4ff;border:1px solid rgba(138,180,255,.32);}
  .dd-script-log__level.is-info{background:rgba(92,126,255,.14);color:#9fb6ff;border:1px solid rgba(92,126,255,.32);}
  .dd-script-log__level.is-warn{background:rgba(255,183,96,.12);color:#ffb760;border:1px solid rgba(255,183,96,.32);}
  .dd-script-log__level.is-error{background:rgba(255,108,132,.16);color:#ff6c84;border:1px solid rgba(255,108,132,.32);}
  .dd-script-log__source{font-size:12px;font-weight:600;opacity:.85;}
  .dd-script-log__context{display:block;font-size:11px;opacity:.6;margin-top:2px;text-transform:uppercase;letter-spacing:.05em;}
  .dd-script-log__message-wrap{display:flex;flex-direction:column;gap:6px;}
  .dd-script-log__message{font-size:13px;line-height:1.45;white-space:pre-wrap;word-break:break-word;}
  .dd-script-log__actions{display:flex;gap:6px;justify-content:flex-end;align-self:flex-end;}
  .dd-script-log__actions button{padding:2px 8px;font-size:11px;border-radius:8px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.04);color:inherit;cursor:pointer;transition:background .12s ease,border-color .12s ease;}
  .dd-script-log__actions button:hover{background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.28);}
  .dd-script-log__details{grid-column:1/-1;margin:4px 0 0;background:#05080c;border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:10px;white-space:pre-wrap;font-family:var(--qmm-font-mono,monospace);font-size:12px;line-height:1.4;display:none;word-break:break-word;max-height:180px;overflow:auto;}
  .dd-script-log__row.is-open .dd-script-log__details{display:block;}
  .dd-log-source-chips{display:flex;flex-wrap:wrap;gap:6px;}
  .dd-log-toolbar-spacer{flex:1 1 auto;}
  .dd-audio-summary{display:grid;gap:4px;font-size:13px;}
  .dd-audio-summary strong{font-size:14px;}
  .dd-audio-volume{font-family:var(--qmm-font-mono,monospace);font-size:12px;opacity:.78;}
  .dd-audio-list{display:flex;flex-direction:column;gap:8px;margin-top:4px;max-height:48vh;overflow:auto;padding-right:4px;}
  .dd-audio-row{display:flex;flex-wrap:wrap;gap:12px;align-items:flex-start;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.08);background:rgba(9,12,18,.72);}
  .dd-audio-row__info{flex:1 1 260px;min-width:0;display:flex;flex-direction:column;gap:6px;}
  .dd-audio-row__title{font-weight:600;font-size:13px;word-break:break-word;}
  .dd-audio-meta{font-size:12px;opacity:.72;display:flex;flex-wrap:wrap;gap:8px;}
  .dd-audio-url{font-family:var(--qmm-font-mono,monospace);font-size:11px;word-break:break-all;color:#d6dcffb3;}
  .dd-audio-actions{display:flex;gap:6px;flex-wrap:wrap;margin-left:auto;}
  .dd-audio-empty{padding:24px 12px;text-align:center;font-size:13px;opacity:.6;}
  .dd-sprite-controls{display:flex;flex-direction:column;gap:12px;}
  .dd-sprite-control-grid{display:grid;gap:10px;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));}
  .dd-sprite-control{display:flex;flex-direction:column;gap:4px;}
  .dd-sprite-control__label{font-size:11px;opacity:.72;text-transform:uppercase;letter-spacing:.08em;}
  .dd-sprite-control.is-hidden{display:none;}
  .dd-sprite-control .qmm-select{width:100%;}
  .dd-sprite-stats{font-size:12px;opacity:.72;margin-top:8px;}
  .dd-sprite-grid{display:grid;gap:12px;border-radius:12px;border:1px solid rgba(255,255,255,.08);padding:12px;background:rgba(6,8,12,.8);max-height:62vh;min-height:360px;overflow:auto;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));}
  .dd-sprite-grid--tiles{grid-template-columns:repeat(3,minmax(0,1fr));}
  .dd-sprite-grid__item{display:flex;flex-direction:column;gap:6px;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.05);background:rgba(255,255,255,.02);text-decoration:none;color:inherit;transition:background .12s ease,border-color .12s ease,transform .12s ease;}
  .dd-sprite-grid__item:hover{background:rgba(255,255,255,.04);border-color:rgba(255,255,255,.16);transform:translateY(-1px);}
  .dd-sprite-grid__item:focus-visible{outline:2px solid rgba(92,126,255,.5);}
  .dd-sprite-grid__img{width:100%;height:120px;object-fit:contain;background:#020407;border-radius:8px;border:1px solid rgba(255,255,255,.08);image-rendering:pixelated;}
  .dd-sprite-grid__name{font-weight:600;font-size:13px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
  .dd-sprite-grid__meta{font-size:11px;opacity:.65;font-family:var(--qmm-font-mono,monospace);word-break:break-word;}
  .dd-sprite-grid__empty{text-align:center;font-size:13px;opacity:.65;padding:20px 0;}
  .dd-sprite-filter-panel{margin-top:16px;display:flex;flex-direction:column;gap:8px;}
  .dd-sprite-filter-row{display:flex;gap:6px;align-items:center;flex-wrap:wrap;}
  .dd-sprite-filter-row .dd-sprite-filter-label{font-size:11px;text-transform:uppercase;letter-spacing:0.1em;opacity:0.6;}
  .dd-sprite-segmented{display:flex;gap:4px;flex-wrap:wrap;}
  .dd-sprite-seg-btn{background:#111418;border:1px solid #29303a;border-radius:8px;padding:4px 10px;font-size:12px;color:#d2ddff;cursor:pointer;transition:background .12s ease,border .12s ease;}
  .dd-sprite-seg-btn.is-active{background:#3d58ff;border-color:#5d7cff;color:#fff;}
  .dd-sprite-export-progress{height:4px;width:100%;border-radius:999px;background:rgba(255,255,255,.06);overflow:hidden;transition:opacity .2s ease;opacity:0;}
  .dd-sprite-export-progress__bar{height:100%;width:0;background:linear-gradient(90deg,#44ffa4,#2ea3ff 35%,#ff7b9a);transition:width .25s ease;}
  `;
    document.head.appendChild(style2);
  }
  async function renderDebugDataMenu(root) {
    ensureStyles2();
    const ui = new Menu({ id: "debug-tools", compact: true });
    ui.mount(root);
    ui.addTab("jotai", "Jotai", (view) => renderJotaiTab(view, ui));
    ui.addTab("atoms-live", "Live atoms", (view) => renderLiveAtomsTab(view, ui));
    ui.addTab("sprites", "Sprites", (view) => renderSpritesTab(view, ui));
    ui.addTab("audio-player", "Audio player", (view) => renderAudioPlayerTab(view, ui));
    ui.addTab("websocket", "WebSocket", (view) => renderWSTab(view, ui));
  }

  // src/ui/menus/locker.ts
  var NO_WEATHER_TAG = "NoWeatherEffect";
  var SEED_EMOJIS = [
    "\u{1F955}",
    "\u{1F353}",
    "\u{1F343}",
    "\u{1F535}",
    "\u{1F34E}",
    "\u{1F337}",
    "\u{1F345}",
    "\u{1F33C}",
    "\u{1F33D}",
    "\u{1F349}",
    "\u{1F383}",
    "\u{1F33F}",
    "\u{1F965}",
    "\u{1F34C}",
    "\u{1F338}",
    "\u{1F7E2}",
    "\u{1F344}",
    "\u{1F335}",
    "\u{1F38D}",
    "\u{1F347}",
    "\u{1F336}\uFE0F",
    "\u{1F34B}",
    "\u{1F96D}",
    "\u{1F409}",
    "\u{1F352}",
    "\u{1F33B}",
    "\u2728",
    "\u{1F506}",
    "\u{1F52E}"
  ];
  var lockerSeedOptions = Object.entries(
    plantCatalog
  ).map(([key2, def]) => ({
    key: key2,
    seedName: def?.seed?.name ?? "",
    cropName: def?.crop?.name ?? ""
  }));
  var lockerSeedEmojiByKey = /* @__PURE__ */ new Map();
  var lockerSeedEmojiBySeedName = /* @__PURE__ */ new Map();
  lockerSeedOptions.forEach((opt, index) => {
    const emoji = SEED_EMOJIS[index % SEED_EMOJIS.length];
    lockerSeedEmojiByKey.set(opt.key, emoji);
    if (opt.seedName) {
      lockerSeedEmojiBySeedName.set(opt.seedName, emoji);
    }
  });
  var getLockerSeedOptions = () => lockerSeedOptions;
  var getLockerSeedEmojiForKey = (key2) => {
    if (!key2) return void 0;
    return lockerSeedEmojiByKey.get(key2) ?? "\u2022";
  };
  var getLockerSeedEmojiForSeedName = (name) => {
    if (!name) return void 0;
    return lockerSeedEmojiBySeedName.get(name) ?? "\u2022";
  };
  function formatMutationLabel(key2) {
    const spaced = key2.replace(/_/g, " ").replace(/([a-z0-9])([A-Z])/g, "$1 $2").replace(/\s+/g, " ").trim();
    if (!spaced) return key2;
    return spaced.charAt(0).toUpperCase() + spaced.slice(1);
  }
  var WEATHER_MUTATION_LABELS = tileRefsMutationLabels ?? {};
  var WEATHER_MUTATIONS = Object.entries(
    tileRefsMutations
  ).filter((entry) => {
    const [key2, value] = entry;
    if (key2 === "Puddle") {
      return false;
    }
    return typeof value === "number" && Number.isFinite(value);
  }).map(([key2, value]) => ({
    key: key2,
    label: WEATHER_MUTATION_LABELS[key2] ?? formatMutationLabel(key2),
    tileRef: value
  }));
  var createNoWeatherIcon = (options) => {
    const size = Math.max(24, options?.size ?? 48);
    const wrap = applyStyles(document.createElement("div"), {
      width: `${size}px`,
      height: `${size}px`,
      display: "grid",
      placeItems: "center"
    });
    const glyph = applyStyles(document.createElement("span"), {
      color: "#ff5c5c",
      fontSize: `${Math.round(size * 0.65)}px`,
      fontWeight: "700",
      textShadow: "0 1px 2px rgba(0, 0, 0, 0.6)",
      lineHeight: "1"
    });
    glyph.textContent = "\u2716";
    wrap.appendChild(glyph);
    return wrap;
  };
  WEATHER_MUTATIONS.unshift({
    key: NO_WEATHER_TAG,
    label: "No weather effect",
    tileRef: null,
    iconFactory: createNoWeatherIcon
  });
  var isWeatherMutationAvailable = (tag) => WEATHER_MUTATIONS.some((info) => info.key === tag);
  var WEATHER_RECIPE_GROUPS = {
    Wet: "condition",
    Chilled: "condition",
    Frozen: "condition",
    Dawnlit: "lighting",
    Amberlit: "lighting",
    Dawncharged: "lighting",
    Ambercharged: "lighting"
  };
  var WEATHER_RECIPE_GROUP_MEMBERS = {
    condition: ["Wet", "Chilled", "Frozen"],
    lighting: ["Dawnlit", "Amberlit", "Dawncharged", "Ambercharged"]
  };
  function normalizeWeatherSelection(selection) {
    selection.forEach((tag) => {
      if (!isWeatherMutationAvailable(tag)) {
        selection.delete(tag);
      }
    });
  }
  function normalizeRecipeSelection(selection) {
    normalizeWeatherSelection(selection);
    const seen = /* @__PURE__ */ new Set();
    WEATHER_MUTATIONS.forEach((info) => {
      if (!selection.has(info.key)) return;
      const group = WEATHER_RECIPE_GROUPS[info.key];
      if (!group) return;
      if (seen.has(group)) {
        selection.delete(info.key);
      } else {
        seen.add(group);
      }
    });
  }
  var applyStyles = (el2, styles) => {
    Object.entries(styles).forEach(([prop, value]) => {
      el2.style[prop] = value;
    });
    return el2;
  };
  var plantSpriteCache = /* @__PURE__ */ new Map();
  var plantSpritePromises = /* @__PURE__ */ new Map();
  var plantSpriteSubscribers = /* @__PURE__ */ new Map();
  var spriteConfig2 = /* @__PURE__ */ new WeakMap();
  var plantSpriteListenerAttached = false;
  var lockerSpritesPreloaded = false;
  var lockerSpritesLoading = false;
  var lockerSpritePreloadTimer = null;
  var weatherModeNameSeq = 0;
  function hasLockerSpriteSources() {
    try {
      if (Sprites.listPlants().length || Sprites.listAllPlants().length) {
        return true;
      }
    } catch {
    }
    try {
      if (Sprites.listTilesByCategory(/mutations/i).length) {
        return true;
      }
    } catch {
    }
    return false;
  }
  function scheduleLockerSpritePreload(delay4 = 0) {
    if (lockerSpritesPreloaded || typeof window === "undefined") {
      return;
    }
    if (lockerSpritePreloadTimer != null) {
      window.clearTimeout(lockerSpritePreloadTimer);
    }
    lockerSpritePreloadTimer = window.setTimeout(() => {
      lockerSpritePreloadTimer = null;
      preloadLockerSprites();
    }, Math.max(0, delay4));
  }
  function ensurePlantSpriteListener() {
    if (plantSpriteListenerAttached) return;
    plantSpriteListenerAttached = true;
    window.addEventListener("mg:sprite-detected", () => {
      plantSpriteCache.clear();
      plantSpritePromises.clear();
      const keys = Array.from(plantSpriteSubscribers.keys());
      keys.forEach((key2) => {
        loadPlantSprite(key2);
      });
    });
  }
  function subscribePlantSprite(seedKey, el2, config) {
    let subs = plantSpriteSubscribers.get(seedKey);
    if (!subs) {
      subs = /* @__PURE__ */ new Set();
      plantSpriteSubscribers.set(seedKey, subs);
    }
    subs.add(el2);
    spriteConfig2.set(el2, config);
  }
  function notifyPlantSpriteSubscribers(seedKey, src) {
    const subs = plantSpriteSubscribers.get(seedKey);
    if (!subs) return;
    subs.forEach((el2) => {
      if (!el2.isConnected) {
        subs.delete(el2);
        spriteConfig2.delete(el2);
        return;
      }
      applySprite2(el2, src);
    });
    if (subs.size === 0) {
      plantSpriteSubscribers.delete(seedKey);
    }
  }
  var TALL_PLANT_SEEDS = /* @__PURE__ */ new Set(["Bamboo", "Cactus"]);
  function plantSheetBases(seedKey) {
    const urls = /* @__PURE__ */ new Set();
    try {
      Sprites.listPlants().forEach((url) => urls.add(url));
    } catch {
    }
    try {
      Sprites.listAllPlants().forEach((url) => urls.add(url));
    } catch {
    }
    const bases = Array.from(urls, (url) => {
      const clean = url.split(/[?#]/)[0] ?? url;
      const file = clean.split("/").pop() ?? clean;
      return file.replace(/\.[^.]+$/, "");
    });
    if (!seedKey) return bases;
    const normalizedBases = bases.map((base) => base.toLowerCase());
    const findPreferred = (predicate) => bases.filter((base, index) => predicate(base, normalizedBases[index] ?? base.toLowerCase()));
    if (TALL_PLANT_SEEDS.has(seedKey)) {
      const tallExact = findPreferred((_, norm3) => norm3 === "tallplants");
      if (tallExact.length) return tallExact;
      const tallAny = findPreferred((base, norm3) => /tall/.test(base) || /tall/.test(norm3));
      if (tallAny.length) return tallAny;
    } else {
      const plantsExact = findPreferred((_, norm3) => norm3 === "plants");
      if (plantsExact.length) return plantsExact;
      const nonTall = findPreferred((base, norm3) => !/tall/.test(base) && !/tall/.test(norm3));
      if (nonTall.length) return nonTall;
    }
    return bases;
  }
  function toTileIndex2(tileRef, bases = []) {
    const value = typeof tileRef === "number" && Number.isFinite(tileRef) ? tileRef : Number(tileRef);
    if (!Number.isFinite(value)) return null;
    if (value <= 0) return value;
    const normalizedBases = bases.map((base) => base.toLowerCase());
    if (normalizedBases.some((base) => base.includes("tall"))) {
      return value - 1;
    }
    if (normalizedBases.some((base) => base.includes("plants"))) {
      return value - 1;
    }
    return value - 1;
  }
  async function fetchPlantSprite(seedKey) {
    await ensureSpritesReady();
    const entry = plantCatalog[seedKey];
    if (!entry) return null;
    const tileRef = entry?.crop?.tileRef ?? entry?.plant?.tileRef ?? entry?.seed?.tileRef;
    const bases = plantSheetBases(seedKey);
    const index = toTileIndex2(tileRef, bases);
    if (index == null) return null;
    for (const base of bases) {
      try {
        const tiles = await loadTileSheet(base);
        const tile = tiles.find((t) => t.index === index);
        if (!tile) continue;
        const canvas = Sprites.toCanvas(tile);
        if (canvas && canvas.width > 0 && canvas.height > 0) {
          const copy2 = document.createElement("canvas");
          copy2.width = canvas.width;
          copy2.height = canvas.height;
          const ctx = copy2.getContext("2d");
          if (!ctx) continue;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(canvas, 0, 0);
          return copy2.toDataURL();
        }
      } catch {
      }
    }
    return null;
  }
  function applySprite2(el2, src) {
    const cfg = spriteConfig2.get(el2);
    if (!cfg) return;
    const { size, fallback } = cfg;
    el2.innerHTML = "";
    el2.style.display = "inline-flex";
    el2.style.alignItems = "center";
    el2.style.justifyContent = "center";
    el2.style.width = `${size}px`;
    el2.style.height = `${size}px`;
    el2.style.flexShrink = "0";
    el2.style.position = "relative";
    if (src) {
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";
      img.decoding = "async";
      img.loading = "lazy";
      img.draggable = false;
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "contain";
      img.style.imageRendering = "pixelated";
      el2.appendChild(img);
    } else {
      el2.textContent = fallback;
      el2.style.fontSize = `${Math.max(10, Math.round(size * 0.8))}px`;
    }
  }
  function loadPlantSprite(seedKey) {
    const cached = plantSpriteCache.get(seedKey);
    if (cached !== void 0) {
      notifyPlantSpriteSubscribers(seedKey, cached);
      return Promise.resolve(cached);
    }
    const inflight = plantSpritePromises.get(seedKey);
    if (inflight) return inflight;
    const promise = fetchPlantSprite(seedKey).then((src) => {
      plantSpriteCache.set(seedKey, src);
      plantSpritePromises.delete(seedKey);
      notifyPlantSpriteSubscribers(seedKey, src);
      return src;
    }).catch(() => {
      plantSpritePromises.delete(seedKey);
      return null;
    });
    plantSpritePromises.set(seedKey, promise);
    return promise;
  }
  function createPlantSprite(seedKey, options = {}) {
    ensurePlantSpriteListener();
    const size = Math.max(12, options.size ?? 24);
    const fallback = options.fallback ?? "\u{1F331}";
    const el2 = document.createElement("span");
    subscribePlantSprite(seedKey, el2, { size, fallback });
    const cached = plantSpriteCache.get(seedKey);
    applySprite2(el2, cached ?? null);
    loadPlantSprite(seedKey);
    return el2;
  }
  var mutationSpriteCache = /* @__PURE__ */ new Map();
  var mutationSpritePromises = /* @__PURE__ */ new Map();
  var mutationSpriteSubscribers = /* @__PURE__ */ new Map();
  var mutationSpriteListenerAttached = false;
  var mutationSpriteBases = null;
  function ensureMutationSpriteListener() {
    if (mutationSpriteListenerAttached) return;
    mutationSpriteListenerAttached = true;
    window.addEventListener("mg:sprite-detected", () => {
      mutationSpriteCache.clear();
      mutationSpritePromises.clear();
      mutationSpriteBases = null;
      const keys = Array.from(mutationSpriteSubscribers.keys());
      keys.forEach((key2) => {
        loadMutationSprite(key2);
      });
    });
  }
  function mutationSheetBases() {
    if (mutationSpriteBases) return mutationSpriteBases;
    const urls = /* @__PURE__ */ new Set();
    try {
      Sprites.listTilesByCategory(/mutations/i).forEach((url) => urls.add(url));
    } catch {
    }
    const bases = Array.from(urls, (url) => {
      const clean = url.split(/[?#]/)[0] ?? url;
      const file = clean.split("/").pop() ?? clean;
      return file.replace(/\.[^.]+$/, "");
    });
    if (!bases.length) {
      bases.push("mutations");
    }
    mutationSpriteBases = bases;
    return mutationSpriteBases;
  }
  function subscribeMutationSprite(tag, el2, config) {
    let subs = mutationSpriteSubscribers.get(tag);
    if (!subs) {
      subs = /* @__PURE__ */ new Set();
      mutationSpriteSubscribers.set(tag, subs);
    }
    subs.add(el2);
    spriteConfig2.set(el2, config);
  }
  function notifyMutationSpriteSubscribers(tag, src) {
    const subs = mutationSpriteSubscribers.get(tag);
    if (!subs) return;
    subs.forEach((el2) => {
      if (!el2.isConnected) {
        subs.delete(el2);
        spriteConfig2.delete(el2);
        return;
      }
      applySprite2(el2, src);
    });
    if (subs.size === 0) {
      mutationSpriteSubscribers.delete(tag);
    }
  }
  async function fetchMutationSprite(tag) {
    await ensureSpritesReady();
    const entry = WEATHER_MUTATIONS.find((info) => info.key === tag);
    if (!entry || entry.tileRef == null) return null;
    const [base] = mutationSheetBases();
    const index = toTileIndex2(entry.tileRef, base ? [base] : []);
    if (index == null || !base) return null;
    try {
      const tiles = await loadTileSheet(base);
      const tile = tiles.find((t) => t.index === index);
      if (!tile) return null;
      const canvas = Sprites.toCanvas(tile);
      if (canvas && canvas.width > 0 && canvas.height > 0) {
        const copy2 = document.createElement("canvas");
        copy2.width = canvas.width;
        copy2.height = canvas.height;
        const ctx = copy2.getContext("2d");
        if (!ctx) return null;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(canvas, 0, 0);
        return copy2.toDataURL();
      }
    } catch {
    }
    return null;
  }
  function loadMutationSprite(tag) {
    const cached = mutationSpriteCache.get(tag);
    if (cached !== void 0) {
      notifyMutationSpriteSubscribers(tag, cached);
      return Promise.resolve(cached);
    }
    const inflight = mutationSpritePromises.get(tag);
    if (inflight) return inflight;
    const promise = fetchMutationSprite(tag).then((src) => {
      mutationSpriteCache.set(tag, src);
      mutationSpritePromises.delete(tag);
      notifyMutationSpriteSubscribers(tag, src);
      return src;
    }).catch(() => {
      mutationSpritePromises.delete(tag);
      return null;
    });
    mutationSpritePromises.set(tag, promise);
    return promise;
  }
  function createMutationSprite(tag, options = {}) {
    ensureMutationSpriteListener();
    const size = Math.max(12, options.size ?? 36);
    const fallback = options.fallback ?? "?";
    const el2 = document.createElement("span");
    subscribeMutationSprite(tag, el2, { size, fallback });
    const cached = mutationSpriteCache.get(tag);
    applySprite2(el2, cached ?? null);
    loadMutationSprite(tag);
    return el2;
  }
  function preloadLockerSprites() {
    if (lockerSpritesPreloaded || lockerSpritesLoading || typeof window === "undefined") {
      return;
    }
    lockerSpritesLoading = true;
    (async () => {
      try {
        await ensureSpritesReady();
        if (!hasLockerSpriteSources()) {
          scheduleLockerSpritePreload(200);
          return;
        }
        lockerSpritesPreloaded = true;
        ensurePlantSpriteListener();
        ensureMutationSpriteListener();
        try {
          const catalog = plantCatalog;
          Object.keys(catalog).forEach((seedKey) => {
            if (seedKey) {
              loadPlantSprite(seedKey);
            }
          });
        } catch {
        }
        WEATHER_MUTATIONS.forEach((info) => {
          if (info.tileRef != null) {
            loadMutationSprite(info.key);
          }
        });
      } finally {
        lockerSpritesLoading = false;
      }
    })().catch((error) => {
      console.warn("[LockerSprites]", "preload failed", error);
      scheduleLockerSpritePreload(500);
    });
  }
  if (typeof window !== "undefined") {
    scheduleLockerSpritePreload();
    window.addEventListener("mg:sprite-detected", () => {
      if (!lockerSpritesPreloaded) {
        scheduleLockerSpritePreload(100);
      }
    });
  }
  function createDefaultSettings() {
    return {
      minScalePct: 50,
      maxScalePct: 100,
      scaleLockMode: "RANGE",
      lockMode: "LOCK",
      minInventory: 91,
      avoidNormal: false,
      visualMutations: /* @__PURE__ */ new Set(),
      weatherMode: "ANY",
      weatherSelected: /* @__PURE__ */ new Set(),
      weatherRecipes: []
    };
  }
  function copySettings(target, source) {
    target.minScalePct = source.minScalePct;
    target.maxScalePct = source.maxScalePct;
    target.scaleLockMode = source.scaleLockMode;
    target.lockMode = source.lockMode;
    target.minInventory = source.minInventory;
    target.avoidNormal = source.avoidNormal;
    target.visualMutations.clear();
    source.visualMutations.forEach((v) => target.visualMutations.add(v));
    target.weatherMode = source.weatherMode;
    target.weatherSelected.clear();
    source.weatherSelected.forEach((v) => target.weatherSelected.add(v));
    target.weatherRecipes.length = 0;
    source.weatherRecipes.forEach((set2) => target.weatherRecipes.push(new Set(set2)));
  }
  function hydrateSettingsFromPersisted(target, persisted) {
    const src = persisted ?? {};
    const mode = src.scaleLockMode === "MINIMUM" ? "MINIMUM" : src.scaleLockMode === "MAXIMUM" ? "MAXIMUM" : src.scaleLockMode === "NONE" ? "NONE" : "RANGE";
    let minScale = Math.max(50, Math.min(100, Math.round(src.minScalePct ?? 50)));
    let maxScale = Math.max(50, Math.min(100, Math.round(src.maxScalePct ?? 100)));
    if (mode === "RANGE") {
      maxScale = Math.max(51, Math.min(100, maxScale));
      if (maxScale <= minScale) {
        if (minScale >= 99) {
          minScale = 99;
          maxScale = 100;
        } else {
          maxScale = Math.min(100, Math.max(51, minScale + 1));
        }
      }
    } else if (mode === "MINIMUM") {
      minScale = Math.max(50, Math.min(100, minScale));
    } else if (mode === "MAXIMUM") {
      maxScale = Math.max(50, Math.min(100, maxScale));
    }
    target.minScalePct = minScale;
    target.maxScalePct = maxScale;
    target.scaleLockMode = mode;
    target.lockMode = src.lockMode === "ALLOW" ? "ALLOW" : "LOCK";
    target.minInventory = Math.max(0, Math.min(999, Math.round(src.minInventory ?? 91)));
    target.avoidNormal = src.avoidNormal === true || src.includeNormal === false;
    target.visualMutations.clear();
    (src.visualMutations ?? []).forEach((mut) => {
      if (mut === "Gold" || mut === "Rainbow") target.visualMutations.add(mut);
    });
    target.weatherMode = src.weatherMode === "ALL" || src.weatherMode === "RECIPES" ? src.weatherMode : "ANY";
    target.weatherSelected.clear();
    (src.weatherSelected ?? []).forEach((tag) => {
      const weatherTag = tag;
      if (isWeatherMutationAvailable(weatherTag)) {
        target.weatherSelected.add(weatherTag);
      }
    });
    target.weatherRecipes.length = 0;
    (src.weatherRecipes ?? []).forEach((recipe) => {
      const set2 = /* @__PURE__ */ new Set();
      if (Array.isArray(recipe)) {
        recipe.forEach((tag) => {
          const weatherTag = tag;
          if (isWeatherMutationAvailable(weatherTag)) {
            set2.add(weatherTag);
          }
        });
      }
      target.weatherRecipes.push(set2);
    });
  }
  function serializeSettingsState(state2) {
    normalizeWeatherSelection(state2.weatherSelected);
    state2.weatherRecipes.forEach((set2) => normalizeRecipeSelection(set2));
    const mode = state2.scaleLockMode === "MINIMUM" ? "MINIMUM" : state2.scaleLockMode === "MAXIMUM" ? "MAXIMUM" : state2.scaleLockMode === "NONE" ? "NONE" : "RANGE";
    let minScale = Math.max(50, Math.min(100, Math.round(state2.minScalePct || 50)));
    let maxScale = Math.max(50, Math.min(100, Math.round(state2.maxScalePct || 100)));
    if (mode === "RANGE") {
      maxScale = Math.max(51, Math.min(100, maxScale));
      if (maxScale <= minScale) {
        if (minScale >= 99) {
          minScale = 99;
          maxScale = 100;
        } else {
          maxScale = Math.min(100, Math.max(51, minScale + 1));
        }
      }
    } else if (mode === "MINIMUM") {
      minScale = Math.max(50, Math.min(100, minScale));
    } else if (mode === "MAXIMUM") {
      maxScale = Math.max(50, Math.min(100, maxScale));
    }
    return {
      minScalePct: minScale,
      maxScalePct: maxScale,
      scaleLockMode: mode,
      lockMode: state2.lockMode === "ALLOW" ? "ALLOW" : "LOCK",
      minInventory: Math.max(0, Math.min(999, Math.round(state2.minInventory || 91))),
      avoidNormal: !!state2.avoidNormal,
      includeNormal: !state2.avoidNormal,
      visualMutations: Array.from(state2.visualMutations),
      weatherMode: state2.weatherMode,
      weatherSelected: Array.from(state2.weatherSelected),
      weatherRecipes: state2.weatherRecipes.map((set2) => Array.from(set2))
    };
  }
  var LockerMenuStore = class {
    constructor(initial) {
      __publicField(this, "global");
      __publicField(this, "overrides", /* @__PURE__ */ new Map());
      __publicField(this, "listeners", /* @__PURE__ */ new Set());
      __publicField(this, "syncing", false);
      this.global = { enabled: false, settings: createDefaultSettings(), hasPersistedSettings: true };
      this.syncFromService(initial);
    }
    applyPersisted(state2) {
      this.global.enabled = !!state2.enabled;
      hydrateSettingsFromPersisted(this.global.settings, state2.settings);
      this.global.hasPersistedSettings = true;
      const seen = /* @__PURE__ */ new Set();
      Object.entries(state2.overrides ?? {}).forEach(([key2, value]) => {
        const entry = this.ensureOverride(key2, { silent: true });
        entry.enabled = !!value?.enabled;
        hydrateSettingsFromPersisted(entry.settings, value?.settings);
        entry.hasPersistedSettings = true;
        seen.add(key2);
      });
      for (const key2 of Array.from(this.overrides.keys())) {
        if (!seen.has(key2)) {
          this.overrides.delete(key2);
        }
      }
    }
    subscribe(listener) {
      this.listeners.add(listener);
      return () => this.listeners.delete(listener);
    }
    emit() {
      for (const listener of this.listeners) {
        try {
          listener();
        } catch {
        }
      }
    }
    syncFromService(state2) {
      this.syncing = true;
      this.applyPersisted(state2);
      this.emit();
      this.syncing = false;
    }
    setGlobalEnabled(enabled) {
      this.global.enabled = !!enabled;
      this.persistGlobal();
      this.emit();
    }
    notifyGlobalSettingsChanged() {
      this.persistGlobal();
      this.emit();
    }
    ensureOverride(key2, opts = {}) {
      let entry = this.overrides.get(key2);
      if (!entry) {
        entry = { enabled: false, settings: createDefaultSettings(), hasPersistedSettings: false };
        this.overrides.set(key2, entry);
        if (!opts.silent) {
          this.emit();
        }
      }
      return entry;
    }
    getOverride(key2) {
      return this.overrides.get(key2);
    }
    setOverrideEnabled(key2, enabled) {
      const entry = this.ensureOverride(key2, { silent: true });
      entry.enabled = !!enabled;
      this.persistOverride(key2);
      this.emit();
    }
    notifyOverrideSettingsChanged(key2) {
      const entry = this.overrides.get(key2);
      if (!entry) return;
      entry.hasPersistedSettings = true;
      this.persistOverride(key2);
      this.emit();
    }
    removeOverride(key2) {
      if (!this.overrides.has(key2)) return;
      this.overrides.delete(key2);
      if (!this.syncing) {
        lockerService.removeOverride(key2);
        lockerService.recomputeCurrentSlot();
      }
      this.emit();
    }
    persistGlobal() {
      if (this.syncing) return;
      lockerService.setGlobalState({
        enabled: this.global.enabled,
        settings: serializeSettingsState(this.global.settings)
      });
      lockerService.recomputeCurrentSlot();
    }
    persistOverride(key2) {
      if (this.syncing) return;
      const entry = this.overrides.get(key2);
      if (!entry) {
        lockerService.removeOverride(key2);
      } else {
        lockerService.setOverride(key2, {
          enabled: entry.enabled,
          settings: serializeSettingsState(entry.settings)
        });
        entry.hasPersistedSettings = true;
      }
      lockerService.recomputeCurrentSlot();
    }
  };
  function setCheck(input, value) {
    input.checked = !!value;
  }
  function createWeatherMutationToggle({
    key: key2,
    label: label2,
    spriteSize,
    dense,
    kind = "main",
    iconFactory
  }) {
    const isMain = kind === "main" && !dense;
    const gap = dense ? "3px" : isMain ? "3px" : "6px";
    const padding = dense ? "4px 6px" : isMain ? "6px 8px" : "10px 12px";
    const minWidth = dense ? "80px" : isMain ? "88px" : "120px";
    const wrapStyles = {
      position: "relative",
      display: "grid",
      justifyItems: "center",
      alignItems: "center",
      gap,
      padding,
      border: "1px solid #4445",
      borderRadius: "10px",
      background: "#0f1318",
      cursor: "pointer",
      minWidth,
      transition: "border-color 120ms ease, box-shadow 120ms ease, background 120ms ease",
      boxShadow: "0 0 0 1px #0002 inset"
    };
    if (isMain) {
      wrapStyles.width = "100%";
    }
    const wrap = applyStyles(document.createElement("label"), wrapStyles);
    wrap.title = "Active filters influence harvest conditions";
    const input = document.createElement("input");
    input.type = "checkbox";
    applyStyles(input, {
      position: "absolute",
      inset: "0",
      opacity: "0",
      pointerEvents: "none",
      margin: "0"
    });
    input.dataset.weatherToggle = kind;
    wrap.appendChild(input);
    wrap.dataset.weatherToggle = kind;
    const iconSize = Math.max(24, spriteSize ?? (dense ? 36 : isMain ? 52 : 72));
    const icon = iconFactory ? iconFactory({ size: iconSize, fallback: label2.charAt(0) || "?" }) : createMutationSprite(key2, {
      size: iconSize,
      fallback: label2.charAt(0) || "?"
    });
    applyStyles(icon, {
      filter: "drop-shadow(0 1px 1px rgba(0, 0, 0, 0.45))"
    });
    wrap.appendChild(icon);
    const caption = applyStyles(document.createElement("div"), {
      fontSize: dense ? "11px" : "11.5px",
      fontWeight: dense ? "500" : "600",
      opacity: "0.85",
      textAlign: "center"
    });
    caption.textContent = label2;
    wrap.appendChild(caption);
    const applyDisabledState = () => {
      if (input.disabled) {
        wrap.style.cursor = "default";
        wrap.style.opacity = "0.55";
        wrap.style.pointerEvents = "none";
      } else {
        wrap.style.cursor = "pointer";
        wrap.style.opacity = "";
        wrap.style.pointerEvents = "";
      }
    };
    const updateState = () => {
      if (input.checked) {
        applyStyles(wrap, {
          borderColor: "#6aa6",
          boxShadow: "0 0 0 1px #6aa4 inset, 0 2px 6px rgba(0, 0, 0, 0.45)",
          background: "#182029"
        });
      } else {
        applyStyles(wrap, {
          borderColor: "#4445",
          boxShadow: "0 0 0 1px #0002 inset",
          background: "#0f1318"
        });
      }
      applyDisabledState();
    };
    const setChecked = (value) => {
      setCheck(input, value);
      updateState();
    };
    const setDisabled = (value) => {
      input.disabled = !!value;
      updateState();
    };
    input.addEventListener("change", updateState);
    input.addEventListener("mg-weather-toggle-refresh", updateState);
    updateState();
    return { key: key2, wrap, input, setChecked, setDisabled };
  }
  function styleBtnFullWidth(button, text) {
    button.textContent = text;
    button.style.flex = "1";
    button.style.margin = "0";
    button.style.padding = "6px 10px";
    button.style.borderRadius = "8px";
    button.style.border = "1px solid #4445";
    button.style.background = "#1f2328";
    button.style.color = "#e7eef7";
    button.style.justifyContent = "center";
    button.onmouseenter = () => button.style.borderColor = "#6aa1";
    button.onmouseleave = () => button.style.borderColor = "#4445";
  }
  function styleBtnCompact(button, text) {
    button.textContent = text;
    button.style.margin = "0";
    button.style.padding = "4px 8px";
    button.style.borderRadius = "8px";
    button.style.border = "1px solid #4445";
    button.style.background = "#1f2328";
    button.style.color = "#e7eef7";
    button.style.display = "inline-flex";
    button.style.alignItems = "center";
    button.style.justifyContent = "center";
    button.style.minWidth = "36px";
    button.onmouseenter = () => button.style.borderColor = "#6aa1";
    button.onmouseleave = () => button.style.borderColor = "#4445";
  }
  function createLockerSettingsCard(ui, state2, opts = {}) {
    const card = document.createElement("div");
    card.dataset.lockerSettingsCard = "1";
    card.style.border = "1px solid #4445";
    card.style.borderRadius = "10px";
    card.style.padding = "12px";
    card.style.display = "flex";
    card.style.flexDirection = "column";
    card.style.gap = "12px";
    card.style.alignItems = "center";
    card.style.overflow = "auto";
    card.style.minHeight = "0";
    card.style.width = "min(760px, 100%)";
    let recipesTitleElement = null;
    const updateRecipeTitleText = () => {
      if (!recipesTitleElement) return;
      const prefix = state2.lockMode === "ALLOW" ? "Allow" : "Lock";
      recipesTitleElement.textContent = `${prefix} when any recipe row matches (OR between rows)`;
    };
    const makeSection = (titleText, content) => {
      const section = document.createElement("div");
      section.style.display = "grid";
      section.style.justifyItems = "center";
      section.style.gap = "8px";
      section.style.textAlign = "center";
      section.style.border = "1px solid #4446";
      section.style.borderRadius = "10px";
      section.style.padding = "10px";
      section.style.background = "#1f2328";
      section.style.boxShadow = "0 0 0 1px #0002 inset";
      section.style.width = "min(720px, 100%)";
      const heading = document.createElement("div");
      heading.textContent = titleText;
      heading.style.fontWeight = "600";
      heading.style.opacity = "0.95";
      section.append(heading, content);
      return section;
    };
    const centerRow = () => {
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.flexWrap = "wrap";
      row.style.justifyContent = "center";
      row.style.alignItems = "center";
      row.style.gap = "8px";
      return row;
    };
    const toLockMode = (value) => value === "allow" ? "ALLOW" : "LOCK";
    const fromLockMode = (mode) => mode === "ALLOW" ? "allow" : "lock";
    const lockModeRow = centerRow();
    lockModeRow.style.flexDirection = "column";
    lockModeRow.style.alignItems = "center";
    lockModeRow.style.gap = "10px";
    const lockModeHint = document.createElement("div");
    lockModeHint.style.fontSize = "12px";
    lockModeHint.style.opacity = "0.8";
    lockModeHint.style.textAlign = "center";
    let isProgrammaticLockMode = false;
    const lockModeSegmented = ui.segmented(
      [
        { value: "lock", label: "Lock" },
        { value: "allow", label: "Allow" }
      ],
      fromLockMode(state2.lockMode),
      (value) => {
        if (isProgrammaticLockMode) return;
        state2.lockMode = toLockMode(value);
        updateLockModeUI();
        opts.onChange?.();
      },
      { ariaLabel: "Harvest mode" }
    );
    lockModeRow.append(lockModeSegmented, lockModeHint);
    const updateLockModeUI = () => {
      const value = fromLockMode(state2.lockMode);
      const current = lockModeSegmented.get?.();
      if (current !== value) {
        isProgrammaticLockMode = true;
        try {
          lockModeSegmented.set?.(value);
        } finally {
          isProgrammaticLockMode = false;
        }
      }
      lockModeHint.textContent = value === "allow" ? "Harvest only when every active filter category matches" : "Harvest is locked whenever any active filter matches";
      updateRecipeTitleText();
    };
    const scaleRow = centerRow();
    scaleRow.style.flexDirection = "column";
    scaleRow.style.alignItems = "center";
    scaleRow.style.width = "100%";
    scaleRow.style.gap = "12px";
    const scaleModeRow = centerRow();
    scaleModeRow.style.flexWrap = "wrap";
    scaleModeRow.style.justifyContent = "center";
    scaleModeRow.style.gap = "12px";
    const minSlider = ui.slider(50, 100, 1, state2.minScalePct);
    applyStyles(minSlider, { width: "min(420px, 100%)" });
    const maxSlider = ui.slider(50, 100, 1, state2.maxScalePct);
    applyStyles(maxSlider, { width: "min(420px, 100%)" });
    const toMode = (value) => {
      switch (value) {
        case "minimum":
          return "MINIMUM";
        case "maximum":
          return "MAXIMUM";
        case "ranged":
          return "RANGE";
        default:
          return "NONE";
      }
    };
    const fromMode = (mode) => {
      switch (mode) {
        case "MINIMUM":
          return "minimum";
        case "MAXIMUM":
          return "maximum";
        case "RANGE":
          return "ranged";
        default:
          return "none";
      }
    };
    let isProgrammaticScaleMode = false;
    const initialScaleMode = fromMode(state2.scaleLockMode);
    const scaleModeSegmented = ui.segmented(
      [
        { value: "none", label: "None" },
        { value: "minimum", label: "Minimum" },
        { value: "maximum", label: "Maximum" },
        { value: "ranged", label: "Range" }
      ],
      initialScaleMode,
      (value) => {
        if (isProgrammaticScaleMode) return;
        applyScaleMode(toMode(value), true);
      },
      { ariaLabel: "Scale lock mode" }
    );
    scaleModeRow.append(scaleModeSegmented);
    const scaleSlider = ui.rangeDual(50, 100, 1, state2.minScalePct, state2.maxScalePct);
    applyStyles(scaleSlider.root, {
      width: "min(420px, 100%)",
      marginLeft: "auto",
      marginRight: "auto"
    });
    const scaleMinSlider = scaleSlider.min;
    const scaleMaxSlider = scaleSlider.max;
    const scaleMinValue = ui.label("50%");
    const scaleMaxValue = ui.label("100%");
    const scaleMinimumValue = ui.label("50%");
    const scaleMaximumValue = ui.label("100%");
    [scaleMinValue, scaleMaxValue, scaleMinimumValue, scaleMaximumValue].forEach((label2) => {
      label2.style.margin = "0";
      label2.style.fontWeight = "600";
    });
    const makeScaleValue = (labelText, valueLabel) => {
      const wrap = applyStyles(document.createElement("div"), {
        display: "flex",
        alignItems: "center",
        gap: "6px"
      });
      const label2 = ui.label(labelText);
      label2.style.margin = "0";
      label2.style.opacity = "0.9";
      wrap.append(label2, valueLabel);
      return wrap;
    };
    const scaleValues = applyStyles(document.createElement("div"), {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      width: "min(420px, 100%)",
      gap: "16px"
    });
    scaleValues.append(makeScaleValue("Min", scaleMinValue), makeScaleValue("Max", scaleMaxValue));
    const minControls = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "12px",
      width: "100%"
    });
    minControls.append(minSlider, makeScaleValue("Minimum", scaleMinimumValue));
    const maxControls = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "12px",
      width: "100%"
    });
    maxControls.append(maxSlider, makeScaleValue("Maximum", scaleMaximumValue));
    const rangeControls = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "12px",
      width: "100%"
    });
    rangeControls.append(scaleSlider.root, scaleValues);
    scaleRow.append(scaleModeRow, minControls, maxControls, rangeControls);
    const applyScaleRange = (commit, notify2 = commit) => {
      let minValue = parseInt(scaleMinSlider.value, 10);
      let maxValue = parseInt(scaleMaxSlider.value, 10);
      if (!Number.isFinite(minValue)) minValue = state2.minScalePct;
      if (!Number.isFinite(maxValue)) maxValue = state2.maxScalePct;
      minValue = Math.max(50, Math.min(99, minValue));
      maxValue = Math.max(51, Math.min(100, maxValue));
      if (maxValue <= minValue) {
        if (minValue >= 99) {
          minValue = 99;
          maxValue = 100;
        } else {
          maxValue = Math.min(100, Math.max(51, minValue + 1));
        }
      }
      scaleSlider.setValues(minValue, maxValue);
      scaleMinValue.textContent = `${minValue}%`;
      scaleMaxValue.textContent = `${maxValue}%`;
      if (commit) {
        state2.minScalePct = minValue;
        state2.maxScalePct = maxValue;
        if (notify2) opts.onChange?.();
      }
    };
    const applyScaleMinimum = (commit, notify2 = commit) => {
      let minValue = parseInt(minSlider.value, 10);
      if (!Number.isFinite(minValue)) minValue = state2.minScalePct;
      minValue = Math.max(50, Math.min(100, minValue));
      minSlider.value = String(minValue);
      scaleMinimumValue.textContent = `${minValue}%`;
      if (commit) {
        state2.minScalePct = minValue;
        if (notify2) opts.onChange?.();
      }
    };
    const applyScaleMaximum = (commit, notify2 = commit) => {
      let maxValue = parseInt(maxSlider.value, 10);
      if (!Number.isFinite(maxValue)) maxValue = state2.maxScalePct;
      maxValue = Math.max(50, Math.min(100, maxValue));
      maxSlider.value = String(maxValue);
      scaleMaximumValue.textContent = `${maxValue}%`;
      if (commit) {
        state2.maxScalePct = maxValue;
        if (notify2) opts.onChange?.();
      }
    };
    const updateScaleModeUI = () => {
      const isRange = state2.scaleLockMode === "RANGE";
      const isMin = state2.scaleLockMode === "MINIMUM";
      const isMax = state2.scaleLockMode === "MAXIMUM";
      rangeControls.style.display = isRange ? "" : "none";
      minControls.style.display = isMin ? "" : "none";
      maxControls.style.display = isMax ? "" : "none";
      const segValue = fromMode(state2.scaleLockMode);
      if (scaleModeSegmented.get?.() !== segValue) {
        isProgrammaticScaleMode = true;
        try {
          scaleModeSegmented.set?.(segValue);
        } finally {
          isProgrammaticScaleMode = false;
        }
      }
    };
    const applyScaleMode = (mode, notify2) => {
      const prevMode = state2.scaleLockMode;
      state2.scaleLockMode = mode;
      if (mode === "RANGE") {
        scaleSlider.setValues(state2.minScalePct, state2.maxScalePct);
        applyScaleRange(prevMode !== mode, false);
      } else if (mode === "MINIMUM") {
        minSlider.value = String(state2.minScalePct);
        applyScaleMinimum(prevMode !== mode, false);
      } else if (mode === "MAXIMUM") {
        maxSlider.value = String(state2.maxScalePct);
        applyScaleMaximum(prevMode !== mode, false);
      }
      updateScaleModeUI();
      if (notify2 && prevMode !== mode) {
        opts.onChange?.();
      }
    };
    minSlider.addEventListener("input", () => applyScaleMinimum(false));
    minSlider.addEventListener("change", () => applyScaleMinimum(true));
    maxSlider.addEventListener("input", () => applyScaleMaximum(false));
    maxSlider.addEventListener("change", () => applyScaleMaximum(true));
    scaleMinSlider.addEventListener("input", () => applyScaleRange(false));
    scaleMaxSlider.addEventListener("input", () => applyScaleRange(false));
    scaleMinSlider.addEventListener("change", () => applyScaleRange(true));
    scaleMaxSlider.addEventListener("change", () => applyScaleRange(true));
    applyScaleRange(false);
    applyScaleMinimum(false);
    applyScaleMaximum(false);
    applyScaleMode(state2.scaleLockMode, false);
    const colorsRow = centerRow();
    colorsRow.style.flexWrap = "wrap";
    colorsRow.style.gap = "8px";
    const createColorButton = (label2, gradient) => {
      const button = document.createElement("button");
      button.type = "button";
      button.title = "Active filters influence harvest conditions";
      applyStyles(button, {
        padding: "6px 12px",
        borderRadius: "8px",
        border: "1px solid #4445",
        background: "#1f2328",
        color: "#e7eef7",
        fontWeight: "600",
        letterSpacing: "0.3px",
        transition: "border-color 120ms ease, box-shadow 120ms ease, background 120ms ease, opacity 120ms ease",
        boxShadow: "0 0 0 1px #0002 inset",
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "6px",
        minWidth: "92px",
        cursor: "pointer"
      });
      const text = document.createElement("span");
      text.textContent = label2;
      if (gradient) {
        applyStyles(text, {
          backgroundImage: gradient,
          backgroundClip: "text",
          WebkitBackgroundClip: "text",
          color: "transparent",
          fontWeight: "700",
          textShadow: "0 0 6px rgba(0, 0, 0, 0.35)"
        });
      }
      button.appendChild(text);
      button.addEventListener("mouseenter", () => {
        if (button.disabled || button.dataset.active === "1") return;
        button.style.borderColor = "#6aa1";
      });
      button.addEventListener("mouseleave", () => {
        if (button.dataset.active === "1") return;
        button.style.borderColor = "#4445";
      });
      return button;
    };
    const btnNormal = createColorButton("Normal");
    const btnGold = createColorButton(
      "Gold",
      "linear-gradient(120deg, #f5d76e, #c9932b, #f9e9b6)"
    );
    const btnRainbow = createColorButton(
      "Rainbow",
      "linear-gradient(90deg, #ff6b6b, #f7d35c, #3fd3ff, #9b6bff, #ff6b6b)"
    );
    const updateColorButtonVisual = (button, active) => {
      button.dataset.active = active ? "1" : "0";
      button.style.borderColor = active ? "#6aa6" : "#4445";
      button.style.boxShadow = active ? "0 0 0 1px #6aa4 inset, 0 2px 6px rgba(0, 0, 0, 0.45)" : "0 0 0 1px #0002 inset";
      button.style.background = active ? "#182029" : "#1f2328";
      button.style.opacity = button.disabled ? "0.55" : "";
      button.style.cursor = button.disabled ? "default" : "pointer";
    };
    const updateColorButtons = () => {
      updateColorButtonVisual(btnNormal, state2.avoidNormal);
      updateColorButtonVisual(btnGold, state2.visualMutations.has("Gold"));
      updateColorButtonVisual(btnRainbow, state2.visualMutations.has("Rainbow"));
    };
    btnNormal.addEventListener("click", () => {
      state2.avoidNormal = !state2.avoidNormal;
      updateColorButtons();
      opts.onChange?.();
    });
    btnGold.addEventListener("click", () => {
      if (state2.visualMutations.has("Gold")) state2.visualMutations.delete("Gold");
      else state2.visualMutations.add("Gold");
      updateColorButtons();
      opts.onChange?.();
    });
    btnRainbow.addEventListener("click", () => {
      if (state2.visualMutations.has("Rainbow")) state2.visualMutations.delete("Rainbow");
      else state2.visualMutations.add("Rainbow");
      updateColorButtons();
      opts.onChange?.();
    });
    colorsRow.append(btnNormal, btnGold, btnRainbow);
    const weatherGrid = applyStyles(document.createElement("div"), {
      display: "grid",
      gridTemplateColumns: "repeat(4, minmax(0, 1fr))",
      columnGap: "6px",
      rowGap: "6px",
      justifyItems: "stretch",
      width: "min(640px, 100%)",
      marginInline: "auto"
    });
    const applyWeatherSelection = (selection) => (tag, checked) => {
      if (checked) {
        selection.add(tag);
      } else {
        selection.delete(tag);
      }
      opts.onChange?.();
    };
    const updateMainWeatherSelection = applyWeatherSelection(state2.weatherSelected);
    const weatherToggles = WEATHER_MUTATIONS.map((info) => {
      const toggle = createWeatherMutationToggle({
        key: info.key,
        label: info.label,
        kind: "main",
        iconFactory: info.iconFactory
      });
      toggle.input.addEventListener(
        "change",
        () => updateMainWeatherSelection(info.key, toggle.input.checked)
      );
      weatherGrid.appendChild(toggle.wrap);
      return toggle;
    });
    const updateWeatherMutationsDisabled = () => {
      const disabled = card.dataset.disabled === "1" || state2.weatherMode === "RECIPES";
      weatherGrid.style.opacity = disabled ? "0.55" : "";
      weatherGrid.style.pointerEvents = disabled ? "none" : "";
      weatherToggles.forEach((toggle) => toggle.setDisabled(disabled));
    };
    const weatherModeName = `locker-weather-mode-${++weatherModeNameSeq}`;
    const weatherModeRow = centerRow();
    const buildRadio = (value, label2) => {
      const wrap = document.createElement("label");
      wrap.style.display = "inline-flex";
      wrap.style.alignItems = "center";
      wrap.style.gap = "6px";
      const input = ui.radio(weatherModeName, value);
      const span = document.createElement("span");
      span.textContent = label2;
      wrap.append(input, span);
      input.addEventListener("change", () => {
        if (!input.checked) return;
        state2.weatherMode = value;
        recipesWrap.style.display = value === "RECIPES" ? "" : "none";
        updateWeatherMutationsDisabled();
        opts.onChange?.();
      });
      return { wrap, input };
    };
    const radioAny = buildRadio("ANY", "Any match (OR)");
    const radioAll = buildRadio("ALL", "All match (AND)");
    const radioRecipes = buildRadio("RECIPES", "Recipes (match rows)");
    weatherModeRow.append(radioAny.wrap, radioAll.wrap, radioRecipes.wrap);
    const recipesWrap = document.createElement("div");
    recipesWrap.style.display = "grid";
    recipesWrap.style.gap = "8px";
    recipesWrap.style.justifyItems = "center";
    recipesWrap.style.width = "min(720px, 100%)";
    const recipesHeader = centerRow();
    recipesHeader.style.width = "100%";
    recipesHeader.style.justifyContent = "space-between";
    const recipesTitle = document.createElement("div");
    recipesTitleElement = recipesTitle;
    updateRecipeTitleText();
    recipesTitle.style.fontWeight = "600";
    recipesTitle.style.opacity = "0.9";
    const btnAddRecipe = document.createElement("button");
    btnAddRecipe.style.maxWidth = "140px";
    styleBtnFullWidth(btnAddRecipe, "+ Recipe");
    recipesHeader.append(recipesTitle, btnAddRecipe);
    const recipesList = document.createElement("div");
    recipesList.style.display = "grid";
    recipesList.style.gap = "8px";
    recipesList.style.gridTemplateColumns = "repeat(auto-fit, minmax(320px, 1fr))";
    recipesList.style.justifyItems = "stretch";
    let editingRecipeIndex = null;
    let editingRecipeDraft = /* @__PURE__ */ new Set();
    const emptyRecipes = document.createElement("div");
    emptyRecipes.textContent = "No recipe rows yet.";
    emptyRecipes.style.fontSize = "12px";
    emptyRecipes.style.opacity = "0.7";
    emptyRecipes.style.textAlign = "center";
    const updateAddRecipeDisabled = () => {
      const editing = editingRecipeIndex !== null;
      const cardDisabled = card.dataset.disabled === "1";
      btnAddRecipe.disabled = editing || cardDisabled;
      btnAddRecipe.style.opacity = editing ? "0.7" : "";
      btnAddRecipe.style.pointerEvents = editing ? "none" : "";
    };
    const startEditingRecipe = (index, base) => {
      editingRecipeIndex = index;
      editingRecipeDraft = new Set(base ?? []);
      normalizeRecipeSelection(editingRecipeDraft);
      repaintRecipes();
    };
    const cancelEditingRecipe = () => {
      editingRecipeIndex = null;
      editingRecipeDraft = /* @__PURE__ */ new Set();
      repaintRecipes();
    };
    const commitEditingRecipe = () => {
      if (editingRecipeIndex === null) return;
      const draft = new Set(editingRecipeDraft);
      normalizeRecipeSelection(draft);
      if (editingRecipeIndex === state2.weatherRecipes.length) {
        state2.weatherRecipes.push(draft);
      } else if (editingRecipeIndex >= 0 && editingRecipeIndex < state2.weatherRecipes.length) {
        state2.weatherRecipes[editingRecipeIndex] = draft;
      }
      editingRecipeIndex = null;
      editingRecipeDraft = /* @__PURE__ */ new Set();
      repaintRecipes();
      opts.onChange?.();
    };
    const deleteRecipeAt = (index) => {
      if (index < 0) return;
      if (index < state2.weatherRecipes.length) {
        state2.weatherRecipes.splice(index, 1);
      }
      if (editingRecipeIndex !== null) {
        if (index === editingRecipeIndex) {
          editingRecipeIndex = null;
          editingRecipeDraft = /* @__PURE__ */ new Set();
        } else if (index < editingRecipeIndex) {
          editingRecipeIndex -= 1;
        }
      }
      repaintRecipes();
      opts.onChange?.();
    };
    const buildRecipeBadge = (info) => {
      const { key: tag, label: label2 } = info;
      const badge = document.createElement("div");
      applyStyles(badge, {
        display: "inline-flex",
        alignItems: "center",
        gap: "6px",
        padding: "4px 10px",
        borderRadius: "999px",
        border: "1px solid #4445",
        background: "#11161c",
        color: "#e7eef7",
        fontSize: "12px",
        fontWeight: "600",
        letterSpacing: "0.2px"
      });
      const sprite = info.iconFactory ? info.iconFactory({ size: 20, fallback: label2.charAt(0) || "?" }) : createMutationSprite(tag, {
        size: 20,
        fallback: label2.charAt(0) || "?"
      });
      applyStyles(sprite, {
        filter: "drop-shadow(0 1px 1px rgba(0, 0, 0, 0.45))"
      });
      const text = document.createElement("span");
      text.textContent = label2;
      badge.append(sprite, text);
      return badge;
    };
    const renderRecipeSummary = (container, selection) => {
      container.innerHTML = "";
      const badges = document.createElement("div");
      applyStyles(badges, {
        display: "flex",
        flexWrap: "wrap",
        gap: "6px",
        justifyContent: "flex-start"
      });
      let count = 0;
      WEATHER_MUTATIONS.forEach((info) => {
        if (!selection.has(info.key)) return;
        count += 1;
        badges.appendChild(buildRecipeBadge(info));
      });
      if (count === 0) {
        const empty = document.createElement("div");
        empty.textContent = "No weather mutation selected.";
        empty.style.fontSize = "12px";
        empty.style.opacity = "0.7";
        empty.style.textAlign = "left";
        badges.appendChild(empty);
      }
      container.appendChild(badges);
    };
    const applyDisabled = () => {
      const cardDisabled = card.dataset.disabled === "1";
      const inputs = card.querySelectorAll("input,button,select,textarea");
      inputs.forEach((el2) => {
        if (el2.dataset.weatherToggle === "main") {
          return;
        }
        el2.disabled = cardDisabled;
        el2.dispatchEvent(new Event("mg-weather-toggle-refresh"));
      });
      updateWeatherMutationsDisabled();
      updateColorButtons();
      card.style.opacity = cardDisabled ? "0.55" : "";
      updateAddRecipeDisabled();
    };
    function buildRecipeToggleGrid(selection, onSelectionChange) {
      const toggleGrid = applyStyles(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "repeat(4, minmax(80px, 1fr))",
        columnGap: "6px",
        rowGap: "6px",
        justifyItems: "center"
      });
      const toggles = /* @__PURE__ */ new Map();
      WEATHER_MUTATIONS.forEach((info) => {
        const toggle = createWeatherMutationToggle({
          key: info.key,
          label: info.label,
          spriteSize: 40,
          dense: true,
          kind: "recipe",
          iconFactory: info.iconFactory
        });
        toggles.set(info.key, toggle);
        toggle.setChecked(selection.has(toggle.key));
        toggle.input.addEventListener("change", () => {
          const checked = toggle.input.checked;
          const group = WEATHER_RECIPE_GROUPS[toggle.key];
          if (checked && group) {
            WEATHER_RECIPE_GROUP_MEMBERS[group].forEach((other) => {
              if (other === toggle.key) return;
              if (!selection.has(other)) return;
              selection.delete(other);
              toggles.get(other)?.setChecked(false);
            });
          }
          if (checked) {
            selection.add(toggle.key);
          } else {
            selection.delete(toggle.key);
          }
          onSelectionChange();
        });
        toggleGrid.appendChild(toggle.wrap);
      });
      return toggleGrid;
    }
    function repaintRecipes() {
      recipesList.innerHTML = "";
      const hasDraftNew = editingRecipeIndex !== null && editingRecipeIndex === state2.weatherRecipes.length;
      const totalRows = state2.weatherRecipes.length + (hasDraftNew ? 1 : 0);
      if (totalRows === 0) {
        recipesList.appendChild(emptyRecipes);
        applyDisabled();
        return;
      }
      state2.weatherRecipes.forEach((set2, index) => {
        normalizeRecipeSelection(set2);
        const isEditing = editingRecipeIndex === index;
        const selection = isEditing ? editingRecipeDraft : set2;
        const row = applyStyles(document.createElement("div"), {
          display: "flex",
          gap: isEditing ? "10px" : "12px",
          border: "1px solid #4446",
          borderRadius: "10px",
          padding: isEditing ? "12px" : "10px 12px",
          background: "#0f1318",
          boxShadow: "0 0 0 1px #0002 inset",
          width: "100%"
        });
        if (isEditing) {
          row.style.flexDirection = "column";
        } else {
          row.style.flexDirection = "row";
          row.style.alignItems = "center";
          row.style.justifyContent = "space-between";
          row.style.flexWrap = "wrap";
        }
        const summary = document.createElement("div");
        renderRecipeSummary(summary, selection);
        if (!isEditing) {
          summary.style.flex = "1 1 auto";
          summary.style.minWidth = "220px";
        }
        row.appendChild(summary);
        if (isEditing) {
          const toggleGrid = buildRecipeToggleGrid(selection, () => renderRecipeSummary(summary, selection));
          row.appendChild(toggleGrid);
          const actions = applyStyles(document.createElement("div"), {
            display: "flex",
            gap: "8px",
            width: "100%"
          });
          const btnCancel = document.createElement("button");
          styleBtnFullWidth(btnCancel, "\u274C");
          btnCancel.onclick = cancelEditingRecipe;
          const btnValidate = document.createElement("button");
          styleBtnFullWidth(btnValidate, "\u2714\uFE0F");
          btnValidate.onclick = commitEditingRecipe;
          actions.append(btnCancel, btnValidate);
          if (editingRecipeIndex !== null && editingRecipeIndex < state2.weatherRecipes.length) {
            const btnDelete = document.createElement("button");
            styleBtnFullWidth(btnDelete, "\u{1F5D1}\uFE0F");
            btnDelete.title = "Delete";
            btnDelete.setAttribute("aria-label", "Delete");
            btnDelete.onclick = () => deleteRecipeAt(index);
            actions.append(btnDelete);
          }
          row.appendChild(actions);
        } else {
          const actions = applyStyles(document.createElement("div"), {
            display: "flex",
            gap: "6px",
            alignItems: "center",
            justifyContent: "flex-end",
            flex: "0 0 auto"
          });
          actions.style.flexWrap = "nowrap";
          const btnEdit = document.createElement("button");
          styleBtnCompact(btnEdit, "\u270F\uFE0F");
          btnEdit.title = "Edit";
          btnEdit.setAttribute("aria-label", "Edit");
          btnEdit.onclick = () => startEditingRecipe(index, set2);
          const btnDelete = document.createElement("button");
          styleBtnCompact(btnDelete, "\u{1F5D1}\uFE0F");
          btnDelete.title = "Delete";
          btnDelete.setAttribute("aria-label", "Delete");
          btnDelete.onclick = () => deleteRecipeAt(index);
          actions.append(btnEdit, btnDelete);
          row.appendChild(actions);
        }
        recipesList.appendChild(row);
      });
      if (hasDraftNew && editingRecipeIndex !== null) {
        const selection = editingRecipeDraft;
        const row = applyStyles(document.createElement("div"), {
          display: "flex",
          flexDirection: "column",
          gap: "10px",
          border: "1px solid #4446",
          borderRadius: "10px",
          padding: "12px",
          background: "#0f1318",
          boxShadow: "0 0 0 1px #0002 inset",
          width: "100%"
        });
        const summary = document.createElement("div");
        renderRecipeSummary(summary, selection);
        row.appendChild(summary);
        const toggleGrid = buildRecipeToggleGrid(selection, () => renderRecipeSummary(summary, selection));
        row.appendChild(toggleGrid);
        const actions = applyStyles(document.createElement("div"), {
          display: "flex",
          gap: "8px",
          width: "100%"
        });
        const btnCancel = document.createElement("button");
        styleBtnFullWidth(btnCancel, "\u274C");
        btnCancel.onclick = cancelEditingRecipe;
        const btnValidate = document.createElement("button");
        styleBtnFullWidth(btnValidate, "\u2714\uFE0F");
        btnValidate.onclick = commitEditingRecipe;
        actions.append(btnCancel, btnValidate);
        row.appendChild(actions);
        recipesList.appendChild(row);
      }
      applyDisabled();
    }
    btnAddRecipe.onclick = () => {
      startEditingRecipe(state2.weatherRecipes.length);
    };
    recipesWrap.append(recipesHeader, recipesList);
    card.append(
      makeSection("Harvest mode", lockModeRow),
      makeSection("Filter by size", scaleRow),
      makeSection("Filter by color", colorsRow),
      makeSection("Filter by weather", weatherGrid),
      makeSection("Weather filter mode", weatherModeRow),
      makeSection("Weather recipes", recipesWrap)
    );
    const refresh = () => {
      updateLockModeUI();
      scaleSlider.setValues(state2.minScalePct, state2.maxScalePct);
      minSlider.value = String(state2.minScalePct);
      maxSlider.value = String(state2.maxScalePct);
      applyScaleRange(false);
      applyScaleMinimum(false);
      applyScaleMaximum(false);
      applyScaleMode(state2.scaleLockMode, false);
      updateColorButtons();
      weatherToggles.forEach((toggle) => toggle.setChecked(state2.weatherSelected.has(toggle.key)));
      radioAny.input.checked = state2.weatherMode === "ANY";
      radioAll.input.checked = state2.weatherMode === "ALL";
      radioRecipes.input.checked = state2.weatherMode === "RECIPES";
      recipesWrap.style.display = state2.weatherMode === "RECIPES" ? "" : "none";
      updateWeatherMutationsDisabled();
      repaintRecipes();
    };
    const setDisabled = (value) => {
      card.dataset.disabled = value ? "1" : "0";
      applyDisabled();
    };
    refresh();
    return { root: card, refresh, setDisabled };
  }
  function createRestrictionsTabRenderer(ui) {
    let state2 = lockerRestrictionsService.getState();
    let bonusFromMultiplier = null;
    let bonusFromPlayers = friendBonusPercentFromPlayers(1);
    let eggOptions = [];
    const disposables = [];
    let subsAttached = false;
    const clampPercent4 = (value) => Math.max(0, Math.min(FRIEND_BONUS_MAX, Math.round(value / FRIEND_BONUS_STEP) * FRIEND_BONUS_STEP));
    const resolveCurrentBonus = () => bonusFromMultiplier ?? bonusFromPlayers ?? 0;
    const layout = applyStyles(document.createElement("div"), {
      display: "grid",
      gap: "12px",
      justifyItems: "center",
      width: "100%",
      maxWidth: "1100px"
    });
    const card = ui.card("Friend bonus locker", {
      align: "stretch"
    });
    card.root.style.width = "100%";
    card.header.style.display = "flex";
    card.header.style.alignItems = "center";
    card.header.style.justifyContent = "space-between";
    const sliderWrap = applyStyles(document.createElement("div"), {
      display: "grid",
      gap: "6px"
    });
    const sliderHeader = ui.flexRow({ justify: "between", align: "center", fullWidth: true });
    const sliderTitle = document.createElement("div");
    sliderTitle.textContent = "Minimum friend bonus required\u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E ";
    sliderTitle.style.fontWeight = "600";
    const sliderValue = applyStyles(document.createElement("div"), {
      fontWeight: "700",
      color: "#ff7a1f",
      textShadow: "0 1px 1px rgba(0, 0, 0, 0.5)"
    });
    sliderHeader.append(sliderTitle, sliderValue);
    const initialRequiredPct = friendBonusPercentFromPlayers(state2.minRequiredPlayers) ?? 0;
    const slider = ui.slider(0, FRIEND_BONUS_MAX, FRIEND_BONUS_STEP, initialRequiredPct);
    slider.style.width = "100%";
    sliderWrap.append(sliderHeader, slider);
    const statusBadge = applyStyles(document.createElement("div"), {
      display: "inline-flex",
      alignItems: "center",
      gap: "6px",
      padding: "4px 10px",
      borderRadius: "999px",
      fontWeight: "700",
      fontSize: "12px",
      letterSpacing: "0.25px"
    });
    statusBadge.style.marginLeft = "auto";
    card.header.appendChild(statusBadge);
    const statusText = applyStyles(document.createElement("div"), {
      fontSize: "12.5px",
      lineHeight: "1.5",
      opacity: "0.92"
    });
    card.body.append(sliderWrap, statusText);
    layout.append(card.root);
    const decorCard = ui.card("Decor pick locker", { align: "stretch" });
    decorCard.root.style.width = "100%";
    const decorRow = applyStyles(document.createElement("div"), {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      gap: "12px"
    });
    const decorText = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "4px"
    });
    const decorSubtitle = document.createElement("div");
    decorSubtitle.textContent = "Prevents placed decors from being picked up";
    decorSubtitle.style.fontSize = "12.5px";
    decorSubtitle.style.opacity = "0.85";
    decorText.append(decorSubtitle);
    const decorToggle = ui.switch(state2.decorPickupLocked);
    decorToggle.addEventListener("change", () => {
      const locked = !!decorToggle.checked;
      state2.decorPickupLocked = locked;
      lockerRestrictionsService.setDecorPickupLocked(locked);
    });
    decorRow.append(decorText, decorToggle);
    decorCard.body.append(decorRow);
    layout.append(decorCard.root);
    const eggCard = ui.card("Egg hatch locker", { align: "stretch" });
    eggCard.root.style.width = "100%";
    const eggList = applyStyles(document.createElement("div"), {
      display: "grid",
      gap: "8px",
      width: "100%"
    });
    eggCard.body.append(eggList);
    layout.append(eggCard.root);
    const LOCKED_ICON = "\u{1F512}";
    const UNLOCKED_ICON = "\u{1F513}";
    const eggRowCache = /* @__PURE__ */ new Map();
    const emptyEggPlaceholder = applyStyles(document.createElement("div"), {
      opacity: "0.7",
      fontSize: "12px"
    });
    emptyEggPlaceholder.textContent = "No eggs detected in shop.";
    const updateEggToggleAppearance = (toggle, locked) => {
      toggle.textContent = locked ? LOCKED_ICON : UNLOCKED_ICON;
      toggle.style.background = locked ? "#331616" : "#12301d";
      toggle.style.color = locked ? "#fca5a5" : "#9ef7c3";
    };
    let renderEggList;
    const createEggRow = (opt) => {
      const row = applyStyles(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "auto auto 1fr",
        alignItems: "center",
        gap: "10px",
        padding: "8px 10px",
        border: "1px solid #4445",
        borderRadius: "10px",
        background: "#0f1318"
      });
      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.style.border = "1px solid #4445";
      toggle.style.borderRadius = "10px";
      toggle.style.padding = "6px 10px";
      toggle.style.fontSize = "14px";
      toggle.style.fontWeight = "700";
      toggle.addEventListener("click", () => {
        const next = !Boolean(state2.eggLocks?.[opt.id]);
        state2.eggLocks = { ...state2.eggLocks || {}, [opt.id]: next };
        lockerRestrictionsService.setEggLock(opt.id, next);
        renderEggList();
      });
      const sprite = createShopSprite("Egg", opt.id, { size: 32, fallback: "\u{1F95A}" });
      sprite.style.filter = "drop-shadow(0 1px 1px rgba(0,0,0,0.45))";
      const name = document.createElement("div");
      name.style.fontWeight = "600";
      name.style.color = "#e7eef7";
      row.append(toggle, sprite, name);
      return { row, toggle, name };
    };
    renderEggList = () => {
      eggList.innerHTML = "";
      if (!eggOptions.length) {
        eggList.appendChild(emptyEggPlaceholder);
        return;
      }
      const fragment = document.createDocumentFragment();
      const seen = /* @__PURE__ */ new Set();
      eggOptions.forEach((opt) => {
        const id = opt.id;
        seen.add(id);
        let entry = eggRowCache.get(id);
        if (!entry) {
          entry = createEggRow(opt);
          eggRowCache.set(id, entry);
        }
        entry.name.textContent = opt.name || id;
        const locked = !!state2.eggLocks?.[id];
        updateEggToggleAppearance(entry.toggle, locked);
        fragment.appendChild(entry.row);
      });
      for (const id of Array.from(eggRowCache.keys())) {
        if (seen.has(id)) continue;
        const entry = eggRowCache.get(id);
        if (entry) {
          entry.row.remove();
        }
        eggRowCache.delete(id);
      }
      eggList.appendChild(fragment);
    };
    const updateSliderValue = (pct) => {
      slider.value = String(pct);
      sliderValue.textContent = `+${pct}%`;
    };
    const setStatusTone = (tone) => {
      const palette = tone === "success" ? { bg: "#0f2f1f", border: "#1b7c4a", color: "#8cf6ba" } : tone === "warn" ? { bg: "#321616", border: "#c74343", color: "#fca5a5" } : { bg: "#16263d", border: "#3f82d1", color: "#a5c7ff" };
      statusBadge.style.background = palette.bg;
      statusBadge.style.border = `1px solid ${palette.border}`;
      statusBadge.style.color = palette.color;
    };
    const updateStatus = () => {
      const requiredPct = clampPercent4(friendBonusPercentFromPlayers(state2.minRequiredPlayers) ?? 0);
      const currentPct = resolveCurrentBonus();
      const requiredPlayers = state2.minRequiredPlayers;
      const currentPlayers = currentPct != null ? percentToRequiredFriendCount(currentPct) : null;
      const allowed = requiredPct <= 0 || currentPct != null && currentPct + 1e-4 >= requiredPct;
      if (requiredPct <= 0) {
        statusBadge.textContent = "Unlocked";
        setStatusTone("info");
        statusText.textContent = currentPct != null ? `Current friend bonus: ${currentPct}% (${currentPlayers} players).` : "Current friend bonus not detected yet.";
        return;
      }
      statusBadge.textContent = allowed ? "Sale allowed" : "Sale locked";
      setStatusTone(allowed ? "success" : "warn");
      statusText.textContent = allowed ? `Current bonus ${currentPct}% (${currentPlayers} players) meets the requirement (${requiredPct}%).` : `Requires ${requiredPct}% (${requiredPlayers} players) or more`;
    };
    const handleSliderInput = (commit) => {
      const raw = Number(slider.value);
      const pct = clampPercent4(Number.isFinite(raw) ? raw : 0);
      updateSliderValue(pct);
      state2.minRequiredPlayers = percentToRequiredFriendCount(pct);
      updateStatus();
      if (commit) {
        lockerRestrictionsService.setMinRequiredPlayers(state2.minRequiredPlayers);
      }
    };
    slider.addEventListener("input", () => handleSliderInput(false));
    slider.addEventListener("change", () => handleSliderInput(true));
    const syncFromService = (next) => {
      state2 = { ...next };
      setCheck(decorToggle, state2.decorPickupLocked);
      updateSliderValue(friendBonusPercentFromPlayers(state2.minRequiredPlayers) ?? 0);
      updateStatus();
      renderEggList();
    };
    const attachSubscriptions = async () => {
      if (subsAttached) return;
      subsAttached = true;
      try {
        const initialBonus = await Atoms.server.friendBonusMultiplier.get();
        bonusFromMultiplier = friendBonusPercentFromMultiplier(initialBonus);
      } catch {
      }
      try {
        const unsub = await Atoms.server.friendBonusMultiplier.onChange((next) => {
          bonusFromMultiplier = friendBonusPercentFromMultiplier(next);
          updateStatus();
        });
        if (typeof unsub === "function") disposables.push(unsub);
      } catch {
      }
      try {
        const initialPlayers = await Atoms.server.numPlayers.get();
        bonusFromPlayers = friendBonusPercentFromPlayers(initialPlayers);
      } catch {
      }
      try {
        const unsubPlayers = await Atoms.server.numPlayers.onChange((next) => {
          bonusFromPlayers = friendBonusPercentFromPlayers(next);
          updateStatus();
        });
        if (typeof unsubPlayers === "function") disposables.push(unsubPlayers);
      } catch {
      }
      const unsubService = lockerRestrictionsService.subscribe(syncFromService);
      disposables.push(unsubService);
      try {
        const initialEggShop = await Atoms.shop.eggShop.get();
        eggOptions = extractEggOptions(initialEggShop);
        renderEggList();
      } catch {
      }
      try {
        const unsubEggShop = await Atoms.shop.eggShop.onChange((next) => {
          eggOptions = extractEggOptions(next);
          renderEggList();
        });
        if (typeof unsubEggShop === "function") disposables.push(unsubEggShop);
      } catch {
      }
    };
    const render = (view) => {
      view.innerHTML = "";
      view.style.maxHeight = "54vh";
      view.style.overflow = "auto";
      view.append(layout);
      syncFromService(lockerRestrictionsService.getState());
      updateStatus();
      void attachSubscriptions();
    };
    const destroy = () => {
      while (disposables.length) {
        const dispose = disposables.pop();
        try {
          dispose?.();
        } catch {
        }
      }
    };
    return { render, destroy };
  }
  function extractEggOptions(raw) {
    const seen = /* @__PURE__ */ new Set();
    const options = [];
    const add = (id, name) => {
      if (typeof id !== "string" || !id) return;
      if (seen.has(id)) return;
      seen.add(id);
      const label2 = typeof name === "string" && name || typeof raw?.names?.[id] === "string" && raw.names[id] || id;
      options.push({ id, name: label2 });
    };
    const walk = (node) => {
      if (!node || typeof node !== "object") return;
      if (Array.isArray(node)) {
        node.forEach(walk);
        return;
      }
      const candidate = node.eggId ?? node.id ?? null;
      add(candidate, node.name);
      for (const value of Object.values(node)) {
        if (value && typeof value === "object") walk(value);
      }
    };
    walk(raw);
    return options;
  }
  function createGeneralTabRenderer(ui, store) {
    const viewRoot = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      alignItems: "center",
      width: "100%"
    });
    const layout = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      alignItems: "center",
      width: "100%"
    });
    const header = applyStyles(document.createElement("div"), {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      justifyContent: "space-between",
      border: "1px solid #4445",
      borderRadius: "10px",
      padding: "12px 16px",
      background: "#1f2328",
      boxShadow: "0 0 0 1px #0002 inset",
      width: "min(760px, 100%)"
    });
    const textWrap = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "4px"
    });
    const title = document.createElement("div");
    title.textContent = "Global locker";
    title.style.fontWeight = "600";
    title.style.fontSize = "15px";
    const subtitle = document.createElement("div");
    subtitle.textContent = "Set the rules for locking or allowing harvests using the filters below";
    subtitle.style.opacity = "0.8";
    subtitle.style.fontSize = "12px";
    textWrap.append(title, subtitle);
    const toggleWrap = applyStyles(document.createElement("label"), {
      display: "flex",
      alignItems: "center",
      gap: "8px"
    });
    const toggleLabel = ui.label("Enabled");
    toggleLabel.style.margin = "0";
    const toggle = ui.switch(store.global.enabled);
    toggleWrap.append(toggleLabel, toggle);
    header.append(textWrap, toggleWrap);
    const form = createLockerSettingsCard(ui, store.global.settings, {
      onChange: () => store.notifyGlobalSettingsChanged()
    });
    layout.append(header, form.root);
    viewRoot.append(layout);
    const update = () => {
      setCheck(toggle, store.global.enabled);
      form.setDisabled(!store.global.enabled);
      form.refresh();
    };
    toggle.addEventListener("change", () => {
      store.setGlobalEnabled(!!toggle.checked);
    });
    const unsubscribe2 = store.subscribe(() => {
      update();
    });
    update();
    const render = (view) => {
      view.innerHTML = "";
      view.style.maxHeight = "54vh";
      view.style.overflow = "auto";
      view.append(viewRoot);
      update();
    };
    return {
      render,
      destroy: () => unsubscribe2()
    };
  }
  function createOverridesTabRenderer(ui, store) {
    const layout = applyStyles(document.createElement("div"), {
      display: "grid",
      gridTemplateColumns: "minmax(220px, 280px) minmax(0, 1fr)",
      gap: "10px",
      alignItems: "stretch",
      height: "54vh",
      overflow: "hidden"
    });
    const left = applyStyles(document.createElement("div"), {
      display: "grid",
      gridTemplateRows: "1fr",
      gap: "8px",
      minHeight: "0"
    });
    layout.appendChild(left);
    const list = applyStyles(document.createElement("div"), {
      display: "grid",
      gridTemplateColumns: "1fr",
      rowGap: "6px",
      overflow: "auto",
      paddingRight: "2px",
      border: "1px solid #4445",
      borderRadius: "10px",
      padding: "6px"
    });
    left.appendChild(list);
    const right = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      minHeight: "0"
    });
    layout.appendChild(right);
    const detail = applyStyles(document.createElement("div"), {
      display: "grid",
      gap: "12px",
      justifyItems: "center",
      alignContent: "start",
      height: "100%",
      overflow: "auto"
    });
    right.appendChild(detail);
    let selectedKey = null;
    let renderedDetailKey = null;
    const detailScrollMemory = /* @__PURE__ */ new Map();
    const getClampedScrollTop = (element) => {
      const max = Math.max(0, element.scrollHeight - element.clientHeight);
      return Math.max(0, Math.min(element.scrollTop, max));
    };
    const restoreScrollTop = (element, value) => {
      const max = Math.max(0, element.scrollHeight - element.clientHeight);
      const target = Math.max(0, Math.min(value, max));
      element.scrollTop = target;
      return target;
    };
    const updateDetailScrollMemory = (key2) => {
      const current = detailScrollMemory.get(key2) ?? { detail: 0, card: 0 };
      current.detail = getClampedScrollTop(detail);
      const currentCard = detail.querySelector('[data-locker-settings-card="1"]');
      if (currentCard) {
        current.card = getClampedScrollTop(currentCard);
      }
      detailScrollMemory.set(key2, current);
    };
    detail.addEventListener("scroll", () => {
      if (!renderedDetailKey) return;
      const memory = detailScrollMemory.get(renderedDetailKey) ?? { detail: 0, card: 0 };
      memory.detail = getClampedScrollTop(detail);
      detailScrollMemory.set(renderedDetailKey, memory);
    });
    const renderList = () => {
      const previousScrollTop = getClampedScrollTop(list);
      list.innerHTML = "";
      const seeds = getLockerSeedOptions();
      if (!seeds.length) {
        const empty = document.createElement("div");
        empty.textContent = "No crops available.";
        empty.style.opacity = "0.7";
        empty.style.fontSize = "12px";
        empty.style.textAlign = "center";
        empty.style.padding = "16px";
        list.appendChild(empty);
        restoreScrollTop(list, previousScrollTop);
        selectedKey = null;
        return;
      }
      scheduleLockerSpritePreload();
      if (selectedKey && !seeds.some((opt) => opt.key === selectedKey)) {
        selectedKey = null;
      }
      const fragment = document.createDocumentFragment();
      seeds.forEach((opt) => {
        const button = document.createElement("button");
        button.className = "qmm-vtab";
        button.style.display = "grid";
        button.style.gridTemplateColumns = "16px 1fr auto";
        button.style.alignItems = "center";
        button.style.gap = "8px";
        button.style.textAlign = "left";
        button.style.padding = "6px 8px";
        button.style.borderRadius = "8px";
        button.style.border = "1px solid #4445";
        button.style.background = selectedKey === opt.key ? "#2b8a3e" : "#1f2328";
        button.style.color = "#e7eef7";
        const dot = document.createElement("span");
        dot.className = "qmm-dot";
        dot.style.background = store.getOverride(opt.key)?.enabled ? "#2ecc71" : "#e74c3c";
        const label2 = document.createElement("span");
        label2.className = "label";
        label2.textContent = opt.cropName || opt.key;
        const fallbackEmoji = getLockerSeedEmojiForKey(opt.key) || getLockerSeedEmojiForSeedName(opt.seedName) || "\u{1F331}";
        const sprite = createPlantSprite(opt.key, {
          size: 24,
          fallback: fallbackEmoji
        });
        button.append(dot, label2, sprite);
        button.onmouseenter = () => button.style.borderColor = "#6aa1";
        button.onmouseleave = () => button.style.borderColor = "#4445";
        button.onclick = () => {
          if (selectedKey === opt.key) return;
          selectedKey = opt.key;
          renderList();
          renderDetail();
        };
        fragment.appendChild(button);
      });
      list.appendChild(fragment);
      restoreScrollTop(list, previousScrollTop);
    };
    const renderDetail = () => {
      if (renderedDetailKey) {
        updateDetailScrollMemory(renderedDetailKey);
      }
      detail.innerHTML = "";
      if (!selectedKey) {
        const empty = document.createElement("div");
        empty.textContent = "Select a crop on the left to customise its locker settings.";
        empty.style.opacity = "0.7";
        empty.style.fontSize = "13px";
        empty.style.textAlign = "center";
        empty.style.padding = "32px 24px";
        empty.style.border = "1px dashed #4445";
        empty.style.borderRadius = "10px";
        empty.style.width = "min(760px, 100%)";
        detail.appendChild(empty);
        renderedDetailKey = null;
        return;
      }
      const seeds = getLockerSeedOptions();
      const seed = seeds.find((opt) => opt.key === selectedKey);
      if (!seed) {
        selectedKey = null;
        renderedDetailKey = null;
        renderDetail();
        return;
      }
      const override = store.ensureOverride(selectedKey, { silent: true });
      const header = ui.flexRow({ justify: "between", align: "center", fullWidth: true });
      header.style.border = "1px solid #4445";
      header.style.borderRadius = "10px";
      header.style.padding = "12px 16px";
      header.style.background = "#1f2328";
      header.style.boxShadow = "0 0 0 1px #0002 inset";
      header.style.width = "min(760px, 100%)";
      const titleWrap = ui.flexRow({ gap: 10, align: "center" });
      titleWrap.style.flexWrap = "nowrap";
      const fallbackEmoji = getLockerSeedEmojiForKey(seed.key) || getLockerSeedEmojiForSeedName(seed.seedName) || "\u{1F331}";
      const sprite = createPlantSprite(seed.key, { size: 32, fallback: fallbackEmoji });
      const title = document.createElement("div");
      title.textContent = seed.cropName || seed.key;
      title.style.fontWeight = "600";
      title.style.fontSize = "15px";
      titleWrap.append(sprite, title);
      const toggleWrap = ui.flexRow({ gap: 8, align: "center" });
      toggleWrap.style.flexWrap = "nowrap";
      const toggleLabel = ui.label("Override");
      toggleLabel.style.margin = "0";
      const toggle = ui.switch(override.enabled);
      toggleWrap.append(toggleLabel, toggle);
      header.append(titleWrap, toggleWrap);
      const status = document.createElement("div");
      status.style.fontSize = "12px";
      status.style.opacity = "0.75";
      status.style.textAlign = "center";
      status.style.width = "min(760px, 100%)";
      const updateStatus = () => {
        status.textContent = override.enabled ? "This crop uses its own locker filters." : "Uses the global locker settings.";
      };
      const form = createLockerSettingsCard(ui, override.settings, {
        onChange: () => {
          if (selectedKey) {
            store.notifyOverrideSettingsChanged(selectedKey);
          }
        }
      });
      const applyEnabledState = () => {
        form.setDisabled(!override.enabled);
        form.refresh();
        updateStatus();
      };
      toggle.addEventListener("change", () => {
        if (!selectedKey) return;
        const wasEnabled = override.enabled;
        const nextEnabled = !!toggle.checked;
        if (nextEnabled && !wasEnabled && !override.hasPersistedSettings) {
          copySettings(override.settings, store.global.settings);
        }
        if (nextEnabled) {
          override.hasPersistedSettings = true;
        }
        store.setOverrideEnabled(selectedKey, nextEnabled);
      });
      applyEnabledState();
      detail.append(header, status, form.root);
      if (selectedKey) {
        const memory = detailScrollMemory.get(selectedKey) ?? { detail: 0, card: 0 };
        memory.detail = restoreScrollTop(detail, memory.detail);
        memory.card = restoreScrollTop(form.root, memory.card);
        detailScrollMemory.set(selectedKey, memory);
        const activeKey = selectedKey;
        form.root.addEventListener("scroll", () => {
          if (renderedDetailKey !== activeKey) return;
          const current = detailScrollMemory.get(activeKey) ?? { detail: getClampedScrollTop(detail), card: 0 };
          current.card = getClampedScrollTop(form.root);
          detailScrollMemory.set(activeKey, current);
        });
        renderedDetailKey = activeKey;
      }
    };
    const refresh = () => {
      renderList();
      renderDetail();
    };
    const unsubscribe2 = store.subscribe(refresh);
    const render = (view) => {
      view.innerHTML = "";
      view.append(layout);
      refresh();
    };
    return {
      render,
      destroy: () => unsubscribe2()
    };
  }
  async function renderLockerMenu(container) {
    const ui = new Menu({ id: "locker", compact: true });
    ui.mount(container);
    const store = new LockerMenuStore(lockerService.getState());
    const restrictionsTab = createRestrictionsTabRenderer(ui);
    const generalTab = createGeneralTabRenderer(ui, store);
    const overridesTab = createOverridesTabRenderer(ui, store);
    ui.addTabs([
      { id: "locker-general", title: "General", render: (view) => generalTab.render(view) },
      { id: "locker-overrides", title: "Overrides", render: (view) => overridesTab.render(view) },
      { id: "locker-restrictions", title: "Restrictions", render: (view) => restrictionsTab.render(view) }
    ]);
    ui.switchTo("locker-general");
    const disposables = [];
    disposables.push(lockerService.subscribe((event) => store.syncFromService(event.state)));
    disposables.push(() => restrictionsTab.destroy());
    disposables.push(() => generalTab.destroy());
    disposables.push(() => overridesTab.destroy());
    const cleanup2 = () => {
      while (disposables.length) {
        const dispose = disposables.pop();
        try {
          dispose?.();
        } catch {
        }
      }
    };
    ui.on("unmounted", cleanup2);
  }

  // src/ui/menus/calculator.ts
  var ROOT_CLASS = "mg-crop-simulation";
  var SIZE_MIN = 50;
  var SIZE_MAX = 100;
  var SCALE_MIN = 1;
  var SCALE_MAX = 3;
  var COLOR_MUTATION_LABELS = ["None", "Gold", "Rainbow"];
  var WEATHER_CONDITION_LABELS = ["None", "Wet", "Chilled", "Frozen"];
  var WEATHER_LIGHTING_LABELS = ["None", "Dawnlit", "Dawnbound", "Amberlit", "Amberbound"];
  var FRIEND_BONUS_LABELS = ["+0%", "+10%", "+20%", "+30%", "+40%", "+50%"];
  var FRIEND_BONUS_MIN_PLAYERS = 1;
  var FRIEND_BONUS_MAX_PLAYERS = FRIEND_BONUS_LABELS.length;
  var COLOR_SEGMENT_METADATA = {
    None: { mgColor: "none" },
    Gold: { mgColor: "gold" },
    Rainbow: { mgColor: "rainbow" }
  };
  var WEATHER_CONDITION_SEGMENT_METADATA = {
    None: { mgWeather: "none" },
    Wet: { mgWeather: "wet" },
    Chilled: { mgWeather: "chilled" },
    Frozen: { mgWeather: "frozen" }
  };
  var WEATHER_LIGHTING_SEGMENT_METADATA = {
    None: { mgLighting: "none" },
    Dawnlit: { mgLighting: "dawnlit" },
    Dawnbound: { mgLighting: "dawnbound" },
    Amberlit: { mgLighting: "amberlit" },
    Amberbound: { mgLighting: "amberbound" }
  };
  var segmentedUi = new Menu({ compact: true });
  var ensureMenuStyles = segmentedUi.ensureStyles;
  ensureMenuStyles?.call(segmentedUi);
  var priceFormatter = new Intl.NumberFormat("en-US");
  var weightFormatter = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 3,
    maximumFractionDigits: 3
  });
  var DEFAULT_STATE2 = {
    sizePercent: SIZE_MIN,
    color: "None",
    weatherCondition: "None",
    weatherLighting: "None",
    friendPlayers: FRIEND_BONUS_MIN_PLAYERS
  };
  var BASE_SPRITE_SIZE_PX = 96;
  var WEATHER_EFFECT_PRIORITY = ["wet", "chilled", "frozen"];
  var LIGHTING_EFFECT_PRIORITY_GROUPS = [
    ["dawnlit"],
    ["dawnbound", "dawncharged", "dawn radiant", "dawnradiant", "dawn-radiant"],
    ["ambershine", "amberlit"],
    ["amberbound", "ambercharged", "amber radiant", "amberradiant", "amber-radiant"]
  ];
  var EFFECTS_CONFIG = {
    Wet: {
      blendMode: "source-atop",
      colors: ["rgb(128, 128, 255)"],
      alpha: 0.2
    },
    Chilled: {
      blendMode: "source-atop",
      colors: ["rgb(183, 183, 236)"],
      alpha: 0.5
    },
    Frozen: {
      blendMode: "source-atop",
      colors: ["rgb(128, 128, 255)"],
      alpha: 0.6
    },
    Dawnlit: {
      blendMode: "source-atop",
      colors: ["rgb(120, 100, 180)"],
      alpha: 0.4
    },
    Ambershine: {
      blendMode: "source-atop",
      colors: ["rgb(255, 140, 26)", "rgb(230, 92, 26)", "rgb(178, 58, 26)"],
      alpha: 0.5
    },
    Dawncharged: {
      blendMode: "source-atop",
      colors: ["rgb(100, 80, 160)", "rgb(110, 90, 170)", "rgb(120, 100, 180)"],
      alpha: 0.5
    },
    Ambercharged: {
      blendMode: "source-atop",
      colors: ["rgb(167, 50, 30)", "rgb(177, 60, 40)", "rgb(187, 70, 50)"],
      alpha: 0.5
    }
  };
  var EFFECT_PRIORITY_BY_LOWER_NAME = (() => {
    const map2 = /* @__PURE__ */ new Map();
    WEATHER_EFFECT_PRIORITY.forEach((name, index) => {
      map2.set(name.toLowerCase(), index);
    });
    let offset = WEATHER_EFFECT_PRIORITY.length;
    LIGHTING_EFFECT_PRIORITY_GROUPS.forEach((group) => {
      group.forEach((name) => {
        map2.set(name.toLowerCase(), offset);
      });
      offset += 1;
    });
    return map2;
  })();
  var LIGHTING_EFFECT_NAMES_LOWER = /* @__PURE__ */ new Set([
    "dawnlit",
    "dawncharged",
    "ambershine",
    "ambercharged"
  ]);
  var EFFECT_TOKEN_ALIASES = /* @__PURE__ */ new Map([
    ["wet", "Wet"],
    ["damp", "Wet"],
    ["moist", "Wet"],
    ["chilled", "Chilled"],
    ["cold", "Chilled"],
    ["frozen", "Frozen"],
    ["ice", "Frozen"],
    ["icy", "Frozen"],
    ["dawnlit", "Dawnlit"],
    ["dawn-lit", "Dawnlit"],
    ["dawnbound", "Dawnlit"],
    ["dawn-bound", "Dawnlit"],
    ["dawncharged", "Dawncharged"],
    ["dawn-charged", "Dawncharged"],
    ["dawn radiant", "Dawncharged"],
    ["dawnradiant", "Dawncharged"],
    ["dawn-radiant", "Dawncharged"],
    ["ambershine", "Ambershine"],
    ["amber-shine", "Ambershine"],
    ["amberlit", "Ambershine"],
    ["amber-lit", "Ambershine"],
    ["amberbound", "Ambercharged"],
    ["amber-bound", "Ambercharged"],
    ["ambercharged", "Ambercharged"],
    ["amber-charged", "Ambercharged"],
    ["amber radiant", "Ambercharged"],
    ["amberradiant", "Ambercharged"],
    ["amber-radiant", "Ambercharged"]
  ]);
  var EFFECT_NAME_BY_TOKEN = (() => {
    const map2 = /* @__PURE__ */ new Map();
    Object.keys(EFFECTS_CONFIG).forEach((key2) => {
      map2.set(key2.toLowerCase(), key2);
    });
    EFFECT_TOKEN_ALIASES.forEach((value, key2) => {
      map2.set(key2, value);
    });
    return map2;
  })();
  var WEATHER_LABEL_NORMALIZATION = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const entries = tileRefsMutationLabels;
    for (const [key2, value] of Object.entries(entries)) {
      if (typeof key2 !== "string" || typeof value !== "string") continue;
      map2.set(key2.toLowerCase(), value);
      map2.set(value.toLowerCase(), value);
    }
    return map2;
  })();
  var TALL_PLANT_SEEDS2 = /* @__PURE__ */ new Set(["Bamboo", "Cactus"]);
  var mutationMetadataByNormalizedName = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const catalog = mutationCatalog;
    for (const [key2, value] of Object.entries(catalog)) {
      if (typeof key2 !== "string" || !key2.trim()) continue;
      const label2 = typeof value?.name === "string" && value.name.trim().length > 0 ? value.name : key2;
      const tileRef = typeof value?.tileRef === "number" ? value.tileRef : null;
      const category = tileRef != null ? "weather" : "color";
      const info = {
        id: key2,
        label: label2,
        tileRef,
        category
      };
      map2.set(key2.toLowerCase(), info);
      map2.set(label2.toLowerCase(), info);
    }
    const tileRefLabels = tileRefsMutationLabels;
    for (const [key2, value] of Object.entries(tileRefLabels)) {
      if (typeof key2 !== "string" || typeof value !== "string") continue;
      const info = map2.get(key2.toLowerCase());
      if (!info) continue;
      const normalizedLabel = value.toLowerCase();
      if (!map2.has(normalizedLabel)) {
        map2.set(normalizedLabel, info);
      }
    }
    const goldInfo = map2.get("gold");
    if (goldInfo) {
      map2.set("golden", goldInfo);
    }
    const normalInfo = {
      id: "Normal",
      label: "Normal",
      tileRef: null,
      category: "color"
    };
    map2.set("normal", normalInfo);
    return map2;
  })();
  var plantSpriteCache2 = /* @__PURE__ */ new Map();
  var plantSpritePromises2 = /* @__PURE__ */ new Map();
  var plantSpriteCanvasCache = /* @__PURE__ */ new Map();
  var plantSpriteCanvasPromises = /* @__PURE__ */ new Map();
  var plantSpriteVariantCache = /* @__PURE__ */ new Map();
  var plantSpriteVariantPromises = /* @__PURE__ */ new Map();
  var plantSpriteEffectVariantCache = /* @__PURE__ */ new Map();
  var plantSpriteEffectVariantPromises = /* @__PURE__ */ new Map();
  var mutationSpriteCache2 = /* @__PURE__ */ new Map();
  var mutationSpritePromises2 = /* @__PURE__ */ new Map();
  var spriteUpdateSeq = 0;
  var CROP_SIMULATION_CSS = `
.${ROOT_CLASS} {
  display: none;
  width: min(100%, 500px);
  padding: 12px 14px;
  color: #e2e8f0;
  display: flex;
  flex-direction: column;
  gap: 10px;
  font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
  position: relative;
  z-index: 2000;
  pointer-events: auto;
}
.${ROOT_CLASS} .mg-crop-simulation__header {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 8px;
}
.${ROOT_CLASS} .mg-crop-simulation__title {
  font-size: 13px;
  font-weight: 600;
  letter-spacing: 0.03em;
  text-transform: uppercase;
  color: #f8fafc;
}
.${ROOT_CLASS} .mg-crop-simulation__crop-name {
  font-size: 13px;
  font-weight: 600;
  color: #38bdf8;
  text-transform: capitalize;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-section {
  display: flex;
  flex-direction: column;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-box {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 12px;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: ${BASE_SPRITE_SIZE_PX}px;
  height: ${BASE_SPRITE_SIZE_PX}px;
  position: relative;
  flex-shrink: 0;
  --mg-crop-simulation-scale: 1;
  transform-origin: center;
  transform: scale(var(--mg-crop-simulation-scale));
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer,
.${ROOT_CLASS} .mg-crop-simulation__sprite-fallback {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  image-rendering: pixelated;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer--base {
  z-index: 1;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer--overlay {
  z-index: 2;
  transform: translateY(-4px);
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer--overlay-lighting {
  transform: translateY(-30px);
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-fallback {
  z-index: 0;
  font-size: 42px;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-container {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 6px;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-label {
  font-size: 12px;
  color: rgba(226, 232, 240, 0.82);
  flex: 0 0 auto;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-value {
  margin-left: auto;
  font-size: 12px;
  font-variant-numeric: tabular-nums;
  color: #f8fafc;
  text-align: right;
  width: 4ch;
  min-width: 4ch;
  flex: 0 0 4ch;
  white-space: nowrap;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-weight {
  font-size: 11px;
  color: rgba(148, 163, 184, 0.82);
  font-variant-numeric: tabular-nums;
  text-align: center;
  white-space: nowrap;
}
.${ROOT_CLASS} .mg-crop-simulation__slider {
  flex: 1 1 auto;
  min-width: 0;
  accent-color: #38bdf8;
}
.${ROOT_CLASS} .mg-crop-simulation__price {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-weight: 700;
  font-size: 14px;
  color: #ffd84d;
  align-self: flex-start;
  margin-top: auto;
}
.${ROOT_CLASS} .mg-crop-simulation__price-icon {
  width: 20px;
  height: 20px;
  flex: 0 0 auto;
  display: inline-block;
  user-select: none;
  pointer-events: none;
}
.${ROOT_CLASS} .mg-crop-simulation__price-value {
  line-height: 1;
}
.${ROOT_CLASS} .mg-crop-simulation__section-title {
  font-size: 11px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: rgba(148, 163, 184, 0.9);
}
.${ROOT_CLASS}.mg-crop-simulation--calculator {
  align-items: center;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__layout {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 12px;
  width: min(440px, 100%);
  margin: 0 auto;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__section {
  display: grid;
  gap: 10px;
  padding: 12px;
  border-radius: 12px;
  border: 1px solid #4446;
  background: #1f2328;
  box-shadow: 0 0 0 1px #0002 inset;
  justify-items: stretch;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__section-heading {
  font-size: 11px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: rgba(226, 232, 240, 0.82);
  font-weight: 600;
  text-align: center;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__section--preview {
  justify-items: center;
  text-align: center;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__section--preview .mg-crop-simulation__slider-row {
  width: 100%;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__mutations-weather {
  display: grid;
  gap: 8px;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__mutations-heading {
  font-size: 10px;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  color: rgba(148, 163, 184, 0.82);
  text-align: center;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-simulation__price {
  margin-top: 0;
}
.${ROOT_CLASS} .mg-crop-simulation__segmented {
  display: flex;
  width: 100%;
}
.${ROOT_CLASS} .mg-crop-simulation__segmented-control {
  --qmm-bg-soft: rgba(11, 15, 19, 0.8);
  --qmm-border-2: rgba(148, 163, 184, 0.28);
  --qmm-text: #e2e8f0;
  --qmm-text-dim: rgba(148, 163, 184, 0.82);
  --seg-pad: 6px;
  --seg-fill: rgba(56, 191, 248, 0.02);
  --seg-stroke-color: rgba(255, 255, 255, 0.49);
  flex: 1 1 auto;
  min-width: 0;
  width: 100%;
}
.${ROOT_CLASS} .mg-crop-simulation__segmented-control .qmm-seg__btn {
  font-size: 11px;
  letter-spacing: 0.02em;
  font-weight: 600;
  flex: 1 1 0;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  min-width: 0;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="none"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="none"].active {
  color: rgba(148, 163, 184, 0.92);
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="gold"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="gold"].active {
  color: #facc15;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="gold"] .qmm-seg__btn-label,
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="gold"].active .qmm-seg__btn-label {
  color: transparent;
  background-image: linear-gradient(90deg, #fef08a, #facc15, #fef08a);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-size: 100% 100%;
  background-repeat: no-repeat;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="rainbow"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="rainbow"].active {
  color: #fbbf24;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="rainbow"] .qmm-seg__btn-label,
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="rainbow"].active .qmm-seg__btn-label {
  color: transparent;
  background-image: linear-gradient(90deg, #f87171, #fbbf24, #34d399, #38bdf8, #c084fc);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-size: 100% 100%;
  background-repeat: no-repeat;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="none"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="none"].active,
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="none"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="none"].active {
  color: rgba(148, 163, 184, 0.92);
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="wet"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="wet"].active {
  color: #5AF6F5;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="chilled"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="chilled"].active {
  color: #AFE0F6;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="frozen"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="frozen"].active {
  color: #AABEFF;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="dawnlit"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="dawnlit"].active {
  color: #7864B4;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="dawnbound"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="dawnbound"].active {
  color: #9785CB;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="amberlit"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="amberlit"].active {
  color: #A04632;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="amberbound"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="amberbound"].active {
  color: #F06E50;
  font-weight: 700;
}
.${ROOT_CLASS} .mg-crop-simulation__mutations-section {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
`;
  var cropSimulationStyleEl = null;
  function ensureCropSimulationStyles() {
    if (cropSimulationStyleEl) return;
    cropSimulationStyleEl = addStyle(CROP_SIMULATION_CSS);
  }
  function resolveEffectNameToken(value) {
    if (typeof value !== "string") return null;
    const normalized = value.trim().toLowerCase();
    if (!normalized) return null;
    return EFFECT_NAME_BY_TOKEN.get(normalized) ?? null;
  }
  function getMutationEffectName(mutation) {
    return resolveEffectNameToken(mutation.id) ?? resolveEffectNameToken(mutation.label);
  }
  function getEffectPriority(effectName) {
    const lower = effectName.toLowerCase();
    return EFFECT_PRIORITY_BY_LOWER_NAME.get(lower) ?? Number.MAX_SAFE_INTEGER;
  }
  function isLightingEffect(effectName) {
    return LIGHTING_EFFECT_NAMES_LOWER.has(effectName.toLowerCase());
  }
  function normalizeEffectNames(effectNames) {
    const seen = /* @__PURE__ */ new Set();
    const order = /* @__PURE__ */ new Map();
    const normalized = [];
    effectNames.forEach((name, index) => {
      if (seen.has(name)) return;
      seen.add(name);
      normalized.push(name);
      order.set(name, index);
    });
    normalized.sort((a, b) => {
      const priorityDiff = getEffectPriority(a) - getEffectPriority(b);
      if (priorityDiff !== 0) return priorityDiff;
      return (order.get(a) ?? 0) - (order.get(b) ?? 0);
    });
    return normalized;
  }
  function getApplicableEffectNames(weatherMutations) {
    const effectNames = weatherMutations.map((mutation) => getMutationEffectName(mutation)).filter((value) => value != null);
    return normalizeEffectNames(effectNames);
  }
  function makeEffectCacheKey(seedKey, variant, effectNames) {
    return `${seedKey}::variant::${variant}::effects::${effectNames.join("+")}`;
  }
  function getMutationSheetBases() {
    const urls = /* @__PURE__ */ new Set();
    try {
      Sprites.listTilesByCategory(/mutations/i).forEach((url) => urls.add(url));
    } catch {
    }
    const bases = Array.from(urls, (url) => {
      const clean = url.split(/[?#]/)[0] ?? url;
      const file = clean.split("/").pop() ?? clean;
      return file.replace(/\.[^.]+$/, "");
    });
    return bases.length ? bases : ["mutations"];
  }
  async function fetchPlantSpriteCanvas(seedKey) {
    await ensureSpritesReady();
    if (typeof window === "undefined") return null;
    const entry = plantCatalog[seedKey];
    if (!entry) return null;
    const tileRef = entry?.crop?.tileRef ?? entry?.plant?.tileRef ?? entry?.seed?.tileRef;
    const bases = plantSheetBases2(seedKey);
    const index = toTileIndex3(tileRef, bases);
    if (index == null) return null;
    for (const base of bases) {
      try {
        const tiles = await loadTileSheet(base);
        const tile = tiles.find((t) => t.index === index);
        if (!tile) continue;
        const canvas = Sprites.toCanvas(tile);
        if (canvas && canvas.width > 0 && canvas.height > 0) {
          const copy2 = document.createElement("canvas");
          copy2.width = canvas.width;
          copy2.height = canvas.height;
          const ctx = copy2.getContext("2d");
          if (!ctx) continue;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(canvas, 0, 0);
          return copy2;
        }
      } catch {
      }
    }
    return null;
  }
  function loadPlantSpriteCanvas(seedKey) {
    const cached = plantSpriteCanvasCache.get(seedKey);
    if (cached !== void 0) return Promise.resolve(cached);
    const inFlight = plantSpriteCanvasPromises.get(seedKey);
    if (inFlight) return inFlight;
    const promise = fetchPlantSpriteCanvas(seedKey).then((canvas) => {
      plantSpriteCanvasCache.set(seedKey, canvas);
      plantSpriteCanvasPromises.delete(seedKey);
      return canvas;
    }).catch(() => {
      plantSpriteCanvasCache.set(seedKey, null);
      plantSpriteCanvasPromises.delete(seedKey);
      return null;
    });
    plantSpriteCanvasPromises.set(seedKey, promise);
    return promise;
  }
  async function loadPlantSpriteCanvasForVariant(seedKey, variant) {
    const canvas = await loadPlantSpriteCanvas(seedKey);
    if (!canvas) return null;
    if (variant === "normal") return canvas;
    const tileInfo = {
      sheet: "",
      url: "",
      index: 0,
      col: 0,
      row: 0,
      size: canvas.width,
      data: canvas
    };
    return Sprites.toCanvas(tileInfo);
  }
  function loadPlantSpriteVariant(seedKey, variant) {
    if (variant === "normal") {
      return loadPlantSprite2(seedKey);
    }
    const cacheKey = `${seedKey}::${variant}`;
    const cached = plantSpriteVariantCache.get(cacheKey);
    if (cached !== void 0) return Promise.resolve(cached);
    const inFlight = plantSpriteVariantPromises.get(cacheKey);
    if (inFlight) return inFlight;
    const promise = loadPlantSpriteCanvasForVariant(seedKey, variant).then((canvas) => {
      if (!canvas) return null;
      return canvas.toDataURL();
    }).then((src) => {
      plantSpriteVariantCache.set(cacheKey, src ?? null);
      plantSpriteVariantPromises.delete(cacheKey);
      return src ?? null;
    }).catch(() => {
      plantSpriteVariantCache.set(cacheKey, null);
      plantSpriteVariantPromises.delete(cacheKey);
      return null;
    });
    plantSpriteVariantPromises.set(cacheKey, promise);
    return promise;
  }
  function loadMutationSprite2(mutation) {
    const tileRef = mutation.tileRef;
    if (tileRef == null) return Promise.resolve(null);
    const cacheKey = mutation.id.toLowerCase();
    const cached = mutationSpriteCache2.get(cacheKey);
    if (cached !== void 0) return Promise.resolve(cached);
    const inFlight = mutationSpritePromises2.get(cacheKey);
    if (inFlight) return inFlight;
    const promise = (async () => {
      await ensureSpritesReady();
      const bases = getMutationSheetBases();
      const index = tileRef > 0 ? tileRef - 1 : tileRef;
      for (const base of bases) {
        try {
          const tiles = await loadTileSheet(base);
          const tile = tiles.find((t) => t.index === index);
          if (!tile) continue;
          const canvas = Sprites.toCanvas(tile);
          if (canvas && canvas.width > 0 && canvas.height > 0) {
            const copy2 = document.createElement("canvas");
            copy2.width = canvas.width;
            copy2.height = canvas.height;
            const ctx = copy2.getContext("2d");
            if (!ctx) continue;
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(canvas, 0, 0);
            return copy2.toDataURL();
          }
        } catch {
        }
      }
      return null;
    })().then((src) => {
      mutationSpriteCache2.set(cacheKey, src);
      mutationSpritePromises2.delete(cacheKey);
      return src;
    }).catch(() => {
      mutationSpriteCache2.set(cacheKey, null);
      mutationSpritePromises2.delete(cacheKey);
      return null;
    });
    mutationSpritePromises2.set(cacheKey, promise);
    return promise;
  }
  function plantSheetBases2(seedKey) {
    const urls = /* @__PURE__ */ new Set();
    try {
      Sprites.listPlants().forEach((url) => urls.add(url));
    } catch {
    }
    try {
      Sprites.listAllPlants().forEach((url) => urls.add(url));
    } catch {
    }
    const bases = Array.from(urls, (url) => {
      const clean = url.split(/[?#]/)[0] ?? url;
      const file = clean.split("/").pop() ?? clean;
      return file.replace(/\.[^.]+$/, "");
    });
    if (!seedKey) return bases.length ? bases : ["plants"];
    const normalizedBases = bases.map((base) => base.toLowerCase());
    const findPreferred = (predicate) => bases.filter((base, index) => predicate(base, normalizedBases[index] ?? base.toLowerCase()));
    if (TALL_PLANT_SEEDS2.has(seedKey)) {
      const tallExact = findPreferred((_, norm3) => norm3 === "tallplants");
      if (tallExact.length) return tallExact;
      const tallAny = findPreferred((base, norm3) => /tall/.test(base) || /tall/.test(norm3));
      if (tallAny.length) return tallAny;
    } else {
      const plantsExact = findPreferred((_, norm3) => norm3 === "plants");
      if (plantsExact.length) return plantsExact;
      const nonTall = findPreferred((base, norm3) => !/tall/.test(base) && !/tall/.test(norm3));
      if (nonTall.length) return nonTall;
    }
    return bases.length ? bases : ["plants"];
  }
  function toTileIndex3(tileRef, bases = []) {
    const value = typeof tileRef === "number" && Number.isFinite(tileRef) ? tileRef : Number(tileRef);
    if (!Number.isFinite(value)) return null;
    if (value <= 0) return value;
    const normalizedBases = bases.map((base) => base.toLowerCase());
    if (normalizedBases.some((base) => base.includes("tall"))) {
      return value - 1;
    }
    if (normalizedBases.some((base) => base.includes("plants"))) {
      return value - 1;
    }
    return value - 1;
  }
  function loadPlantSprite2(seedKey) {
    const cached = plantSpriteCache2.get(seedKey);
    if (cached !== void 0) return Promise.resolve(cached);
    const inFlight = plantSpritePromises2.get(seedKey);
    if (inFlight) return inFlight;
    const promise = loadPlantSpriteCanvas(seedKey).then((canvas) => {
      const src = canvas ? canvas.toDataURL() : null;
      plantSpriteCache2.set(seedKey, src);
      plantSpritePromises2.delete(seedKey);
      return src;
    }).catch(() => {
      plantSpriteCache2.set(seedKey, null);
      plantSpritePromises2.delete(seedKey);
      return null;
    });
    plantSpritePromises2.set(seedKey, promise);
    return promise;
  }
  function sortMutationsForRendering(mutations) {
    const entries = mutations.map((mutation, index) => ({ mutation, index }));
    entries.sort((a, b) => {
      const effectA = getMutationEffectName(a.mutation);
      const effectB = getMutationEffectName(b.mutation);
      const priorityA = effectA ? getEffectPriority(effectA) : Number.MAX_SAFE_INTEGER;
      const priorityB = effectB ? getEffectPriority(effectB) : Number.MAX_SAFE_INTEGER;
      if (priorityA !== priorityB) {
        return priorityA - priorityB;
      }
      return a.index - b.index;
    });
    return entries.map((entry) => entry.mutation);
  }
  function applyEffectToCanvas(canvas, effect) {
    if (!effect.colors.length) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.globalCompositeOperation = effect.blendMode;
    ctx.globalAlpha = effect.alpha;
    if (effect.colors.length === 1) {
      ctx.fillStyle = effect.colors[0] ?? "transparent";
    } else {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      const stops = effect.colors.length - 1;
      effect.colors.forEach((color, index) => {
        const stop2 = stops === 0 ? 0 : index / stops;
        gradient.addColorStop(stop2, color);
      });
      ctx.fillStyle = gradient;
    }
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function loadPlantSpriteWithEffects(seedKey, variant, effectNames) {
    const normalizedEffects = normalizeEffectNames(effectNames);
    if (!normalizedEffects.length) {
      return loadPlantSpriteVariant(seedKey, variant);
    }
    const cacheKey = makeEffectCacheKey(seedKey, variant, normalizedEffects);
    const cached = plantSpriteEffectVariantCache.get(cacheKey);
    if (cached !== void 0) return Promise.resolve(cached);
    const inFlight = plantSpriteEffectVariantPromises.get(cacheKey);
    if (inFlight) return inFlight;
    const promise = loadPlantSpriteCanvasForVariant(seedKey, variant).then((canvas) => {
      if (!canvas) return null;
      const copy2 = document.createElement("canvas");
      copy2.width = canvas.width;
      copy2.height = canvas.height;
      const ctx = copy2.getContext("2d");
      if (!ctx) return null;
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(canvas, 0, 0);
      normalizedEffects.forEach((effectName) => {
        const effect = EFFECTS_CONFIG[effectName];
        if (effect) {
          applyEffectToCanvas(copy2, effect);
        }
      });
      return copy2.toDataURL();
    }).then((src) => {
      plantSpriteEffectVariantCache.set(cacheKey, src ?? null);
      plantSpriteEffectVariantPromises.delete(cacheKey);
      return src ?? null;
    }).catch(() => {
      plantSpriteEffectVariantCache.set(cacheKey, null);
      plantSpriteEffectVariantPromises.delete(cacheKey);
      return null;
    });
    plantSpriteEffectVariantPromises.set(cacheKey, promise);
    return promise;
  }
  function getCachedPlantSpriteSource(seedKey, variant, effectNames) {
    const normalizedEffects = normalizeEffectNames(effectNames);
    if (normalizedEffects.length === 0) {
      if (variant === "normal") {
        return plantSpriteCache2.get(seedKey);
      }
      const variantCacheKey = `${seedKey}::${variant}`;
      return plantSpriteVariantCache.get(variantCacheKey);
    }
    const cacheKey = makeEffectCacheKey(seedKey, variant, normalizedEffects);
    return plantSpriteEffectVariantCache.get(cacheKey);
  }
  function isLightingOverlay(mutation) {
    const effectName = getMutationEffectName(mutation);
    if (!effectName) return false;
    return isLightingEffect(effectName);
  }
  function applySpriteElement(el2, baseSrc, overlayLayers, fallbackText) {
    el2.innerHTML = "";
    if (baseSrc) {
      const baseLayer = document.createElement("span");
      baseLayer.className = "mg-crop-simulation__sprite-layer mg-crop-simulation__sprite-layer--base";
      const img = document.createElement("img");
      img.src = baseSrc;
      img.alt = "";
      img.decoding = "async";
      img.loading = "lazy";
      img.draggable = false;
      baseLayer.appendChild(img);
      el2.appendChild(baseLayer);
    }
    overlayLayers.forEach(({ src, mutation }, index) => {
      const layer = document.createElement("span");
      layer.className = "mg-crop-simulation__sprite-layer mg-crop-simulation__sprite-layer--overlay";
      layer.style.setProperty("--mg-crop-simulation-layer", String(index + 1));
      if (isLightingOverlay(mutation)) {
        layer.classList.add("mg-crop-simulation__sprite-layer--overlay-lighting");
      }
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";
      img.decoding = "async";
      img.loading = "lazy";
      img.draggable = false;
      layer.appendChild(img);
      el2.appendChild(layer);
    });
    if (!baseSrc && overlayLayers.length === 0) {
      const fallback = document.createElement("span");
      fallback.className = "mg-crop-simulation__sprite-fallback";
      const content = typeof fallbackText === "string" && fallbackText.trim().length > 0 ? fallbackText : "\u{1F331}";
      fallback.textContent = content;
      el2.appendChild(fallback);
    }
  }
  function setSpriteElement(el2, speciesKey, options) {
    spriteUpdateSeq += 1;
    const seq = spriteUpdateSeq;
    el2.dataset.spriteSeq = String(seq);
    if (!speciesKey) {
      applySpriteElement(el2, null, [], options.fallback ?? null);
      return;
    }
    const { colorVariant, weatherMutations } = options;
    const sortedMutations = sortMutationsForRendering(weatherMutations);
    const effectNames = colorVariant === "normal" ? getApplicableEffectNames(sortedMutations) : [];
    const cachedBase = getCachedPlantSpriteSource(speciesKey, colorVariant, effectNames);
    const cachedOverlays = sortedMutations.map((mutation) => {
      const src = mutationSpriteCache2.get(mutation.id.toLowerCase());
      return typeof src === "string" && src.length > 0 ? { mutation, src } : null;
    }).filter((value) => value != null);
    const baseSrcCached = typeof cachedBase === "string" ? cachedBase : null;
    applySpriteElement(el2, baseSrcCached, cachedOverlays, options.fallback ?? null);
    const basePromise = loadPlantSpriteWithEffects(speciesKey, colorVariant, effectNames);
    const overlayPromises = sortedMutations.map(async (mutation) => ({
      mutation,
      src: await loadMutationSprite2(mutation)
    }));
    Promise.all([basePromise, Promise.all(overlayPromises)]).then(([baseSrc, overlays]) => {
      if (el2.dataset.spriteSeq !== String(seq)) return;
      const overlaySources = overlays.filter(
        (entry) => typeof entry.src === "string" && entry.src.length > 0
      );
      applySpriteElement(el2, baseSrc ?? null, overlaySources, options.fallback ?? null);
    }).catch(() => {
      if (el2.dataset.spriteSeq !== String(seq)) return;
      applySpriteElement(el2, null, [], options.fallback ?? null);
    });
  }
  function labelToVariant(label2) {
    const normalized = typeof label2 === "string" ? label2.trim().toLowerCase() : "";
    if (normalized === "gold") return "gold";
    if (normalized === "rainbow") return "rainbow";
    return "normal";
  }
  function normalizeMutationName2(name) {
    if (typeof name !== "string") return null;
    const trimmed = name.trim();
    if (!trimmed) return null;
    const normalized = trimmed.toLowerCase();
    const info = mutationMetadataByNormalizedName.get(normalized);
    if (info) {
      return info;
    }
    const normalizedLabel = WEATHER_LABEL_NORMALIZATION.get(normalized);
    if (normalizedLabel) {
      const fallback = mutationMetadataByNormalizedName.get(normalizedLabel.toLowerCase());
      if (fallback) {
        return fallback;
      }
    }
    return {
      id: trimmed,
      label: trimmed,
      tileRef: null,
      category: "weather"
    };
  }
  function applyCropSimulationSprite(el2, speciesKey, options = {}) {
    const colorLabel = options.colorLabel ?? "None";
    const colorVariant = labelToVariant(colorLabel);
    const weatherLabels = Array.isArray(options.weatherLabels) ? options.weatherLabels : [];
    const seen = /* @__PURE__ */ new Set();
    const weatherMutations = [];
    for (const label2 of weatherLabels) {
      if (!label2 || typeof label2 !== "string") continue;
      const info = normalizeMutationName2(label2);
      if (!info || info.category !== "weather") continue;
      const key2 = info.id.toLowerCase();
      if (seen.has(key2)) continue;
      seen.add(key2);
      weatherMutations.push(info);
    }
    setSpriteElement(el2, speciesKey, {
      colorVariant,
      weatherMutations,
      fallback: options.fallback ?? null
    });
  }
  var applyStyles2 = (el2, styles) => {
    const toKebab = (s) => s.startsWith("--") ? s : s.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase());
    for (const [key2, value] of Object.entries(styles)) {
      el2.style.setProperty(toKebab(key2), value);
    }
    return el2;
  };
  var calculatorStyleEl = null;
  function ensureCalculatorStyles() {
    ensureCropSimulationStyles();
    if (calculatorStyleEl) return;
    calculatorStyleEl = addStyle(`
    .${ROOT_CLASS}.mg-crop-simulation--calculator {
      width: 100%;
      max-width: none;
      min-width: 0;
      position: relative;
    }
    .${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-simulation__price {
      justify-content: center;
      margin: 0 0 12px;
      font-size: 20px;
      gap: 10px;
    }
    .${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-simulation__price-value {
      font-size: 20px;
    }
    .mg-crop-calculator__placeholder {
      font-size: 13px;
      text-align: center;
      opacity: 0.7;
      padding: 24px 12px;
    }
  `);
  }
  function clamp3(value, min, max) {
    return Math.min(max, Math.max(min, value));
  }
  function coerceLabel(label2, allowed) {
    const normalized = typeof label2 === "string" ? label2.trim().toLowerCase() : "";
    for (const candidate of allowed) {
      if (candidate.toLowerCase() === normalized) {
        return candidate;
      }
    }
    return allowed[0];
  }
  function clampFriendPlayers(players) {
    if (typeof players !== "number" || !Number.isFinite(players)) {
      return FRIEND_BONUS_MIN_PLAYERS;
    }
    const rounded = Math.round(players);
    return clamp3(rounded, FRIEND_BONUS_MIN_PLAYERS, FRIEND_BONUS_MAX_PLAYERS);
  }
  function friendPlayersToLabel(players) {
    const clamped = clampFriendPlayers(players);
    return FRIEND_BONUS_LABELS[clamped - 1] ?? FRIEND_BONUS_LABELS[0];
  }
  function labelToFriendPlayers(label2) {
    const coerced = coerceLabel(label2, FRIEND_BONUS_LABELS);
    const index = FRIEND_BONUS_LABELS.indexOf(coerced);
    const players = index >= 0 ? index + 1 : FRIEND_BONUS_MIN_PLAYERS;
    return clamp3(players, FRIEND_BONUS_MIN_PLAYERS, FRIEND_BONUS_MAX_PLAYERS);
  }
  function setSpriteScale(el2, sizePercent) {
    const clamped = clamp3(Math.round(sizePercent), SIZE_MIN, SIZE_MAX);
    const scale = clamped / 100;
    el2.style.setProperty("--mg-crop-simulation-scale", scale.toString());
  }
  function applySizePercent(refs, sizePercent, maxScale, baseWeight) {
    const clamped = clamp3(Math.round(sizePercent), SIZE_MIN, SIZE_MAX);
    refs.sizeSlider.value = String(clamped);
    refs.sizeValue.textContent = `${clamped}%`;
    setSpriteScale(refs.sprite, clamped);
    if (typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > SCALE_MIN) {
      refs.sizeSlider.dataset.maxScale = String(maxScale);
    } else {
      delete refs.sizeSlider.dataset.maxScale;
    }
    const [minWeight, maxWeight] = computeWeightRange(baseWeight, clamped, maxScale);
    refs.sizeWeight.textContent = formatWeightRange(minWeight, maxWeight);
  }
  function formatCoinValue(value) {
    if (typeof value !== "number" || !Number.isFinite(value)) return "\u2014";
    const safe = Math.max(0, Math.round(value));
    return priceFormatter.format(safe);
  }
  function formatCoinRange(min, max) {
    const minValue = typeof min === "number" && Number.isFinite(min) ? Math.max(0, min) : null;
    const maxValue = typeof max === "number" && Number.isFinite(max) ? Math.max(0, max) : null;
    if (minValue == null && maxValue == null) return "\u2014";
    if (minValue == null) return formatCoinValue(maxValue);
    if (maxValue == null) return formatCoinValue(minValue);
    if (Math.round(minValue) === Math.round(maxValue)) {
      return formatCoinValue(minValue);
    }
    return `${formatCoinValue(minValue)} \u2013 ${formatCoinValue(maxValue)}`;
  }
  function computeWeightRange(baseWeight, sizePercent, maxScale) {
    const numericWeight = typeof baseWeight === "number" ? baseWeight : Number(baseWeight);
    if (!Number.isFinite(numericWeight) || numericWeight == null || numericWeight <= 0) {
      return [null, null];
    }
    const scale = sizePercentToScale(sizePercent, maxScale);
    if (!Number.isFinite(scale) || scale <= 0) {
      return [null, null];
    }
    const minWeight = numericWeight * scale;
    const safeMax = typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > SCALE_MIN ? maxScale : SCALE_MIN;
    const variation = 1 + Math.max(0, (safeMax - scale) * 0.02);
    const maxWeight = minWeight * variation;
    return [minWeight, maxWeight];
  }
  function formatWeight(value) {
    if (typeof value !== "number" || !Number.isFinite(value) || value <= 0) return null;
    const formatted = weightFormatter.format(value);
    return formatted.replace(/(\.\d*?[1-9])0+$/u, "$1").replace(/\.0+$/u, "");
  }
  function formatWeightRange(min, max) {
    const minFormatted = formatWeight(min);
    const maxFormatted = formatWeight(max);
    if (!minFormatted && !maxFormatted) return "\u2014";
    if (!maxFormatted || minFormatted === maxFormatted) {
      return `${minFormatted ?? maxFormatted} kg`;
    }
    return `${minFormatted ?? "\u2014"} \u2013 ${maxFormatted} kg`;
  }
  function sizePercentToScale(sizePercent, maxScale) {
    const numeric = Number(sizePercent);
    if (!Number.isFinite(numeric)) return SCALE_MIN;
    const clampedPercent = clamp3(numeric, SIZE_MIN, SIZE_MAX);
    const safeMax = typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > SCALE_MIN ? maxScale : SCALE_MAX;
    if (safeMax <= SCALE_MIN) return SCALE_MIN;
    const normalized = (clampedPercent - SIZE_MIN) / (SIZE_MAX - SIZE_MIN);
    const scale = SCALE_MIN + normalized * (safeMax - SCALE_MIN);
    return Number.isFinite(scale) ? scale : SCALE_MIN;
  }
  function createSegmentedControl(labels, selectedLabel, interactive, onSelect, ariaLabel) {
    const coerced = coerceLabel(selectedLabel, labels);
    const items = labels.map((label2) => ({ value: label2, label: label2, disabled: !interactive }));
    const segmented = segmentedUi.segmented(
      items,
      coerced,
      interactive && onSelect ? (value) => onSelect(value) : void 0,
      { ariaLabel, fullWidth: true }
    );
    segmented.classList.add("mg-crop-simulation__segmented-control");
    return segmented;
  }
  function applySegmentedButtonMetadata(segmented, metadata) {
    const buttons = segmented.querySelectorAll(".qmm-seg__btn");
    buttons.forEach((button) => {
      const label2 = button.textContent?.trim();
      if (!label2) return;
      const meta = metadata[label2];
      if (!meta) return;
      Object.entries(meta).forEach(([key2, value]) => {
        if (!value) return;
        button.dataset[key2] = value;
      });
    });
  }
  function getMutationsForState(state2) {
    const mutations = [];
    if (state2.color !== "None") mutations.push(state2.color);
    if (state2.weatherCondition !== "None") mutations.push(state2.weatherCondition);
    if (state2.weatherLighting !== "None") mutations.push(state2.weatherLighting);
    return mutations;
  }
  function getWeatherLabelsForState(state2) {
    const labels = [];
    if (state2.weatherCondition !== "None") labels.push(state2.weatherCondition);
    if (state2.weatherLighting !== "None") labels.push(state2.weatherLighting);
    return labels;
  }
  function computePrice(speciesKey, state2, percent, maxScale) {
    const scale = sizePercentToScale(percent, maxScale);
    if (!Number.isFinite(scale) || scale <= 0) return null;
    const mutations = getMutationsForState(state2);
    const friendPlayers = clampFriendPlayers(state2.friendPlayers);
    const pricingOptions = { ...DefaultPricing, friendPlayers };
    const value = estimateProduceValue(speciesKey, scale, mutations, pricingOptions);
    return Number.isFinite(value) && value > 0 ? value : null;
  }
  function getMaxScaleForSpecies(key2) {
    const entry = plantCatalog[key2];
    const candidates = [entry?.crop?.maxScale, entry?.plant?.maxScale, entry?.seed?.maxScale];
    for (const candidate of candidates) {
      const numeric = typeof candidate === "number" ? candidate : Number(candidate);
      if (Number.isFinite(numeric) && numeric > 0) {
        return numeric;
      }
    }
    return null;
  }
  function getBaseWeightForSpecies(key2) {
    const entry = plantCatalog[key2];
    const candidates = [
      entry?.produce?.baseWeight,
      entry?.crop?.baseWeight,
      entry?.item?.baseWeight,
      entry?.seed?.baseWeight
    ];
    for (const candidate of candidates) {
      const numeric = typeof candidate === "number" ? candidate : Number(candidate);
      if (Number.isFinite(numeric) && numeric > 0) {
        return numeric;
      }
    }
    return null;
  }
  async function renderCalculatorMenu(container) {
    ensureCalculatorStyles();
    scheduleLockerSpritePreload();
    const ui = new Menu({ id: "calculator", compact: true });
    ui.addTab("crops", "Crops", (root) => {
      root.innerHTML = "";
      root.style.padding = "8px";
      root.style.boxSizing = "border-box";
      root.style.height = "61vh";
      root.style.overflow = "auto";
      root.style.display = "grid";
      const layout = applyStyles2(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "minmax(220px, 280px) minmax(0, 1fr)",
        gap: "10px",
        alignItems: "stretch",
        height: "100%",
        overflow: "hidden"
      });
      root.appendChild(layout);
      const left = applyStyles2(document.createElement("div"), {
        display: "grid",
        gridTemplateRows: "minmax(0, 1fr)",
        minHeight: "0",
        flex: "0 0 260px",
        minWidth: "220px",
        maxWidth: "280px"
      });
      layout.appendChild(left);
      const list = applyStyles2(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "1fr",
        overflow: "auto",
        paddingRight: "2px",
        border: "1px solid #4445",
        borderRadius: "10px",
        minHeight: "0",
        // important
        height: "100%"
        // pour que overflow: auto prenne effet
      });
      left.appendChild(list);
      const right = applyStyles2(document.createElement("div"), {
        display: "flex",
        flexDirection: "column",
        minHeight: "0",
        flex: "1 1 auto"
      });
      layout.appendChild(right);
      const detailScroll = applyStyles2(document.createElement("div"), {
        flex: "1 1 auto",
        overflow: "auto",
        display: "flex",
        justifyContent: "center"
      });
      right.appendChild(detailScroll);
      const simulationRoot = document.createElement("div");
      simulationRoot.className = `${ROOT_CLASS} mg-crop-simulation--visible mg-crop-simulation--calculator`;
      const detailLayout = document.createElement("div");
      detailLayout.className = "mg-crop-calculator__layout";
      const createSection = (title, extraClass) => {
        const section = document.createElement("div");
        section.className = "mg-crop-calculator__section";
        if (extraClass) {
          section.classList.add(extraClass);
        }
        if (title) {
          const heading = document.createElement("div");
          heading.className = "mg-crop-calculator__section-heading";
          heading.textContent = title;
          section.appendChild(heading);
        }
        return section;
      };
      const previewSection = createSection(null, "mg-crop-calculator__section--preview");
      const priceRow = document.createElement("div");
      priceRow.className = "mg-crop-simulation__price";
      const priceIcon = document.createElement("img");
      priceIcon.className = "mg-crop-simulation__price-icon";
      priceIcon.src = coin.img64;
      priceIcon.alt = "";
      priceIcon.decoding = "async";
      priceIcon.loading = "lazy";
      priceIcon.setAttribute("aria-hidden", "true");
      priceIcon.draggable = false;
      const priceValue = document.createElement("span");
      priceValue.className = "mg-crop-simulation__price-value";
      priceValue.textContent = "\u2014";
      priceRow.append(priceIcon, priceValue);
      const spriteSection = document.createElement("div");
      spriteSection.className = "mg-crop-simulation__sprite-section";
      const spriteBox = document.createElement("div");
      spriteBox.className = "mg-crop-simulation__sprite-box";
      const sprite = document.createElement("span");
      sprite.className = "mg-crop-simulation__sprite";
      spriteBox.appendChild(sprite);
      const sliderContainer = document.createElement("div");
      sliderContainer.className = "mg-crop-simulation__slider-container";
      const sliderRow = document.createElement("div");
      sliderRow.className = "mg-crop-simulation__slider-row";
      const sliderLabel = document.createElement("span");
      sliderLabel.className = "mg-crop-simulation__slider-label";
      sliderLabel.textContent = "Size";
      const slider = ui.slider(SIZE_MIN, SIZE_MAX, 1, SIZE_MIN);
      slider.classList.add("mg-crop-simulation__slider");
      slider.disabled = true;
      const sliderValue = document.createElement("span");
      sliderValue.className = "mg-crop-simulation__slider-value";
      sliderValue.textContent = `${SIZE_MIN}%`;
      const sliderWeight = document.createElement("span");
      sliderWeight.className = "mg-crop-simulation__slider-weight";
      sliderWeight.textContent = "\u2014";
      sliderRow.append(sliderLabel, slider, sliderValue);
      sliderContainer.append(sliderRow, sliderWeight);
      spriteSection.append(spriteBox, sliderContainer);
      previewSection.appendChild(spriteSection);
      const mutationsSection = createSection("Mutations");
      const colorList = document.createElement("div");
      colorList.className = "mg-crop-simulation__segmented";
      mutationsSection.appendChild(colorList);
      const weatherContainer = document.createElement("div");
      weatherContainer.className = "mg-crop-calculator__mutations-weather";
      const weatherConditions = document.createElement("div");
      weatherConditions.className = "mg-crop-simulation__segmented";
      const weatherLighting = document.createElement("div");
      weatherLighting.className = "mg-crop-simulation__segmented";
      weatherContainer.append(weatherConditions, weatherLighting);
      mutationsSection.appendChild(weatherContainer);
      const friendBonusSection = createSection("Friend bonus", "mg-crop-calculator__section--friend-bonus");
      const friendBonus = document.createElement("div");
      friendBonus.className = "mg-crop-simulation__segmented";
      friendBonusSection.appendChild(friendBonus);
      detailLayout.append(
        priceRow,
        previewSection,
        mutationsSection,
        friendBonusSection
      );
      simulationRoot.appendChild(detailLayout);
      detailScroll.appendChild(simulationRoot);
      const refs = {
        root: simulationRoot,
        sprite,
        sizeSlider: slider,
        sizeValue: sliderValue,
        sizeWeight: sliderWeight,
        colorMutations: colorList,
        weatherConditions,
        weatherLighting,
        friendBonus,
        priceValue
      };
      const states = /* @__PURE__ */ new Map();
      const optionByKey = /* @__PURE__ */ new Map();
      const options = getLockerSeedOptions();
      options.forEach((opt) => optionByKey.set(opt.key, opt));
      const getStateForKey = (key2) => {
        const existing = states.get(key2);
        if (existing) return existing;
        const state2 = { ...DEFAULT_STATE2 };
        states.set(key2, state2);
        return state2;
      };
      let selectedKey = null;
      let currentMaxScale = null;
      let currentBaseWeight = null;
      function renderColorSegment(state2, interactive) {
        const active = state2?.color ?? COLOR_MUTATION_LABELS[0];
        const segmented = createSegmentedControl(
          COLOR_MUTATION_LABELS,
          active,
          interactive,
          interactive ? (label2) => {
            if (!selectedKey) return;
            const target = getStateForKey(selectedKey);
            target.color = coerceLabel(label2, COLOR_MUTATION_LABELS);
            renderColorSegment(target, true);
            renderWeatherConditions(target, true);
            renderWeatherLighting(target, true);
            updateSprite();
            updateOutputs();
          } : void 0,
          "Mutations"
        );
        applySegmentedButtonMetadata(segmented, COLOR_SEGMENT_METADATA);
        refs.colorMutations.innerHTML = "";
        refs.colorMutations.appendChild(segmented);
      }
      function renderWeatherConditions(state2, interactive) {
        const active = state2?.weatherCondition ?? WEATHER_CONDITION_LABELS[0];
        const segmented = createSegmentedControl(
          WEATHER_CONDITION_LABELS,
          active,
          interactive,
          interactive ? (label2) => {
            if (!selectedKey) return;
            const target = getStateForKey(selectedKey);
            target.weatherCondition = coerceLabel(label2, WEATHER_CONDITION_LABELS);
            renderWeatherConditions(target, true);
            updateSprite();
            updateOutputs();
          } : void 0,
          "Weather condition"
        );
        applySegmentedButtonMetadata(segmented, WEATHER_CONDITION_SEGMENT_METADATA);
        refs.weatherConditions.innerHTML = "";
        refs.weatherConditions.appendChild(segmented);
      }
      function renderWeatherLighting(state2, interactive) {
        const active = state2?.weatherLighting ?? WEATHER_LIGHTING_LABELS[0];
        const segmented = createSegmentedControl(
          WEATHER_LIGHTING_LABELS,
          active,
          interactive,
          interactive ? (label2) => {
            if (!selectedKey) return;
            const target = getStateForKey(selectedKey);
            target.weatherLighting = coerceLabel(label2, WEATHER_LIGHTING_LABELS);
            renderWeatherLighting(target, true);
            updateSprite();
            updateOutputs();
          } : void 0,
          "Weather lighting"
        );
        applySegmentedButtonMetadata(segmented, WEATHER_LIGHTING_SEGMENT_METADATA);
        refs.weatherLighting.innerHTML = "";
        refs.weatherLighting.appendChild(segmented);
      }
      function renderFriendBonus(state2, interactive) {
        const active = friendPlayersToLabel(state2?.friendPlayers ?? FRIEND_BONUS_MIN_PLAYERS);
        const segmented = createSegmentedControl(
          FRIEND_BONUS_LABELS,
          active,
          interactive,
          interactive ? (label2) => {
            if (!selectedKey) return;
            const target = getStateForKey(selectedKey);
            target.friendPlayers = labelToFriendPlayers(label2);
            renderFriendBonus(target, true);
            updateOutputs();
          } : void 0,
          "Friend bonus"
        );
        refs.friendBonus.innerHTML = "";
        refs.friendBonus.appendChild(segmented);
      }
      function updateOutputs() {
        const key2 = selectedKey;
        if (!key2) {
          refs.priceValue.textContent = "\u2014";
          return;
        }
        const state2 = getStateForKey(key2);
        const min = computePrice(key2, state2, state2.sizePercent, currentMaxScale);
        const maxPercent = Math.min(SIZE_MAX, state2.sizePercent + 1);
        const max = computePrice(key2, state2, maxPercent, currentMaxScale);
        refs.priceValue.textContent = formatCoinRange(min, max);
      }
      function updateSprite() {
        const key2 = selectedKey;
        if (!key2) {
          refs.sprite.innerHTML = "";
          return;
        }
        const state2 = getStateForKey(key2);
        const option = optionByKey.get(key2);
        const fallbackEmoji = getLockerSeedEmojiForKey(key2) || (option?.seedName ? getLockerSeedEmojiForSeedName(option.seedName) : void 0) || "\u{1F331}";
        applyCropSimulationSprite(refs.sprite, key2, {
          colorLabel: state2.color,
          weatherLabels: getWeatherLabelsForState(state2),
          fallback: fallbackEmoji
        });
      }
      function renderDetail() {
        const key2 = selectedKey;
        if (!key2) {
          refs.sprite.innerHTML = "";
          refs.sizeSlider.disabled = true;
          currentBaseWeight = null;
          applySizePercent(refs, SIZE_MIN, null, currentBaseWeight);
          renderColorSegment(null, false);
          renderWeatherConditions(null, false);
          renderWeatherLighting(null, false);
          renderFriendBonus(null, false);
          refs.priceValue.textContent = "\u2014";
          return;
        }
        currentMaxScale = getMaxScaleForSpecies(key2);
        currentBaseWeight = getBaseWeightForSpecies(key2);
        const state2 = getStateForKey(key2);
        refs.sizeSlider.disabled = false;
        applySizePercent(refs, state2.sizePercent, currentMaxScale, currentBaseWeight);
        renderColorSegment(state2, true);
        renderWeatherConditions(state2, true);
        renderWeatherLighting(state2, true);
        renderFriendBonus(state2, true);
        updateSprite();
        updateOutputs();
      }
      slider.addEventListener("input", () => {
        if (!selectedKey) return;
        const state2 = getStateForKey(selectedKey);
        const raw = Number(slider.value);
        const value = clamp3(Math.round(raw), SIZE_MIN, SIZE_MAX);
        state2.sizePercent = value;
        applySizePercent(refs, value, currentMaxScale, currentBaseWeight);
        updateOutputs();
      });
      function renderList() {
        const previous = list.scrollTop;
        list.innerHTML = "";
        if (!options.length) {
          const empty = document.createElement("div");
          empty.className = "mg-crop-calculator__placeholder";
          empty.textContent = "No crops available.";
          list.appendChild(empty);
          selectedKey = null;
          currentMaxScale = null;
          renderDetail();
          return;
        }
        if (selectedKey && !options.some((opt) => opt.key === selectedKey)) {
          selectedKey = options[0].key;
          currentMaxScale = getMaxScaleForSpecies(selectedKey);
        }
        if (!selectedKey) {
          selectedKey = options[0].key;
          currentMaxScale = getMaxScaleForSpecies(selectedKey);
        }
        const fragment = document.createDocumentFragment();
        scheduleLockerSpritePreload();
        options.forEach((opt) => {
          const button = document.createElement("button");
          button.className = "qmm-vtab";
          button.style.display = "grid";
          button.style.gridTemplateColumns = "16px 1fr auto";
          button.style.alignItems = "center";
          button.style.gap = "8px";
          button.style.textAlign = "left";
          button.style.padding = "6px 8px";
          button.style.marginBottom = "6px";
          button.style.borderRadius = "8px";
          button.style.border = "1px solid #4445";
          button.style.background = selectedKey === opt.key ? "#2b8a3e" : "#1f2328";
          button.style.color = "#e7eef7";
          const dot = document.createElement("span");
          dot.className = "qmm-dot";
          dot.style.background = selectedKey === opt.key ? "#2ecc71" : "#4c566a";
          const label2 = document.createElement("span");
          label2.className = "label";
          label2.textContent = opt.cropName || opt.key;
          const fallbackEmoji = getLockerSeedEmojiForKey(opt.key) || getLockerSeedEmojiForSeedName(opt.seedName) || "\u{1F331}";
          const sprite2 = createPlantSprite(opt.key, {
            size: 24,
            fallback: fallbackEmoji
          });
          button.append(dot, label2, sprite2);
          button.onmouseenter = () => button.style.borderColor = "#6aa1";
          button.onmouseleave = () => button.style.borderColor = "#4445";
          button.onclick = () => {
            if (selectedKey === opt.key) return;
            selectedKey = opt.key;
            currentMaxScale = getMaxScaleForSpecies(opt.key);
            renderList();
          };
          fragment.appendChild(button);
        });
        list.appendChild(fragment);
        list.scrollTop = previous;
        renderDetail();
      }
      renderList();
    });
    ui.mount(container);
  }

  // src/services/pet-alerts.ts
  var clampPct2 = (v) => Math.max(1, Math.min(100, Math.round(v)));
  var prefs = {
    globalEnabled: true,
    generalEnabled: false,
    defaultThresholdPct: 25,
    pets: {}
  };
  var started4 = false;
  var unsubPets = null;
  var lastPets = [];
  var seenBelow = /* @__PURE__ */ new Map();
  function loadPrefs() {
    try {
      const parsed = readAriesPath("pets.alerts");
      if (parsed && typeof parsed === "object") {
        prefs = {
          globalEnabled: parsed.globalEnabled !== false,
          generalEnabled: !!parsed.generalEnabled,
          defaultThresholdPct: clampPct2(parsed.defaultThresholdPct ?? prefs.defaultThresholdPct),
          pets: typeof parsed.pets === "object" && parsed.pets ? parsed.pets : {}
        };
      }
    } catch {
    }
    return prefs;
  }
  function savePrefs() {
    try {
      writeAriesPath("pets.alerts", prefs);
    } catch {
    }
  }
  function prefFor(petId) {
    const baseThreshold = clampPct2(prefs.defaultThresholdPct);
    if (prefs.generalEnabled) {
      return { enabled: prefs.globalEnabled !== false, thresholdPct: baseThreshold };
    }
    if (!petId) return { enabled: false, thresholdPct: baseThreshold };
    const entry = prefs.pets[petId] ?? {};
    const enabled = entry.enabled ?? false;
    const thresholdPct = clampPct2(entry.thresholdPct ?? baseThreshold);
    return { enabled, thresholdPct };
  }
  async function triggerAlert(key2) {
    try {
      await audio.trigger(key2, {}, "pets");
    } catch {
    }
  }
  function evaluatePet(pet) {
    const petId = String(pet?.slot?.id || "");
    if (!petId || !prefs.globalEnabled) {
      seenBelow.set(petId, false);
      return;
    }
    const { enabled, thresholdPct } = prefFor(petId);
    const hungerPct = PetsService.getHungerPctFor(pet);
    const below = enabled && Number.isFinite(hungerPct) && hungerPct < thresholdPct;
    const wasBelow = seenBelow.get(petId) === true;
    const loopKey = prefs.generalEnabled ? "pets:general" : `pet:${petId}`;
    const mode = audio.getPlaybackMode?.("pets") ?? "oneshot";
    if (below) {
      if (mode === "loop") {
        void triggerAlert(loopKey);
      } else if (!wasBelow) {
        void triggerAlert(loopKey);
      }
    } else {
      try {
        audio.stopLoop(loopKey);
      } catch {
      }
    }
    seenBelow.set(petId, below);
  }
  async function evaluateAll(pets = null) {
    const list = pets ?? lastPets;
    for (const pet of Array.isArray(list) ? list : []) {
      try {
        evaluatePet(pet);
      } catch {
      }
    }
  }
  async function ensureStarted() {
    if (started4) return;
    loadPrefs();
    try {
      unsubPets = await PetsService.onPetsChangeNow((arr) => {
        lastPets = Array.isArray(arr) ? arr.slice(0, 3) : [];
        void evaluateAll(lastPets);
      });
    } catch {
      unsubPets = null;
    }
    started4 = true;
  }
  function stop() {
    try {
      unsubPets?.();
    } catch {
    }
    unsubPets = null;
    started4 = false;
    seenBelow.clear();
  }
  var PetAlertService = {
    async start() {
      await ensureStarted();
      return () => stop();
    },
    isGlobalEnabled() {
      return prefs.globalEnabled !== false;
    },
    setGlobalEnabled(on) {
      prefs.globalEnabled = !!on;
      if (!on) seenBelow.clear();
      savePrefs();
    },
    isGeneralEnabled() {
      return !!prefs.generalEnabled;
    },
    setGeneralEnabled(on) {
      prefs.generalEnabled = !!on;
      savePrefs();
      void this.refreshNow();
    },
    getGeneralThresholdPct() {
      return clampPct2(prefs.defaultThresholdPct);
    },
    setGeneralThresholdPct(pct) {
      const next = clampPct2(pct);
      prefs.defaultThresholdPct = next;
      savePrefs();
      void this.refreshNow();
      return next;
    },
    getDefaultThresholdPct() {
      return clampPct2(prefs.defaultThresholdPct);
    },
    setDefaultThresholdPct(pct) {
      const next = clampPct2(pct);
      prefs.defaultThresholdPct = next;
      savePrefs();
      return next;
    },
    isPetEnabled(petId) {
      return prefFor(petId).enabled;
    },
    setPetEnabled(petId, on) {
      if (!petId) return;
      prefs.pets[petId] = { ...prefs.pets[petId] || {}, enabled: !!on };
      savePrefs();
      void evaluateAll();
    },
    getPetThresholdPct(petId) {
      return prefFor(petId).thresholdPct;
    },
    setPetThresholdPct(petId, pct) {
      if (!petId) return this.getDefaultThresholdPct();
      const next = clampPct2(pct);
      prefs.pets[petId] = { ...prefs.pets[petId] || {}, thresholdPct: next };
      savePrefs();
      void evaluateAll();
      return next;
    },
    async refreshNow() {
      await evaluateAll();
    }
  };

  // src/ui/menus/notifier.ts
  var rulePopover = null;
  var detachRuleDocHandler = null;
  var detachRuleKeyBlocker = null;
  var detachRuleWheelBlocker = null;
  var detachRuleDragHandler = null;
  var closeRuleEditor = () => {
    if (rulePopover) {
      try {
        rulePopover.remove();
      } catch {
      }
      rulePopover = null;
    }
    if (detachRuleDocHandler) {
      detachRuleDocHandler();
      detachRuleDocHandler = null;
    }
    if (detachRuleKeyBlocker) {
      detachRuleKeyBlocker();
      detachRuleKeyBlocker = null;
    }
    if (detachRuleWheelBlocker) {
      detachRuleWheelBlocker();
      detachRuleWheelBlocker = null;
    }
    if (detachRuleDragHandler) {
      detachRuleDragHandler();
      detachRuleDragHandler = null;
    }
  };
  var setSwitchCapState = (wrap, capped) => {
    if (capped) {
      wrap.setAttribute("aria-disabled", "true");
      wrap.style.opacity = "0.5";
      wrap.style.pointerEvents = "none";
      wrap.style.cursor = "not-allowed";
      wrap.title = "Max owned \u2014 notifications disabled";
    } else {
      wrap.removeAttribute("aria-disabled");
      wrap.style.opacity = "";
      wrap.style.pointerEvents = "";
      wrap.style.cursor = "";
      wrap.removeAttribute("title");
    }
  };
  var createSwitch = (onToggle) => {
    const wrap = document.createElement("label");
    wrap.style.display = "inline-flex";
    wrap.style.alignItems = "center";
    wrap.style.justifyContent = "center";
    wrap.style.width = "100%";
    wrap.style.padding = "4px 6px";
    wrap.style.userSelect = "none";
    wrap.setAttribute("role", "switch");
    wrap.setAttribute("aria-checked", "false");
    const box = document.createElement("span");
    box.style.position = "relative";
    box.style.width = "42px";
    box.style.height = "24px";
    box.style.borderRadius = "999px";
    box.style.background = "#1f2328";
    box.style.border = "1px solid #4446";
    box.style.display = "inline-block";
    box.style.boxShadow = "inset 0 0 0 1px #0005";
    const knob = document.createElement("span");
    knob.style.position = "absolute";
    knob.style.top = "50%";
    knob.style.left = "3px";
    knob.style.transform = "translateY(-50%)";
    knob.style.width = "18px";
    knob.style.height = "18px";
    knob.style.borderRadius = "50%";
    knob.style.background = "#e7eef7";
    knob.style.boxShadow = "0 1px 2px rgba(0,0,0,.7)";
    knob.style.transition = "left 160ms ease, transform 160ms ease";
    const input = document.createElement("input");
    input.type = "checkbox";
    input.style.position = "absolute";
    input.style.opacity = "0";
    input.style.pointerEvents = "none";
    input.tabIndex = -1;
    const apply = (on) => {
      input.checked = on;
      wrap.setAttribute("aria-checked", on ? "true" : "false");
      knob.style.left = on ? "21px" : "3px";
      knob.style.transform = on ? "translateY(-50%) scale(1.02)" : "translateY(-50%) scale(1)";
      if (on) {
        box.style.background = "linear-gradient(180deg, #2b5cff, #1e40ff)";
        box.style.borderColor = "#7aa2ff";
        box.style.boxShadow = "0 0 0 2px #7aa2ff55, inset 0 0 0 1px #0005";
      } else {
        box.style.background = "#1f2328";
        box.style.borderColor = "#4446";
        box.style.boxShadow = "inset 0 0 0 1px #0005";
      }
    };
    input.disabled = true;
    wrap.addEventListener("mousedown", (e) => e.preventDefault());
    wrap.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      apply(!input.checked);
      onToggle?.(input.checked);
    });
    box.appendChild(knob);
    wrap.appendChild(input);
    wrap.appendChild(box);
    apply(false);
    return wrap;
  };
  var setSwitchVisual = (wrap, checked) => {
    const input = wrap.querySelector("input");
    const box = wrap.querySelector("span");
    const knob = box?.querySelector("span");
    if (!input || !box || !knob) return;
    input.checked = !!checked;
    knob.style.left = checked ? "21px" : "3px";
    knob.style.transform = checked ? "translateY(-50%) scale(1.02)" : "translateY(-50%) scale(1)";
    if (checked) {
      box.style.background = "linear-gradient(180deg, #2b5cff, #1e40ff)";
      box.style.borderColor = "#7aa2ff";
      box.style.boxShadow = "0 0 0 2px #7aa2ff55, inset 0 0 0 1px #0005";
      wrap.setAttribute("aria-checked", "true");
    } else {
      box.style.background = "#1f2328";
      box.style.borderColor = "#4446";
      box.style.boxShadow = "inset 0 0 0 1px #0005";
      wrap.setAttribute("aria-checked", "false");
    }
  };
  var wrapCell = (child) => {
    const d = document.createElement("div");
    d.style.display = "flex";
    d.style.alignItems = "center";
    d.style.justifyContent = "center";
    d.style.borderBottom = "1px solid #ffffff12";
    d.style.padding = "4px 6px";
    d.style.boxSizing = "border-box";
    d.appendChild(child);
    return d;
  };
  var mkHeadCell = (txt, align = "center") => {
    const el2 = document.createElement("div");
    el2.textContent = txt;
    el2.style.fontWeight = "600";
    el2.style.opacity = "0.9";
    el2.style.padding = "4px 6px";
    el2.style.display = "flex";
    el2.style.alignItems = "center";
    el2.style.justifyContent = align === "left" ? "flex-start" : "center";
    return el2;
  };
  function rarityBadge(raw) {
    const rarity2 = String(raw || "").trim();
    const key2 = (() => {
      const k = rarity2.toLowerCase();
      if (k === "mythical") return "Mythical";
      if (k === "celestial") return "Celestial";
      if (k === "divine") return "Divine";
      if (k === "legendary") return "Legendary";
      if (k === "rare") return "Rare";
      if (k === "uncommon") return "Uncommon";
      if (k === "common") return "Common";
      return rarity2 || "\u2014";
    })();
    const COLORS = {
      Common: "#E7E7E7",
      Uncommon: "#67BD4D",
      Rare: "#0071C6",
      Legendary: "#FFC734",
      Mythical: "#9944A7",
      Divine: "#FF7835",
      Celestial: null
    };
    const darkText = /* @__PURE__ */ new Set(["Common", "Uncommon", "Legendary", "Divine"]);
    const el2 = document.createElement("div");
    el2.textContent = key2;
    Object.assign(el2.style, {
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      padding: "4px 8px",
      borderRadius: "5px",
      fontSize: "12px",
      fontWeight: "700",
      margin: "2px auto",
      color: darkText.has(key2) ? "#0b0b0b" : "#ffffff",
      boxShadow: "0 0 0 1px #0006 inset",
      lineHeight: "1.1",
      whiteSpace: "nowrap"
    });
    if (key2 === "Celestial") {
      if (!document.getElementById("qws-celestial-kf")) {
        const style2 = document.createElement("style");
        style2.id = "qws-celestial-kf";
        style2.textContent = `
@keyframes qwsCelestialShift {
  0%   { background-position: 0% 50%; }
  50%  { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}`;
        document.head.appendChild(style2);
      }
      el2.style.background = `linear-gradient(130deg,
      rgb(0,180,216) 0%,
      rgb(124,42,232) 40%,
      rgb(160,0,126) 60%,
      rgb(255,215,0) 100%)`;
      el2.style.backgroundSize = "200% 200%";
      el2.style.animation = "qwsCelestialShift 4s linear infinite";
    } else {
      el2.style.background = COLORS[key2] || "#444";
    }
    return el2;
  }
  var applyRuleState = (itemCell, ruleCell, rule) => {
    const gearBtn = ruleCell?.querySelector("button[data-role='rule']") ?? null;
    const hint = itemCell.querySelector('[data-role="rule-hint"]');
    const hasRule = !!(rule && (rule.sound || rule.playbackMode || rule.stopMode || rule.loopIntervalMs != null));
    const summary = hasRule ? formatRuleSummary(rule) : "";
    if (gearBtn) {
      gearBtn.dataset.active = hasRule ? "1" : "0";
      gearBtn.title = hasRule && summary ? `Custom rule \u2014 ${summary}` : "Custom rule";
    }
    if (hint) {
      if (hasRule && summary) {
        hint.textContent = summary;
        hint.style.visibility = "visible";
      } else {
        hint.textContent = "";
        hint.style.visibility = "hidden";
      }
    }
  };
  var openRuleEditor = (ui, row, anchor) => {
    closeRuleEditor();
    const pop = document.createElement("div");
    pop.className = "qws-rule-popover";
    Object.assign(pop.style, {
      position: "fixed",
      zIndex: "var(--qws-z-popover)",
      minWidth: "260px",
      maxWidth: "320px",
      padding: "14px 16px",
      borderRadius: "14px",
      border: "1px solid #32404e",
      background: "linear-gradient(180deg, #111923, #0b131c)",
      boxShadow: "0 16px 40px rgba(0,0,0,0.45)"
    });
    const margin = 12;
    const clampPosition = (value, min, max) => {
      if (!Number.isFinite(min) || !Number.isFinite(max)) return value;
      if (max >= min) {
        return Math.min(Math.max(value, min), max);
      }
      return Math.min(Math.max(value, max), min);
    };
    const applyPosition = (left2, top2) => {
      const width2 = pop.offsetWidth;
      const height2 = pop.offsetHeight;
      const boundedLeft = clampPosition(left2, margin, window.innerWidth - width2 - margin);
      const boundedTop = clampPosition(top2, margin, window.innerHeight - height2 - margin);
      pop.style.left = `${Math.round(boundedLeft)}px`;
      pop.style.top = `${Math.round(boundedTop)}px`;
      return { left: boundedLeft, top: boundedTop };
    };
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "flex-start";
    header.style.gap = "12px";
    header.style.cursor = "move";
    header.style.userSelect = "none";
    header.style.touchAction = "none";
    const titleWrap = document.createElement("div");
    const title = document.createElement("div");
    title.textContent = row.name;
    title.style.fontWeight = "700";
    title.style.fontSize = "14px";
    title.style.lineHeight = "1.2";
    const subtitle = document.createElement("div");
    subtitle.textContent = row.type;
    subtitle.style.opacity = "0.7";
    subtitle.style.fontSize = "12px";
    titleWrap.append(title, subtitle);
    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.textContent = "\u2715";
    Object.assign(closeBtn.style, {
      background: "transparent",
      border: "none",
      color: "#c8d7e8",
      fontSize: "16px",
      lineHeight: "1",
      cursor: "pointer"
    });
    closeBtn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      closeRuleEditor();
    });
    header.append(titleWrap, closeBtn);
    let dragState = null;
    const onDragMove = (ev) => {
      if (!dragState) return;
      if (ev.pointerId !== dragState.pointerId) return;
      const dx = ev.clientX - dragState.startX;
      const dy = ev.clientY - dragState.startY;
      applyPosition(dragState.baseLeft + dx, dragState.baseTop + dy);
    };
    const stopDrag = (ev) => {
      if (!dragState) return;
      if (ev && ev.pointerId !== dragState.pointerId) return;
      document.removeEventListener("pointermove", onDragMove);
      document.removeEventListener("pointerup", stopDrag);
      document.removeEventListener("pointercancel", stopDrag);
      try {
        header.releasePointerCapture(dragState.pointerId);
      } catch {
      }
      dragState = null;
    };
    const onPointerDown = (ev) => {
      if (ev.button !== 0) return;
      const target = ev.target;
      if (target && closeBtn.contains(target)) return;
      if (dragState) stopDrag();
      const rect = pop.getBoundingClientRect();
      dragState = {
        pointerId: ev.pointerId,
        startX: ev.clientX,
        startY: ev.clientY,
        baseLeft: rect.left,
        baseTop: rect.top
      };
      try {
        header.setPointerCapture(ev.pointerId);
      } catch {
      }
      document.addEventListener("pointermove", onDragMove);
      document.addEventListener("pointerup", stopDrag);
      document.addEventListener("pointercancel", stopDrag);
      ev.preventDefault();
    };
    header.addEventListener("pointerdown", onPointerDown);
    detachRuleDragHandler = () => {
      header.removeEventListener("pointerdown", onPointerDown);
      stopDrag();
    };
    pop.appendChild(header);
    const current = NotifierService.getRule(row.id);
    const defaults = audio.getPlaybackSettings(row.context);
    const contextDefaults = row.context === "shops" || row.context === "weather" ? NotifierService.getContextStopDefaults(row.context) : { stopMode: "manual", stopRepeats: null, loopIntervalMs: defaults.loopIntervalMs };
    const allowPurchase = row.context === "shops";
    const defaultSoundName = (() => {
      const label2 = (defaults.defaultSoundName || "").trim();
      return label2 || "Default";
    })();
    const formatModeLabel = (mode) => mode === "loop" ? "Loop" : "One-shot";
    const defaultModeLabel = formatModeLabel(defaults.mode);
    const defaultIntervalMs = Math.max(
      150,
      Math.floor(contextDefaults.loopIntervalMs ?? defaults.loopIntervalMs ?? 150)
    );
    const soundField = document.createElement("div");
    soundField.className = "qws-rule-field";
    const soundLabel = document.createElement("label");
    soundLabel.textContent = "Sound";
    const soundSelect = document.createElement("select");
    soundSelect.className = "qmm-input";
    soundSelect.style.width = "100%";
    const populateSoundOptions = () => {
      const selected = current?.sound ?? "";
      soundSelect.innerHTML = "";
      const optDefault = document.createElement("option");
      optDefault.value = "";
      optDefault.textContent = defaultSoundName;
      soundSelect.appendChild(optDefault);
      const names = audio.listSounds();
      for (const name of names) {
        if (name === defaultSoundName && selected !== name) continue;
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        soundSelect.appendChild(opt);
      }
      if (selected && !names.includes(selected)) {
        const extra = document.createElement("option");
        extra.value = selected;
        extra.textContent = selected.length > 32 ? `${selected.slice(0, 29)}\u2026` : selected;
        extra.dataset.extra = "1";
        soundSelect.appendChild(extra);
      }
      soundSelect.value = selected;
    };
    populateSoundOptions();
    soundField.append(soundLabel, soundSelect);
    pop.appendChild(soundField);
    const modeField = document.createElement("div");
    modeField.className = "qws-rule-field";
    const modeLabel = document.createElement("label");
    modeLabel.textContent = "Playback mode";
    const modeSelect = document.createElement("select");
    modeSelect.className = "qmm-input";
    const modeOptions = allowPurchase ? defaults.mode === "loop" ? ["loop", "oneshot"] : ["oneshot", "loop"] : ["oneshot"];
    modeOptions.forEach((value) => {
      const opt = document.createElement("option");
      opt.value = value;
      opt.textContent = formatModeLabel(value);
      modeSelect.appendChild(opt);
    });
    const initialMode = allowPurchase ? current?.playbackMode ?? defaults.mode : "oneshot";
    modeSelect.value = initialMode === "loop" && !allowPurchase ? "oneshot" : initialMode;
    if (!allowPurchase) modeSelect.disabled = true;
    modeField.append(modeLabel, modeSelect);
    pop.appendChild(modeField);
    let stopSelect = null;
    const stopField = document.createElement("div");
    stopField.className = "qws-rule-field";
    if (allowPurchase) {
      const stopLabel = document.createElement("label");
      stopLabel.textContent = "Stop condition";
      stopSelect = document.createElement("select");
      stopSelect.className = "qmm-input";
      const stopOption = document.createElement("option");
      stopOption.value = "purchase";
      stopOption.textContent = "Until purchase";
      stopSelect.appendChild(stopOption);
      const initialStopMode = current?.stopMode ?? contextDefaults.stopMode;
      stopSelect.value = initialStopMode === "purchase" ? "purchase" : "purchase";
      stopField.append(stopLabel, stopSelect);
      pop.appendChild(stopField);
    }
    const intervalField = document.createElement("div");
    intervalField.className = "qws-rule-field";
    const intervalLabel = document.createElement("label");
    intervalLabel.textContent = "Loop interval (ms)";
    const intervalInput = document.createElement("input");
    intervalInput.type = "number";
    intervalInput.className = "qmm-input";
    intervalInput.min = "150";
    intervalInput.step = "50";
    intervalInput.placeholder = String(defaultIntervalMs);
    intervalInput.value = current?.loopIntervalMs != null ? String(current.loopIntervalMs) : "";
    intervalInput.inputMode = "numeric";
    intervalField.append(intervalLabel, intervalInput);
    if (allowPurchase) pop.appendChild(intervalField);
    const enforceIntegerOnly = (input) => {
      input.addEventListener("keydown", (ev) => {
        ev.stopPropagation();
        ev.stopImmediatePropagation();
        if (ev.ctrlKey || ev.metaKey || ev.altKey) return;
        const key2 = ev.key;
        if (/^[0-9]$/.test(key2)) return;
        if (key2 === "Backspace" || key2 === "Delete" || key2 === "Tab" || key2 === "Enter" || key2 === "ArrowLeft" || key2 === "ArrowRight" || key2 === "ArrowUp" || key2 === "ArrowDown" || key2 === "Home" || key2 === "End") {
          return;
        }
        ev.preventDefault();
      });
      input.addEventListener("input", () => {
        const sanitized = input.value.replace(/\D+/g, "");
        if (sanitized !== input.value) input.value = sanitized;
      });
    };
    enforceIntegerOnly(intervalInput);
    const resolveMode = () => {
      const raw = modeSelect.value;
      if (raw === "oneshot" || raw === "loop") return raw;
      return allowPurchase ? defaults.mode : "oneshot";
    };
    const resolveStop = () => {
      if (!allowPurchase) return "purchase";
      const raw = stopSelect?.value;
      if (raw === "purchase") return "purchase";
      return "purchase";
    };
    const updateLoopVisibility = () => {
      if (!allowPurchase) {
        stopField.style.display = "none";
        intervalField.style.display = "none";
        return;
      }
      const mode = resolveMode();
      const showLoop = mode === "loop";
      stopField.style.display = showLoop ? "grid" : "none";
      intervalField.style.display = showLoop ? "grid" : "none";
    };
    const forceLoopMode = () => {
      if (!allowPurchase) return;
      if (modeSelect.value === "loop") return;
      modeSelect.value = "loop";
      updateLoopVisibility();
    };
    modeSelect.addEventListener("change", () => {
      updateLoopVisibility();
    });
    if (allowPurchase && stopSelect) {
      stopSelect.addEventListener("change", () => {
        forceLoopMode();
      });
    }
    if (allowPurchase) intervalInput.addEventListener("input", forceLoopMode);
    updateLoopVisibility();
    const hint = document.createElement("div");
    hint.textContent = "Leave fields empty to inherit global defaults.";
    hint.style.opacity = "0.7";
    hint.style.fontSize = "12px";
    pop.appendChild(hint);
    const actions = document.createElement("div");
    actions.className = "qws-rule-actions";
    const clearBtn = ui.btn("Clear", { variant: "ghost", size: "sm" });
    clearBtn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      NotifierService.clearRule(row.id);
      closeRuleEditor();
    });
    if (!current) ui.setButtonEnabled(clearBtn, false);
    const saveBtn = ui.btn("Save", { variant: "primary", size: "sm" });
    saveBtn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      const sound = soundSelect.value?.trim() || null;
      const modeRaw = modeSelect.value || "";
      const stopRaw = stopSelect?.value || "";
      const intervalRaw = intervalInput.value?.trim();
      let playbackMode = modeRaw === "oneshot" || modeRaw === "loop" ? modeRaw : null;
      if (playbackMode === defaults.mode) playbackMode = null;
      let stopMode = allowPurchase ? stopRaw === "purchase" ? "purchase" : null : null;
      if (stopMode != null && stopMode === contextDefaults.stopMode) {
        stopMode = null;
      }
      let loopIntervalMs = null;
      if (allowPurchase && intervalRaw) {
        const parsed = Number(intervalRaw);
        if (Number.isFinite(parsed)) {
          const normalized = Math.max(150, Math.min(1e4, Math.floor(parsed)));
          if (normalized !== defaultIntervalMs) loopIntervalMs = normalized;
        }
      }
      if (allowPurchase && !playbackMode && defaults.mode !== "loop" && (stopMode != null || loopIntervalMs != null)) {
        playbackMode = "loop";
      }
      NotifierService.setRule(row.id, {
        sound,
        playbackMode,
        stopMode,
        loopIntervalMs
      });
      closeRuleEditor();
    });
    actions.append(clearBtn, saveBtn);
    pop.appendChild(actions);
    document.body.appendChild(pop);
    const anchorRect = anchor.getBoundingClientRect();
    const width = pop.offsetWidth;
    const height = pop.offsetHeight;
    let left = anchorRect.right - width;
    let top = anchorRect.bottom + 8;
    if (left < margin) left = margin;
    if (left + width > window.innerWidth - margin) left = window.innerWidth - width - margin;
    if (top + height > window.innerHeight - margin) top = anchorRect.top - height - 8;
    if (top < margin) top = margin;
    applyPosition(left, top);
    const onDocPointer = (ev) => {
      const target = ev.target;
      if (!target) return;
      if (pop.contains(target)) return;
      if (anchor.contains(target)) return;
      closeRuleEditor();
    };
    setTimeout(() => document.addEventListener("pointerdown", onDocPointer, true));
    detachRuleDocHandler = () => document.removeEventListener("pointerdown", onDocPointer, true);
    const keyBlocker = (ev) => {
      if (!rulePopover) return;
      if (rulePopover.contains(ev.target)) return;
      ev.stopImmediatePropagation();
    };
    document.addEventListener("keydown", keyBlocker, true);
    detachRuleKeyBlocker = () => document.removeEventListener("keydown", keyBlocker, true);
    const wheelBlocker = (ev) => {
      const t = ev.target;
      if (rulePopover && t && rulePopover.contains(t)) {
        ev.stopImmediatePropagation();
      }
    };
    document.addEventListener("wheel", wheelBlocker, { capture: true, passive: true });
    detachRuleWheelBlocker = () => {
      document.removeEventListener("wheel", wheelBlocker, { capture: true });
    };
    rulePopover = pop;
  };
  function renderSettingsTab(view, ui) {
    view.innerHTML = "";
    void PetAlertService.start().catch(() => {
    });
    const section = (title) => {
      const card = ui.card(title, { tone: "muted" });
      card.body.style.display = "grid";
      card.body.style.gap = "10px";
      return card;
    };
    const row = (labelTxt, control, opts) => {
      const { root: r, label: label2 } = ui.formRow(labelTxt, control, { alignTop: opts?.alignTop, labelWidth: "160px" });
      label2.style.opacity = "0.9";
      label2.style.fontWeight = "600";
      return r;
    };
    const radio = (name, value, text) => {
      const chip = ui.toggleChip(text, { type: "radio", name, value });
      chip.root.classList.add("qmm-radio-chip");
      return { label: chip.root, input: chip.input };
    };
    const makeSelect = (id) => {
      const sel = ui.select({ id, width: "180px" });
      return sel;
    };
    const playIconBtn = (title = "Play") => {
      return ui.btn("", { icon: "\u25B6", size: "sm", tooltip: title, ariaLabel: title });
    };
    const smallBtn = (txt) => ui.btn(txt, { size: "sm" });
    const errorBar = () => ui.errorBar();
    const root = document.createElement("div");
    Object.assign(root.style, {
      display: "grid",
      gridTemplateRows: "1fr",
      gap: "12px",
      height: "54vh",
      minHeight: "0",
      overflow: "hidden"
    });
    view.appendChild(root);
    const s1 = section("Audio & Playback");
    root.appendChild(s1.root);
    const contextControls = {};
    const contextOrder = [
      { key: "shops", label: "Shops", allowPurchase: true, showStop: true },
      { key: "weather", label: "Weather", allowPurchase: false },
      { key: "pets", label: "Pets", allowPurchase: true, showStop: false }
    ];
    for (const cfg of contextOrder) {
      const card = document.createElement("div");
      Object.assign(card.style, {
        display: "grid",
        gap: "12px",
        padding: "16px",
        borderRadius: "12px",
        border: "1px solid #1f2429",
        background: "#111821"
      });
      const heading = document.createElement("div");
      heading.textContent = cfg.label;
      heading.style.fontWeight = "700";
      heading.style.fontSize = "14px";
      heading.style.letterSpacing = "0.02em";
      card.appendChild(heading);
      const defaultWrap = document.createElement("div");
      defaultWrap.style.display = "flex";
      defaultWrap.style.alignItems = "center";
      defaultWrap.style.gap = "8px";
      const select2 = makeSelect(`ap.defaultSound.${cfg.key}`);
      select2.dataset.soundSelect = cfg.key;
      const playBtn = playIconBtn(`Play ${cfg.label.toLowerCase()} sound`);
      defaultWrap.append(select2, playBtn);
      card.appendChild(row("Default sound", defaultWrap));
      const volumeWrap = document.createElement("div");
      volumeWrap.style.display = "flex";
      volumeWrap.style.alignItems = "center";
      volumeWrap.style.gap = "10px";
      const volumeRange = document.createElement("input");
      volumeRange.type = "range";
      volumeRange.min = "0";
      volumeRange.max = "100";
      volumeRange.step = "1";
      volumeRange.style.width = "220px";
      const volumeValue = document.createElement("span");
      volumeValue.style.minWidth = "32px";
      volumeValue.style.textAlign = "right";
      volumeWrap.append(volumeRange, volumeValue);
      card.appendChild(row("Volume", volumeWrap));
      const modeWrap = document.createElement("div");
      modeWrap.style.display = "flex";
      modeWrap.style.gap = "12px";
      const modeOne = radio(`ap.mode.${cfg.key}`, "oneshot", "One-shot");
      modeWrap.append(modeOne.label);
      let modeLoop = null;
      if (cfg.allowPurchase) {
        modeLoop = radio(`ap.mode.${cfg.key}`, "loop", "Loop");
        modeWrap.append(modeLoop.label);
      }
      card.appendChild(row("Playback mode", modeWrap));
      let stopRow;
      let loopInput;
      let loopWrap;
      if (cfg.allowPurchase) {
        const stopWrap = document.createElement("div");
        stopWrap.style.display = "flex";
        stopWrap.style.flexDirection = "column";
        stopWrap.style.gap = "10px";
        loopWrap = document.createElement("div");
        loopWrap.style.display = "flex";
        loopWrap.style.flexDirection = "column";
        loopWrap.style.gap = "4px";
        const loopTitle = document.createElement("div");
        loopTitle.textContent = "Loop interval";
        loopTitle.style.opacity = "0.8";
        loopTitle.style.fontSize = "12px";
        loopTitle.style.fontWeight = "600";
        const loopBox = document.createElement("div");
        loopBox.style.display = "inline-flex";
        loopBox.style.alignItems = "center";
        loopBox.style.gap = "8px";
        loopInput = document.createElement("input");
        loopInput.type = "number";
        loopInput.min = "150";
        loopInput.max = "10000";
        loopInput.step = "50";
        loopInput.style.width = "100px";
        loopInput.style.textAlign = "center";
        const loopLabel = document.createElement("span");
        loopLabel.textContent = "ms between plays";
        loopLabel.style.opacity = "0.85";
        loopBox.append(loopInput, loopLabel);
        loopWrap.append(loopTitle, loopBox);
        const stopInfo = document.createElement("div");
        stopInfo.textContent = cfg.showStop === false ? "Loops keep repeating; stop manually by disabling the alert." : "Loops stop automatically when the item is purchased.";
        stopInfo.style.opacity = "0.75";
        stopInfo.style.fontSize = "12px";
        stopInfo.style.lineHeight = "1.4";
        stopWrap.append(stopInfo, loopWrap);
        if (cfg.showStop !== false) {
          stopRow = row("Stop condition", stopWrap);
        } else {
          stopRow = row("Loop interval", stopWrap);
        }
        card.appendChild(stopRow);
      } else {
        const info = document.createElement("div");
        info.textContent = "Weather alerts play once per trigger.";
        info.style.opacity = "0.75";
        info.style.fontSize = "12px";
        info.style.lineHeight = "1.4";
        card.appendChild(row("Details", info));
      }
      contextControls[cfg.key] = {
        container: card,
        select: select2,
        playBtn,
        volumeRange,
        volumeValue,
        modeOneshot: modeOne.input,
        modeLoop: modeLoop?.input,
        stopRow,
        loopInput,
        loopWrap
      };
      s1.body.appendChild(card);
    }
    const s1Err = errorBar();
    s1.body.appendChild(s1Err.el);
    const s2 = section("Sound library");
    root.appendChild(s2.root);
    const importRow = document.createElement("div");
    Object.assign(importRow.style, {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      width: "100%"
    });
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = "audio/*";
    fileInput.multiple = true;
    fileInput.style.display = "none";
    const fileCard = document.createElement("div");
    Object.assign(fileCard.style, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      gap: "6px",
      padding: "18px 22px",
      width: "100%",
      minHeight: "110px",
      borderRadius: "14px",
      border: "1px dashed #5d6a7d",
      background: "linear-gradient(180deg, #0b141c, #091018)",
      transition: "border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease",
      cursor: "pointer",
      textAlign: "center"
    });
    fileCard.tabIndex = 0;
    fileCard.setAttribute("role", "button");
    fileCard.setAttribute("aria-label", "Select audio files");
    const fileCardTitle = document.createElement("div");
    fileCardTitle.textContent = "Select audio files";
    Object.assign(fileCardTitle.style, {
      fontWeight: "600",
      fontSize: "14px",
      letterSpacing: "0.02em"
    });
    const fileStatus = document.createElement("div");
    const defaultStatusText = "Click to browse or drop files";
    fileStatus.textContent = defaultStatusText;
    Object.assign(fileStatus.style, {
      fontSize: "12px",
      opacity: "0.75"
    });
    fileCard.append(fileCardTitle, fileStatus);
    const setFileCardActive = (active) => {
      if (active) {
        fileCard.style.borderColor = "#6fc3ff";
        fileCard.style.boxShadow = "0 0 0 3px #6fc3ff22";
        fileCard.style.background = "linear-gradient(180deg, #102030, #0b1826)";
      } else {
        fileCard.style.borderColor = "#5d6a7d";
        fileCard.style.boxShadow = "none";
        fileCard.style.background = "linear-gradient(180deg, #0b141c, #091018)";
      }
    };
    fileCard.addEventListener("mouseenter", () => setFileCardActive(true));
    fileCard.addEventListener("mouseleave", () => setFileCardActive(document.activeElement === fileCard));
    fileCard.addEventListener("focus", () => setFileCardActive(true));
    fileCard.addEventListener("blur", () => setFileCardActive(false));
    fileCard.addEventListener("dragover", (ev) => {
      ev.preventDefault();
      setFileCardActive(true);
      if (ev.dataTransfer) ev.dataTransfer.dropEffect = "copy";
    });
    fileCard.addEventListener("dragleave", () => setFileCardActive(document.activeElement === fileCard));
    const triggerFileSelect = () => fileInput.click();
    fileCard.addEventListener("click", triggerFileSelect);
    fileCard.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter" || ev.key === " ") {
        ev.preventDefault();
        triggerFileSelect();
      }
    });
    const displaySelection = (files) => {
      if (!files || !files.length) {
        fileStatus.textContent = defaultStatusText;
        return;
      }
      fileStatus.textContent = files.length === 1 ? files[0].name : `${files.length} files selected`;
    };
    fileCard.addEventListener("drop", async (ev) => {
      ev.preventDefault();
      const files = ev.dataTransfer?.files || null;
      displaySelection(files);
      await handleFiles(files);
      displaySelection(null);
      setFileCardActive(document.activeElement === fileCard);
    });
    importRow.append(fileInput, fileCard);
    s2.body.appendChild(importRow);
    const tip = document.createElement("div");
    tip.textContent = "MP3, WAV, OGG \u2014 limited to \u2264 10 s and \u2264 200 KB.";
    tip.style.opacity = "0.75";
    tip.style.fontSize = "12px";
    s2.body.appendChild(tip);
    const listWrap = document.createElement("div");
    Object.assign(listWrap.style, {
      display: "grid",
      gridTemplateRows: "auto 1fr",
      gap: "6px",
      border: "1px solid #4445",
      borderRadius: "10px",
      background: "#10161c",
      padding: "10px"
    });
    const listHeader = document.createElement("div");
    Object.assign(listHeader.style, {
      display: "grid",
      gridTemplateColumns: "minmax(0, 1fr) auto",
      gap: "12px",
      fontSize: "12px",
      letterSpacing: "0.05em",
      textTransform: "uppercase",
      opacity: "0.65",
      paddingBottom: "4px",
      borderBottom: "1px solid #ffffff14"
    });
    const headName = document.createElement("span");
    headName.textContent = "Sound";
    const headActions = document.createElement("span");
    headActions.textContent = "Actions";
    headActions.style.justifySelf = "end";
    listHeader.append(headName, headActions);
    const listBody = document.createElement("div");
    Object.assign(listBody.style, {
      display: "flex",
      flexDirection: "column",
      gap: "6px",
      maxHeight: "240px",
      overflowY: "auto",
      paddingRight: "4px",
      minHeight: "0",
      padding: "4px 0"
    });
    listWrap.append(listHeader, listBody);
    s2.body.appendChild(listWrap);
    const s2Err = errorBar();
    s2.body.appendChild(s2Err.el);
    const sanitizeLoopInput = (input, fallback) => {
      const trimmed = (input.value || "").trim();
      const raw = trimmed ? Number(trimmed) : NaN;
      const normalized = Number.isFinite(raw) ? raw : fallback;
      const clamped = Math.max(150, Math.min(1e4, Math.floor(normalized)));
      input.value = String(clamped);
      return clamped;
    };
    const updateStopVisibility = (context) => {
      const controls = contextControls[context];
      const loopChecked = controls.modeLoop?.checked ?? false;
      if (controls.stopRow) controls.stopRow.style.display = loopChecked ? "" : "none";
      if (controls.loopWrap) controls.loopWrap.style.display = loopChecked ? "flex" : "none";
    };
    const applyMode = (context, mode) => {
      if (context === "weather" && mode === "loop") {
        audio.setPlaybackMode("oneshot", context);
        contextControls[context].modeOneshot.checked = true;
        contextControls[context].modeLoop && (contextControls[context].modeLoop.checked = false);
        updateStopVisibility(context);
        return;
      }
      audio.setPlaybackMode(mode, context);
      updateStopVisibility(context);
    };
    const applyShopsStop = () => {
      const controls = contextControls.shops;
      if (!controls.loopInput) return;
      const loopMs = sanitizeLoopInput(controls.loopInput, audio.getLoopInterval("shops"));
      audio.setLoopInterval(loopMs, "shops");
      if (!controls.modeLoop?.checked) {
        if (controls.modeLoop) controls.modeLoop.checked = true;
        controls.modeOneshot.checked = false;
        applyMode("shops", "loop");
      }
      audio.setStopPurchase("shops");
      NotifierService.setContextStopDefaults("shops", { stopMode: "purchase", stopRepeats: null, loopIntervalMs: loopMs });
      return loopMs;
    };
    for (const cfg of contextOrder) {
      const controls = contextControls[cfg.key];
      controls.select.addEventListener("change", () => {
        audio.setDefaultSoundByName(controls.select.value, cfg.key);
        renderLibList();
      });
      controls.playBtn.addEventListener("click", () => {
        audio.trigger("preview", { sound: controls.select.value }, cfg.key).catch(() => {
        });
      });
      controls.volumeRange.addEventListener("input", () => {
        const value = Math.max(0, Math.min(100, parseInt(controls.volumeRange.value || "0", 10) || 0));
        controls.volumeValue.textContent = `${value}%`;
        audio.setVolume(value / 100, cfg.key);
      });
      controls.modeOneshot.addEventListener("change", () => {
        if (!controls.modeOneshot.checked) return;
        applyMode(cfg.key, "oneshot");
        if (cfg.key === "shops") {
          const loopMs = controls.loopInput ? sanitizeLoopInput(controls.loopInput, audio.getLoopInterval("shops")) : audio.getLoopInterval("shops");
          audio.setLoopInterval(loopMs, "shops");
          audio.setStopManual("shops");
          NotifierService.setContextStopDefaults("shops", { stopMode: "manual", stopRepeats: null, loopIntervalMs: loopMs });
        }
      });
      controls.modeLoop?.addEventListener("change", () => {
        if (!controls.modeLoop?.checked) return;
        applyMode(cfg.key, "loop");
        if (cfg.key === "shops") applyShopsStop();
      });
      if (cfg.allowPurchase) {
        controls.loopInput?.addEventListener("change", applyShopsStop);
        controls.loopInput?.addEventListener("blur", applyShopsStop);
      }
    }
    const refreshAllSoundSelects = () => {
      const names = audio.listSounds();
      const applyOptions = (sel, context) => {
        const current = sel.value;
        sel.innerHTML = "";
        for (const n of names) {
          const option = document.createElement("option");
          option.value = n;
          option.textContent = n;
          sel.appendChild(option);
        }
        const preferred = audio.getDefaultSoundName(context);
        if (names.includes(current)) sel.value = current;
        else if (preferred && names.includes(preferred)) sel.value = preferred;
        else if (names.length) sel.value = names[0];
      };
      for (const cfg of contextOrder) {
        applyOptions(contextControls[cfg.key].select, cfg.key);
      }
      const all = Array.from(document.querySelectorAll("select[data-sound-select]"));
      for (const sel of all) {
        const ctx = sel.dataset.soundSelect || "shops";
        if (contextControls[ctx]?.select === sel) continue;
        applyOptions(sel, ctx);
      }
    };
    const renderLibList = () => {
      listBody.replaceChildren();
      const names = audio.listSounds();
      if (!names.length) {
        const empty = document.createElement("div");
        empty.textContent = "No sounds in the library.";
        empty.style.opacity = "0.75";
        empty.style.textAlign = "center";
        empty.style.padding = "12px 6px";
        listBody.appendChild(empty);
        return;
      }
      const defaultShops = audio.getDefaultSoundName("shops");
      const defaultWeather = audio.getDefaultSoundName("weather");
      for (const name of names) {
        const row2 = document.createElement("div");
        Object.assign(row2.style, {
          display: "grid",
          gridTemplateColumns: "minmax(0, 1fr) auto",
          gap: "12px",
          alignItems: "center",
          padding: "8px 10px",
          borderRadius: "8px",
          border: "1px solid #1f2429",
          background: "#151b22"
        });
        const info = document.createElement("div");
        Object.assign(info.style, {
          display: "flex",
          alignItems: "center",
          gap: "8px",
          minWidth: "0"
        });
        const title = document.createElement("span");
        title.textContent = name;
        title.style.fontWeight = "600";
        title.style.overflow = "hidden";
        title.style.textOverflow = "ellipsis";
        title.style.whiteSpace = "nowrap";
        info.appendChild(title);
        const badges = document.createElement("div");
        badges.style.display = "flex";
        badges.style.gap = "6px";
        const makeBadge = (label2) => {
          const badge = document.createElement("span");
          badge.textContent = label2;
          Object.assign(badge.style, {
            fontSize: "11px",
            padding: "2px 6px",
            borderRadius: "999px",
            background: "#2b5cff33",
            border: "1px solid #2b5cff66",
            color: "#9cbcff",
            fontWeight: "600",
            textTransform: "uppercase",
            letterSpacing: "0.04em"
          });
          return badge;
        };
        const isShopsDefault = defaultShops === name;
        const isWeatherDefault = defaultWeather === name;
        const isPetsDefault = audio.getDefaultSoundName("pets") === name;
        if (isShopsDefault) badges.appendChild(makeBadge("Shops"));
        if (isWeatherDefault) badges.appendChild(makeBadge("Weather"));
        if (isPetsDefault) badges.appendChild(makeBadge("Pets"));
        if (badges.childElementCount) info.appendChild(badges);
        if (isShopsDefault || isWeatherDefault || isPetsDefault) {
          row2.style.borderColor = "#2b5cff99";
          row2.style.boxShadow = "0 0 0 1px #2b5cff33";
        }
        const actions = document.createElement("div");
        Object.assign(actions.style, {
          display: "flex",
          gap: "6px",
          justifyContent: "flex-end",
          flexWrap: "wrap"
        });
        const btnPlay = smallBtn("\u25B6");
        const btnSetShops = smallBtn("Set shops");
        const btnSetWeather = smallBtn("Set weather");
        const btnSetPets = smallBtn("Set pets");
        const btnDel = smallBtn("Remove");
        btnPlay.title = "Preview";
        btnSetShops.title = "Set as shops default";
        btnSetWeather.title = "Set as weather default";
        btnSetPets.title = "Set as pets default";
        btnDel.title = "Remove from library";
        const isProtected = typeof audio.isProtectedSound === "function" && audio.isProtectedSound(name);
        if (isProtected || isShopsDefault || isWeatherDefault) {
          btnDel.disabled = true;
          btnDel.style.opacity = "0.6";
          if (isProtected) btnDel.title = "Built-in sound cannot be removed";
          else btnDel.title = "Currently used as default";
        }
        btnPlay.onclick = () => audio.trigger("preview", { sound: name }, "shops").catch(() => {
        });
        btnSetShops.onclick = () => {
          audio.setDefaultSoundByName(name, "shops");
          refreshAllSoundSelects();
          renderLibList();
        };
        btnSetWeather.onclick = () => {
          audio.setDefaultSoundByName(name, "weather");
          refreshAllSoundSelects();
          renderLibList();
        };
        btnSetPets.onclick = () => {
          audio.setDefaultSoundByName(name, "pets");
          refreshAllSoundSelects();
          renderLibList();
        };
        btnDel.onclick = () => {
          audio.unregisterSound(name);
          refreshAllSoundSelects();
          renderLibList();
        };
        actions.append(btnPlay, btnSetShops, btnSetWeather, btnSetPets, btnDel);
        row2.append(info, actions);
        listBody.appendChild(row2);
      }
    };
    const syncContext = (context) => {
      const controls = contextControls[context];
      const settings = audio.getPlaybackSettings(context);
      const names = audio.listSounds();
      if (settings.defaultSoundName && names.includes(settings.defaultSoundName)) {
        controls.select.value = settings.defaultSoundName;
      }
      const volPercent = Math.round(settings.volume * 100);
      controls.volumeRange.value = String(volPercent);
      controls.volumeValue.textContent = `${volPercent}%`;
      if (controls.modeLoop && settings.mode === "loop") controls.modeLoop.checked = true;
      else controls.modeOneshot.checked = true;
      const defaults = context === "shops" || context === "weather" ? NotifierService.getContextStopDefaults(context) : { stopMode: "manual", stopRepeats: null, loopIntervalMs: settings.loopIntervalMs };
      const fallbackLoop = Math.max(
        150,
        Math.min(1e4, Math.floor(defaults.loopIntervalMs || settings.loopIntervalMs || 150))
      );
      const loopMs = controls.loopInput ? sanitizeLoopInput(controls.loopInput, fallbackLoop) : fallbackLoop;
      audio.setLoopInterval(loopMs, context);
      if (context === "shops") {
        if (controls.modeLoop?.checked) {
          audio.setStopPurchase("shops");
          NotifierService.setContextStopDefaults("shops", { stopMode: "purchase", stopRepeats: null, loopIntervalMs: loopMs });
        } else {
          audio.setStopManual("shops");
          NotifierService.setContextStopDefaults("shops", { stopMode: "manual", stopRepeats: null, loopIntervalMs: loopMs });
        }
      } else if (context === "weather") {
        applyMode("weather", "oneshot");
        audio.setStopManual("weather");
        NotifierService.setContextStopDefaults("weather", { stopMode: "manual", stopRepeats: null, loopIntervalMs: loopMs });
      } else if (context === "pets") {
        audio.setLoopInterval(loopMs, "pets");
        audio.setStopManual("pets");
      }
      updateStopVisibility(context);
    };
    const syncFromAudio = () => {
      refreshAllSoundSelects();
      syncContext("shops");
      syncContext("weather");
      syncContext("pets");
      renderLibList();
    };
    const handleFiles = async (files) => {
      s2Err.clear();
      if (!files || !files.length) return;
      const added = [];
      for (const f of Array.from(files)) {
        try {
          const res = await audio.importFileAsSound(f, {
            maxBytes: 200 * 1024,
            maxSeconds: 10,
            bitrates: [48e3, 32e3, 2e4, 12e3, 8e3],
            maxInputBytes: 8 * 1024 * 1024
          });
          added.push(res.name);
        } catch (e) {
          s2Err.show(`Failed for "${f.name}": ${e?.message || e}`);
        }
      }
      if (added.length) {
        refreshAllSoundSelects();
        renderLibList();
        for (const cfg of contextOrder) {
          if (!audio.getDefaultSoundName(cfg.key)) {
            audio.setDefaultSoundByName(added[0], cfg.key);
          }
        }
        refreshAllSoundSelects();
        renderLibList();
      }
      fileInput.value = "";
    };
    fileInput.onchange = async () => {
      const files = fileInput.files;
      displaySelection(files);
      await handleFiles(files);
      displaySelection(null);
      setFileCardActive(document.activeElement === fileCard);
    };
    syncFromAudio();
    const scroller = document.createElement("div");
    Object.assign(scroller.style, {
      overflow: "auto",
      minHeight: "0",
      height: "100%",
      display: "grid",
      gap: "12px"
    });
    scroller.append(s1.root, s2.root);
    root.appendChild(scroller);
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderShopTab(view, ui) {
    view.innerHTML = "";
    view.style.cssText = "";
    if (!document.getElementById("qws-rule-style")) {
      const style2 = document.createElement("style");
      style2.id = "qws-rule-style";
      style2.textContent = `
:root {
  /* PATCH: z-index centralis\xE9 */
  --qws-z-popover: 99999999999999;
}

/* PATCH: bouton engrenage carr\xE9, centr\xE9, plus gros */
.qws-rule-btn {
  display: inline-grid;
  place-items: center;
  width: 32px;
  height: 32px;
  padding: 0;
  border-radius: 8px;
  line-height: 1;
  font-size: 18px; /* taille de l'ic\xF4ne */
  min-width: 32px; /* \xE9vite les r\xE9tr\xE9cissements */
  box-sizing: border-box;
}
.qws-rule-btn[data-active="1"] {
  background: linear-gradient(180deg, #1b2735, #101821);
  box-shadow: 0 0 0 1px #658dff88 inset;
  color: #c7daff;
}

/* PATCH: popover toujours devant */
.qws-rule-popover {
  position: fixed !important;
  z-index: var(--qws-z-popover) !important;
  display: flex;
  flex-direction: column;
  gap: 10px;
  color: #f1f6ff;
}
.qws-rule-popover .qws-rule-field {
  display: grid;
  gap: 6px;
}
.qws-rule-popover .qws-rule-field label {
  font-weight: 600;
  font-size: 13px;
}
.qws-rule-popover .qws-rule-actions {
  display: flex;
  justify-content: space-between;
  gap: 8px;
}

/* PATCH: r\xE9serve un espace pour le r\xE9sum\xE9 afin d'\xE9viter tout shift */
[data-role="rule-hint"] {
  min-height: 1.2em;  /* ~1 ligne r\xE9serv\xE9e */
}
`;
      document.head.appendChild(style2);
    }
    const wrap = document.createElement("div");
    Object.assign(wrap.style, {
      display: "grid",
      gridTemplateRows: "auto 1fr",
      gap: "10px",
      height: "54vh",
      overflow: "hidden",
      minHeight: "0",
      position: "relative"
    });
    view.appendChild(wrap);
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.flexWrap = "wrap";
    header.style.alignItems = "center";
    header.style.gap = "10px";
    header.style.rowGap = "8px";
    wrap.appendChild(header);
    const lblType = ui.label("Type");
    const selType = document.createElement("select");
    selType.className = "qmm-input";
    selType.style.minWidth = "140px";
    selType.id = "shop.filter.type";
    [
      ["all", "All"],
      ["seed", "Seeds"],
      ["egg", "Eggs"],
      ["tool", "Tools"],
      ["decor", "Decor"]
    ].forEach(([v, t]) => {
      const o = document.createElement("option");
      o.value = v;
      o.textContent = t;
      selType.appendChild(o);
    });
    selType.value = "all";
    const lblRarity = ui.label("Rarity");
    const selRarity = document.createElement("select");
    selRarity.className = "qmm-input";
    selRarity.style.minWidth = "160px";
    selRarity.id = "shop.filter.rarity";
    [
      ["all", "All"],
      ["common", "Common"],
      ["uncommon", "Uncommon"],
      ["rare", "Rare"],
      ["legendary", "Legendary"],
      ["mythical", "Mythical"],
      ["divine", "Divine"],
      ["celestial", "Celestial"]
    ].forEach(([v, t]) => {
      const o = document.createElement("option");
      o.value = v;
      o.textContent = t;
      selRarity.appendChild(o);
    });
    selRarity.value = "all";
    const followedBadge = document.createElement("div");
    followedBadge.id = "shop.followedCount";
    followedBadge.textContent = "Followed: 0";
    followedBadge.title = "Items with Overlay enabled";
    followedBadge.style.padding = "6px 10px";
    followedBadge.style.borderRadius = "999px";
    followedBadge.style.border = "1px solid #4445";
    followedBadge.style.background = "#1f2328";
    followedBadge.style.color = "#e7eef7";
    followedBadge.style.fontWeight = "600";
    followedBadge.style.marginLeft = "auto";
    followedBadge.style.width = "115px";
    header.append(lblType, selType, lblRarity, selRarity, followedBadge);
    const card = document.createElement("div");
    card.style.border = "1px solid #4445";
    card.style.borderRadius = "10px";
    card.style.padding = "10px";
    card.style.background = "#0f1318";
    card.style.overflow = "hidden";
    card.style.display = "grid";
    card.style.gridTemplateRows = "auto 1fr";
    card.style.minHeight = "0";
    wrap.appendChild(card);
    const headerGrid = document.createElement("div");
    const COLS = "minmax(200px, 1fr) 9rem 7rem 8rem";
    headerGrid.style.display = "grid";
    headerGrid.style.gridTemplateColumns = COLS;
    headerGrid.style.justifyContent = "start";
    headerGrid.style.columnGap = "0";
    headerGrid.style.borderBottom = "1px solid #ffffff1a";
    headerGrid.style.padding = "0 0 4px 0";
    headerGrid.style.position = "sticky";
    headerGrid.style.top = "0";
    headerGrid.append(
      mkHeadCell("Item", "left"),
      mkHeadCell("Rarity"),
      mkHeadCell("Notify"),
      mkHeadCell("Custom rules")
    );
    card.appendChild(headerGrid);
    const bodyGrid = document.createElement("div");
    bodyGrid.style.display = "grid";
    bodyGrid.style.gridTemplateColumns = COLS;
    bodyGrid.style.justifyContent = "start";
    bodyGrid.style.gridAutoRows = "auto";
    bodyGrid.style.alignContent = "start";
    bodyGrid.style.minHeight = "0";
    bodyGrid.style.height = "100%";
    bodyGrid.style.overflow = "auto";
    bodyGrid.style.overscrollBehavior = "contain";
    bodyGrid.style.width = "100%";
    bodyGrid.style.scrollbarGutter = "stable";
    card.appendChild(bodyGrid);
    const refreshRulesUI = () => {
      const kids = Array.from(bodyGrid.children);
      for (let i = 0; i + 3 < kids.length; i += 4) {
        const itemCell = kids[i];
        const ruleCell = kids[i + 3];
        const id = itemCell?.dataset?.id;
        if (!id) continue;
        applyRuleState(itemCell, ruleCell ?? null, NotifierService.getRule(id));
      }
    };
    const softUpdateRenderedRows = (next) => {
      const byId = new Map(next.rows.map((r) => [r.id, r]));
      const kids = Array.from(bodyGrid.children);
      for (let i = 0; i + 3 < kids.length; i += 4) {
        const itemCell = kids[i];
        const popupCell = kids[i + 2];
        const ruleCell = kids[i + 3];
        const id = itemCell.dataset.id;
        const row = byId.get(id);
        if (!row) continue;
        const popupSwitch = popupCell.querySelector("label");
        if (popupSwitch) setSwitchVisual(popupSwitch, !!row.popup);
        itemCell.dataset.follow = row.followed ? "1" : "0";
        applyRuleState(itemCell, ruleCell ?? null, NotifierService.getRule(id));
        const capped = NotifierService.isIdCapped?.(id) ?? false;
        if (popupSwitch) setSwitchCapState(popupSwitch, capped);
      }
    };
    const syncHeaderToScrollbar = () => {
      const sbw = bodyGrid.offsetWidth - bodyGrid.clientWidth;
      headerGrid.style.boxSizing = "border-box";
      headerGrid.style.paddingRight = `${sbw}px`;
    };
    syncHeaderToScrollbar();
    const resizeObserver = new ResizeObserver(syncHeaderToScrollbar);
    resizeObserver.observe(bodyGrid);
    const onResize = () => syncHeaderToScrollbar();
    window.addEventListener("resize", onResize);
    const lastSeenRefs = /* @__PURE__ */ new Map();
    let state2 = null;
    let renderedIds = /* @__PURE__ */ new Set();
    const getFilters = () => ({
      type: selType.value || "all",
      rarity: selRarity.value || "all"
    });
    const passesFilters = (rows) => NotifierService.filterRows(rows, getFilters());
    const mkItemCell = (row) => {
      const wrap2 = document.createElement("div");
      Object.assign(wrap2.style, {
        display: "flex",
        alignItems: "center",
        gap: "6px",
        padding: "4px 6px",
        borderBottom: "1px solid #ffffff12"
      });
      const ICON = 40;
      const iconWrap = document.createElement("div");
      Object.assign(iconWrap.style, {
        width: `${ICON}px`,
        height: `${ICON}px`,
        flex: `0 0 ${ICON}px`,
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: "8px",
        background: "#101820",
        marginRight: "6px",
        aspectRatio: "1 / 1"
      });
      const afterColon = (s) => {
        const i = s.indexOf(":");
        return i >= 0 ? s.slice(i + 1) : s;
      };
      const spriteFallback = row.type === "Seed" ? "\u{1F331}" : row.type === "Egg" ? "\u{1F95A}" : row.type === "Tool" ? "\u{1F9F0}" : "\u{1F3E0}";
      const spriteKey2 = afterColon(row.id);
      const sprite = createShopSprite(row.type, spriteKey2, {
        size: ICON - 6,
        fallback: spriteFallback,
        alt: row.name
      });
      iconWrap.appendChild(sprite);
      const col = document.createElement("div");
      Object.assign(col.style, {
        display: "flex",
        flexDirection: "column",
        gap: "2px",
        lineHeight: "1.15",
        minWidth: "0",
        // autorise l'ellipsis
        flex: "1 1 auto"
      });
      const title = document.createElement("div");
      title.textContent = row.name;
      Object.assign(title.style, {
        fontWeight: "700",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      });
      const sub = document.createElement("div");
      sub.textContent = row.type;
      sub.style.opacity = "0.7";
      sub.style.fontSize = "12px";
      const ruleHint = document.createElement("div");
      ruleHint.dataset.role = "rule-hint";
      ruleHint.style.display = "none";
      ruleHint.style.opacity = "0.75";
      ruleHint.style.fontSize = "11px";
      ruleHint.style.whiteSpace = "nowrap";
      ruleHint.style.overflow = "hidden";
      ruleHint.style.textOverflow = "ellipsis";
      ruleHint.style.minHeight = "1.2em";
      ruleHint.style.visibility = "hidden";
      col.append(title, sub, ruleHint);
      wrap2.append(iconWrap, col);
      return wrap2;
    };
    const addRow = (row) => {
      const itemCell = mkItemCell(row);
      itemCell.dataset.id = row.id;
      itemCell.dataset.type = row.type;
      itemCell.dataset.follow = row.followed ? "1" : "0";
      itemCell.dataset.context = "shops";
      const rarityCell = document.createElement("div");
      rarityCell.style.display = "flex";
      rarityCell.style.alignItems = "center";
      rarityCell.style.justifyContent = "center";
      rarityCell.style.borderBottom = "1px solid #ffffff12";
      rarityCell.appendChild(rarityBadge(String(row.rarity ?? "\u2014")));
      const popupSwitch = createSwitch((on) => {
        try {
          NotifierService.setPopup(row.id, !!on);
        } catch {
        }
        const cur = NotifierService.getPref(row.id);
        itemCell.dataset.follow = cur.followed ? "1" : "0";
      });
      setSwitchVisual(popupSwitch, !!row.popup);
      popupSwitch.style.padding = "0";
      const popupCell = wrapCell(popupSwitch);
      const capped = NotifierService.isIdCapped?.(row.id) ?? false;
      setSwitchCapState(popupSwitch, capped);
      const gearBtn = ui.btn("", {
        icon: "\u2699",
        size: "sm",
        tooltip: "Custom rule",
        ariaLabel: `Custom rule for ${row.name}`
      });
      gearBtn.dataset.role = "rule";
      gearBtn.classList.add("qws-rule-btn");
      gearBtn.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        openRuleEditor(ui, {
          id: row.id,
          name: row.name,
          type: row.type,
          context: "shops"
        }, gearBtn);
      });
      const ruleCell = wrapCell(gearBtn);
      ruleCell.dataset.role = "rule-cell";
      bodyGrid.append(itemCell, rarityCell, popupCell, ruleCell);
      applyRuleState(itemCell, ruleCell, NotifierService.getRule(row.id));
    };
    function clearBody() {
      closeRuleEditor();
      bodyGrid.innerHTML = "";
      renderedIds = /* @__PURE__ */ new Set();
    }
    function renderEmpty() {
      const empty = document.createElement("div");
      empty.textContent = "No items.";
      empty.style.opacity = "0.75";
      empty.style.gridColumn = "1 / -1";
      empty.style.padding = "8px";
      bodyGrid.appendChild(empty);
    }
    function rebuildGrid() {
      clearBody();
      if (!state2) {
        renderEmpty();
        return;
      }
      const rows = passesFilters(state2.rows);
      if (!rows.length) {
        renderEmpty();
      } else {
        rows.forEach((r) => {
          addRow(r);
          renderedIds.add(r.id);
        });
      }
      refreshRulesUI();
      followedBadge.textContent = `Followed: ${state2.counts.followed}`;
      syncHeaderToScrollbar();
    }
    function softUpdateBadge(next) {
      followedBadge.textContent = `Followed: ${next.counts.followed}`;
    }
    function filteredIdSet(s) {
      const set2 = /* @__PURE__ */ new Set();
      for (const r of passesFilters(s.rows)) set2.add(r.id);
      return set2;
    }
    let unsub = null;
    let unsubRules = null;
    (async () => {
      try {
        await NotifierService.start();
      } catch {
      }
      unsub = await NotifierService.onChangeNow((s) => {
        const prev = state2;
        state2 = s;
        if (!prev) {
          rebuildGrid();
          softUpdateRenderedRows(state2);
          return;
        }
        const prevIds = renderedIds;
        const nextIds = filteredIdSet(s);
        let needRebuild = false;
        if (prevIds.size !== nextIds.size) needRebuild = true;
        else {
          for (const id of nextIds) if (!prevIds.has(id)) {
            needRebuild = true;
            break;
          }
        }
        if (needRebuild) {
          rebuildGrid();
        } else {
          softUpdateBadge(s);
          softUpdateRenderedRows(s);
        }
      });
      try {
        unsubRules = await NotifierService.onRulesChangeNow(() => refreshRulesUI());
      } catch {
      }
    })();
    const onFilterChange = () => {
      if (state2) rebuildGrid();
    };
    selType.onchange = onFilterChange;
    selRarity.onchange = onFilterChange;
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsub?.();
        } catch {
        }
        try {
          unsubRules?.();
        } catch {
        }
        try {
          resizeObserver.disconnect();
        } catch {
        }
        try {
          window.removeEventListener("resize", onResize);
        } catch {
        }
        try {
          closeRuleEditor();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderPetAlertsTab(view, ui) {
    view.innerHTML = "";
    void PetAlertService.start().catch(() => {
    });
    const card = document.createElement("div");
    Object.assign(card.style, {
      display: "grid",
      gridTemplateColumns: "minmax(220px, 260px) minmax(0, 1fr)",
      gap: "10px",
      alignItems: "stretch",
      height: "54vh",
      overflow: "hidden",
      border: "1px solid #4445",
      borderRadius: "10px",
      padding: "10px",
      background: "#0f1318"
    });
    view.appendChild(card);
    const petList = document.createElement("div");
    Object.assign(petList.style, {
      display: "grid",
      gridTemplateColumns: "1fr",
      rowGap: "6px",
      overflow: "auto",
      padding: "6px",
      border: "1px solid #4445",
      borderRadius: "10px"
    });
    card.appendChild(petList);
    const right = document.createElement("div");
    Object.assign(right.style, {
      display: "flex",
      flexDirection: "column",
      gap: "10px",
      overflow: "auto",
      minHeight: "0"
    });
    card.appendChild(right);
    let pets = [];
    let unsubPets2 = null;
    let generalEnabled = PetAlertService.isGeneralEnabled();
    const formRow = (labelTxt, control) => {
      const { root } = ui.formRow(labelTxt, control, { labelWidth: "180px" });
      return root;
    };
    const generalCard = ui.card("General notifications", { tone: "muted", align: "stretch" });
    generalCard.body.style.display = "grid";
    generalCard.body.style.gap = "10px";
    const generalRow = ui.flexRow({ justify: "start", gap: 10 });
    const generalSw = ui.switch(PetAlertService.isGeneralEnabled());
    const generalLbl = document.createElement("div");
    generalLbl.textContent = "Use a shared threshold for all pets";
    generalLbl.style.opacity = "0.9";
    generalRow.append(generalSw, generalLbl);
    generalCard.body.append(formRow("Enable general", generalRow));
    const generalInput = ui.inputNumber(1, 100, 1, PetAlertService.getGeneralThresholdPct());
    generalCard.body.append(formRow("General threshold (%)", generalInput.wrap ?? generalInput));
    right.appendChild(generalCard.root);
    const syncGeneralUI = () => {
      generalEnabled = PetAlertService.isGeneralEnabled();
      generalSw.checked = generalEnabled;
      generalInput.value = String(PetAlertService.getGeneralThresholdPct());
    };
    generalSw.onchange = () => {
      PetAlertService.setGeneralEnabled(generalSw.checked);
      syncGeneralUI();
    };
    generalInput.addEventListener("change", () => {
      const next = Math.max(1, Math.min(100, Number(generalInput.value) || PetAlertService.getGeneralThresholdPct()));
      generalInput.value = String(PetAlertService.setGeneralThresholdPct(next));
    });
    syncGeneralUI();
    const renderPetList = () => {
      petList.innerHTML = "";
      if (!pets.length) {
        const empty = document.createElement("div");
        empty.textContent = "No active pets.";
        empty.style.opacity = "0.75";
        petList.appendChild(empty);
        return;
      }
      for (const pet of pets) {
        const slot = pet?.slot ?? {};
        const name = String(slot?.name || slot?.petSpecies || "Pet");
        const hunger = PetsService.getHungerPctFor(pet);
        const hungerText = Number.isFinite(hunger) ? `${hunger}%` : "\u2014";
        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.justifyContent = "space-between";
        row.style.gap = "10px";
        row.style.width = "100%";
        row.style.textAlign = "left";
        row.style.padding = "6px 8px";
        row.style.borderRadius = "8px";
        row.style.border = "1px solid #4445";
        row.style.background = "#121820";
        const left = document.createElement("div");
        left.style.display = "flex";
        left.style.alignItems = "center";
        left.style.gap = "8px";
        left.style.minWidth = "0";
        const avatar = document.createElement("div");
        avatar.style.width = "40px";
        avatar.style.height = "40px";
        avatar.style.borderRadius = "8px";
        avatar.style.display = "inline-flex";
        avatar.style.alignItems = "center";
        avatar.style.justifyContent = "center";
        avatar.style.background = "#111821";
        avatar.style.border = "1px solid #1f2429";
        avatar.style.overflow = "hidden";
        const useEmojiFallback = () => {
          avatar.replaceChildren();
          const span = document.createElement("span");
          span.textContent = "\u{1F43E}";
          span.style.fontSize = "28px";
          span.setAttribute("aria-hidden", "true");
          avatar.appendChild(span);
        };
        let iconRequestId = 0;
        const setIcon = (species2, mutation) => {
          iconRequestId += 1;
          const requestId = iconRequestId;
          const speciesLabel = String(species2 ?? "").trim();
          if (!speciesLabel) {
            useEmojiFallback();
            return;
          }
          useEmojiFallback();
          loadPetSpriteFromMutations(speciesLabel, mutation).then((src) => {
            if (requestId !== iconRequestId) return;
            if (!src) {
              useEmojiFallback();
              return;
            }
            const img = new Image();
            img.src = src;
            img.alt = speciesLabel || "pet";
            img.decoding = "async";
            img.loading = "lazy";
            img.draggable = false;
            Object.assign(img.style, {
              width: "100%",
              height: "100%",
              imageRendering: "auto",
              objectFit: "contain"
            });
            avatar.replaceChildren(img);
          }).catch(() => {
            if (requestId !== iconRequestId) return;
            useEmojiFallback();
          });
        };
        const species = String(slot?.petSpecies || "");
        const mutations = slot?.mutations ?? pet?.mutations;
        setIcon(species, mutations);
        const titleWrap = document.createElement("div");
        titleWrap.style.display = "flex";
        titleWrap.style.flexDirection = "column";
        titleWrap.style.gap = "2px";
        titleWrap.style.minWidth = "0";
        const title = document.createElement("div");
        title.textContent = name;
        title.style.fontWeight = "600";
        title.style.overflow = "hidden";
        title.style.textOverflow = "ellipsis";
        title.style.whiteSpace = "nowrap";
        titleWrap.append(title);
        left.append(avatar, titleWrap);
        const hungerValue = document.createElement("div");
        hungerValue.textContent = hungerText;
        hungerValue.style.fontWeight = "700";
        hungerValue.style.color = "#FFD84D";
        row.append(left, hungerValue);
        petList.appendChild(row);
      }
    };
    (async () => {
      try {
        unsubPets2 = await PetsService.onPetsChangeNow((arr) => {
          pets = Array.isArray(arr) ? arr.slice(0, 3) : [];
          renderPetList();
        });
      } catch {
        pets = [];
        renderPetList();
      }
    })();
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsubPets2?.();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderWeatherTab(view, ui) {
    view.innerHTML = "";
    view.style.cssText = "";
    const wrap = document.createElement("div");
    Object.assign(wrap.style, {
      display: "grid",
      gridTemplateRows: "1fr",
      height: "54vh",
      overflow: "hidden",
      minHeight: "0"
    });
    view.appendChild(wrap);
    const card = document.createElement("div");
    card.style.border = "1px solid #4445";
    card.style.borderRadius = "10px";
    card.style.padding = "10px";
    card.style.background = "#0f1318";
    card.style.overflow = "hidden";
    card.style.display = "grid";
    card.style.gridTemplateRows = "auto 1fr";
    card.style.minHeight = "0";
    wrap.appendChild(card);
    const headerGrid = document.createElement("div");
    const COLS = "minmax(240px, 1fr) 9rem 7rem 8rem";
    headerGrid.style.display = "grid";
    headerGrid.style.gridTemplateColumns = COLS;
    headerGrid.style.justifyContent = "start";
    headerGrid.style.columnGap = "0";
    headerGrid.style.borderBottom = "1px solid #ffffff1a";
    headerGrid.style.padding = "0 0 4px 0";
    headerGrid.style.position = "sticky";
    headerGrid.style.top = "0";
    headerGrid.append(
      mkHeadCell("Weather", "left"),
      mkHeadCell("Last seen"),
      mkHeadCell("Notify"),
      mkHeadCell("Custom rules")
    );
    card.appendChild(headerGrid);
    const bodyGrid = document.createElement("div");
    bodyGrid.style.display = "grid";
    bodyGrid.style.gridTemplateColumns = COLS;
    bodyGrid.style.justifyContent = "start";
    bodyGrid.style.gridAutoRows = "auto";
    bodyGrid.style.alignContent = "start";
    bodyGrid.style.minHeight = "0";
    bodyGrid.style.height = "100%";
    bodyGrid.style.overflow = "auto";
    bodyGrid.style.overscrollBehavior = "contain";
    bodyGrid.style.width = "100%";
    bodyGrid.style.scrollbarGutter = "stable";
    card.appendChild(bodyGrid);
    const weatherLastSeenRefs = /* @__PURE__ */ new Map();
    const refreshRulesUI = () => {
      const kids = Array.from(bodyGrid.children);
      for (let i = 0; i + 3 < kids.length; i += 4) {
        const itemCell = kids[i];
        const ruleCell = kids[i + 3];
        const id = itemCell?.dataset?.id;
        if (!id) continue;
        applyRuleState(itemCell, ruleCell ?? null, NotifierService.getRule(id));
      }
    };
    const syncHeaderToScrollbar = () => {
      const sbw = bodyGrid.offsetWidth - bodyGrid.clientWidth;
      headerGrid.style.boxSizing = "border-box";
      headerGrid.style.paddingRight = `${sbw}px`;
    };
    syncHeaderToScrollbar();
    const resizeObserver = new ResizeObserver(syncHeaderToScrollbar);
    resizeObserver.observe(bodyGrid);
    const onResize = () => syncHeaderToScrollbar();
    window.addEventListener("resize", onResize);
    const makeItemCell = (row) => {
      const wrapCellDiv = document.createElement("div");
      Object.assign(wrapCellDiv.style, {
        display: "flex",
        alignItems: "center",
        gap: "8px",
        padding: "6px",
        borderBottom: "1px solid #ffffff12"
      });
      const ICON = 40;
      const iconWrap = document.createElement("div");
      Object.assign(iconWrap.style, {
        width: `${ICON}px`,
        height: `${ICON}px`,
        flex: `0 0 ${ICON}px`,
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: "8px",
        background: "#101820"
      });
      const weatherSprite = createWeatherSprite(row.spriteKey ?? row.id, {
        size: ICON - 4,
        fallback: "\u{1F326}",
        alt: row.name
      });
      iconWrap.appendChild(weatherSprite);
      const col = document.createElement("div");
      Object.assign(col.style, {
        display: "flex",
        flexDirection: "column",
        gap: "4px",
        lineHeight: "1.2",
        minWidth: "0",
        flex: "1 1 auto"
      });
      const headerRow = document.createElement("div");
      Object.assign(headerRow.style, {
        display: "flex",
        alignItems: "center",
        gap: "6px",
        minWidth: "0"
      });
      const title = document.createElement("div");
      title.textContent = row.name;
      Object.assign(title.style, {
        fontWeight: "700",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        flex: "1 1 auto"
      });
      headerRow.appendChild(title);
      if (row.isCurrent) {
        const badge = document.createElement("span");
        badge.textContent = "Current";
        Object.assign(badge.style, {
          fontSize: "11px",
          padding: "2px 6px",
          borderRadius: "999px",
          background: "#2b5cff33",
          border: "1px solid #2b5cff66",
          color: "#9cbcff",
          fontWeight: "600",
          whiteSpace: "nowrap"
        });
        headerRow.appendChild(badge);
      }
      const mutationsLabel = document.createElement("div");
      mutationsLabel.textContent = "Mutations";
      Object.assign(mutationsLabel.style, {
        fontSize: "11px",
        opacity: "0.7",
        fontWeight: "600"
      });
      const mutationsList = document.createElement("div");
      Object.assign(mutationsList.style, {
        display: "flex",
        flexWrap: "wrap",
        gap: "6px",
        alignItems: "flex-start",
        fontSize: "12px",
        lineHeight: "1.3",
        opacity: row.mutations.length ? "0.85" : "0.6"
      });
      if (row.mutations.length) {
        for (const mutation of row.mutations) {
          const chip = document.createElement("span");
          chip.textContent = formatWeatherMutation(mutation);
          Object.assign(chip.style, {
            display: "inline-flex",
            alignItems: "center",
            padding: "2px 8px",
            borderRadius: "999px",
            background: "#ffffff12",
            whiteSpace: "nowrap"
          });
          mutationsList.appendChild(chip);
        }
      } else {
        const chip = document.createElement("span");
        chip.textContent = "No mutation effects.";
        chip.style.whiteSpace = "nowrap";
        mutationsList.appendChild(chip);
      }
      const ruleHint = document.createElement("div");
      ruleHint.dataset.role = "rule-hint";
      ruleHint.style.opacity = "0.75";
      ruleHint.style.fontSize = "11px";
      ruleHint.style.whiteSpace = "nowrap";
      ruleHint.style.overflow = "hidden";
      ruleHint.style.textOverflow = "ellipsis";
      ruleHint.style.minHeight = "1.2em";
      ruleHint.style.visibility = "hidden";
      col.append(headerRow, mutationsLabel, mutationsList, ruleHint);
      wrapCellDiv.append(iconWrap, col);
      if (row.isCurrent) {
        wrapCellDiv.style.background = "linear-gradient(180deg, #1b2735, #141d25)";
        wrapCellDiv.style.borderRadius = "8px";
      }
      return wrapCellDiv;
    };
    const addRow = (row) => {
      const itemCell = makeItemCell(row);
      itemCell.dataset.id = row.id;
      itemCell.dataset.context = "weather";
      itemCell.dataset.current = row.isCurrent ? "1" : "0";
      const lastSeenInfo = document.createElement("div");
      const { label: label2, title } = formatLastSeen(row.lastSeen, row.isCurrent);
      lastSeenInfo.textContent = label2;
      lastSeenInfo.title = title;
      lastSeenInfo.style.fontWeight = "600";
      lastSeenInfo.style.opacity = label2 === "Never" ? "0.7" : "1";
      lastSeenInfo.style.whiteSpace = "nowrap";
      const lastSeenCell = wrapCell(lastSeenInfo);
      weatherLastSeenRefs.set(row.id, lastSeenInfo);
      const notifySwitch = createSwitch((on) => {
        try {
          NotifierService.setWeatherNotify(row.id, !!on);
        } catch {
        }
      });
      setSwitchVisual(notifySwitch, !!row.notify);
      notifySwitch.style.padding = "0";
      const notifyCell = wrapCell(notifySwitch);
      const gearBtn = ui.btn("", {
        icon: "\u2699",
        size: "sm",
        tooltip: "Custom rule",
        ariaLabel: `Custom rule for ${row.name}`
      });
      gearBtn.dataset.role = "rule";
      gearBtn.classList.add("qws-rule-btn");
      gearBtn.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        openRuleEditor(ui, {
          id: row.id,
          name: row.name,
          type: row.type,
          context: "weather"
        }, gearBtn);
      });
      const ruleCell = wrapCell(gearBtn);
      ruleCell.dataset.role = "rule-cell";
      bodyGrid.append(itemCell, lastSeenCell, notifyCell, ruleCell);
      applyRuleState(itemCell, ruleCell, NotifierService.getRule(row.id));
    };
    const clearGrid = () => {
      closeRuleEditor();
      bodyGrid.innerHTML = "";
      weatherLastSeenRefs.clear();
    };
    const renderEmpty = () => {
      const empty = document.createElement("div");
      empty.textContent = "No weather entries.";
      empty.style.opacity = "0.75";
      empty.style.gridColumn = "1 / -1";
      empty.style.padding = "8px";
      bodyGrid.appendChild(empty);
    };
    let state2 = null;
    let stateSig = "";
    const updateDynamicWeatherStats = () => {
      if (!state2) return;
      for (const row of state2.rows) {
        const target = weatherLastSeenRefs.get(row.id);
        if (target) {
          const { label: label2, title } = formatLastSeen(row.lastSeen, row.isCurrent);
          target.textContent = label2;
          target.title = title;
          target.style.opacity = label2 === "Never" ? "0.7" : "1";
        }
      }
    };
    const rebuildGrid = () => {
      clearGrid();
      if (!state2 || !state2.rows.length) {
        renderEmpty();
      } else {
        state2.rows.forEach(addRow);
        refreshRulesUI();
      }
      syncHeaderToScrollbar();
      updateDynamicWeatherStats();
    };
    let unsubWeather = null;
    let unsubRules = null;
    (async () => {
      try {
        await NotifierService.start();
      } catch {
      }
      try {
        unsubWeather = await NotifierService.onWeatherChangeNow((next) => {
          state2 = next;
          stateSig = weatherStateSignature(next.rows);
          rebuildGrid();
        });
      } catch {
      }
      try {
        unsubRules = await NotifierService.onRulesChangeNow(() => refreshRulesUI());
      } catch {
      }
    })();
    const refreshWeatherState = async () => {
      try {
        const next = await NotifierService.getWeatherState();
        const nextSig = weatherStateSignature(next.rows);
        const changed = nextSig !== stateSig;
        state2 = next;
        stateSig = nextSig;
        if (changed) rebuildGrid();
        else updateDynamicWeatherStats();
      } catch {
      }
    };
    const dynamicTimer = window.setInterval(updateDynamicWeatherStats, 3e4);
    const weatherRefreshTimer = window.setInterval(() => {
      void refreshWeatherState();
    }, 6e4);
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsubWeather?.();
        } catch {
        }
        try {
          unsubRules?.();
        } catch {
        }
        try {
          resizeObserver.disconnect();
        } catch {
        }
        try {
          window.removeEventListener("resize", onResize);
        } catch {
        }
        try {
          window.clearInterval(dynamicTimer);
        } catch {
        }
        try {
          window.clearInterval(weatherRefreshTimer);
        } catch {
        }
        try {
          closeRuleEditor();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderNotifierMenu(root) {
    const ui = new Menu({ id: "alerts", compact: true, windowSelector: ".qws-win" });
    ui.addTab("shops", "\u{1F6D2} Shops", (view) => renderShopTab(view, ui));
    ui.addTab("weather", "\u{1F326} Weather", (view) => renderWeatherTab(view, ui));
    ui.addTab("pets", "\u{1F43E} Pets", (view) => renderPetAlertsTab(view, ui));
    ui.addTab("settings", "\u2699\uFE0F Settings", (view) => renderSettingsTab(view, ui));
    ui.mount(root);
  }

  // src/utils/format.ts
  function formatPrice(val) {
    const n = typeof val === "number" ? val : Number(val);
    if (!Number.isFinite(n)) return n === Infinity ? "\u221E" : null;
    const abs = Math.abs(n);
    const fmt = (x) => Number.isInteger(x) ? String(x) : x.toFixed(1);
    if (abs >= 1e12) return `${fmt(n / 1e12)}T`;
    if (abs >= 1e9) return `${fmt(n / 1e9)}B`;
    if (abs >= 1e6) return `${fmt(n / 1e6)}M`;
    if (abs >= 1e3) return `${fmt(n / 1e3)}k`;
    return String(n);
  }

  // src/ui/menus/stats.ts
  var NF_INT = new Intl.NumberFormat("en-US");
  var formatInt = (value) => NF_INT.format(Math.max(0, Math.floor(value || 0)));
  var DURATION_ABILITIES = /* @__PURE__ */ new Set([
    "egggrowthboost",
    "egggrowthboostii_new",
    "egggrowthboostii",
    "plantgrowthboost",
    "plantgrowthboostii"
  ]);
  var XP_ABILITIES = /* @__PURE__ */ new Set([
    "petxpboost",
    "petxpboostii",
    "petageboost",
    "petageboostii"
  ]);
  var STRENGTH_ABILITIES = /* @__PURE__ */ new Set(["pethatchsizeboost", "pethatchsizeboostii"]);
  var HUNGER_ABILITIES = /* @__PURE__ */ new Set([
    "hungerrestore",
    "hungerrestoreii",
    "hungerboost",
    "hungerboostii"
  ]);
  function isPlainRecord(value) {
    return typeof value === "object" && value !== null;
  }
  function isGardenStatsSectionEmpty(garden2) {
    return (garden2.totalPlanted ?? 0) <= 0 && (garden2.totalHarvested ?? 0) <= 0 && (garden2.totalDestroyed ?? 0) <= 0 && (garden2.watercanUsed ?? 0) <= 0 && (garden2.waterTimeSavedMs ?? 0) <= 0;
  }
  function isShopStatsSectionEmpty(shops2) {
    return (shops2.seedsBought ?? 0) <= 0 && (shops2.decorBought ?? 0) <= 0 && (shops2.eggsBought ?? 0) <= 0 && (shops2.toolsBought ?? 0) <= 0 && (shops2.cropsSoldCount ?? 0) <= 0 && (shops2.cropsSoldValue ?? 0) <= 0 && (shops2.petsSoldCount ?? 0) <= 0 && (shops2.petsSoldValue ?? 0) <= 0;
  }
  function isPetStatsSectionEmpty(stats) {
    const entries = Object.values(stats.pets?.hatchedByType ?? {});
    if (entries.length === 0) return true;
    return entries.every((counts) => {
      if (!counts) return true;
      const normal = Number(counts.normal) || 0;
      const gold = Number(counts.gold) || 0;
      const rainbow = Number(counts.rainbow) || 0;
      return normal <= 0 && gold <= 0 && rainbow <= 0;
    });
  }
  async function readInventoryQuantity(atom, label2) {
    try {
      const raw = await atom.get();
      if (!Array.isArray(raw)) return 0;
      let total = 0;
      for (const entry of raw) {
        if (!entry || typeof entry !== "object") continue;
        const quantity = Number(entry.quantity);
        if (Number.isFinite(quantity) && quantity > 0) {
          total += Math.max(0, Math.floor(quantity));
        }
      }
      return total;
    } catch (error) {
      console.warn(`[StatsMenu] Failed to read ${label2} inventory`, error);
      return 0;
    }
  }
  async function initGarden(stats) {
    if (!isGardenStatsSectionEmpty(stats.garden)) return;
    let state2;
    try {
      state2 = await garden.get();
    } catch (error) {
      console.warn("[StatsMenu] Failed to read garden data", error);
      return;
    }
    if (!state2 || !isPlainRecord(state2.tileObjects)) return;
    let totalPlanted = 0;
    for (const value of Object.values(state2.tileObjects)) {
      if (!isPlainRecord(value)) continue;
      const objectType = typeof value.objectType === "string" ? value.objectType.toLowerCase() : "";
      if (objectType === "plant") {
        totalPlanted += 1;
      }
    }
    if (totalPlanted <= 0) return;
    StatsService.update((draft) => {
      if (!isGardenStatsSectionEmpty(draft.garden)) return;
      draft.garden.totalPlanted = totalPlanted;
    });
  }
  async function initShops(stats) {
    if (!isShopStatsSectionEmpty(stats.shops)) return;
    let state2 = null;
    try {
      state2 = await garden.get();
    } catch (error) {
      console.warn("[StatsMenu] Failed to read garden data", error);
    }
    let seedsBought = 0;
    let eggsBought = 0;
    let decorBought = 0;
    let toolsBought = 0;
    if (state2 && isPlainRecord(state2.tileObjects)) {
      for (const value of Object.values(state2.tileObjects)) {
        if (!isPlainRecord(value)) continue;
        const objectType = typeof value.objectType === "string" ? value.objectType.toLowerCase() : "";
        if (objectType === "plant") {
          seedsBought += 1;
        } else if (objectType === "egg") {
          eggsBought += 1;
        }
      }
    }
    if (state2 && isPlainRecord(state2.boardwalkTileObjects)) {
      for (const value of Object.values(state2.boardwalkTileObjects)) {
        if (value != null) {
          decorBought += 1;
        }
      }
    }
    const [seedInventoryQty, toolInventoryQty, eggInventoryQty, decorInventoryQty] = await Promise.all([
      readInventoryQuantity(mySeedInventory, "seed"),
      readInventoryQuantity(myToolInventory, "tool"),
      readInventoryQuantity(myEggInventory, "egg"),
      readInventoryQuantity(myDecorInventory, "decor")
    ]);
    seedsBought += seedInventoryQty;
    eggsBought += eggInventoryQty;
    decorBought += decorInventoryQty;
    toolsBought += toolInventoryQty;
    if (seedsBought <= 0 && eggsBought <= 0 && decorBought <= 0 && toolsBought <= 0) return;
    StatsService.update((draft) => {
      if (!isShopStatsSectionEmpty(draft.shops)) return;
      if (seedsBought > 0 && (draft.shops.seedsBought ?? 0) <= 0) {
        draft.shops.seedsBought = seedsBought;
      }
      if (eggsBought > 0 && (draft.shops.eggsBought ?? 0) <= 0) {
        draft.shops.eggsBought = eggsBought;
      }
      if (decorBought > 0 && (draft.shops.decorBought ?? 0) <= 0) {
        draft.shops.decorBought = decorBought;
      }
      if (toolsBought > 0 && (draft.shops.toolsBought ?? 0) <= 0) {
        draft.shops.toolsBought = toolsBought;
      }
    });
  }
  function getInventoryItems(raw) {
    if (Array.isArray(raw)) return raw;
    if (isPlainRecord(raw) && Array.isArray(raw.items)) {
      return raw.items;
    }
    return [];
  }
  function determinePetMutationType(mutations) {
    if (!Array.isArray(mutations)) return "normal";
    let hasGold = false;
    for (const mutation of mutations) {
      if (typeof mutation !== "string") continue;
      const normalized = mutation.trim().toLowerCase();
      if (normalized === "rainbow") {
        return "rainbow";
      }
      if (normalized === "gold") {
        hasGold = true;
      }
    }
    return hasGold ? "gold" : "normal";
  }
  async function initPets(stats) {
    if (!isPetStatsSectionEmpty(stats)) return;
    let inventory;
    try {
      inventory = await myInventory.get();
    } catch (error) {
      console.warn("[StatsMenu] Failed to read inventory data", error);
      inventory = null;
    }
    let activePetsRaw;
    try {
      activePetsRaw = await myPetInfos.get();
    } catch (error) {
      console.warn("[StatsMenu] Failed to read active pet data", error);
      activePetsRaw = null;
    }
    const items = getInventoryItems(inventory);
    const activePets = Array.isArray(activePetsRaw) ? activePetsRaw : [];
    if (items.length === 0 && activePets.length === 0) return;
    const countsBySpecies = /* @__PURE__ */ new Map();
    for (const item of items) {
      if (!isPlainRecord(item)) continue;
      const itemType = typeof item.itemType === "string" ? item.itemType.toLowerCase() : "";
      if (itemType !== "pet") continue;
      const speciesRaw = typeof item.petSpecies === "string" ? item.petSpecies : null;
      const species = speciesRaw?.trim();
      if (!species) continue;
      const key2 = species.toLowerCase();
      const counts = countsBySpecies.get(key2) ?? { normal: 0, gold: 0, rainbow: 0 };
      const rarityKey = determinePetMutationType(item.mutations);
      counts[rarityKey] = (counts[rarityKey] ?? 0) + 1;
      countsBySpecies.set(key2, counts);
    }
    for (const entry of activePets) {
      if (!isPlainRecord(entry)) continue;
      const slot = isPlainRecord(entry.slot) ? entry.slot : null;
      if (!slot) continue;
      const speciesRaw = typeof slot.petSpecies === "string" ? slot.petSpecies : null;
      const species = speciesRaw?.trim();
      if (!species) continue;
      const key2 = species.toLowerCase();
      const counts = countsBySpecies.get(key2) ?? { normal: 0, gold: 0, rainbow: 0 };
      const rarityKey = determinePetMutationType(slot.mutations);
      counts[rarityKey] = (counts[rarityKey] ?? 0) + 1;
      countsBySpecies.set(key2, counts);
    }
    let hasCounts = false;
    for (const counts of countsBySpecies.values()) {
      if ((counts.normal ?? 0) > 0 || (counts.gold ?? 0) > 0 || (counts.rainbow ?? 0) > 0) {
        hasCounts = true;
        break;
      }
    }
    if (!hasCounts) return;
    StatsService.update((draft) => {
      if (!isPetStatsSectionEmpty(draft)) return;
      for (const [speciesKey, counts] of countsBySpecies) {
        if ((counts.normal ?? 0) <= 0 && (counts.gold ?? 0) <= 0 && (counts.rainbow ?? 0) <= 0) {
          continue;
        }
        const entry = draft.pets.hatchedByType[speciesKey] ?? { normal: 0, gold: 0, rainbow: 0 };
        entry.normal = (entry.normal ?? 0) + (counts.normal ?? 0);
        entry.gold = (entry.gold ?? 0) + (counts.gold ?? 0);
        entry.rainbow = (entry.rainbow ?? 0) + (counts.rainbow ?? 0);
        draft.pets.hatchedByType[speciesKey] = entry;
      }
    });
  }
  function formatAbilityTotalValue(abilityId, totalValue) {
    const normalized = abilityId.toLowerCase();
    const safeValue = Number.isFinite(totalValue) ? Math.max(0, totalValue) : 0;
    if (DURATION_ABILITIES.has(normalized)) {
      return formatDuration(safeValue);
    }
    if (XP_ABILITIES.has(normalized)) {
      return `${formatInt(safeValue)} XP`;
    }
    if (STRENGTH_ABILITIES.has(normalized)) {
      return `${formatInt(safeValue)} strength`;
    }
    if (HUNGER_ABILITIES.has(normalized)) {
      const rounded = Math.round(safeValue);
      const isWholeNumber = Math.abs(safeValue - rounded) < 1e-6;
      const formatted = isWholeNumber ? formatInt(rounded) : safeValue.toFixed(1);
      return `${formatted}% hunger`;
    }
    return formatPrice(safeValue) ?? formatInt(safeValue);
  }
  var STATS_WINDOW_MIN_WIDTH = 560;
  var LS_STATS_COLLAPSE_KEY = "menu:stats:collapsed";
  var collapseStateCache = null;
  function getStatsStorage() {
    try {
      if (typeof window !== "undefined" && window.localStorage) {
        return window.localStorage;
      }
    } catch {
    }
    try {
      if (typeof localStorage !== "undefined") {
        return localStorage;
      }
    } catch {
    }
    return null;
  }
  function readCollapseState() {
    const storage = getStatsStorage();
    if (!storage) return {};
    try {
      const raw = storage.getItem(LS_STATS_COLLAPSE_KEY);
      if (!raw) return {};
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return {};
      const entries = Object.entries(parsed).filter((entry) => {
        return typeof entry[1] === "boolean";
      });
      return Object.fromEntries(entries);
    } catch (error) {
      console.warn("[StatsMenu] Failed to read collapse state", error);
      return {};
    }
  }
  function writeCollapseState(state2) {
    const storage = getStatsStorage();
    if (!storage) return;
    try {
      storage.setItem(LS_STATS_COLLAPSE_KEY, JSON.stringify(state2));
    } catch (error) {
      console.warn("[StatsMenu] Failed to save collapse state", error);
    }
  }
  function getCollapseState() {
    if (!collapseStateCache) {
      collapseStateCache = readCollapseState();
    }
    return collapseStateCache;
  }
  function getSectionCollapsed(id, fallback) {
    const state2 = getCollapseState();
    const value = state2[id];
    return typeof value === "boolean" ? value : fallback;
  }
  function setSectionCollapsed(id, collapsed) {
    const current = getCollapseState();
    if (current[id] === collapsed) return;
    const next = { ...current, [id]: collapsed };
    collapseStateCache = next;
    writeCollapseState(next);
  }
  var DATE_TIME_FORMATTER = new Intl.DateTimeFormat(void 0, {
    dateStyle: "medium",
    timeStyle: "short"
  });
  var RELATIVE_TIME_FORMATTER = new Intl.RelativeTimeFormat(void 0, {
    numeric: "auto"
  });
  var RARITY_ORDER2 = [
    rarity.Common,
    rarity.Uncommon,
    rarity.Rare,
    rarity.Legendary,
    rarity.Mythic,
    rarity.Divine,
    rarity.Celestial
  ];
  var RARITY_BORDER_COLORS = {
    [rarity.Common]: "#E7E7E7",
    [rarity.Uncommon]: "#67BD4D",
    [rarity.Rare]: "#0071C6",
    [rarity.Legendary]: "#FFC734",
    [rarity.Mythic]: "#9944A7",
    [rarity.Divine]: "#FF7835",
    [rarity.Celestial]: "#7C2AE8"
  };
  function createCollapsibleCard(ui, title, opts = {}) {
    const card = ui.card(title, { tone: "muted", align: "stretch", subtitle: opts.subtitle, icon: opts.icon });
    card.root.classList.add("qmm-card--collapsible");
    const toggle = document.createElement("button");
    toggle.type = "button";
    toggle.className = "qmm-btn qmm-btn--ghost qmm-btn--sm stats-collapse-toggle";
    toggle.style.marginLeft = "auto";
    const toggleIcon = document.createElement("span");
    toggleIcon.className = "stats-collapse-toggle__icon";
    toggleIcon.setAttribute("aria-hidden", "true");
    const toggleLabel = document.createElement("span");
    toggleLabel.className = "stats-collapse-toggle__label";
    toggle.append(toggleIcon, toggleLabel);
    const titleElement = card.header.querySelector(".qmm-card__title");
    if (titleElement) titleElement.insertAdjacentElement("afterend", toggle);
    else card.header.appendChild(toggle);
    const storageId = opts.storageId?.trim() || null;
    let currentAnimation = null;
    const stopAnimation = () => {
      if (!currentAnimation) return;
      currentAnimation.cancel();
      currentAnimation = null;
    };
    const animateBody = (collapsed) => {
      const body = card.body;
      stopAnimation();
      const prefersReducedMotion = typeof window.matchMedia === "function" && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      if (prefersReducedMotion) {
        body.style.display = collapsed ? "none" : "grid";
        body.style.height = "";
        body.style.opacity = "";
        body.style.overflow = "";
        return;
      }
      const easing = "cubic-bezier(0.33, 1, 0.68, 1)";
      const duration = 220;
      body.style.overflow = "hidden";
      if (!collapsed) {
        body.style.display = "grid";
        body.style.height = "0px";
        body.style.opacity = "0";
        const targetHeight = body.scrollHeight;
        currentAnimation = body.animate(
          [
            { height: "0px", opacity: 0 },
            { height: `${targetHeight}px`, opacity: 1 }
          ],
          { duration, easing, fill: "forwards" }
        );
      } else {
        const startHeight = body.offsetHeight;
        body.style.height = `${startHeight}px`;
        body.style.opacity = "1";
        currentAnimation = body.animate(
          [
            { height: `${startHeight}px`, opacity: 1 },
            { height: "0px", opacity: 0 }
          ],
          { duration, easing, fill: "forwards" }
        );
      }
      if (!currentAnimation) {
        body.style.display = collapsed ? "none" : "grid";
        body.style.height = "";
        body.style.opacity = "";
        body.style.overflow = "";
        return;
      }
      currentAnimation.onfinish = () => {
        if (collapsed) {
          body.style.display = "none";
          body.style.opacity = "";
        } else {
          body.style.display = "grid";
          body.style.opacity = "";
        }
        body.style.height = "";
        body.style.overflow = "";
        currentAnimation = null;
      };
      currentAnimation.oncancel = () => {
        body.style.height = "";
        body.style.opacity = "";
        body.style.overflow = "";
        if (collapsed) {
          body.style.display = "none";
        }
        currentAnimation = null;
      };
    };
    const setCollapsed = (collapsed, persist2 = true, animate = true) => {
      if (!animate) {
        stopAnimation();
        card.body.style.display = collapsed ? "none" : "grid";
        card.body.style.height = "";
        card.body.style.opacity = "";
        card.body.style.overflow = "";
      } else {
        animateBody(collapsed);
      }
      card.root.dataset.collapsed = collapsed ? "true" : "false";
      toggle.setAttribute("aria-expanded", String(!collapsed));
      const verb = collapsed ? "Show" : "Hide";
      const label2 = `${verb} ${title}`;
      toggleLabel.textContent = verb;
      toggle.setAttribute("aria-label", label2);
      toggle.title = label2;
      card.root.classList.toggle("is-collapsed", collapsed);
      if (persist2 && storageId) {
        setSectionCollapsed(storageId, collapsed);
      }
    };
    const defaultCollapsed = !!opts.startCollapsed;
    const initialCollapsed = storageId ? getSectionCollapsed(storageId, defaultCollapsed) : defaultCollapsed;
    setCollapsed(initialCollapsed, false, false);
    toggle.addEventListener("click", () => {
      const collapsed = card.root.dataset.collapsed === "true";
      setCollapsed(!collapsed);
    });
    return { root: card.root, body: card.body, header: card.header, setCollapsed };
  }
  function createMetricGrid(rows) {
    const grid = document.createElement("div");
    grid.className = "stats-metric-grid";
    for (const row of rows) {
      const card = document.createElement("div");
      card.className = "stats-metric";
      if (row.hint) card.title = row.hint;
      const label2 = document.createElement("span");
      label2.className = "stats-metric__label";
      label2.textContent = row.label;
      const value = document.createElement("span");
      value.className = "stats-metric__value qmm-num";
      value.textContent = row.value;
      card.append(label2, value);
      grid.appendChild(card);
    }
    return grid;
  }
  function createWeatherNameCell(entry) {
    const wrapper = document.createElement("span");
    wrapper.className = "stats-weather__name";
    const iconWrap = document.createElement("span");
    iconWrap.className = "stats-weather__icon";
    const sprite = createWeatherSprite(entry.spriteKey ?? entry.label, {
      size: 32,
      fallback: "\u{1F326}",
      alt: entry.label
    });
    iconWrap.appendChild(sprite);
    const label2 = document.createElement("span");
    label2.className = "stats-weather__label";
    label2.textContent = entry.label;
    wrapper.append(iconWrap, label2);
    return { content: wrapper };
  }
  function createStatList(columns, rows) {
    const container = document.createElement("div");
    container.className = "stats-list";
    const toTemplate = (column) => {
      if (column.width) return column.width;
      if (column.minWidth) return `minmax(${column.minWidth}, 1fr)`;
      return "minmax(0, 1fr)";
    };
    const template = columns.map(toTemplate).join(" ");
    const header = document.createElement("div");
    header.className = "stats-list__row stats-list__row--header";
    header.style.gridTemplateColumns = template;
    for (const column of columns) {
      const cell = document.createElement("span");
      cell.className = "stats-list__cell";
      const align = column.align ?? "left";
      if (align !== "left") cell.classList.add(`stats-list__cell--align-${align}`);
      if (column.headerClassName) cell.classList.add(column.headerClassName);
      cell.textContent = column.label;
      header.appendChild(cell);
    }
    container.appendChild(header);
    for (const row of rows) {
      const rowEl = document.createElement("div");
      rowEl.className = "stats-list__row";
      rowEl.style.gridTemplateColumns = template;
      row.forEach((cellData, index) => {
        const column = columns[index];
        const cell = document.createElement("span");
        cell.className = "stats-list__cell";
        const align = cellData.align ?? column.align ?? "left";
        if (align !== "left") {
          cell.classList.add(`stats-list__cell--align-${align}`);
          if (align === "right") cell.classList.add("qmm-num");
        }
        if (cellData.hint) cell.title = cellData.hint;
        const hasContent = Boolean(cellData.content);
        if (cellData.content) {
          cell.appendChild(cellData.content);
        }
        if (cellData.text != null) {
          if (hasContent) {
            const textSpan = document.createElement("span");
            textSpan.textContent = cellData.text;
            cell.appendChild(textSpan);
          } else {
            cell.textContent = cellData.text;
          }
        } else if (!hasContent) {
          cell.textContent = "";
        }
        rowEl.appendChild(cell);
      });
      container.appendChild(rowEl);
    }
    return container;
  }
  function formatDuration(ms) {
    const value = Math.max(0, ms || 0);
    if (value < 1e3) return `${formatInt(value)} ms`;
    const seconds = value / 1e3;
    if (seconds < 60) return `${seconds.toFixed(1)} s`;
    const minutes = seconds / 60;
    if (minutes < 60) return `${minutes.toFixed(1)} min`;
    const hours = minutes / 60;
    return `${hours.toFixed(1)} h`;
  }
  function formatDateTime(ms) {
    return DATE_TIME_FORMATTER.format(new Date(ms));
  }
  function renderMetaSection(ui, root, stats) {
    const card = ui.card("\u{1F5D3}\uFE0F Tracking", {
      tone: "muted",
      align: "stretch",
      compactHeader: true
    });
    const createdAt = Number.isFinite(stats.createdAt) ? Math.max(0, Math.floor(stats.createdAt)) : 0;
    const hasCreatedAt = createdAt > 0;
    const row = ui.flexRow({ align: "center", gap: 12, className: "stats-meta" });
    const label2 = document.createElement("span");
    label2.className = "stats-meta__label";
    label2.textContent = "Tracking started:";
    row.appendChild(label2);
    const value = document.createElement("strong");
    value.className = "stats-meta__value";
    value.textContent = hasCreatedAt ? formatDateTime(createdAt) : "Unavailable";
    row.appendChild(value);
    const resetButton = ui.btn("RESET", { variant: "danger" });
    resetButton.style.marginLeft = "auto";
    resetButton.addEventListener("click", () => {
      const freshStats = StatsService.reset();
      void initGarden(freshStats);
      void initShops(freshStats);
      void initPets(freshStats);
    });
    row.appendChild(resetButton);
    card.body.appendChild(row);
    root.appendChild(card.root);
  }
  function renderGardenSection(ui, root, stats) {
    const card = createCollapsibleCard(ui, "\u{1F331} Garden", {
      subtitle: "Field activity",
      storageId: "garden"
    });
    const rows = [
      { label: "Total planted", value: formatInt(stats.garden.totalPlanted) },
      { label: "Total harvested", value: formatInt(stats.garden.totalHarvested) },
      { label: "Total destroyed", value: formatInt(stats.garden.totalDestroyed) },
      { label: "Watering can Used", value: formatInt(stats.garden.watercanUsed) },
      {
        label: "Water time saved",
        value: formatDuration(stats.garden.waterTimeSavedMs),
        hint: `${formatInt(stats.garden.waterTimeSavedMs)} ms`
      }
    ];
    card.body.appendChild(createMetricGrid(rows));
    root.appendChild(card.root);
  }
  function renderShopSection(ui, root, stats) {
    const card = createCollapsibleCard(ui, "\u{1F3EA} Shops", {
      subtitle: "Purchases & sales",
      storageId: "shops"
    });
    const rows = [
      { label: "Seeds bought", value: formatInt(stats.shops.seedsBought) },
      { label: "Tools bought", value: formatInt(stats.shops.toolsBought) },
      { label: "Eggs bought", value: formatInt(stats.shops.eggsBought) },
      { label: "Decor bought", value: formatInt(stats.shops.decorBought) },
      { label: "Crops sold", value: `${formatInt(stats.shops.cropsSoldCount)} items` },
      {
        label: "Crop revenue",
        value: formatPrice(stats.shops.cropsSoldValue) ?? formatInt(stats.shops.cropsSoldValue)
      },
      { label: "Pets sold", value: `${formatInt(stats.shops.petsSoldCount)} pets` },
      {
        label: "Pet revenue",
        value: formatPrice(stats.shops.petsSoldValue) ?? formatInt(stats.shops.petsSoldValue)
      }
    ];
    card.body.appendChild(createMetricGrid(rows));
    root.appendChild(card.root);
  }
  function createPetRarityGroups() {
    const map2 = /* @__PURE__ */ new Map();
    for (const rarityKey of RARITY_ORDER2) {
      map2.set(rarityKey, []);
    }
    for (const species of Object.keys(petCatalog)) {
      const info = petCatalog[species];
      const rarityValue = info?.rarity ?? rarity.Common;
      const list = map2.get(rarityValue) ?? [];
      list.push(species);
      map2.set(rarityValue, list);
    }
    for (const list of map2.values()) {
      list.sort((a, b) => a.localeCompare(b));
    }
    return map2;
  }
  var petSpriteCache2 = /* @__PURE__ */ new Map();
  var petSpritePromises2 = /* @__PURE__ */ new Map();
  var petSpriteSubscribers = /* @__PURE__ */ new Map();
  var petSpriteConfig = /* @__PURE__ */ new WeakMap();
  var petSpriteListenerAttached = false;
  var petSheetBasesCache2 = null;
  function resetPetSheetBases() {
    petSheetBasesCache2 = null;
  }
  function getPetSheetBases2() {
    if (petSheetBasesCache2) return petSheetBasesCache2;
    const urls = /* @__PURE__ */ new Set();
    try {
      Sprites.listPets().forEach((url) => urls.add(url));
    } catch {
    }
    const bases = Array.from(urls, (url) => {
      const clean = url.split(/[?#]/)[0] ?? url;
      const file = clean.split("/").pop() ?? clean;
      return file.replace(/\.[^.]+$/, "");
    });
    petSheetBasesCache2 = bases;
    return bases;
  }
  function toPetTileIndex2(tileRef) {
    const value = typeof tileRef === "number" && Number.isFinite(tileRef) ? tileRef : Number(tileRef);
    if (!Number.isFinite(value)) return null;
    if (value <= 0) return value;
    return value - 1;
  }
  async function fetchPetSprite2(species) {
    await ensureSpritesReady();
    const entry = petCatalog[species];
    const tileRef = entry?.tileRef;
    if (tileRef == null) return null;
    const index = toPetTileIndex2(tileRef);
    if (index == null) return null;
    const baseCandidates = new Set(getPetSheetBases2());
    if (baseCandidates.size === 0) {
      baseCandidates.add("pets");
      baseCandidates.add("Pets");
    }
    for (const base of baseCandidates) {
      try {
        const tiles = await loadTileSheet(base);
        const tile = tiles.find((t) => t.index === index);
        if (!tile) continue;
        const canvas = Sprites.toCanvas(tile);
        if (canvas && canvas.width > 0 && canvas.height > 0) {
          const copy2 = document.createElement("canvas");
          copy2.width = canvas.width;
          copy2.height = canvas.height;
          const ctx = copy2.getContext("2d");
          if (!ctx) continue;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(canvas, 0, 0);
          return copy2.toDataURL();
        }
      } catch {
      }
    }
    return null;
  }
  function applyPetSprite(el2, src) {
    const cfg = petSpriteConfig.get(el2);
    if (!cfg) return;
    const { size, fallback } = cfg;
    el2.classList.add("stats-pet__sprite-icon");
    el2.style.setProperty("--stats-pet-sprite-size", `${size}px`);
    el2.innerHTML = "";
    if (src) {
      el2.style.fontSize = "";
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";
      img.decoding = "async";
      img.loading = "lazy";
      img.draggable = false;
      el2.appendChild(img);
    } else {
      el2.textContent = fallback;
      el2.style.fontSize = `${Math.max(10, Math.round(size * 0.7))}px`;
    }
  }
  function subscribePetSprite(species, el2, config) {
    let subs = petSpriteSubscribers.get(species);
    if (!subs) {
      subs = /* @__PURE__ */ new Set();
      petSpriteSubscribers.set(species, subs);
    }
    subs.add(el2);
    petSpriteConfig.set(el2, config);
  }
  function notifyPetSpriteSubscribers(species, src) {
    const subs = petSpriteSubscribers.get(species);
    if (!subs) return;
    subs.forEach((el2) => {
      if (!el2.isConnected) {
        subs.delete(el2);
        petSpriteConfig.delete(el2);
        return;
      }
      applyPetSprite(el2, src);
    });
    if (subs.size === 0) {
      petSpriteSubscribers.delete(species);
    }
  }
  function loadPetSprite2(species) {
    if (typeof window === "undefined") {
      return Promise.resolve(null);
    }
    const cached = petSpriteCache2.get(species);
    if (cached !== void 0) {
      notifyPetSpriteSubscribers(species, cached);
      return Promise.resolve(cached);
    }
    const inflight = petSpritePromises2.get(species);
    if (inflight) return inflight;
    const promise = fetchPetSprite2(species).then((src) => {
      petSpriteCache2.set(species, src);
      petSpritePromises2.delete(species);
      notifyPetSpriteSubscribers(species, src);
      return src;
    }).catch(() => {
      petSpritePromises2.delete(species);
      return null;
    });
    petSpritePromises2.set(species, promise);
    return promise;
  }
  function ensurePetSpriteListener() {
    if (petSpriteListenerAttached || typeof window === "undefined") return;
    petSpriteListenerAttached = true;
    window.addEventListener("mg:sprite-detected", () => {
      petSpriteCache2.clear();
      petSpritePromises2.clear();
      resetPetSheetBases();
      const keys = Array.from(petSpriteSubscribers.keys());
      keys.forEach((key2) => {
        void loadPetSprite2(key2);
      });
    });
  }
  function createPetSprite(species, options = {}) {
    const size = Math.max(12, options.size ?? 28);
    const defaultFallback2 = species.trim().charAt(0) || "\u{1F43E}";
    const fallbackSource = options.fallback ?? defaultFallback2;
    const fallback = fallbackSource.toString();
    const el2 = document.createElement("span");
    if (typeof window === "undefined") {
      el2.classList.add("stats-pet__sprite-icon");
      el2.style.setProperty("--stats-pet-sprite-size", `${size}px`);
      el2.textContent = fallback;
      el2.style.fontSize = `${Math.max(10, Math.round(size * 0.7))}px`;
      return el2;
    }
    ensurePetSpriteListener();
    subscribePetSprite(species, el2, { size, fallback });
    const cached = petSpriteCache2.get(species);
    applyPetSprite(el2, cached ?? null);
    void loadPetSprite2(species);
    return el2;
  }
  function createPetSpeciesCell(species) {
    const wrapper = document.createElement("span");
    wrapper.className = "stats-pet__species";
    const sprite = createPetSprite(species, {
      size: 28,
      fallback: species.trim().charAt(0).toUpperCase() || "\u{1F43E}"
    });
    const label2 = document.createElement("span");
    label2.className = "stats-pet__label";
    label2.textContent = species;
    wrapper.appendChild(sprite);
    wrapper.appendChild(label2);
    return { content: wrapper };
  }
  function createPetTotalValueCell(total) {
    const value = document.createElement("span");
    value.className = "stats-pet__total-value qmm-num";
    value.textContent = formatInt(total);
    return { content: value, align: "center" };
  }
  function renderPetSection(ui, root, stats) {
    const card = createCollapsibleCard(ui, "\u{1F43E} Pets", {
      subtitle: "Hatching overview",
      storageId: "pets"
    });
    const groups = createPetRarityGroups();
    for (const rarityKey of RARITY_ORDER2) {
      const speciesList = groups.get(rarityKey) ?? [];
      if (!speciesList.length) continue;
      const group = document.createElement("div");
      group.className = "stats-pet-group";
      group.style.setProperty("--stats-pet-group-border-color", RARITY_BORDER_COLORS[rarityKey]);
      const summary = document.createElement("div");
      summary.className = "stats-pet-group__summary";
      summary.textContent = "";
      const badge = rarityBadge(rarityKey);
      badge.style.margin = "0";
      summary.appendChild(badge);
      group.appendChild(summary);
      const content = document.createElement("div");
      content.className = "stats-pet-group__content";
      const columns = [
        { label: "Species", width: "2.2fr" },
        { label: "Normal", align: "center", width: "1fr" },
        { label: "Gold", align: "center", width: "1fr", headerClassName: "stats-list__header-label--gold" },
        {
          label: "Rainbow",
          align: "center",
          width: "1fr",
          headerClassName: "stats-list__header-label--rainbow"
        },
        { label: "Total", align: "center", width: "1fr" }
      ];
      const rows = [];
      for (const species of speciesList) {
        const key2 = species.toLowerCase();
        const counts = stats.pets.hatchedByType[key2] ?? { normal: 0, gold: 0, rainbow: 0 };
        const total = counts.normal + counts.gold + counts.rainbow;
        rows.push([
          createPetSpeciesCell(species),
          { text: formatInt(counts.normal), align: "center" },
          { text: formatInt(counts.gold), align: "center" },
          { text: formatInt(counts.rainbow), align: "center" },
          createPetTotalValueCell(total)
        ]);
      }
      content.appendChild(createStatList(columns, rows));
      group.appendChild(content);
      card.body.appendChild(group);
    }
    root.appendChild(card.root);
  }
  function renderAbilitySection(ui, root, stats) {
    const card = createCollapsibleCard(ui, "\u{1F9E0} Abilities", {
      subtitle: "Trigger counts",
      storageId: "abilities"
    });
    const abilityIds = Object.keys(petAbilities).sort((a, b) => {
      const nameA = petAbilities[a]?.name ?? a;
      const nameB = petAbilities[b]?.name ?? b;
      return nameA.localeCompare(nameB);
    });
    const columns = [
      { label: "Ability", width: "2.2fr" },
      { label: "Triggers", align: "right", width: "1fr" },
      { label: "Value", align: "right", width: "1.2fr" }
    ];
    const rows = [];
    for (const id of abilityIds) {
      const info = petAbilities[id];
      const statsEntry = stats.abilities[id] ?? { triggers: 0, totalValue: 0 };
      const formatted = formatAbilityTotalValue(id, statsEntry.totalValue);
      rows.push([
        { text: info?.name ?? id, hint: info?.description },
        { text: formatInt(statsEntry.triggers) },
        { text: formatted }
      ]);
    }
    card.body.appendChild(createStatList(columns, rows));
    root.appendChild(card.root);
  }
  function renderWeatherSection(ui, root, stats) {
    const card = createCollapsibleCard(ui, "\u26C5 Weather", {
      subtitle: "Events overview",
      storageId: "weather"
    });
    const columns = [
      { label: "Weather", width: "2fr" },
      { label: "TOTAL", align: "right", width: "1fr" }
    ];
    const rows = [];
    const weatherEntries = Object.keys(weatherCatalog).map((key2) => {
      const info = weatherCatalog[key2];
      const label2 = info?.atomValue ?? key2;
      const lower = key2.toLowerCase();
      const entry = stats.weather[lower] ?? { triggers: 0 };
      const spriteKey2 = getWeatherSpriteKey(key2) ?? getWeatherSpriteKey(info?.atomValue) ?? getWeatherSpriteKey(info?.displayName) ?? null;
      return { key: lower, label: label2, triggers: entry.triggers, spriteKey: spriteKey2 };
    }).sort((a, b) => a.label.localeCompare(b.label));
    for (const entry of weatherEntries) {
      rows.push([
        createWeatherNameCell({ label: entry.label, spriteKey: entry.spriteKey }),
        { text: formatInt(entry.triggers) }
      ]);
    }
    card.body.appendChild(createStatList(columns, rows));
    root.appendChild(card.root);
  }
  function renderStatsMenu(container) {
    const root = container;
    if (typeof root.__statsCleanup === "function") {
      try {
        root.__statsCleanup();
      } catch (error) {
        console.error("[StatsMenu] Cleanup error", error);
      }
      root.__statsCleanup = void 0;
    }
    const prevRoot = container.firstElementChild;
    const prevView = prevRoot?.classList.contains("qmm") ? prevRoot.querySelector(".qmm-views") ?? null : null;
    const previousScrollTop = prevView ? prevView.scrollTop : null;
    let rafId = null;
    let unsubscribed = false;
    let unsubscribe2 = () => {
    };
    const cleanup2 = () => {
      if (unsubscribed) return;
      unsubscribed = true;
      try {
        unsubscribe2();
      } catch (error) {
        console.error("[StatsMenu] Unsubscribe error", error);
      }
      if (rafId !== null) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
      if (root.__statsCleanup === cleanup2) {
        root.__statsCleanup = void 0;
      }
    };
    unsubscribe2 = StatsService.subscribe(() => {
      if (!root.isConnected) {
        cleanup2();
        return;
      }
      if (rafId !== null) return;
      rafId = requestAnimationFrame(() => {
        rafId = null;
        renderStatsMenu(container);
      });
    });
    root.__statsCleanup = cleanup2;
    const ui = new Menu({ id: "stats", compact: true });
    ui.mount(container);
    const win = ui.root.closest(".qws-win");
    if (win) {
      win.style.minWidth = `${STATS_WINDOW_MIN_WIDTH}px`;
    }
    const paddingStyle = getComputedStyle(container);
    const paddingLeft = Number.parseFloat(paddingStyle.paddingLeft) || 0;
    const paddingRight = Number.parseFloat(paddingStyle.paddingRight) || 0;
    const minContentWidth = Math.max(0, STATS_WINDOW_MIN_WIDTH - paddingLeft - paddingRight);
    container.style.minWidth = `${minContentWidth}px`;
    const view = ui.root.querySelector(".qmm-views");
    if (!view) return;
    view.innerHTML = "";
    view.style.display = "grid";
    view.style.gap = "12px";
    view.style.padding = "4px 0";
    view.style.minHeight = "0";
    view.style.alignContent = "start";
    view.style.maxHeight = "54vh";
    const stats = StatsService.getSnapshot();
    initGarden(stats).catch((error) => {
      console.error("[StatsMenu] Failed to initialize garden stats", error);
    });
    initShops(stats).catch((error) => {
      console.error("[StatsMenu] Failed to initialize shop stats", error);
    });
    initPets(stats).catch((error) => {
      console.error("[StatsMenu] Failed to initialize pet stats", error);
    });
    renderMetaSection(ui, view, stats);
    renderGardenSection(ui, view, stats);
    renderShopSection(ui, view, stats);
    renderPetSection(ui, view, stats);
    renderAbilitySection(ui, view, stats);
    renderWeatherSection(ui, view, stats);
    if (previousScrollTop !== null) {
      view.scrollTop = previousScrollTop;
    }
  }

  // src/ui/menus/pets.ts
  function getAbilityChipColors(id) {
    const key2 = String(id || "");
    const base = (PetsService.getAbilityNameWithoutLevel?.(key2) || "").replace(/[\s\-_]+/g, "").toLowerCase();
    const is = (prefix) => key2.startsWith(prefix) || base === prefix.toLowerCase();
    if (is("ProduceScaleBoost")) return { bg: "rgba(34,139,34,0.9)", hover: "rgba(34,139,34,1)" };
    if (is("PlantGrowthBoost")) return { bg: "rgba(0,128,128,0.9)", hover: "rgba(0,128,128,1)" };
    if (is("EggGrowthBoost")) return { bg: "rgba(180,90,240,0.9)", hover: "rgba(180,90,240,1)" };
    if (is("PetAgeBoost")) return { bg: "rgba(147,112,219,0.9)", hover: "rgba(147,112,219,1)" };
    if (is("PetHatchSizeBoost")) return { bg: "rgba(128,0,128,0.9)", hover: "rgba(128,0,128,1)" };
    if (is("PetXpBoost")) return { bg: "rgba(30,144,255,0.9)", hover: "rgba(30,144,255,1)" };
    if (is("HungerBoost")) return { bg: "rgba(255,20,147,0.9)", hover: "rgba(255,20,147,1)" };
    if (is("SellBoost")) return { bg: "rgba(220,20,60,0.9)", hover: "rgba(220,20,60,1)" };
    if (is("CoinFinder")) return { bg: "rgba(180,150,0,0.9)", hover: "rgba(180,150,0,1)" };
    if (is("ProduceMutationBoost")) return { bg: "rgba(138,43,226,0.9)", hover: "rgba(138,43,226,1)" };
    if (is("DoubleHarvest")) return { bg: "rgba(0,120,180,0.9)", hover: "rgba(0,120,180,1)" };
    if (is("ProduceEater")) return { bg: "rgba(255,69,0,0.9)", hover: "rgba(255,69,0,1)" };
    if (is("ProduceRefund")) return { bg: "rgba(255,99,71,0.9)", hover: "rgba(255,99,71,1)" };
    if (is("PetMutationBoost")) return { bg: "rgba(156,65,181,0.9)", hover: "rgba(156,65,181,1)" };
    if (is("HungerRestore")) return { bg: "rgba(255,105,180,0.9)", hover: "rgba(255,105,180,1)" };
    if (is("PetRefund")) return { bg: "rgba(0,80,120,0.9)", hover: "rgba(0,80,120,1)" };
    if (is("Copycat")) return { bg: "rgba(255,140,0,0.9)", hover: "rgba(255,140,0,1)" };
    if (is("GoldGranter")) {
      return {
        bg: "linear-gradient(135deg, rgba(225,200,55,0.9) 0%, rgba(225,180,10,0.9) 40%, rgba(215,185,45,0.9) 70%, rgba(210,185,45,0.9) 100%)",
        hover: "linear-gradient(135deg, rgba(220,200,70,1) 0%, rgba(210,175,5,1) 40%, rgba(210,185,55,1) 70%, rgba(200,175,30,1) 100%)"
      };
    }
    if (is("RainbowGranter")) {
      return {
        bg: "linear-gradient(45deg, rgba(200,0,0,0.9), rgba(200,120,0,0.9), rgba(160,170,30,0.9), rgba(60,170,60,0.9), rgba(50,170,170,0.9), rgba(40,150,180,0.9), rgba(20,90,180,0.9), rgba(70,30,150,0.9))",
        hover: "linear-gradient(45deg, rgba(200,0,0,1), rgba(200,120,0,1), rgba(160,170,30,1), rgba(60,170,60,1), rgba(50,170,170,1), rgba(40,150,180,1), rgba(20,90,180,1), rgba(70,30,150,1))"
      };
    }
    if (is("SeedFinderIV")) {
      return {
        bg: "linear-gradient(130deg, rgba(0,180,216,0.9) 0%, rgba(124,42,232,0.9) 40%, rgba(160,0,126,0.9) 60%, rgba(255,215,0,0.9) 100%)",
        hover: "linear-gradient(130deg, rgba(0,180,216,1) 0%, rgba(124,42,232,1) 40%, rgba(160,0,126,1) 60%, rgba(255,215,0,1) 100%)"
      };
    }
    if (is("SeedFinder")) {
      const lv = key2.replace(/.*?([IVX]+)$/, "$1");
      if (lv === "II") return { bg: "rgba(183,121,31,0.9)", hover: "rgba(183,121,31,1)" };
      if (lv === "III") return { bg: "rgba(139,62,152,0.9)", hover: "rgba(139,62,152,1)" };
      return { bg: "rgba(94,172,70,0.9)", hover: "rgba(94,172,70,1)" };
    }
    return { bg: "rgba(100,100,100,0.9)", hover: "rgba(150,150,150,1)" };
  }
  function renderManagerTab(view, ui) {
    view.innerHTML = "";
    let teams = [];
    let selectedId = null;
    let activeTeamId = null;
    let activePetIdSet = /* @__PURE__ */ new Set();
    let isApplyingTeam = false;
    let draggingIdx = null;
    let overInsertIdx = null;
    let draggingHeight = 0;
    let invCacheMap = null;
    const lastRenderedSlotIds = [null, null, null];
    function applySubtleBorder(btn, hex, alpha = 0.22) {
      const toRgba = (h, a) => {
        const m = h.replace("#", "");
        const r = parseInt(m.length === 3 ? m[0] + m[0] : m.slice(0, 2), 16);
        const g = parseInt(m.length === 3 ? m[1] + m[1] : m.slice(2, 4), 16);
        const b = parseInt(m.length === 3 ? m[2] + m[2] : m.slice(4, 6), 16);
        return `rgba(${r},${g},${b},${a})`;
      };
      const border = toRgba(hex, alpha);
      btn.style.border = `1px solid ${border}`;
      btn.style.background = "#1f2328";
      btn.style.boxShadow = "none";
      btn.style.transition = "none";
    }
    const framed = (title, content) => {
      const cardSection = ui.card(title, { tone: "muted", align: "center" });
      cardSection.body.append(content);
      cardSection.root.style.maxWidth = "720px";
      return cardSection.root;
    };
    const row = (opts) => ui.flexRow({ justify: opts?.justify ?? "center" });
    const wrap = document.createElement("div");
    wrap.style.display = "grid";
    wrap.style.gridTemplateColumns = "minmax(220px, 280px) minmax(0, 1fr)";
    wrap.style.gap = "10px";
    wrap.style.alignItems = "stretch";
    wrap.style.height = "54vh";
    wrap.style.overflow = "hidden";
    view.appendChild(wrap);
    const left = document.createElement("div");
    left.style.display = "grid";
    left.style.gridTemplateRows = "1fr auto";
    left.style.gap = "8px";
    left.style.minHeight = "0";
    wrap.appendChild(left);
    const teamList = document.createElement("div");
    teamList.style.display = "flex";
    teamList.style.flexDirection = "column";
    teamList.style.gap = "6px";
    teamList.style.overflow = "auto";
    teamList.style.padding = "6px";
    teamList.style.border = "1px solid #4445";
    teamList.style.borderRadius = "10px";
    teamList.style.scrollBehavior = "smooth";
    teamList.style.minHeight = "0";
    left.appendChild(teamList);
    const footer = document.createElement("div");
    footer.style.display = "flex";
    footer.style.gap = "6px";
    left.appendChild(footer);
    const btnNew = ui.btn("\u2795 New", { variant: "primary", size: "sm" });
    btnNew.id = "pets.teams.new";
    btnNew.style.flex = "1 1 0";
    const btnDel = ui.btn("\u{1F5D1}\uFE0F Delete", { variant: "danger", size: "sm" });
    btnDel.id = "pets.teams.delete";
    btnDel.style.flex = "1 1 0";
    applySubtleBorder(btnNew, "#22c55e", 0.22);
    applySubtleBorder(btnDel, "#ef4444", 0.22);
    footer.append(btnNew, btnDel);
    function getSelectedTeam() {
      return teams.find((t) => t.id === selectedId) || null;
    }
    function computeInsertIndex(clientY) {
      const children = Array.from(teamList.children);
      if (!children.length) return 0;
      const first = children[0].getBoundingClientRect();
      if (clientY < first.top + first.height / 2) return 0;
      for (let i = 0; i < children.length; i++) {
        const rect = children[i].getBoundingClientRect();
        const mid = rect.top + rect.height / 2;
        if (clientY < mid) return i;
      }
      return children.length;
    }
    function abilitiesBadge(abilities) {
      const wrap2 = document.createElement("span");
      wrap2.style.display = "inline-flex";
      wrap2.style.alignItems = "center";
      wrap2.style.lineHeight = "1";
      const SPACING_PX = 8;
      const SIZE_PX = 12;
      const RADIUS_PX = 3;
      const ids = Array.isArray(abilities) ? abilities.filter(Boolean) : [];
      if (!ids.length) {
        const empty = document.createElement("span");
        empty.textContent = "No ability";
        empty.style.opacity = "0.75";
        empty.style.fontSize = "12px";
        wrap2.appendChild(empty);
        return wrap2;
      }
      ids.forEach((id, i) => {
        const chip = document.createElement("span");
        const { bg, hover } = getAbilityChipColors(id);
        chip.title = PetsService.getAbilityName(id) || id;
        chip.setAttribute("aria-label", chip.title);
        Object.assign(chip.style, {
          display: "inline-block",
          width: `${SIZE_PX}px`,
          height: `${SIZE_PX}px`,
          borderRadius: `${RADIUS_PX}px`,
          marginRight: i === ids.length - 1 ? "0" : `${SPACING_PX}px`,
          background: bg,
          transition: "transform 80ms ease, box-shadow 120ms ease, background 120ms ease",
          cursor: "default",
          boxShadow: "0 0 0 1px #0006 inset, 0 0 0 1px #ffffff1a"
        });
        chip.onmouseenter = () => {
          chip.style.background = hover;
          chip.style.transform = "scale(1.08)";
          chip.style.boxShadow = "0 0 0 1px #0006 inset, 0 0 0 1px #ffffff33";
        };
        chip.onmouseleave = () => {
          chip.style.background = bg;
          chip.style.transform = "none";
          chip.style.boxShadow = "0 0 0 1px #0006 inset, 0 0 0 1px #ffffff1a";
        };
        wrap2.appendChild(chip);
      });
      return wrap2;
    }
    function applyLiveTransforms() {
      const children = Array.from(teamList.children);
      children.forEach((el2) => el2.style.transform = "");
      if (draggingIdx === null || overInsertIdx === null) return;
      const from = draggingIdx;
      const to = overInsertIdx;
      children.forEach((el2, idx) => {
        el2.style.transition = "transform 120ms ease";
        if (idx === from) return;
        if (to > from && idx > from && idx < to) {
          el2.style.transform = `translateY(${-draggingHeight}px)`;
        }
        if (to < from && idx >= to && idx < from) {
          el2.style.transform = `translateY(${draggingHeight}px)`;
        }
      });
    }
    function clearLiveTransforms() {
      Array.from(teamList.children).forEach((el2) => {
        el2.style.transform = "";
        el2.style.transition = "";
      });
    }
    async function refreshActiveIds() {
      activeTeamId = null;
      activePetIdSet = /* @__PURE__ */ new Set();
      try {
        const pets = await PetsService.getPets();
        const equipIds = Array.isArray(pets) ? pets.map((p) => String(p?.slot?.id || "")).filter(Boolean) : [];
        activePetIdSet = new Set(equipIds);
        for (const t of teams) {
          const tIds = (t.slots || []).filter(Boolean);
          if (tIds.length !== equipIds.length) continue;
          let same = true;
          for (const id of tIds) {
            if (!activePetIdSet.has(id)) {
              same = false;
              break;
            }
          }
          if (same) {
            activeTeamId = t.id;
            break;
          }
        }
      } catch {
      }
    }
    async function refreshTeamList(skipDetectActive = false) {
      if (!skipDetectActive) {
        await refreshActiveIds();
      }
      clearLiveTransforms();
      draggingIdx = null;
      overInsertIdx = null;
      draggingHeight = 0;
      teamList.innerHTML = "";
      if (!teams.length) {
        const empty = document.createElement("div");
        empty.textContent = "No teams yet. Create one!";
        empty.style.opacity = "0.75";
        empty.style.textAlign = "center";
        empty.style.padding = "8px";
        teamList.appendChild(empty);
        hydrateEditor(null);
        return;
      }
      teams.forEach((t, idx) => {
        const item = document.createElement("div");
        const isActive = t.id === activeTeamId;
        item.dataset.index = String(idx);
        item.textContent = "";
        item.style.height = "36px";
        item.style.lineHeight = "36px";
        item.style.padding = "0 10px";
        item.style.border = "1px solid #ffffff15";
        item.style.borderRadius = "6px";
        item.style.cursor = "pointer";
        item.style.fontSize = "13px";
        item.style.overflow = "hidden";
        item.style.whiteSpace = "nowrap";
        item.style.textOverflow = "ellipsis";
        item.style.display = "flex";
        item.style.flex = "0 0 auto";
        item.style.gap = "8px";
        item.style.alignItems = "center";
        item.style.background = t.id === selectedId ? "#2a313a" : "#1f2328";
        const dot = document.createElement("span");
        dot.style.width = "10px";
        dot.style.height = "10px";
        dot.style.borderRadius = "50%";
        dot.style.boxShadow = "0 0 0 1px #0006 inset";
        dot.style.background = isActive ? "#48d170" : "#64748b";
        dot.title = isActive ? "This team is currently active" : "Inactive team";
        const label2 = document.createElement("span");
        label2.textContent = t.name || "(unnamed)";
        label2.style.overflow = "hidden";
        label2.style.textOverflow = "ellipsis";
        label2.style.whiteSpace = "nowrap";
        item.append(dot, label2);
        const grab = document.createElement("span");
        grab.className = "qmm-grab";
        grab.title = "Drag to reorder";
        grab.innerHTML = "&#8942;";
        grab.draggable = true;
        item.onmouseenter = () => item.style.borderColor = "#6aa1";
        item.onmouseleave = () => item.style.borderColor = "#ffffff15";
        item.onclick = (ev) => {
          if (ev.__byDrag) return;
          const changed = selectedId !== t.id;
          if (changed) {
            selectedId = t.id;
            refreshTeamList(true);
          }
          void hydrateEditor(getSelectedTeam());
        };
        grab.addEventListener("dragstart", (ev) => {
          draggingIdx = idx;
          draggingHeight = item.getBoundingClientRect().height;
          item.classList.add("qmm-dragging");
          ev.dataTransfer?.setData("text/plain", String(idx));
          if (ev.dataTransfer) ev.dataTransfer.effectAllowed = "move";
          try {
            const ghost = item.cloneNode(true);
            ghost.style.width = `${item.getBoundingClientRect().width}px`;
            ghost.style.position = "absolute";
            ghost.style.top = "-9999px";
            document.body.appendChild(ghost);
            ev.dataTransfer.setDragImage(ghost, ghost.offsetWidth / 2, ghost.offsetHeight / 2);
            setTimeout(() => document.body.removeChild(ghost), 0);
          } catch {
          }
        });
        grab.addEventListener("dragend", () => {
          item.classList.remove("qmm-dragging");
          clearLiveTransforms();
          draggingIdx = null;
          overInsertIdx = null;
        });
        item.addEventListener("dragover", (ev) => {
          ev.preventDefault();
          if (ev.dataTransfer) ev.dataTransfer.dropEffect = "move";
          if (draggingIdx === null) return;
          const idxOver = Number(ev.currentTarget.dataset.index || -1);
          if (idxOver < 0) return;
          const rect = item.getBoundingClientRect();
          const mid = rect.top + rect.height / 2;
          const insertIdx = ev.clientY < mid ? idxOver : idxOver + 1;
          const clamped = Math.max(0, Math.min(teams.length, insertIdx));
          if (overInsertIdx !== clamped) {
            overInsertIdx = clamped;
            applyLiveTransforms();
          }
          const edge = 28;
          const listRect = teamList.getBoundingClientRect();
          if (ev.clientY < listRect.top + edge) teamList.scrollTop -= 18;
          else if (ev.clientY > listRect.bottom - edge) teamList.scrollTop += 18;
        });
        item.addEventListener("drop", (ev) => {
          ev.preventDefault();
          ev.__byDrag = true;
          if (draggingIdx === null) return;
          let target = overInsertIdx ?? computeInsertIndex(ev.clientY);
          if (target > draggingIdx) target -= 1;
          target = Math.max(0, Math.min(teams.length - 1, target));
          if (target !== draggingIdx) {
            const a = teams.slice();
            const [it] = a.splice(draggingIdx, 1);
            a.splice(target, 0, it);
            teams = a;
            try {
              PetsService.setTeamsOrder(teams.map((x) => x.id));
            } catch {
            }
          }
          clearLiveTransforms();
          draggingIdx = null;
          overInsertIdx = null;
          draggingHeight = 0;
          refreshTeamList();
        });
        item.appendChild(grab);
        teamList.appendChild(item);
      });
    }
    teamList.addEventListener("dragover", (e) => {
      e.preventDefault();
      if (e.dataTransfer) e.dataTransfer.dropEffect = "move";
      if (draggingIdx === null) return;
      const idx = computeInsertIndex(e.clientY);
      if (overInsertIdx !== idx) {
        overInsertIdx = idx;
        applyLiveTransforms();
      }
      const edge = 28;
      const listRect = teamList.getBoundingClientRect();
      if (e.clientY < listRect.top + edge) teamList.scrollTop -= 18;
      else if (e.clientY > listRect.bottom - edge) teamList.scrollTop += 18;
    });
    teamList.addEventListener("drop", (e) => {
      e.preventDefault();
      if (draggingIdx === null) return;
      let target = overInsertIdx ?? computeInsertIndex(e.clientY);
      if (target > draggingIdx) target -= 1;
      target = Math.max(0, Math.min(teams.length - 1, target));
      if (target !== draggingIdx) {
        const a = teams.slice();
        const [it] = a.splice(draggingIdx, 1);
        a.splice(target, 0, it);
        teams = a;
        try {
          PetsService.setTeamsOrder(teams.map((x) => x.id));
        } catch {
        }
      }
      clearLiveTransforms();
      draggingIdx = null;
      overInsertIdx = null;
      draggingHeight = 0;
      refreshTeamList();
    });
    btnNew.onclick = () => {
      const created = PetsService.createTeam("New Team");
      selectedId = created.id;
      refreshTeamList();
      hydrateEditor(getSelectedTeam());
    };
    btnDel.onclick = () => {
      if (!selectedId) return;
      const ok = PetsService.deleteTeam(selectedId);
      if (!ok) return;
    };
    let unsubTeams = null;
    (async () => {
      try {
        unsubTeams = await PetsService.onTeamsChangeNow(async (all) => {
          teams = Array.isArray(all) ? all.slice() : [];
          if (selectedId && !teams.some((t) => t.id === selectedId)) {
            selectedId = teams[0]?.id ?? null;
          }
          if (!selectedId && teams.length) selectedId = teams[0].id;
          refreshTeamList();
          setTeamsForHotkeys(teams);
          await PetsService.getInventoryPets().catch(() => []);
          await hydrateEditor(getSelectedTeam());
        });
      } catch {
      }
    })();
    const right = document.createElement("div");
    right.style.display = "grid";
    right.style.gridTemplateRows = "auto 1fr";
    right.style.gap = "10px";
    right.style.minHeight = "0";
    wrap.appendChild(right);
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.gap = "8px";
    const headerTitle = document.createElement("div");
    headerTitle.textContent = "Team editor \u2014 ";
    headerTitle.style.fontWeight = "700";
    headerTitle.style.fontSize = "14px";
    const btnUseTeam = document.createElement("button");
    btnUseTeam.id = "pets.teams.useThisTeam";
    btnUseTeam.textContent = "Use this team";
    btnUseTeam.style.padding = "6px 10px";
    btnUseTeam.style.borderRadius = "8px";
    btnUseTeam.style.border = "1px solid #4445";
    btnUseTeam.style.background = "#1f2328";
    btnUseTeam.style.color = "#e7eef7";
    btnUseTeam.style.cursor = "pointer";
    btnUseTeam.onmouseenter = () => btnUseTeam.style.borderColor = "#6aa1";
    btnUseTeam.onmouseleave = () => btnUseTeam.style.borderColor = "#4445";
    btnUseTeam.disabled = true;
    const btnSave = document.createElement("button");
    btnSave.id = "pets.teams.save";
    btnSave.textContent = "\u{1F4BE} Save";
    btnSave.style.padding = "6px 10px";
    btnSave.style.borderRadius = "8px";
    btnSave.style.border = "1px solid #4445";
    btnSave.style.background = "#1f2328";
    btnSave.style.color = "#e7eef7";
    btnSave.style.cursor = "pointer";
    btnSave.onmouseenter = () => btnSave.style.borderColor = "#6aa1";
    btnSave.onmouseleave = () => btnSave.style.borderColor = "#4445";
    btnSave.disabled = true;
    header.append(headerTitle, btnUseTeam);
    right.appendChild(header);
    const card = document.createElement("div");
    card.style.border = "1px solid #4445";
    card.style.borderRadius = "10px";
    card.style.padding = "10px";
    card.style.display = "flex";
    card.style.flexDirection = "column";
    card.style.gap = "12px";
    card.style.overflow = "auto";
    card.style.minHeight = "0";
    card.style.background = "#0f1318";
    right.appendChild(card);
    const secName = (() => {
      const r = row();
      r.style.width = "100%";
      const nameInput = ui.inputText("Team name", "");
      nameInput.id = "pets.teams.editor.name";
      nameInput.style.flex = "1";
      nameInput.style.minWidth = "0";
      btnSave.style.marginLeft = "auto";
      btnSave.style.padding = "6px 10px";
      r.append(nameInput, btnSave);
      card.appendChild(framed("\u{1F3F7}\uFE0F Team name", r));
      return { nameInput };
    })();
    const secSearch = (() => {
      const wrapOuter = document.createElement("div");
      wrapOuter.style.display = "flex";
      wrapOuter.style.flexDirection = "column";
      wrapOuter.style.gap = "10px";
      wrapOuter.style.alignItems = "center";
      let isProgrammaticModeSet = false;
      let currentMode = "ability";
      const seg = ui.segmented(
        [
          { value: "ability", label: "\u2728 Ability" },
          { value: "species", label: "\u{1F9EC} Species" }
        ],
        "ability",
        async (val) => {
          if (isProgrammaticModeSet) return;
          currentMode = val;
          await rebuildOptionsFromInventory();
          select2.value = "";
          applyFilterToTeam();
        },
        { ariaLabel: "Search mode" }
      );
      const select2 = document.createElement("select");
      select2.className = "qmm-input";
      select2.id = "pets.teams.filter.select";
      select2.style.minWidth = "260px";
      const getMode = () => currentMode;
      const setMode = (m) => {
        currentMode = m;
        isProgrammaticModeSet = true;
        seg.set(m);
        isProgrammaticModeSet = false;
      };
      const rebuildOptionsFromInventory = async () => {
        const prev = select2.value;
        const inv = await PetsService.getInventoryPets().catch(() => []);
        select2.innerHTML = "";
        const opt0 = document.createElement("option");
        opt0.value = "";
        opt0.textContent = "\u2014 No filter \u2014";
        select2.appendChild(opt0);
        if (getMode() === "ability") {
          const nameSet = /* @__PURE__ */ new Set();
          for (const p of inv) {
            const abs = Array.isArray(p?.abilities) ? p.abilities.filter(Boolean) : [];
            for (const id of abs) {
              const base = PetsService.getAbilityNameWithoutLevel?.(id) || "";
              if (base) nameSet.add(base);
            }
          }
          for (const name of Array.from(nameSet).sort((a, b) => a.localeCompare(b))) {
            const o = document.createElement("option");
            o.value = name;
            o.textContent = name;
            select2.appendChild(o);
          }
        } else {
          const set2 = /* @__PURE__ */ new Set();
          for (const p of inv) {
            const sp = String(p?.petSpecies || "").trim();
            if (sp) set2.add(sp);
          }
          for (const v of Array.from(set2).sort((a, b) => a.localeCompare(b))) {
            const o = document.createElement("option");
            o.value = v;
            o.textContent = v.charAt(0).toUpperCase() + v.slice(1);
            select2.appendChild(o);
          }
        }
        if (Array.from(select2.options).some((o) => o.value === prev)) select2.value = prev;
      };
      const applyFilterToTeam = () => {
        const t = getSelectedTeam();
        if (!t) return;
        const val = (select2.value || "").trim();
        const raw = getMode() === "ability" ? val ? `ab:${val}` : "" : val ? `sp:${val}` : "";
        PetsService.setTeamSearch(t.id, raw);
      };
      select2.addEventListener("change", applyFilterToTeam);
      wrapOuter.append(seg, select2);
      card.appendChild(framed("\u{1F50D} Search", wrapOuter));
      const ensureOptionExists = (val, pretty) => {
        const v = (val || "").trim();
        if (!v) return;
        const has = Array.from(select2.options).some((o) => o.value === v);
        if (!has) {
          const o = document.createElement("option");
          o.value = v;
          o.textContent = pretty ?? v;
          select2.appendChild(o);
        }
      };
      return {
        getMode,
        setMode,
        select: select2,
        rebuild: rebuildOptionsFromInventory,
        apply: applyFilterToTeam,
        setFromSearchString(s) {
          const m = (s || "").match(/^(ab|sp):\s*(.*)$/i);
          if (!m) {
            setMode("ability");
            select2.value = "";
            return;
          }
          const mode = m[1].toLowerCase() === "ab" ? "ability" : "species";
          const val = (m[2] || "").trim();
          setMode(mode);
          ensureOptionExists(val, mode === "species" ? val.charAt(0).toUpperCase() + val.slice(1) : val);
          select2.value = val;
        }
      };
    })();
    const secSlots = (() => {
      const grid = document.createElement("div");
      grid.style.display = "grid";
      grid.style.gridTemplateColumns = "1fr";
      grid.style.rowGap = "10px";
      grid.style.justifyItems = "center";
      const mkRow = (idx) => {
        const root = document.createElement("div");
        const BTN = 28;
        const ICON = 40;
        root.style.display = "grid";
        root.style.gridTemplateColumns = `${ICON}px minmax(0,1fr) ${BTN}px ${BTN}px`;
        root.style.alignItems = "center";
        root.style.gap = "8px";
        root.style.width = "min(560px, 100%)";
        root.style.border = "1px solid #4445";
        root.style.borderRadius = "10px";
        root.style.padding = "8px 10px";
        root.style.background = "#0f1318";
        const iconWrap = document.createElement("div");
        Object.assign(iconWrap.style, {
          width: `${ICON}px`,
          height: `${ICON}px`,
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center"
        });
        const useEmojiFallback = () => {
          iconWrap.replaceChildren();
          const span = document.createElement("span");
          span.textContent = "\u{1F43E}";
          span.style.fontSize = `${Math.max(ICON - 6, 12)}px`;
          span.setAttribute("aria-hidden", "true");
          iconWrap.appendChild(span);
        };
        let iconRequestId = 0;
        const setIcon = (species, mutation) => {
          iconRequestId += 1;
          const requestId = iconRequestId;
          const speciesLabel = String(species ?? "").trim();
          if (!speciesLabel) {
            useEmojiFallback();
            return;
          }
          useEmojiFallback();
          loadPetSpriteFromMutations(speciesLabel, mutation).then((src) => {
            if (requestId !== iconRequestId) return;
            if (!src) {
              useEmojiFallback();
              return;
            }
            const img = new Image();
            img.src = src;
            img.alt = speciesLabel || "pet";
            img.decoding = "async";
            img.loading = "lazy";
            img.draggable = false;
            Object.assign(img.style, {
              width: "100%",
              height: "100%",
              imageRendering: "auto",
              objectFit: "contain"
            });
            iconWrap.replaceChildren(img);
          }).catch(() => {
            if (requestId !== iconRequestId) return;
            useEmojiFallback();
          });
        };
        const left2 = document.createElement("div");
        left2.style.display = "flex";
        left2.style.flexDirection = "column";
        left2.style.gap = "6px";
        left2.style.minWidth = "0";
        const nameEl = document.createElement("div");
        nameEl.style.fontWeight = "700";
        nameEl.textContent = "None";
        nameEl.style.overflow = "hidden";
        nameEl.style.textOverflow = "ellipsis";
        nameEl.style.whiteSpace = "nowrap";
        let abilitiesEl = abilitiesBadge([]);
        abilitiesEl.style.display = "inline-block";
        left2.append(nameEl, abilitiesEl);
        const btnChoose = document.createElement("button");
        btnChoose.textContent = "+";
        Object.assign(btnChoose.style, {
          width: `${BTN}px`,
          minWidth: `${BTN}px`,
          height: `${BTN}px`,
          padding: "0",
          fontSize: "16px",
          lineHeight: "1",
          borderRadius: "10px",
          boxShadow: "none",
          display: "grid",
          placeItems: "center"
        });
        btnChoose.title = "Choose a pet";
        btnChoose.setAttribute("aria-label", "Choose a pet");
        const btnClear2 = document.createElement("button");
        btnClear2.textContent = "\u2212";
        Object.assign(btnClear2.style, {
          width: `${BTN}px`,
          minWidth: `${BTN}px`,
          height: `${BTN}px`,
          padding: "0",
          fontSize: "16px",
          lineHeight: "1",
          borderRadius: "10px",
          boxShadow: "none",
          display: "grid",
          placeItems: "center"
        });
        btnClear2.title = "Remove this pet";
        btnClear2.setAttribute("aria-label", "Remove this pet");
        root.append(iconWrap, left2, btnChoose, btnClear2);
        function update(p) {
          if (!p) {
            nameEl.textContent = "None";
            setIcon(void 0, void 0);
            const fresh2 = abilitiesBadge([]);
            fresh2.style.display = "inline-block";
            left2.replaceChild(fresh2, left2.children[1]);
            abilitiesEl = fresh2;
            return;
          }
          const species = String(p.petSpecies || "").trim();
          const muts = Array.isArray(p.mutations) ? p.mutations : [];
          setIcon(species, muts);
          const speciesLabel = species ? species.charAt(0).toUpperCase() + species.slice(1) : "";
          nameEl.textContent = p.name?.trim() || speciesLabel || "Pet";
          const abs = Array.isArray(p.abilities) ? p.abilities.filter(Boolean) : [];
          const fresh = abilitiesBadge(abs);
          fresh.style.display = "inline-block";
          left2.replaceChild(fresh, left2.children[1]);
          abilitiesEl = fresh;
        }
        btnChoose.onclick = async () => {
          const t = getSelectedTeam();
          if (!t) return;
          btnChoose.disabled = true;
          btnClear2.disabled = true;
          ui.setWindowVisible(false);
          try {
            await PetsService.chooseSlotPet(t.id, idx);
            await repaintSlots(getSelectedTeam());
          } finally {
            ui.setWindowVisible(true);
            btnChoose.disabled = false;
            btnClear2.disabled = false;
          }
        };
        btnClear2.onclick = async () => {
          const t = getSelectedTeam();
          if (!t) return;
          const next = t.slots.slice(0, 3);
          next[idx] = null;
          PetsService.saveTeam({ id: t.id, slots: next });
          await repaintSlots(t);
        };
        return { root, nameEl, abilitiesEl, btnChoose, btnClear: btnClear2, update };
      };
      const r0 = mkRow(0);
      const r1 = mkRow(1);
      const r2 = mkRow(2);
      grid.append(r0.root, r1.root, r2.root);
      const extra = document.createElement("div");
      extra.style.display = "flex";
      extra.style.gap = "6px";
      extra.style.justifyContent = "center";
      const btnUseCurrent = ui.btn("Current active", { variant: "primary" });
      btnUseCurrent.id = "pets.teams.useCurrent";
      btnUseCurrent.style.minWidth = "140px";
      const btnClear = ui.btn("Clear slots", { variant: "secondary" });
      btnClear.id = "pets.teams.clearSlots";
      btnClear.style.minWidth = "140px";
      const DARK_BG = "#0f1318";
      extra.append(btnUseCurrent, btnClear);
      Object.assign(btnUseCurrent.style, {
        width: "auto",
        fontSize: "16px",
        borderRadius: "10px",
        background: DARK_BG,
        boxShadow: "none"
      });
      Object.assign(btnClear.style, {
        width: "auto",
        fontSize: "16px",
        borderRadius: "10px",
        background: DARK_BG,
        boxShadow: "none"
      });
      const wrapSlots = document.createElement("div");
      wrapSlots.style.display = "flex";
      wrapSlots.style.flexDirection = "column";
      wrapSlots.style.gap = "8px";
      wrapSlots.append(grid, extra);
      card.appendChild(framed("\u26A1 Active pets (3 slots)", wrapSlots));
      return {
        rows: [r0, r1, r2],
        btnUseCurrent,
        btnClear
      };
    })();
    async function repaintSlots(sourceTeam) {
      const t = sourceTeam ?? getSelectedTeam();
      if (!t) return;
      let inv = await PetsService.getInventoryPets().catch(() => null);
      if (!inv || inv.length === 0) {
      } else {
        invCacheMap = /* @__PURE__ */ new Map();
        for (const p of inv) {
          const id = p?.id != null ? String(p.id) : "";
          if (id) invCacheMap.set(id, p);
        }
      }
      const map2 = invCacheMap ?? /* @__PURE__ */ new Map();
      [0, 1, 2].forEach((i) => {
        const id = t.slots[i] || null;
        if (!id) {
          if (lastRenderedSlotIds[i] !== null) {
            secSlots.rows[i].update(null);
            lastRenderedSlotIds[i] = null;
          }
          return;
        }
        const pet = map2.get(id);
        if (!pet) return;
        if (lastRenderedSlotIds[i] === id) return;
        secSlots.rows[i].update(pet);
        lastRenderedSlotIds[i] = id;
      });
    }
    async function hydrateEditor(team) {
      const has = !!team;
      secName.nameInput.disabled = !has;
      secSlots.btnClear.disabled = !has;
      secSlots.btnUseCurrent.disabled = !has;
      btnUseTeam.disabled = !has;
      btnSave.disabled = !has;
      if (has) {
        const saved = PetsService.getTeamSearch(team.id) || "";
        const m = saved.match(/^(ab|sp):\s*(.*)$/i);
        const mode = m ? m[1].toLowerCase() === "ab" ? "ability" : "species" : "ability";
        secSearch.setMode(mode);
        await secSearch.rebuild();
        if (m) secSearch.setFromSearchString(saved);
      } else {
        await secSearch.rebuild();
      }
      if (!has) {
        secSlots.rows.forEach((r) => r.update(null));
        secName.nameInput.value = "";
        return;
      }
      secName.nameInput.value = String(team.name || "");
      await repaintSlots(team);
    }
    secName.nameInput.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") ev.currentTarget.blur();
    });
    secName.nameInput.addEventListener("blur", () => {
      const t = getSelectedTeam();
      if (!t) return;
      const nextName = secName.nameInput.value.trim();
      if (nextName !== t.name) {
        PetsService.saveTeam({ id: t.id, name: nextName });
      }
    });
    secSlots.btnUseCurrent.onclick = async () => {
      const t = getSelectedTeam();
      if (!t) return;
      try {
        const arr = await PetsService.getPets();
        const list = Array.isArray(arr) ? arr : [];
        const ids = list.map((p) => String(p?.slot?.id || "")).filter((x) => !!x).slice(0, 3);
        const nextSlots = [ids[0] || null, ids[1] || null, ids[2] || null];
        PetsService.saveTeam({ id: t.id, slots: nextSlots });
        await repaintSlots(t);
      } catch {
      }
    };
    secSlots.btnClear.onclick = async () => {
      const t = getSelectedTeam();
      if (!t) return;
      PetsService.saveTeam({ id: t.id, slots: [null, null, null] });
      await repaintSlots(t);
    };
    btnSave.onclick = () => {
      const t = getSelectedTeam();
      if (!t) return;
      const name = secName.nameInput.value.trim();
      const slots = t.slots.slice(0, 3);
      PetsService.saveTeam({ id: t.id, name, slots });
      void repaintSlots(t);
    };
    function sameSet(a, b) {
      if (a.length !== b.length) return false;
      const s = new Set(a);
      for (const x of b) if (!s.has(x)) return false;
      return true;
    }
    async function waitForActiveTeam(team, timeoutMs = 2e3) {
      const target = (team.slots || []).filter(Boolean);
      const t0 = performance.now();
      while (performance.now() - t0 < timeoutMs) {
        const pets = await PetsService.getPets().catch(() => null);
        const equip = Array.isArray(pets) ? pets.map((p) => String(p?.slot?.id || "")).filter(Boolean) : [];
        if (sameSet(equip, target)) return true;
        await new Promise((r) => setTimeout(r, 80));
      }
      return false;
    }
    btnUseTeam.onclick = async () => {
      const t = getSelectedTeam();
      if (!t) return;
      try {
        isApplyingTeam = true;
        activeTeamId = t.id;
        await refreshTeamList(true);
        await PetsService.useTeam(t.id);
        await waitForActiveTeam(t);
        await hydrateEditor(getSelectedTeam());
        await refreshTeamList();
      } catch (e) {
        console.warn("[Pets] Use this team failed:", e);
        await refreshTeamList();
      } finally {
        isApplyingTeam = false;
      }
    };
    let unsubPets2 = null;
    (async () => {
      try {
        unsubPets2 = await onActivePetsStructuralChangeNow(async () => {
          if (isApplyingTeam) return;
          await repaintSlots(getSelectedTeam());
          await refreshTeamList();
        });
      } catch {
      }
    })();
    installPetTeamHotkeysOnce(async (teamId) => {
      const t = teams.find((tt) => tt.id === teamId) || null;
      try {
        isApplyingTeam = true;
        if (t) {
          activeTeamId = t.id;
          await refreshTeamList(true);
        }
        await PetsService.useTeam(teamId);
        if (t) await waitForActiveTeam(t);
        await hydrateEditor(getSelectedTeam());
        await refreshTeamList();
      } catch (e) {
        console.warn("[Pets] hotkey useTeam failed:", e);
        await refreshTeamList();
      } finally {
        isApplyingTeam = false;
      }
    });
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsubTeams?.();
        } catch {
        }
        try {
          unsubPets2?.();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderLogsTab(view, ui) {
    view.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "grid";
    wrap.style.gridTemplateRows = "auto 1fr";
    wrap.style.gap = "10px";
    wrap.style.height = "54vh";
    view.appendChild(wrap);
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.flexWrap = "wrap";
    header.style.alignItems = "center";
    header.style.gap = "8px";
    header.style.border = "1px solid #4445";
    header.style.borderRadius = "10px";
    header.style.padding = "8px 10px";
    header.style.background = "#0f1318";
    wrap.appendChild(header);
    const selAbility = ui.select({ id: "pets.logs.filter.ability", width: "200px" });
    const selSort = ui.select({ id: "pets.logs.sort", width: "140px" });
    [["desc", "Newest first"], ["asc", "Oldest first"]].forEach(([v, t]) => {
      const o = document.createElement("option");
      o.value = v;
      o.textContent = t;
      selSort.appendChild(o);
    });
    selSort.value = "desc";
    const inputSearch = ui.inputText("search (pet / ability / details)", "");
    inputSearch.id = "pets.logs.search";
    inputSearch.style.minWidth = "220px";
    const btnClear = ui.btn("\u{1F9F9} Clear", { size: "sm" });
    btnClear.id = "pets.logs.clear";
    btnClear.style.flex = "0 0 auto";
    header.append(
      ui.label("Ability"),
      selAbility,
      ui.label("Sort"),
      selSort,
      inputSearch,
      btnClear
    );
    const card = document.createElement("div");
    card.style.border = "1px solid #4445";
    card.style.borderRadius = "10px";
    card.style.padding = "10px";
    card.style.background = "#0f1318";
    card.style.overflow = "hidden";
    card.style.display = "grid";
    card.style.gridTemplateRows = "auto 1fr";
    card.style.minHeight = "0";
    wrap.appendChild(card);
    const headerGrid = document.createElement("div");
    headerGrid.style.display = "grid";
    headerGrid.style.gridTemplateColumns = "140px 220px 200px minmax(0,1fr)";
    headerGrid.style.columnGap = "0";
    headerGrid.style.borderBottom = "1px solid #ffffff1a";
    headerGrid.style.padding = "0 0 6px 0";
    function mkHeadCell2(txt, align = "center") {
      const el2 = document.createElement("div");
      el2.textContent = txt;
      el2.style.fontWeight = "600";
      el2.style.opacity = "0.9";
      el2.style.padding = "6px 8px";
      el2.style.textAlign = align;
      return el2;
    }
    headerGrid.append(
      mkHeadCell2("Date & Time"),
      mkHeadCell2("Pet"),
      mkHeadCell2("Ability"),
      mkHeadCell2("Details", "left")
    );
    card.appendChild(headerGrid);
    const bodyGrid = document.createElement("div");
    bodyGrid.style.display = "grid";
    bodyGrid.style.gridTemplateColumns = "140px 220px 200px minmax(0,1fr)";
    bodyGrid.style.gridAutoRows = "auto";
    bodyGrid.style.alignContent = "start";
    bodyGrid.style.overflow = "auto";
    bodyGrid.style.width = "100%";
    bodyGrid.style.minHeight = "0";
    card.appendChild(bodyGrid);
    const sessionStart = PetsService.getAbilityLogsSessionStart?.() ?? 0;
    let logs = [];
    let abilityFilter = "";
    let sortDir = "desc";
    let q = "";
    function rebuildAbilityOptions() {
      const current = selAbility.value;
      selAbility.innerHTML = "";
      const opts = [["", "All abilities"], ...PetsService.getSeenAbilityIds().map((a) => [a, a])];
      for (const [v, t] of opts) {
        const o = document.createElement("option");
        o.value = v;
        o.textContent = t;
        selAbility.appendChild(o);
      }
      selAbility.value = opts.some(([v]) => v === current) ? current : "";
    }
    function formatDateMMDDYY(timestamp) {
      const value = Number(timestamp);
      if (!Number.isFinite(value)) return "";
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return "";
      const mm = String(date.getMonth() + 1).padStart(2, "0");
      const dd = String(date.getDate()).padStart(2, "0");
      const yy = String(date.getFullYear() % 100).padStart(2, "0");
      return `${mm}/${dd}/${yy}`;
    }
    function cell(txt, align = "center") {
      const el2 = document.createElement("div");
      el2.textContent = txt;
      el2.style.padding = "6px 8px";
      el2.style.display = "flex";
      el2.style.flexDirection = "column";
      el2.style.justifyContent = "center";
      el2.style.alignItems = align === "left" ? "flex-start" : "center";
      el2.style.textAlign = align;
      el2.style.whiteSpace = align === "left" ? "pre-wrap" : "normal";
      el2.style.wordBreak = align === "left" ? "break-word" : "normal";
      el2.style.borderBottom = "1px solid #ffffff12";
      return el2;
    }
    function row(log2) {
      const time = cell("", "center");
      time.style.gap = "2px";
      const dateLine = document.createElement("div");
      const timeLine = document.createElement("div");
      const hasDate = typeof log2.date === "string" && log2.date.trim().length > 0;
      if (hasDate) dateLine.textContent = log2.date ?? "";
      timeLine.textContent = log2.time12;
      if (hasDate) time.appendChild(dateLine);
      time.appendChild(timeLine);
      const petLabel = log2.petName || log2.species || "Pet";
      const pet = cell(petLabel, "center");
      const abName = cell(log2.abilityName || log2.abilityId, "center");
      const detText = typeof log2.data === "string" ? log2.data : (() => {
        try {
          return JSON.stringify(log2.data);
        } catch {
          return "";
        }
      })();
      const det = cell(detText, "left");
      if (log2.isActiveSession) {
        [time, pet, abName, det].forEach((el2) => {
          el2.style.background = "rgba(89, 162, 255, 0.14)";
        });
      }
      bodyGrid.append(time, pet, abName, det);
    }
    const normAbilityKey = (s) => String(s ?? "").toLowerCase().replace(/\s+/g, "").replace(/([ivx]+)$/i, "");
    function applyFilters() {
      let arr = logs.slice();
      if (abilityFilter && abilityFilter.trim()) {
        const f = normAbilityKey(abilityFilter);
        arr = arr.filter((l) => {
          const idKey = normAbilityKey(l.abilityId);
          const nameKey = normAbilityKey(PetsService.getAbilityNameWithoutLevel(l.abilityId));
          return idKey === f || nameKey === f;
        });
      }
      if (q && q.trim()) {
        const qq = q.toLowerCase();
        arr = arr.filter((l) => {
          const pet = (l.petName || l.species || "").toLowerCase();
          const abName = (l.abilityName || "").toLowerCase();
          const abId = (l.abilityId || "").toLowerCase();
          const det = (typeof l.data === "string" ? l.data : (() => {
            try {
              return JSON.stringify(l.data);
            } catch {
              return "";
            }
          })()).toLowerCase();
          return pet.includes(qq) || abName.includes(qq) || abId.includes(qq) || det.includes(qq) || (l.petId || "").toLowerCase().includes(qq);
        });
      }
      arr.sort(
        (a, b) => sortDir === "asc" ? a.performedAt - b.performedAt : b.performedAt - a.performedAt
      );
      return arr;
    }
    function repaint() {
      bodyGrid.innerHTML = "";
      const arr = applyFilters();
      if (!arr.length) {
        const empty = document.createElement("div");
        empty.textContent = "No logs yet.";
        empty.style.opacity = "0.75";
        empty.style.gridColumn = "1 / -1";
        empty.style.padding = "8px";
        bodyGrid.appendChild(empty);
        return;
      }
      arr.forEach(row);
      if (sortDir === "asc") bodyGrid.scrollTop = bodyGrid.scrollHeight + 32;
      else bodyGrid.scrollTop = 0;
    }
    selAbility.onchange = () => {
      abilityFilter = selAbility.value;
      repaint();
    };
    selSort.onchange = () => {
      sortDir = selSort.value || "desc";
      repaint();
    };
    inputSearch.addEventListener("input", () => {
      q = inputSearch.value.trim();
      repaint();
    });
    btnClear.onclick = () => {
      try {
        PetsService.clearAbilityLogs();
      } catch {
      }
    };
    let stopWatcher = null;
    let unsubLogs = null;
    (async () => {
      try {
        stopWatcher = await PetsService.startAbilityLogsWatcher();
        rebuildAbilityOptions();
        unsubLogs = PetsService.onAbilityLogs((all) => {
          logs = all.map((e) => ({
            petId: e.petId,
            petName: e.name ?? null,
            species: e.species ?? null,
            abilityId: e.abilityId,
            abilityName: e.abilityName,
            data: e.data,
            performedAt: e.performedAt,
            date: formatDateMMDDYY(e.performedAt),
            time12: e.time12,
            isActiveSession: sessionStart > 0 && e.performedAt >= sessionStart
          }));
          rebuildAbilityOptions();
          repaint();
        });
      } catch {
      }
    })();
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsubLogs?.();
        } catch {
        }
        try {
          stopWatcher?.();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
    repaint();
  }
  function renderPetsMenu(root) {
    const ui = new Menu({ id: "pets", compact: true, windowSelector: ".qws-win" });
    ui.mount(root);
    ui.addTab("manager", "\u{1F9F0} Manager", (view) => renderManagerTab(view, ui));
    ui.addTab("logs", "\u{1F4DD} Logs", (view) => renderLogsTab(view, ui));
  }

  // src/ui/menus/misc.ts
  var formatShortDuration = (seconds) => {
    const sec = Math.max(0, Math.round(seconds));
    if (sec < 60) return `${sec} s`;
    const m = Math.floor(sec / 60);
    const r = sec % 60;
    if (r === 0) return `${m} min`;
    return `${m} min ${r} s`;
  };
  var NF_US2 = new Intl.NumberFormat("en-US");
  var formatNum2 = (n) => NF_US2.format(Math.max(0, Math.floor(n || 0)));
  var formatDurationShort = (ms) => {
    if (ms < 1e3) return `${ms} ms`;
    const seconds = ms / 1e3;
    if (seconds < 10) return `${seconds.toFixed(1)} s`;
    return `${Math.round(seconds)} s`;
  };
  var formatFinishTime = (timestamp) => new Date(timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
  var EXTRA_ESTIMATE_BUFFER_PER_DELETE_MS = 10;
  var buildEstimateSentence = (count, delayMs, finishTimestamp) => {
    if (count <= 0 || delayMs <= 0) return "";
    const durationMs = count * (delayMs + EXTRA_ESTIMATE_BUFFER_PER_DELETE_MS);
    const durationText = formatDurationShort(durationMs);
    if (!finishTimestamp) return ` \xB7 Estimated time ${durationText}`;
    return ` \xB7 Estimated time ${durationText} (${formatFinishTime(finishTimestamp)})`;
  };
  async function renderMiscMenu(container) {
    const ui = new Menu({ id: "misc", compact: true });
    ui.mount(container);
    const view = ui.root.querySelector(".qmm-views");
    view.innerHTML = "";
    view.style.display = "grid";
    view.style.gap = "8px";
    view.style.minHeight = "0";
    view.style.justifyItems = "center";
    const secAutoReco = (() => {
      const card = ui.card("\u{1F504} Auto reconnect on session conflict", { tone: "muted", align: "center" });
      card.root.style.maxWidth = "480px";
      card.body.style.display = "grid";
      card.body.style.gap = "10px";
      const header = ui.flexRow({ align: "center", justify: "between", fullWidth: true });
      const toggleWrap = document.createElement("div");
      toggleWrap.style.display = "inline-flex";
      toggleWrap.style.alignItems = "center";
      toggleWrap.style.gap = "8px";
      const toggleLabel = ui.label("Activate");
      toggleLabel.style.margin = "0";
      const toggle = ui.switch(MiscService.readAutoRecoEnabled(false));
      toggleWrap.append(toggleLabel, toggle);
      header.append(toggleWrap);
      const initialSeconds = Math.round(MiscService.getAutoRecoDelayMs() / 1e3);
      const sliderRow = ui.flexRow({ align: "center", gap: 10, justify: "between", fullWidth: true });
      const sliderLabel = ui.label("Reconnect after");
      sliderLabel.style.margin = "0";
      const slider = ui.slider(30, 300, 30, initialSeconds);
      slider.style.flex = "1";
      const sliderValue = document.createElement("div");
      sliderValue.style.minWidth = "72px";
      sliderValue.style.textAlign = "right";
      sliderValue.textContent = formatShortDuration(initialSeconds);
      sliderRow.append(sliderLabel, slider, sliderValue);
      const hint = document.createElement("div");
      hint.style.opacity = "0.8";
      hint.style.fontSize = "12px";
      hint.style.lineHeight = "1.35";
      const clampSeconds = (value) => Math.max(30, Math.min(300, Math.round(value / 30) * 30));
      const syncToggle = () => {
        const on = !!toggle.checked;
        slider.disabled = !on;
        MiscService.writeAutoRecoEnabled(on);
        hint.textContent = on ? "Automatically log back in if this account is disconnected because it was opened in another session." : "Auto reconnect on session conflict is turned off.";
      };
      const updateSlider = (raw, persist2) => {
        const seconds = clampSeconds(raw);
        slider.value = String(seconds);
        sliderValue.textContent = formatShortDuration(seconds);
        if (persist2) MiscService.setAutoRecoDelayMs(seconds * 1e3);
        syncToggle();
      };
      toggle.addEventListener("change", syncToggle);
      slider.addEventListener("input", () => updateSlider(Number(slider.value), false));
      slider.addEventListener("change", () => updateSlider(Number(slider.value), true));
      syncToggle();
      card.body.append(header, sliderRow, hint);
      return card.root;
    })();
    const secPlayer = (() => {
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "12px";
      row.style.flexWrap = "wrap";
      const pair = (labelText, controlEl, labelId) => {
        const wrap = document.createElement("div");
        wrap.style.display = "inline-flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "6px";
        const lab = ui.label(labelText);
        lab.style.fontSize = "13px";
        lab.style.margin = "0";
        lab.style.justifySelf = "start";
        if (labelId) lab.id = labelId;
        wrap.append(lab, controlEl);
        return wrap;
      };
      const ghostSwitch = ui.switch(MiscService.readGhostEnabled(false));
      ghostSwitch.id = "player.ghostMode";
      const ghostPair = pair("Ghost", ghostSwitch, "label.ghost");
      const delayInput = ui.inputNumber(10, 1e3, 5, 50);
      delayInput.id = "player.moveDelay";
      const delayWrap = delayInput.wrap ?? delayInput;
      delayWrap.style && (delayWrap.style.margin = "0");
      delayInput.style && (delayInput.style.width = "84px");
      const delayPair = pair("Delay (ms)", delayWrap, "label.delay");
      row.append(ghostPair, delayPair);
      const ghost = MiscService.createGhostController();
      delayInput.value = String(MiscService.getGhostDelayMs());
      delayInput.addEventListener("change", () => {
        const v = Math.max(10, Math.min(1e3, Math.floor(Number(delayInput.value) || 50)));
        delayInput.value = String(v);
        ghost.setSpeed?.(v);
        MiscService.setGhostDelayMs(v);
      });
      if (ghostSwitch.checked) ghost.start();
      ghostSwitch.onchange = () => {
        const on = !!ghostSwitch.checked;
        MiscService.writeGhostEnabled(on);
        on ? ghost.start() : ghost.stop();
      };
      row.__cleanup__ = () => {
        try {
          ghost.stop();
        } catch {
        }
      };
      const card = ui.card("\u{1F3AE} Player controls", { tone: "muted", align: "center" });
      card.root.style.maxWidth = "440px";
      card.body.append(row);
      return card.root;
    })();
    const secSeed = (() => {
      const grid = ui.formGrid({ columnGap: 6, rowGap: 6 });
      grid.style.gridTemplateColumns = "1fr";
      const selRow = document.createElement("div");
      selRow.style.display = "flex";
      selRow.style.alignItems = "center";
      selRow.style.justifyContent = "flex-start";
      selRow.style.gap = "8px";
      selRow.style.gridColumn = "1 / -1";
      const selLabel = ui.label("Selected");
      selLabel.style.fontSize = "13px";
      selLabel.style.margin = "0";
      const selValue = document.createElement("div");
      selValue.id = "misc.seedDeleter.summary";
      selValue.style.fontSize = "13px";
      selValue.style.opacity = "0.9";
      selValue.textContent = "0 species - 0 seeds";
      selRow.append(selLabel, selValue);
      grid.append(selRow);
      const actionsRow = document.createElement("div");
      actionsRow.style.display = "flex";
      actionsRow.style.alignItems = "center";
      actionsRow.style.gap = "8px";
      actionsRow.style.justifyContent = "flex-start";
      actionsRow.style.gridColumn = "1 / -1";
      const actLabel = ui.label("Actions");
      actLabel.style.fontSize = "13px";
      actLabel.style.margin = "0";
      const actions = ui.flexRow({ gap: 6 });
      const btnSelect = ui.btn("Select seeds", { variant: "primary", size: "sm" });
      const btnDelete = ui.btn("Delete", { variant: "danger", size: "sm", disabled: true });
      const btnClear = ui.btn("Clear", { size: "sm", disabled: true });
      actions.append(btnSelect, btnDelete, btnClear);
      actionsRow.append(actLabel, actions);
      grid.append(actionsRow);
      const statusLabel = ui.label("Status");
      statusLabel.style.fontSize = "13px";
      statusLabel.style.margin = "0";
      statusLabel.style.justifySelf = "start";
      const statusLine = document.createElement("div");
      statusLine.style.fontSize = "13px";
      statusLine.style.fontWeight = "600";
      statusLine.style.color = "#f9f9f9";
      statusLine.style.whiteSpace = "nowrap";
      statusLine.textContent = "Idle";
      const controlRow = ui.flexRow({ gap: 6 });
      const btnPause = ui.btn("Pause", { size: "sm" });
      const btnPlay = ui.btn("Play", { size: "sm" });
      const btnStop = ui.btn("Stop", { size: "sm", variant: "ghost" });
      btnPause.onclick = () => {
        MiscService.pauseSeedDeletion();
        updateSeedControlState();
      };
      btnPlay.onclick = () => {
        MiscService.resumeSeedDeletion();
        updateSeedControlState();
      };
      btnStop.onclick = () => {
        MiscService.cancelSeedDeletion();
        updateSeedControlState();
      };
      controlRow.append(btnPause, btnPlay, btnStop);
      const seedStatus = { species: "\u2014", done: 0, total: 0, remaining: 0 };
      const describeSeedStatus = () => {
        const running = MiscService.isSeedDeletionRunning();
        const paused = MiscService.isSeedDeletionPaused();
        const target = seedStatus.species || "\u2014";
        const base = `${target} (${seedStatus.done}/${seedStatus.total})`;
        if (!running) return "Idle";
        return paused ? `Paused \xB7 ${base}` : base;
      };
      const updateSeedStatusUI = () => {
        statusLine.textContent = describeSeedStatus();
      };
      const updateSeedControlState = () => {
        const running = MiscService.isSeedDeletionRunning();
        const paused = MiscService.isSeedDeletionPaused();
        btnPause.disabled = !running || paused;
        btnPlay.disabled = !running || !paused;
        btnStop.disabled = !running;
        updateSeedStatusUI();
      };
      let seedEstimatedFinish = null;
      let seedSummaryTimer = null;
      const clearSeedSummaryTimer = () => {
        if (seedSummaryTimer !== null) {
          clearTimeout(seedSummaryTimer);
          seedSummaryTimer = null;
        }
      };
      const scheduleSeedSummaryRefresh = () => {
        clearSeedSummaryTimer();
        seedSummaryTimer = window.setTimeout(() => updateSummaryUI(), 1e3);
      };
      const onSeedProgress = (event) => {
        const detail = event.detail;
        seedStatus.species = detail.species;
        seedStatus.done = detail.done;
        seedStatus.total = detail.total;
        seedStatus.remaining = detail.remainingForSpecies;
        updateSeedStatusUI();
        updateSeedControlState();
      };
      const onSeedComplete = () => {
        seedStatus.species = "\u2014";
        seedStatus.done = 0;
        seedStatus.total = 0;
        seedStatus.remaining = 0;
        updateSeedStatusUI();
        updateSeedControlState();
      };
      const onSeedPaused = () => updateSeedControlState();
      const onSeedResumed = () => updateSeedControlState();
      window.addEventListener("qws:seeddeleter:progress", onSeedProgress);
      window.addEventListener("qws:seeddeleter:done", onSeedComplete);
      window.addEventListener("qws:seeddeleter:error", onSeedComplete);
      window.addEventListener("qws:seeddeleter:paused", onSeedPaused);
      window.addEventListener("qws:seeddeleter:resumed", onSeedResumed);
      const cleanupSeedListeners = () => {
        window.removeEventListener("qws:seeddeleter:progress", onSeedProgress);
        window.removeEventListener("qws:seeddeleter:done", onSeedComplete);
        window.removeEventListener("qws:seeddeleter:error", onSeedComplete);
        window.removeEventListener("qws:seeddeleter:paused", onSeedPaused);
        window.removeEventListener("qws:seeddeleter:resumed", onSeedResumed);
      };
      updateSeedStatusUI();
      updateSeedControlState();
      const statusRow = document.createElement("div");
      statusRow.style.display = "flex";
      statusRow.style.alignItems = "center";
      statusRow.style.gap = "8px";
      statusRow.style.gridColumn = "1 / -1";
      statusRow.append(statusLabel, controlRow, statusLine);
      grid.append(statusRow);
      function readSelection() {
        const sel = MiscService.getCurrentSeedSelection?.() || [];
        const speciesCount = sel.length;
        let totalQty = 0;
        for (const it of sel) totalQty += Math.max(0, Math.floor(it?.qty || 0));
        return { sel, speciesCount, totalQty };
      }
      function updateSummaryUI() {
        const { speciesCount, totalQty } = readSelection();
        const seedDelayMs = DEFAULT_SEED_DELETE_DELAY_MS;
        const estimateMs = totalQty * (seedDelayMs + EXTRA_ESTIMATE_BUFFER_PER_DELETE_MS);
        const isRunning = MiscService.isSeedDeletionRunning();
        const finishTimestamp = isRunning ? seedEstimatedFinish : estimateMs > 0 ? Date.now() + estimateMs : null;
        const estimateText = buildEstimateSentence(totalQty, seedDelayMs, finishTimestamp);
        selValue.textContent = `${speciesCount} species - ${formatNum2(totalQty)} seeds${estimateText}`;
        const has = speciesCount > 0 && totalQty > 0;
        ui.setButtonEnabled(btnDelete, has);
        ui.setButtonEnabled(btnClear, has);
        if (!isRunning && totalQty > 0) {
          scheduleSeedSummaryRefresh();
        } else {
          clearSeedSummaryTimer();
        }
      }
      btnSelect.onclick = async () => {
        await MiscService.openSeedSelectorFlow(ui.setWindowVisible.bind(ui));
        updateSummaryUI();
      };
      btnClear.onclick = () => {
        try {
          MiscService.clearSeedSelection?.();
        } catch {
        }
        updateSummaryUI();
      };
      btnDelete.onclick = async () => {
        const { totalQty } = readSelection();
        const seedDelayMs = DEFAULT_SEED_DELETE_DELAY_MS;
        const estimateMs = totalQty * (seedDelayMs + EXTRA_ESTIMATE_BUFFER_PER_DELETE_MS);
        seedEstimatedFinish = estimateMs > 0 ? Date.now() + estimateMs : null;
        clearSeedSummaryTimer();
        const deletionPromise = MiscService.deleteSelectedSeeds({ delayMs: seedDelayMs });
        updateSummaryUI();
        await deletionPromise;
        seedEstimatedFinish = null;
        updateSummaryUI();
      };
      const card = ui.card("Seed deleter", { tone: "muted", align: "center" });
      card.root.style.maxWidth = "440px";
      card.body.append(grid);
      card.root.__cleanup__ = () => {
        clearSeedSummaryTimer();
        cleanupSeedListeners();
      };
      return card.root;
    })();
    const secDecor = (() => {
      const grid = ui.formGrid({ columnGap: 6, rowGap: 6 });
      grid.style.gridTemplateColumns = "1fr";
      const selRow = document.createElement("div");
      selRow.style.display = "flex";
      selRow.style.alignItems = "center";
      selRow.style.justifyContent = "flex-start";
      selRow.style.gap = "8px";
      selRow.style.gridColumn = "1 / -1";
      const selLabel = ui.label("Selected");
      selLabel.style.fontSize = "13px";
      selLabel.style.margin = "0";
      const selValue = document.createElement("div");
      selValue.id = "misc.decorDeleter.summary";
      selValue.style.fontSize = "13px";
      selValue.style.opacity = "0.9";
      selValue.textContent = "0 decor - 0 items";
      selRow.append(selLabel, selValue);
      grid.append(selRow);
      const actionsRow = document.createElement("div");
      actionsRow.style.display = "flex";
      actionsRow.style.alignItems = "center";
      actionsRow.style.gap = "8px";
      actionsRow.style.justifyContent = "flex-start";
      actionsRow.style.gridColumn = "1 / -1";
      const actLabel = ui.label("Actions");
      actLabel.style.fontSize = "13px";
      actLabel.style.margin = "0";
      const actions = ui.flexRow({ gap: 6 });
      const btnSelect = ui.btn("Select decor", { variant: "primary", size: "sm" });
      const btnDelete = ui.btn("Delete", { variant: "danger", size: "sm", disabled: true });
      const btnClear = ui.btn("Clear", { size: "sm", disabled: true });
      actions.append(btnSelect, btnDelete, btnClear);
      actionsRow.append(actLabel, actions);
      grid.append(actionsRow);
      const statusLabel = ui.label("Status");
      statusLabel.style.fontSize = "13px";
      statusLabel.style.margin = "0";
      statusLabel.style.justifySelf = "start";
      const statusLine = document.createElement("div");
      statusLine.style.fontSize = "13px";
      statusLine.style.fontWeight = "600";
      statusLine.style.color = "#f9f9f9";
      statusLine.style.whiteSpace = "nowrap";
      statusLine.textContent = "Idle";
      const controlRow = ui.flexRow({ gap: 6 });
      const btnPause = ui.btn("Pause", { size: "sm" });
      const btnPlay = ui.btn("Play", { size: "sm" });
      const btnStop = ui.btn("Stop", { size: "sm", variant: "ghost" });
      btnPause.onclick = () => {
        MiscService.pauseDecorDeletion();
        updateDecorControlState();
      };
      btnPlay.onclick = () => {
        MiscService.resumeDecorDeletion();
        updateDecorControlState();
      };
      btnStop.onclick = () => {
        MiscService.cancelDecorDeletion();
        updateDecorControlState();
      };
      controlRow.append(btnPause, btnPlay, btnStop);
      const decorStatus = { name: "\u2014", done: 0, total: 0, remaining: 0 };
      const describeDecorStatus = () => {
        const running = MiscService.isDecorDeletionRunning();
        const paused = MiscService.isDecorDeletionPaused();
        const target = decorStatus.name || "\u2014";
        const base = `${target} (${decorStatus.done}/${decorStatus.total})`;
        if (!running) return "Idle";
        return paused ? `Paused \xB7 ${base}` : base;
      };
      const updateDecorStatusUI = () => {
        statusLine.textContent = describeDecorStatus();
      };
      const updateDecorControlState = () => {
        const running = MiscService.isDecorDeletionRunning();
        const paused = MiscService.isDecorDeletionPaused();
        btnPause.disabled = !running || paused;
        btnPlay.disabled = !running || !paused;
        btnStop.disabled = !running;
        updateDecorStatusUI();
      };
      const onDecorProgress = (event) => {
        const detail = event.detail;
        decorStatus.name = detail.decorId;
        decorStatus.done = detail.done;
        decorStatus.total = detail.total;
        decorStatus.remaining = detail.remainingForDecor;
        updateDecorStatusUI();
        updateDecorControlState();
      };
      const onDecorComplete = () => {
        decorStatus.name = "\u2014";
        decorStatus.done = 0;
        decorStatus.total = 0;
        decorStatus.remaining = 0;
        updateDecorStatusUI();
        updateDecorControlState();
      };
      const onDecorPaused = () => updateDecorControlState();
      const onDecorResumed = () => updateDecorControlState();
      window.addEventListener("qws:decordeleter:progress", onDecorProgress);
      window.addEventListener("qws:decordeleter:done", onDecorComplete);
      window.addEventListener("qws:decordeleter:error", onDecorComplete);
      window.addEventListener("qws:decordeleter:paused", onDecorPaused);
      window.addEventListener("qws:decordeleter:resumed", onDecorResumed);
      const cleanupDecorListeners = () => {
        window.removeEventListener("qws:decordeleter:progress", onDecorProgress);
        window.removeEventListener("qws:decordeleter:done", onDecorComplete);
        window.removeEventListener("qws:decordeleter:error", onDecorComplete);
        window.removeEventListener("qws:decordeleter:paused", onDecorPaused);
        window.removeEventListener("qws:decordeleter:resumed", onDecorResumed);
      };
      updateDecorStatusUI();
      updateDecorControlState();
      let decorEstimatedFinish = null;
      let decorSummaryTimer = null;
      const clearDecorSummaryTimer = () => {
        if (decorSummaryTimer !== null) {
          clearTimeout(decorSummaryTimer);
          decorSummaryTimer = null;
        }
      };
      const scheduleDecorSummaryRefresh = () => {
        clearDecorSummaryTimer();
        decorSummaryTimer = window.setTimeout(() => updateSummaryUI(), 1e3);
      };
      const statusRow = document.createElement("div");
      statusRow.style.display = "flex";
      statusRow.style.alignItems = "center";
      statusRow.style.gap = "8px";
      statusRow.style.gridColumn = "1 / -1";
      statusRow.append(statusLabel, controlRow, statusLine);
      grid.append(statusRow);
      function readSelection() {
        const sel = MiscService.getCurrentDecorSelection?.() || [];
        const decorCount = sel.length;
        let totalQty = 0;
        for (const it of sel) totalQty += Math.max(0, Math.floor(it?.qty || 0));
        return { sel, decorCount, totalQty };
      }
      function updateSummaryUI() {
        const { decorCount, totalQty } = readSelection();
        const decorDelayMs = DEFAULT_DECOR_DELETE_DELAY_MS * 2;
        const estimateMs = totalQty * (decorDelayMs + EXTRA_ESTIMATE_BUFFER_PER_DELETE_MS);
        const isRunning = MiscService.isDecorDeletionRunning();
        const finishTimestamp = isRunning ? decorEstimatedFinish : estimateMs > 0 ? Date.now() + estimateMs : null;
        const estimateText = buildEstimateSentence(totalQty, decorDelayMs, finishTimestamp);
        selValue.textContent = decorCount + " decor - " + formatNum2(totalQty) + " items" + estimateText;
        const has = decorCount > 0 && totalQty > 0;
        ui.setButtonEnabled(btnDelete, has);
        ui.setButtonEnabled(btnClear, has);
        if (!isRunning && totalQty > 0) {
          scheduleDecorSummaryRefresh();
        } else {
          clearDecorSummaryTimer();
        }
      }
      btnSelect.onclick = async () => {
        await MiscService.openDecorSelectorFlow(ui.setWindowVisible.bind(ui));
        updateSummaryUI();
      };
      btnDelete.onclick = async () => {
        const { totalQty } = readSelection();
        const decorDelayMs = DEFAULT_DECOR_DELETE_DELAY_MS * 2;
        const estimateMs = totalQty * (decorDelayMs + EXTRA_ESTIMATE_BUFFER_PER_DELETE_MS);
        decorEstimatedFinish = estimateMs > 0 ? Date.now() + estimateMs : null;
        clearDecorSummaryTimer();
        const deletionPromise = MiscService.deleteSelectedDecor?.({ delayMs: DEFAULT_DECOR_DELETE_DELAY_MS });
        updateSummaryUI();
        if (deletionPromise) await deletionPromise;
        decorEstimatedFinish = null;
        updateSummaryUI();
      };
      btnClear.onclick = () => {
        try {
          MiscService.clearDecorSelection?.();
        } catch {
        }
        updateSummaryUI();
      };
      const card = ui.card("Decor deleter", { tone: "muted", align: "center" });
      card.root.style.maxWidth = "440px";
      card.body.append(grid);
      card.root.__cleanup__ = () => {
        clearDecorSummaryTimer();
        cleanupDecorListeners();
      };
      return card.root;
    })();
    const content = document.createElement("div");
    content.style.display = "grid";
    content.style.gap = "8px";
    content.style.justifyItems = "center";
    content.append(secAutoReco, secPlayer, secSeed, secDecor);
    view.appendChild(content);
    view.__cleanup__ = () => {
      try {
        secPlayer.__cleanup__?.();
      } catch {
      }
      try {
        secSeed.__cleanup__?.();
      } catch {
      }
      try {
        secDecor.__cleanup__?.();
      } catch {
      }
    };
  }

  // src/services/settings.ts
  var STORAGE_KEY = "aries_backups";
  var MAX_BACKUPS = 25;
  var DEFAULT_VERSION = 1;
  function generateId() {
    if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
      return crypto.randomUUID();
    }
    return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2)}`;
  }
  function ensureVersion(snapshot) {
    const next = { ...snapshot };
    if (!Number.isFinite(next.version)) {
      next.version = DEFAULT_VERSION;
    }
    return next;
  }
  function readRawStorage() {
    try {
      if (typeof GM_getValue === "function") {
        return GM_getValue(STORAGE_KEY, "[]") ?? "[]";
      }
      if (typeof window !== "undefined" && typeof window.localStorage !== "undefined") {
        return window.localStorage.getItem(STORAGE_KEY) ?? "[]";
      }
    } catch {
    }
    return "[]";
  }
  function writeRawStorage(payload) {
    try {
      if (typeof GM_setValue === "function") {
        GM_setValue(STORAGE_KEY, payload);
        return;
      }
      if (typeof window !== "undefined" && typeof window.localStorage !== "undefined") {
        window.localStorage.setItem(STORAGE_KEY, payload);
      }
    } catch {
    }
  }
  function readBackups() {
    const raw = readRawStorage();
    try {
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) {
        return parsed;
      }
    } catch {
    }
    return [];
  }
  function persistBackups(backups) {
    writeRawStorage(JSON.stringify(backups));
  }
  function listBackups() {
    const entries = readBackups();
    return [...entries].sort((a, b) => b.timestamp - a.timestamp);
  }
  function saveBackup(name) {
    const normalizedName = name.trim() || `Backup ${(/* @__PURE__ */ new Date()).toLocaleString()}`;
    const current = ensureVersion(getAriesStorage());
    const entry = {
      id: generateId(),
      name: normalizedName,
      timestamp: Date.now(),
      data: current
    };
    const next = [entry, ...readBackups()].slice(0, MAX_BACKUPS);
    persistBackups(next);
    return { success: true, message: "Backup saved.", backup: entry };
  }
  function loadBackup(id) {
    const entry = readBackups().find((backup) => backup.id === id);
    if (!entry) {
      return { success: false, message: "Backup not found." };
    }
    try {
      saveAriesStorage(entry.data);
      return { success: true, message: "Backup loaded. Reload the game to apply the changes." };
    } catch (error) {
      return {
        success: false,
        message: `Failed to load backup (${error instanceof Error ? error.message : "unknown error"}).`
      };
    }
  }
  function deleteBackup(id) {
    const next = readBackups().filter((backup) => backup.id !== id);
    if (next.length === readBackups().length) {
      return { success: false, message: "Backup not found." };
    }
    persistBackups(next);
    return { success: true, message: "Backup deleted." };
  }
  function exportAllSettings() {
    const current = ensureVersion(getAriesStorage());
    return JSON.stringify(current, null, 2);
  }
  function importSettings(payload) {
    const trimmed = payload.trim();
    if (!trimmed) {
      return { success: false, message: "Payload is empty." };
    }
    let parsed;
    try {
      parsed = JSON.parse(trimmed);
    } catch (error) {
      return {
        success: false,
        message: `Invalid JSON (${error instanceof Error ? error.message : "unknown error"}).`
      };
    }
    if (!parsed || typeof parsed !== "object") {
      return { success: false, message: "JSON payload must be an object." };
    }
    try {
      const normalized = ensureVersion(parsed);
      saveAriesStorage(normalized);
      return { success: true, message: "Settings applied. Reload the game to apply the changes." };
    } catch (error) {
      return {
        success: false,
        message: `Failed to import settings (${error instanceof Error ? error.message : "unknown error"}).`
      };
    }
  }

  // src/ui/menus/settings.ts
  function createActionButton(label2) {
    const button = document.createElement("button");
    button.type = "button";
    button.textContent = label2;
    button.style.borderRadius = "6px";
    button.style.border = "1px solid rgba(255,255,255,0.2)";
    button.style.background = "rgba(255,255,255,0.04)";
    button.style.color = "inherit";
    button.style.fontWeight = "600";
    button.style.fontSize = "13px";
    button.style.padding = "6px 12px";
    button.style.cursor = "pointer";
    button.addEventListener("mouseenter", () => button.style.background = "rgba(255,255,255,0.08)");
    button.addEventListener("mouseleave", () => button.style.background = "rgba(255,255,255,0.04)");
    return button;
  }
  function createStatusLine() {
    const line = document.createElement("div");
    line.style.fontSize = "13px";
    line.style.minHeight = "18px";
    line.style.opacity = "0.9";
    return line;
  }
  function showStatus(line, result) {
    line.textContent = result.message;
    line.style.color = result.success ? "#8bf1b5" : "#ff9c9c";
  }
  function formatBackupDate(value) {
    return new Date(value).toLocaleDateString();
  }
  function copyTextToClipboard(text) {
    if (navigator.clipboard?.writeText) {
      navigator.clipboard.writeText(text);
      return;
    }
    const textarea = document.createElement("textarea");
    textarea.value = text;
    textarea.style.position = "fixed";
    textarea.style.left = "-9999px";
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand("copy");
    textarea.remove();
  }
  function downloadJSONFile(filename, payload) {
    if (typeof GM_download === "function") {
      try {
        const encoded = encodeURIComponent(payload);
        const url = `data:application/json;charset=utf-8,${encoded}`;
        GM_download({ name: filename, url, saveAs: true });
        return;
      } catch {
      }
    }
    const win = pageWindow || window;
    const safePayload = JSON.stringify(payload);
    const safeFilename = JSON.stringify(filename);
    const script = `(function(){try{const data=${safePayload};const name=${safeFilename};const blob=new Blob([data],{type:"application/json"});const url=URL.createObjectURL(blob);const a=document.createElement("a");a.href=url;a.download=name;a.style.display="none";const parent=document.body||document.documentElement||document;parent.appendChild(a);a.click();a.remove();URL.revokeObjectURL(url);}catch(e){console.error("[settings] download:",e)}})();`;
    try {
      win.eval(script);
      return;
    } catch {
    }
    try {
      const doc = win.document || document;
      const root = doc.body || doc.documentElement || document.body;
      const blob = new Blob([payload], { type: "application/json" });
      const url = (win.URL || URL).createObjectURL(blob);
      const a = doc.createElement("a");
      a.href = url;
      a.download = filename;
      a.style.display = "none";
      if (root) {
        root.appendChild(a);
      }
      a.click();
      if (root) {
        root.removeChild(a);
      }
      (win.URL || URL).revokeObjectURL(url);
    } catch {
      copyTextToClipboard(payload);
    }
  }
  function exportBackupData(entry) {
    const json = JSON.stringify(entry.data, null, 2);
    const filename = `${entry.name || "aries-backup"}-${entry.id}.json`;
    downloadJSONFile(filename, json);
  }
  function createBackupRow(entry, statusLine, listHolder) {
    const container = document.createElement("div");
    container.style.display = "flex";
    container.style.flexDirection = "column";
    container.style.gap = "6px";
    container.style.padding = "10px";
    container.style.borderRadius = "8px";
    container.style.border = "1px solid rgba(255,255,255,0.08)";
    container.style.background = "rgba(255,255,255,0.01)";
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "baseline";
    header.style.flexWrap = "wrap";
    header.style.gap = "8px";
    const title = document.createElement("div");
    title.textContent = entry.name;
    title.style.fontWeight = "600";
    title.style.fontSize = "13px";
    const date = document.createElement("div");
    date.innerHTML = `<strong>Created:</strong> ${formatBackupDate(entry.timestamp)}`;
    date.style.fontSize = "11px";
    date.style.opacity = "0.65";
    header.append(title, date);
    const actions = document.createElement("div");
    actions.style.display = "flex";
    actions.style.gap = "6px";
    actions.style.flexWrap = "wrap";
    const loadButton = createActionButton("Load");
    loadButton.addEventListener("click", () => {
      const result = loadBackup(entry.id);
      showStatus(statusLine, result);
    });
    const deleteButton = createActionButton("Delete");
    deleteButton.addEventListener("click", () => {
      const result = deleteBackup(entry.id);
      showStatus(statusLine, result);
      refreshBackupList(statusLine, listHolder);
    });
    const exportButton = createActionButton("Export");
    exportButton.addEventListener("click", () => {
      exportBackupData(entry);
      showStatus(statusLine, { success: true, message: "Backup exported." });
    });
    actions.append(loadButton, deleteButton);
    actions.append(exportButton);
    container.append(header, actions);
    return container;
  }
  function refreshBackupList(statusLine, listHolder) {
    const backups = listBackups();
    listHolder.innerHTML = "";
    if (!backups.length) {
      const empty = document.createElement("div");
      empty.textContent = "No backups saved yet.";
      empty.style.opacity = "0.6";
      listHolder.appendChild(empty);
      return;
    }
    backups.forEach((entry) => {
      const row = createBackupRow(entry, statusLine, listHolder);
      listHolder.appendChild(row);
    });
  }
  function renderDataTab(view, ui) {
    view.innerHTML = "";
    const layout = document.createElement("div");
    layout.style.display = "flex";
    layout.style.flexDirection = "column";
    layout.style.gap = "12px";
    const ioCard = ui.card("Import / Export", {
      description: "Import or export the mod settings directly through JSON files."
    });
    const card = ui.card("Backup", {
      description: "Save our settings directly inside the mod storage for easy restores."
    });
    ioCard.body.style.display = "flex";
    ioCard.body.style.flexDirection = "column";
    ioCard.body.style.gap = "10px";
    card.body.style.display = "flex";
    card.body.style.flexDirection = "column";
    card.body.style.gap = "10px";
    const ioStatus = createStatusLine();
    const exportButton = createActionButton("Export Settings");
    exportButton.style.width = "100%";
    exportButton.style.boxSizing = "border-box";
    exportButton.addEventListener("click", () => {
      const payload = exportAllSettings();
      const filename = `aries-settings-${Date.now()}.json`;
      downloadJSONFile(filename, payload);
      showStatus(ioStatus, { success: true, message: "Settings exported as JSON file." });
    });
    const importWrapper = document.createElement("div");
    importWrapper.style.display = "flex";
    importWrapper.style.flexDirection = "column";
    importWrapper.style.gap = "8px";
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = ".json,application/json,text/plain";
    fileInput.style.display = "none";
    const fileCard = document.createElement("div");
    Object.assign(fileCard.style, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      gap: "6px",
      padding: "18px 22px",
      width: "100%",
      minHeight: "110px",
      borderRadius: "14px",
      border: "1px dashed #5d6a7d",
      background: "linear-gradient(180deg, #0b141c, #091018)",
      transition: "border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease",
      cursor: "pointer",
      textAlign: "center"
    });
    fileCard.tabIndex = 0;
    fileCard.setAttribute("role", "button");
    fileCard.setAttribute("aria-label", "Import settings JSON");
    const fileCardTitle = document.createElement("div");
    fileCardTitle.textContent = "Import settings";
    Object.assign(fileCardTitle.style, {
      fontWeight: "600",
      fontSize: "14px",
      letterSpacing: "0.02em"
    });
    const fileStatus = document.createElement("div");
    const defaultStatusText = "Drop a JSON file or click to browse.";
    fileStatus.textContent = defaultStatusText;
    Object.assign(fileStatus.style, {
      fontSize: "12px",
      opacity: "0.75"
    });
    fileCard.append(fileCardTitle, fileStatus);
    const setFileCardActive = (active) => {
      if (active) {
        fileCard.style.borderColor = "#6fc3ff";
        fileCard.style.boxShadow = "0 0 0 3px #6fc3ff22";
        fileCard.style.background = "linear-gradient(180deg, #102030, #0b1826)";
      } else {
        fileCard.style.borderColor = "#5d6a7d";
        fileCard.style.boxShadow = "none";
        fileCard.style.background = "linear-gradient(180deg, #0b141c, #091018)";
      }
    };
    const triggerFileSelect = () => fileInput.click();
    fileCard.addEventListener("mouseenter", () => setFileCardActive(true));
    fileCard.addEventListener("mouseleave", () => setFileCardActive(document.activeElement === fileCard));
    fileCard.addEventListener("focus", () => setFileCardActive(true));
    fileCard.addEventListener("blur", () => setFileCardActive(false));
    fileCard.addEventListener("click", triggerFileSelect);
    fileCard.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter" || ev.key === " ") {
        ev.preventDefault();
        triggerFileSelect();
      }
    });
    fileCard.addEventListener("dragover", (ev) => {
      ev.preventDefault();
      setFileCardActive(true);
      if (ev.dataTransfer) ev.dataTransfer.dropEffect = "copy";
    });
    fileCard.addEventListener("dragleave", () => setFileCardActive(document.activeElement === fileCard));
    const displaySelection = (files) => {
      if (!files || !files.length) {
        fileStatus.textContent = defaultStatusText;
        return;
      }
      fileStatus.textContent = files.length === 1 ? files[0].name : `${files.length} files selected`;
    };
    const handleFiles = async (files) => {
      if (!files || !files.length) return;
      const file = files[0];
      try {
        const text = await file.text();
        const result = importSettings(text);
        showStatus(ioStatus, result);
      } catch (error) {
        showStatus(ioStatus, {
          success: false,
          message: `Failed to read file (${error instanceof Error ? error.message : "unknown error"}).`
        });
      } finally {
        fileInput.value = "";
      }
    };
    fileCard.addEventListener("drop", async (ev) => {
      ev.preventDefault();
      const files = ev.dataTransfer?.files || null;
      displaySelection(files);
      await handleFiles(files);
      displaySelection(null);
      setFileCardActive(document.activeElement === fileCard);
    });
    fileInput.onchange = async () => {
      const files = fileInput.files;
      displaySelection(files);
      await handleFiles(files);
      displaySelection(null);
      setFileCardActive(document.activeElement === fileCard);
    };
    importWrapper.append(fileInput, fileCard);
    ioCard.body.append(importWrapper, ioStatus, exportButton);
    layout.appendChild(ioCard.root);
    const controlRow = document.createElement("div");
    controlRow.style.display = "flex";
    controlRow.style.gap = "8px";
    controlRow.style.alignItems = "center";
    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.placeholder = "Backup name";
    nameInput.style.flex = "1";
    nameInput.style.borderRadius = "6px";
    nameInput.style.border = "1px solid rgba(255,255,255,0.08)";
    nameInput.style.background = "rgba(255,255,255,0.02)";
    nameInput.style.color = "inherit";
    nameInput.style.padding = "8px 10px";
    nameInput.style.fontSize = "13px";
    const saveButton = createActionButton("Save");
    const controlStatus = createStatusLine();
    const backupListHolder = document.createElement("div");
    backupListHolder.style.display = "flex";
    backupListHolder.style.flexDirection = "column";
    backupListHolder.style.gap = "10px";
    saveButton.addEventListener("click", () => {
      const result = saveBackup(nameInput.value);
      showStatus(controlStatus, result);
      if (result.success) {
        nameInput.value = "";
        refreshBackupList(controlStatus, backupListHolder);
      }
    });
    controlRow.append(nameInput, saveButton);
    card.body.append(controlRow, controlStatus, backupListHolder);
    layout.appendChild(card.root);
    view.appendChild(layout);
    refreshBackupList(controlStatus, backupListHolder);
  }
  function createInfoRow(ui, label2, value) {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "1fr auto";
    row.style.alignItems = "baseline";
    row.style.gap = "12px";
    const labelEl = ui.label(label2);
    labelEl.style.fontSize = "12px";
    labelEl.style.opacity = "0.8";
    const valueEl = document.createElement("div");
    valueEl.style.textAlign = "right";
    valueEl.style.fontSize = "13px";
    valueEl.style.fontWeight = "600";
    valueEl.style.wordBreak = "break-word";
    valueEl.textContent = value;
    row.append(labelEl, valueEl);
    return row;
  }
  function getWindowSizeLabel(win) {
    if (!win) return "n/a";
    const width = typeof win.innerWidth === "number" ? Math.floor(win.innerWidth) : null;
    const height = typeof win.innerHeight === "number" ? Math.floor(win.innerHeight) : null;
    if (width === null || height === null) {
      return "unknown";
    }
    return `${width} x ${height}`;
  }
  function describeSurface(env) {
    if (!env) return "n/a";
    return env.surface === "discord" ? "Discord" : "Web";
  }
  function describePlatform(env, nav) {
    if (!env) return "n/a";
    if (env.platform === "desktop") {
      return "Desktop";
    }
    if (env.platform === "mobile") {
      const ua = nav?.userAgent ?? "";
      if (/tablet|ipad|playbook|silk|kindle/i.test(ua)) {
        return "Mobile (Tablet)";
      }
      if (/mobile|iphone|ipod|android/i.test(ua)) {
        return "Mobile (Phone)";
      }
      return "Mobile";
    }
    return env.platform;
  }
  function detectOsLabel(nav) {
    const platform = nav?.platform ?? "";
    const userAgent = nav?.userAgent ?? "";
    const target = `${platform} ${userAgent}`.toLowerCase();
    if (!target.trim()) {
      return "n/a";
    }
    if (/windows/.test(target)) return "Windows";
    if (/mac os|macintosh|darwin/.test(target)) return "macOS";
    if (/android/.test(target) && !/windows/.test(target)) return "Android";
    if (/iphone|ipad|ipod/.test(target)) return "iOS";
    if (/linux/.test(target) && !/android/.test(target)) return "Linux";
    if (/cros/.test(target)) return "Chrome OS";
    if (/freebsd/.test(target)) return "FreeBSD";
    if (/sunos|solaris/.test(target)) return "Solaris";
    return nav?.platform || nav?.userAgent || "Unknown";
  }
  function renderInfosTab(view, ui) {
    view.innerHTML = "";
    const safeWindow = typeof window !== "undefined" ? window : null;
    const safeNavigator = typeof navigator !== "undefined" ? navigator : null;
    const safeLocation = typeof location !== "undefined" ? location : null;
    const environment = safeWindow ? detectEnvironment() : null;
    const resolvedGameVersion = gameVersion ?? "unknown";
    const resolvedModVersion = getLocalVersion() ?? "unknown";
    const infoCard = ui.card("Runtime infos");
    infoCard.body.style.display = "flex";
    infoCard.body.style.flexDirection = "column";
    infoCard.body.style.gap = "10px";
    const infoRows = [
      { label: "Mod version", value: resolvedModVersion },
      { label: "Game version", value: resolvedGameVersion },
      { label: "Window size", value: getWindowSizeLabel(safeWindow) },
      {
        label: "Host",
        value: environment?.host ?? safeLocation?.hostname ?? "n/a"
      },
      { label: "Surface", value: describeSurface(environment) },
      { label: "Platform", value: describePlatform(environment, safeNavigator) },
      { label: "OS", value: detectOsLabel(safeNavigator) }
    ];
    infoRows.forEach((entry) => {
      infoCard.body.appendChild(createInfoRow(ui, entry.label, entry.value));
    });
    view.appendChild(infoCard.root);
  }
  function renderSettingsMenu(container) {
    const ui = new Menu({ id: "settings", compact: true });
    ui.mount(container);
    ui.addTabs([
      { id: "settings-data", title: "Settings", render: (root) => renderDataTab(root, ui) },
      { id: "settings-infos", title: "Infos", render: (root) => renderInfosTab(root, ui) }
    ]);
    ui.switchTo("settings-data");
  }

  // src/services/tools.ts
  var TOOL_LIST = [
    {
      id: "wiki",
      title: "Magic Garden Wiki",
      description: "Community-curated documentation for plants, mechanics, weather, and more.",
      url: "https://magicgarden.fandom.com/wiki/MagicCircle_Wiki",
      icon: "\u{1F4DA}",
      tags: ["guide"]
    },
    {
      id: "calculator",
      title: "Magic Garden Calculator",
      description: "Numerous optimisation statistics at your fingertips.",
      url: "https://daserix.github.io/magic-garden-calculator/",
      icon: "\u{1F9EE}",
      tags: ["calculator"]
    },
    {
      id: "mgtools",
      title: "MGTools",
      description: "Utility scripts designed to streamline your time in Magic Garden.",
      url: "https://github.com/Myke247/MGTools/",
      icon: "\u{1F6E0}\uFE0F",
      tags: ["utility"]
    },
    {
      id: "pet-revenue",
      title: "Pet Revenue Planner",
      description: "Forecast the extra income your pets generate, showing $/min and per-boost gains so you can decide which pets and crops to prioritize.",
      url: "https://docs.google.com/spreadsheets/d/1tG1LIEsXQlNRxaN2pySkwwN688_eCLgGIil_xRaPnBo/edit?gid=1430710045#gid=1430710045",
      icon: "\u{1F43E}",
      tags: ["calculator"]
    },
    {
      id: "dollar-hour",
      title: "$ per Hour Calculators",
      description: "Estimate your gold per hour: select a crop, apply weather and friend/pet boosts, set the duration, and get an instant $/h result.",
      url: "https://docs.google.com/spreadsheets/d/1ZYikURs-vBMfTQCU_fFbl25CITBrjsEZePxWc-DqOm8/edit?gid=689506777#gid=689506777",
      icon: "\u{1F4B8}",
      tags: ["calculator"]
    },
    {
      id: "should-i-invest",
      title: "Should I Invest?",
      description: "Instant ROI calculator, select crop, weather, mutation, size, and boost to see if it\u2019s worth it.",
      url: "https://docs.google.com/spreadsheets/d/1PyKd9NG3GsocFmCgwQ01ZQ783ADzcim5LS5XLSLJtqI/edit",
      icon: "\u{1F914}",
      tags: ["calculator"]
    },
    {
      id: "matrixes",
      title: "Matrixes Reference",
      description: "A reference matrix that compares and ranks each plant\u2019s $/h across all buffs and combos, with quick pick/freeze/gold suggestions.",
      url: "https://docs.google.com/spreadsheets/d/1gUdu8LBFbkN7CJzqX_nDwLW9nxdIks-0jRJTrUI19U4/edit?gid=1450892699#gid=1450892699",
      icon: "\u{1F9E9}",
      tags: ["reference"]
    },
    {
      id: "beginners-guide",
      title: "Beginner's Guide Snapshot",
      description: "A concise visual cheat sheet to get new gardeners up to speed quickly.",
      url: "https://i.imgur.com/7IHU0RJ.png",
      icon: "\u{1F331}",
      tags: ["guide", "beginner"]
    }
  ];
  var TOOL_TAGS = Array.from(
    new Set(
      TOOL_LIST.flatMap((tool) => {
        return tool.tags ?? [];
      })
    )
  ).sort((a, b) => a.localeCompare(b));
  function cloneTool(tool) {
    return {
      ...tool,
      tags: tool.tags ? [...tool.tags] : void 0
    };
  }
  function resolve(tool) {
    if (typeof tool === "string") {
      const found = TOOL_LIST.find((entry) => entry.id === tool);
      return found ? cloneTool(found) : null;
    }
    return cloneTool(tool);
  }
  function openUrl(url) {
    if (typeof GM_openInTab === "function") {
      GM_openInTab(url, { active: true, insert: true });
      return true;
    }
    if (typeof window === "undefined") return false;
    try {
      const a = document.createElement("a");
      a.href = url;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      document.body.appendChild(a);
      a.click();
      a.remove();
      return true;
    } catch {
      return false;
    }
  }
  var ToolsService = {
    list() {
      const list = TOOL_LIST.map(cloneTool);
      return list;
    },
    tags() {
      return TOOL_TAGS.map((tag) => tag);
    },
    get(id) {
      const found = TOOL_LIST.find((tool) => tool.id === id);
      const entry = found ? cloneTool(found) : null;
      return entry;
    },
    open(tool) {
      const entry = resolve(tool);
      if (!entry) {
        return false;
      }
      const ok = openUrl(entry.url);
      return ok;
    }
  };

  // src/ui/menus/tools.ts
  function createTagPill(label2) {
    const pill = document.createElement("span");
    pill.textContent = label2;
    pill.style.display = "inline-flex";
    pill.style.alignItems = "center";
    pill.style.justifyContent = "center";
    pill.style.padding = "2px 8px";
    pill.style.borderRadius = "999px";
    pill.style.background = "#ffffff11";
    pill.style.border = "1px solid #ffffff22";
    pill.style.fontSize = "11px";
    pill.style.letterSpacing = "0.02em";
    pill.style.textTransform = "uppercase";
    pill.style.opacity = "0.8";
    return pill;
  }
  function renderToolCard(ui, tool) {
    const title = `${tool.icon ? `${tool.icon} ` : ""}${tool.title}`;
    const card = ui.card(title, { tone: "muted", align: "stretch" });
    card.root.style.width = "100%";
    const body = card.body;
    body.style.display = "grid";
    body.style.gap = "10px";
    body.style.justifyItems = "stretch";
    const description = document.createElement("p");
    description.textContent = tool.description;
    description.style.margin = "0";
    description.style.fontSize = "13px";
    description.style.lineHeight = "1.45";
    description.style.opacity = "0.9";
    description.style.textAlign = "left";
    body.appendChild(description);
    if (tool.tags?.length) {
      const tags = document.createElement("div");
      tags.style.display = "flex";
      tags.style.flexWrap = "wrap";
      tags.style.gap = "6px";
      tags.style.opacity = "0.85";
      tool.tags.forEach((tag) => tags.appendChild(createTagPill(tag)));
      body.appendChild(tags);
    }
    const actions = ui.flexRow({ gap: 8, justify: "end", fullWidth: true });
    actions.style.marginTop = "4px";
    const openBtn = ui.btn("Open tool", {
      variant: "primary",
      icon: "\u{1F517}",
      fullWidth: true,
      title: "Open the tool in a new tab"
    });
    openBtn.style.flex = "1 1 auto";
    openBtn.style.minWidth = "0";
    openBtn.onclick = () => {
      const ok = ToolsService.open(tool);
      if (!ok) {
        void toastSimple("Unable to open link", "Please open the address manually.", "error");
      }
    };
    actions.append(openBtn);
    body.appendChild(actions);
    return card.root;
  }
  async function renderToolsMenu(container) {
    const ui = new Menu({ id: "tools", compact: true });
    ui.mount(container);
    const view = ui.root.querySelector(".qmm-views");
    view.innerHTML = "";
    view.style.display = "flex";
    view.style.flexDirection = "column";
    view.style.gap = "12px";
    view.style.alignItems = "center";
    view.style.padding = "8px";
    view.style.width = "100%";
    view.style.maxHeight = "54vh";
    view.style.overflowY = "auto";
    view.style.overflowX = "auto";
    const WRAPPER_WIDTH = 720;
    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.flexDirection = "column";
    wrapper.style.gap = "12px";
    wrapper.style.width = `${WRAPPER_WIDTH}px`;
    wrapper.style.minWidth = `${WRAPPER_WIDTH}px`;
    wrapper.style.maxWidth = `${WRAPPER_WIDTH}px`;
    wrapper.style.boxSizing = "border-box";
    wrapper.style.alignSelf = "center";
    const intro = ui.card("\u{1F9F0} Community tools", {
      tone: "muted",
      align: "stretch"
    });
    const introText = document.createElement("p");
    introText.textContent = "Discover community-made helpers to plan, calculate, and simplify your Magic Garden adventures.";
    introText.style.margin = "0";
    introText.style.fontSize = "13px";
    introText.style.lineHeight = "1.5";
    introText.style.opacity = "0.9";
    introText.style.textAlign = "left";
    intro.body.appendChild(introText);
    wrapper.appendChild(intro.root);
    const allTools = ToolsService.list();
    const filterSection = document.createElement("div");
    filterSection.style.display = "flex";
    filterSection.style.flexDirection = "column";
    filterSection.style.gap = "8px";
    filterSection.style.background = "#ffffff08";
    filterSection.style.border = "1px solid #ffffff11";
    filterSection.style.borderRadius = "12px";
    filterSection.style.padding = "12px";
    const filterTitle = document.createElement("span");
    filterTitle.textContent = "Filter by tags";
    filterTitle.style.fontSize = "12px";
    filterTitle.style.letterSpacing = "0.05em";
    filterTitle.style.textTransform = "uppercase";
    filterTitle.style.opacity = "0.75";
    filterTitle.style.fontWeight = "600";
    const filterControls = document.createElement("div");
    filterControls.style.display = "flex";
    filterControls.style.flexWrap = "wrap";
    filterControls.style.gap = "8px";
    const selectedTags = /* @__PURE__ */ new Set();
    const tagButtons = /* @__PURE__ */ new Map();
    let allButton;
    let cardsContainer;
    const filterBtnBaseStyle = (btn) => {
      btn.type = "button";
      btn.style.display = "inline-flex";
      btn.style.alignItems = "center";
      btn.style.justifyContent = "center";
      btn.style.padding = "4px 10px";
      btn.style.borderRadius = "999px";
      btn.style.border = "1px solid";
      btn.style.background = "#ffffff11";
      btn.style.borderColor = "#ffffff22";
      btn.style.fontSize = "11px";
      btn.style.fontWeight = "600";
      btn.style.letterSpacing = "0.03em";
      btn.style.textTransform = "uppercase";
      btn.style.color = "inherit";
      btn.style.opacity = "0.85";
      btn.style.cursor = "pointer";
      btn.style.transition = "background 120ms ease, border-color 120ms ease, opacity 120ms ease";
    };
    const setActiveState = (btn, active) => {
      if (active) {
        btn.style.background = "#2d8cff33";
        btn.style.borderColor = "#2d8cff66";
        btn.style.opacity = "1";
      } else {
        btn.style.background = "#ffffff11";
        btn.style.borderColor = "#ffffff22";
        btn.style.opacity = "0.85";
      }
    };
    const renderList = () => {
      cardsContainer.innerHTML = "";
      const filtered = selectedTags.size ? allTools.filter((tool) => tool.tags?.some((tag) => selectedTags.has(tag))) : allTools;
      if (filtered.length === 0) {
        const empty = document.createElement("p");
        empty.textContent = "No tools match the selected tags yet.";
        empty.style.margin = "12px 0 0";
        empty.style.fontSize = "13px";
        empty.style.opacity = "0.75";
        empty.style.textAlign = "center";
        cardsContainer.appendChild(empty);
        return;
      }
      filtered.forEach((tool) => {
        cardsContainer.appendChild(renderToolCard(ui, tool));
      });
    };
    const refreshButtonStates = () => {
      tagButtons.forEach((btn, tag) => {
        setActiveState(btn, selectedTags.has(tag));
      });
      setActiveState(allButton, selectedTags.size === 0);
    };
    const handleToggle = (tag) => {
      if (selectedTags.has(tag)) {
        selectedTags.delete(tag);
      } else {
        selectedTags.add(tag);
      }
      refreshButtonStates();
      renderList();
    };
    allButton = document.createElement("button");
    allButton.textContent = "All";
    filterBtnBaseStyle(allButton);
    allButton.onclick = () => {
      if (selectedTags.size === 0) return;
      selectedTags.clear();
      refreshButtonStates();
      renderList();
    };
    filterControls.appendChild(allButton);
    ToolsService.tags().forEach((tag) => {
      const btn = document.createElement("button");
      btn.textContent = tag;
      filterBtnBaseStyle(btn);
      btn.onclick = () => handleToggle(tag);
      filterControls.appendChild(btn);
      tagButtons.set(tag, btn);
    });
    filterSection.appendChild(filterTitle);
    filterSection.appendChild(filterControls);
    wrapper.appendChild(filterSection);
    cardsContainer = document.createElement("div");
    cardsContainer.style.display = "flex";
    cardsContainer.style.flexDirection = "column";
    cardsContainer.style.gap = "12px";
    renderList();
    refreshButtonStates();
    wrapper.appendChild(cardsContainer);
    view.appendChild(wrapper);
  }

  // src/services/editor.ts
  var ARIES_SAVED_GARDENS_PATH = "editor.savedGardens";
  var FIXED_SLOT_START = 1760866288723;
  var FIXED_SLOT_END = 1760867858782;
  var mutationColorMap = {
    Gold: "rgba(200, 170, 0, 1)",
    Rainbow: "linear-gradient(135deg, #ff0000, #ff7a00, #ffeb3b, #00c853, #40c4ff, #8e24aa)",
    Wet: "rgb(30, 140, 230)",
    Chilled: "rgb(100, 190, 200)",
    Frozen: "rgb(100, 120, 255)",
    Dawnlit: "rgba(120, 100, 180, 1)",
    Ambershine: "rgba(160, 70, 50, 1)",
    // <- important : Ambershine, pas Amberlit
    Dawncharged: "rgba(160, 140, 220, 1)",
    Ambercharged: "rgba(240, 110, 80, 1)"
  };
  var overlayEl = null;
  var currentEnabled = false;
  var listeners4 = /* @__PURE__ */ new Set();
  var sideOverlayEl = null;
  var sideListWrap = null;
  var sideSelect = null;
  var sideRightWrap = null;
  var currentSideMode = "plants";
  var selectedPlantId = null;
  var selectedDecorId = null;
  var currentItemOverlayEl = null;
  var currentItemUnsub = null;
  var currentItemApplyAll = false;
  var currentItemSlotModes = {};
  var editorKeybindsInstalled = false;
  var overlaysVisible = true;
  var EDITOR_PLACE_REMOVE_FIRST_DELAY_MS = 200;
  var EDITOR_PLACE_REMOVE_REPEAT_MS = 100;
  var lastEditorPlaceRemoveTs = 0;
  var lastEditorPressStartTs = 0;
  var lastEditorFirstFired = false;
  var lastEditorTileKey = null;
  var lastEditorTileType;
  var lastEditorFirstActionTs = 0;
  var editorActionHeld = false;
  async function triggerEditorAnimation(animation) {
    try {
      const playerId2 = await getPlayerId();
      if (!playerId2) return;
      await Atoms.player.avatarTriggerAnimationAtom.set({ playerId: playerId2, animation });
      if (animation === "dig") {
        void audioPlayer.playBy("Break_Dirt_01");
      } else if (animation === "dropObject") {
        void (audioPlayer.playGroup("plant") || audioPlayer.playGroup("hit_dirt") || audioPlayer.playGroup("hit") || audioPlayer.playBy(/Hit_Dirt/i));
      }
    } catch {
    }
  }
  var stateFrozenValue = null;
  var statePatch = null;
  var stateOriginalValue = null;
  var friendGardenPreviewActive = false;
  function persist(enabled) {
  }
  function ensureOverlay() {
    if (overlayEl && document.contains(overlayEl)) return overlayEl;
    const el2 = document.createElement("div");
    el2.id = "qws-editor-overlay";
    el2.textContent = "Editor mode";
    Object.assign(el2.style, {
      position: "fixed",
      top: "7%",
      left: "50%",
      transform: "translateX(-50%)",
      zIndex: "1000001",
      padding: "8px 12px",
      borderRadius: "999px",
      border: "1px solid #ffffff33",
      background: "linear-gradient(180deg, rgba(17,24,31,0.95), rgba(12,18,26,0.92))",
      color: "#e7eef7",
      font: "600 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif",
      letterSpacing: "0.3px",
      boxShadow: "0 10px 30px rgba(0,0,0,.35)",
      pointerEvents: "none"
    });
    (document.body || document.documentElement || document).appendChild(el2);
    overlayEl = el2;
    return el2;
  }
  function showOverlay() {
    ensureOverlay();
  }
  function hideOverlay() {
    if (overlayEl) {
      overlayEl.remove();
      overlayEl = null;
    }
  }
  function getSelectedId() {
    return currentSideMode === "decor" ? selectedDecorId : selectedPlantId;
  }
  function setSelectedId(next) {
    if (currentSideMode === "decor") {
      selectedDecorId = next;
    } else {
      selectedPlantId = next;
    }
  }
  function getSideEntries() {
    if (currentSideMode === "decor") {
      return Object.entries(decorCatalog || {}).map(([decorId, val]) => ({
        id: decorId,
        label: String(val?.name || decorId)
      }));
    }
    return Object.entries(plantCatalog || {}).map(([species, val]) => ({
      id: species,
      label: String(val?.crop?.name || val?.seed?.name || species)
    }));
  }
  function getSideEntry(id) {
    if (!id) return null;
    return currentSideMode === "decor" ? decorCatalog?.[id] : plantCatalog?.[id];
  }
  function getSideEntryLabel(id, entry) {
    if (currentSideMode === "decor") return entry?.name || id;
    return entry?.crop?.name || entry?.seed?.name || id;
  }
  function getSideSpriteKind() {
    return currentSideMode === "decor" ? "Decor" : "Crop";
  }
  function ensureSideOverlay() {
    if (sideOverlayEl && document.contains(sideOverlayEl)) return sideOverlayEl;
    void ensureSpritesReady().catch(() => {
    });
    const root = document.createElement("div");
    root.id = "qws-editor-side";
    Object.assign(root.style, {
      position: "fixed",
      top: "12%",
      left: "12px",
      zIndex: "1000001",
      width: "560px",
      minHeight: "420px",
      maxHeight: "86vh",
      height: "min(720px, 86vh)",
      display: "grid",
      gridTemplateRows: "auto 1fr",
      // <- header + contenu
      gap: "10px",
      padding: "10px",
      borderRadius: "12px",
      border: "1px solid #ffffff22",
      background: "linear-gradient(180deg, rgba(14,18,25,0.95), rgba(10,14,20,0.92))",
      color: "#e7eef7",
      boxShadow: "0 10px 30px rgba(0,0,0,0.35)",
      pointerEvents: "auto"
    });
    const header = document.createElement("div");
    header.textContent = "Item picker";
    header.style.fontWeight = "700";
    header.style.fontSize = "13px";
    header.style.letterSpacing = "0.08em";
    header.style.textTransform = "uppercase";
    header.style.opacity = "0.85";
    header.style.textAlign = "center";
    const content = document.createElement("div");
    content.style.display = "grid";
    content.style.gridTemplateColumns = "260px 1fr";
    content.style.gap = "10px";
    content.style.minHeight = "0";
    const left = document.createElement("div");
    left.style.display = "grid";
    left.style.gridTemplateRows = "auto 1fr";
    left.style.gap = "8px";
    left.style.minHeight = "0";
    const select2 = document.createElement("select");
    select2.id = "qws-editor-side-select";
    select2.style.width = "100%";
    select2.style.padding = "8px";
    select2.style.borderRadius = "10px";
    select2.style.border = "1px solid #33404e";
    select2.style.background = "rgba(20,25,33,0.9)";
    select2.style.color = "#e7eef7";
    select2.style.fontWeight = "600";
    select2.style.cursor = "pointer";
    const optPlants = document.createElement("option");
    optPlants.value = "plants";
    optPlants.textContent = "Plants";
    const optDecor = document.createElement("option");
    optDecor.value = "decor";
    optDecor.textContent = "Decor";
    select2.append(optPlants, optDecor);
    select2.value = currentSideMode;
    select2.onchange = () => {
      currentSideMode = select2.value === "decor" ? "decor" : "plants";
      renderSideList();
    };
    sideSelect = select2;
    const listWrap = document.createElement("div");
    listWrap.id = "qws-editor-side-list";
    Object.assign(listWrap.style, {
      border: "1px solid #2c3643",
      borderRadius: "10px",
      background: "rgba(16,21,28,0.9)",
      overflow: "auto",
      padding: "6px",
      maxHeight: "72vh"
    });
    sideListWrap = listWrap;
    left.append(select2, listWrap);
    const right = document.createElement("div");
    right.id = "qws-editor-side-details";
    right.style.display = "grid";
    right.style.gridTemplateRows = "1fr auto";
    right.style.gap = "8px";
    right.style.border = "1px solid #2c3643";
    right.style.borderRadius = "10px";
    right.style.background = "rgba(16,21,28,0.9)";
    right.style.padding = "10px";
    right.style.minHeight = "0";
    right.style.overflow = "hidden";
    sideRightWrap = right;
    content.append(left, right);
    root.append(header, content);
    (document.body || document.documentElement || document).appendChild(root);
    sideOverlayEl = root;
    renderSideList();
    renderSideDetails();
    return root;
  }
  function showSideOverlay() {
    ensureSideOverlay();
  }
  function hideSideOverlay() {
    if (sideOverlayEl) {
      sideOverlayEl.remove();
      sideOverlayEl = null;
      sideListWrap = null;
      sideSelect = null;
      sideRightWrap = null;
    }
  }
  function ensureCurrentItemOverlay() {
    if (currentItemOverlayEl && document.contains(currentItemOverlayEl)) return currentItemOverlayEl;
    const root = document.createElement("div");
    root.id = "qws-editor-current-item";
    Object.assign(root.style, {
      position: "fixed",
      top: "12%",
      right: "12px",
      zIndex: "1000001",
      width: "420px",
      minHeight: "200px",
      maxHeight: "86vh",
      display: "grid",
      gridTemplateRows: "auto 1fr",
      gap: "10px",
      padding: "10px",
      borderRadius: "12px",
      border: "1px solid #ffffff22",
      background: "linear-gradient(180deg, rgba(14,18,25,0.95), rgba(10,14,20,0.92))",
      color: "#e7eef7",
      boxShadow: "0 10px 30px rgba(0,0,0,0.35)",
      pointerEvents: "auto"
    });
    const header = document.createElement("div");
    header.textContent = "Current item";
    header.style.fontWeight = "700";
    header.style.fontSize = "13px";
    header.style.letterSpacing = "0.08em";
    header.style.textTransform = "uppercase";
    header.style.opacity = "0.85";
    header.style.textAlign = "center";
    const content = document.createElement("div");
    content.id = "qws-editor-current-item-content";
    content.style.display = "grid";
    content.style.gap = "10px";
    content.style.minHeight = "0";
    content.style.overflow = "auto";
    root.append(header, content);
    (document.body || document.documentElement || document).appendChild(root);
    currentItemOverlayEl = root;
    attachCurrentItemListener();
    renderCurrentItemOverlay();
    return root;
  }
  function showCurrentItemOverlay() {
    ensureCurrentItemOverlay();
  }
  function hideCurrentItemOverlay() {
    if (currentItemUnsub) {
      try {
        currentItemUnsub();
      } catch {
      }
      currentItemUnsub = null;
    }
    if (currentItemOverlayEl) {
      currentItemOverlayEl.remove();
      currentItemOverlayEl = null;
    }
  }
  function attachCurrentItemListener() {
    if (currentItemUnsub) {
      try {
        currentItemUnsub();
      } catch {
      }
      currentItemUnsub = null;
    }
    void (async () => {
      try {
        const atom = getAtomByLabel("myCurrentGardenObjectAtom");
        const selectedIdxAtom = getAtomByLabel("myValidatedSelectedItemIndexAtom");
        const store = await ensureStore().catch(() => null);
        if (!atom || !store) return;
        const unsubA = store.sub(atom, () => {
          renderCurrentItemOverlay();
        });
        const unsubB = selectedIdxAtom ? store.sub(selectedIdxAtom, () => renderCurrentItemOverlay()) : null;
        currentItemUnsub = () => {
          try {
            unsubA();
          } catch {
          }
          if (unsubB) {
            try {
              unsubB();
            } catch {
            }
          }
        };
      } catch {
      }
    })();
  }
  async function readCurrentTileContext() {
    try {
      const store = await ensureStore().catch(() => null);
      if (!store) return { tileType: void 0, tileKey: null, tileObject: null };
      const tileAtom = getAtomByLabel("myCurrentGardenTileAtom");
      if (!tileAtom) return { tileType: void 0, tileKey: null, tileObject: null };
      const tileVal = store.get(tileAtom);
      if (!tileVal) return { tileType: void 0, tileKey: null, tileObject: null };
      const tileType = tileVal.tileType;
      const localTileIndex = tileVal.localTileIndex;
      const userSlotIdxRaw = tileVal.userSlotIdx;
      const userSlotIdx = typeof userSlotIdxRaw === "number" && Number.isFinite(userSlotIdxRaw) ? userSlotIdxRaw : 0;
      if (localTileIndex == null || !Number.isFinite(localTileIndex)) {
        return { tileType, tileKey: null, tileObject: null };
      }
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const garden2 = Array.isArray(cur?.child?.data?.userSlots) ? cur?.child?.data?.userSlots?.[userSlotIdx]?.data?.garden : cur?.child?.data?.userSlots?.[String(userSlotIdx)]?.data?.garden;
      const safeGarden = garden2 && typeof garden2 === "object" ? garden2 : makeEmptyGarden();
      const key2 = String(localTileIndex);
      const targetMap = tileType === "Dirt" ? safeGarden.tileObjects || {} : safeGarden.boardwalkTileObjects || {};
      return { tileType, tileKey: key2, tileObject: targetMap[key2] };
    } catch {
      return { tileType: void 0, tileKey: null, tileObject: null };
    }
  }
  function getGardenObjectLabel(obj) {
    if (!obj || typeof obj !== "object") return "Unknown";
    if (obj.objectType === "plant") {
      const entry = plantCatalog[obj.species];
      return entry?.crop?.name || entry?.seed?.name || obj.species || "Plant";
    }
    if (obj.objectType === "decor") {
      const entry = decorCatalog[obj.decorId];
      return entry?.name || obj.decorId || "Decor";
    }
    return String(obj.objectType || "Item");
  }
  function getInventoryItemLabel(item) {
    if (!item || typeof item !== "object") return "Item";
    if (item.itemType === "Plant") {
      const entry = plantCatalog[item.species];
      return entry?.crop?.name || entry?.seed?.name || item.species || "Plant";
    }
    if (item.itemType === "Decor") {
      const entry = decorCatalog[item.decorId];
      return entry?.name || item.decorId || "Decor";
    }
    return String(item.itemType || "Item");
  }
  function renderCurrentItemOverlay() {
    if (!currentItemOverlayEl) return;
    const content = currentItemOverlayEl.querySelector("#qws-editor-current-item-content");
    if (!content) return;
    void (async () => {
      content.innerHTML = "";
      const { tileType, tileKey, tileObject } = await readCurrentTileContext();
      if (!tileObject) {
        const empty = document.createElement("div");
        empty.textContent = "Look at a plant or decor to edit it.";
        empty.style.opacity = "0.7";
        empty.style.textAlign = "center";
        content.appendChild(empty);
        try {
          const inv = await Atoms.inventory.myInventory.get();
          const idx = await Atoms.inventory.myValidatedSelectedItemIndex.get();
          const items = Array.isArray(inv?.items) ? inv.items : [];
          const selected = typeof idx === "number" ? items[idx] : null;
          if (selected) {
            const infoRow = document.createElement("div");
            infoRow.style.display = "flex";
            infoRow.style.flexDirection = "column";
            infoRow.style.alignItems = "center";
            infoRow.style.gap = "6px";
            const sprite2 = createShopSprite(
              selected.itemType === "Decor" ? "Decor" : "Crop",
              selected.itemType === "Decor" ? selected.decorId : selected.species,
              { size: 40, fallback: "?" }
            );
            sprite2.style.display = "inline-block";
            const nameEl2 = document.createElement("div");
            nameEl2.textContent = getInventoryItemLabel(selected);
            nameEl2.style.fontWeight = "700";
            nameEl2.style.fontSize = "14px";
            nameEl2.style.overflow = "hidden";
            nameEl2.style.textOverflow = "ellipsis";
            nameEl2.style.whiteSpace = "nowrap";
            nameEl2.style.textAlign = "center";
            infoRow.append(sprite2, nameEl2);
            content.appendChild(infoRow);
            if (selected.itemType === "Plant") {
              const slotsArr = Array.isArray(selected.slots) ? selected.slots : [];
              const mutSet = /* @__PURE__ */ new Set();
              for (const s of slotsArr) {
                const muts = Array.isArray(s?.mutations) ? s.mutations : [];
                muts.forEach((m) => mutSet.add(m));
              }
              const mutList = Array.from(mutSet);
              const mutRow = document.createElement("div");
              mutRow.style.display = "flex";
              mutRow.style.flexWrap = "wrap";
              mutRow.style.gap = "6px";
              mutRow.style.justifyContent = "center";
              if (mutList.length) {
                for (const mutId of mutList) {
                  const tag = document.createElement("span");
                  tag.textContent = mutationCatalog[mutId]?.name?.charAt(0)?.toUpperCase() || mutId.charAt(0)?.toUpperCase() || "?";
                  tag.style.fontWeight = "900";
                  tag.style.fontSize = "12px";
                  tag.style.padding = "4px 8px";
                  tag.style.borderRadius = "999px";
                  tag.style.border = "1px solid #2c3643";
                  tag.style.background = "rgba(10,14,20,0.9)";
                  const color = mutationColorMap[mutId];
                  if (color) {
                    if (color.startsWith("linear-gradient")) {
                      tag.style.backgroundImage = color;
                      tag.style.backgroundClip = "text";
                      tag.style.webkitBackgroundClip = "text";
                      tag.style.color = "transparent";
                      tag.style.webkitTextFillColor = "transparent";
                    } else {
                      tag.style.color = color;
                    }
                  }
                  mutRow.appendChild(tag);
                }
              } else {
                const none = document.createElement("div");
                none.textContent = "No mutations";
                none.style.opacity = "0.7";
                none.style.fontSize = "11px";
                mutRow.appendChild(none);
              }
              content.append(mutRow);
            }
            const placeBtn = document.createElement("button");
            placeBtn.type = "button";
            placeBtn.textContent = "Place";
            Object.assign(placeBtn.style, {
              width: "100%",
              padding: "8px 10px",
              borderRadius: "8px",
              border: "1px solid #2b3441",
              background: "linear-gradient(180deg, rgba(42,154,255,0.12), rgba(30,91,181,0.35))",
              color: "#e7eef7",
              fontWeight: "700",
              cursor: "pointer"
            });
            placeBtn.onclick = () => {
              void placeSelectedItemInGardenAtCurrentTile();
            };
            content.appendChild(placeBtn);
          }
        } catch {
        }
        return;
      }
      const name = getGardenObjectLabel(tileObject);
      const sprite = createShopSprite(
        tileObject.objectType === "decor" ? "Decor" : "Crop",
        tileObject.objectType === "decor" ? tileObject.decorId : tileObject.species,
        { size: 48, fallback: "?" }
      );
      sprite.style.display = "inline-block";
      const header = document.createElement("div");
      header.style.display = "flex";
      header.style.flexDirection = "column";
      header.style.alignItems = "center";
      header.style.gap = "6px";
      const nameEl = document.createElement("div");
      nameEl.textContent = name;
      nameEl.style.fontWeight = "700";
      nameEl.style.fontSize = "15px";
      nameEl.style.overflow = "hidden";
      nameEl.style.textOverflow = "ellipsis";
      nameEl.style.whiteSpace = "nowrap";
      nameEl.style.textAlign = "center";
      header.append(sprite, nameEl);
      content.appendChild(header);
      if (tileObject.objectType === "plant") {
        renderCurrentPlantEditor(content, tileObject, tileKey || "");
      }
      const addBtn = document.createElement("button");
      addBtn.type = "button";
      addBtn.textContent = "Copy to inventory";
      Object.assign(addBtn.style, {
        width: "100%",
        padding: "8px 10px",
        borderRadius: "8px",
        border: "1px solid #2b3441",
        background: "linear-gradient(180deg, rgba(42,154,255,0.12), rgba(30,91,181,0.35))",
        color: "#e7eef7",
        fontWeight: "700",
        cursor: "pointer"
      });
      addBtn.onclick = () => {
        void addTileObjectToInventory(tileObject);
      };
      content.appendChild(addBtn);
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.textContent = "Remove";
      Object.assign(removeBtn.style, {
        width: "100%",
        padding: "8px 10px",
        borderRadius: "8px",
        border: "1px solid #2b3441",
        background: "linear-gradient(180deg, rgba(220,80,80,0.18), rgba(160,40,40,0.25))",
        color: "#e7eef7",
        fontWeight: "700",
        cursor: "pointer"
      });
      removeBtn.onclick = () => {
        if (tileObject.objectType === "plant") void removeItemFromGardenAtCurrentTile();
        else void removeDecorFromGardenAtCurrentTile();
      };
      content.appendChild(removeBtn);
    })();
  }
  function renderCurrentPlantEditor(content, tileObject, tileKey) {
    const species = tileObject?.species;
    const slots = Array.isArray(tileObject?.slots) ? tileObject.slots : [];
    const modeKey = tileKey || "default";
    const slotModeMap = currentItemSlotModes[modeKey] || {};
    let applyAll = currentItemApplyAll;
    const slotsList = document.createElement("div");
    slotsList.style.display = "grid";
    slotsList.style.gap = "8px";
    const maxSlots = getMaxSlotsForSpecies(species);
    const applyAllRow = document.createElement("label");
    applyAllRow.style.display = "flex";
    applyAllRow.style.alignItems = "center";
    applyAllRow.style.gap = "6px";
    applyAllRow.style.fontSize = "12px";
    applyAllRow.style.opacity = "0.9";
    const applyToggle = document.createElement("input");
    applyToggle.type = "checkbox";
    applyToggle.checked = applyAll;
    applyToggle.onchange = () => {
      applyAll = !!applyToggle.checked;
      currentItemApplyAll = applyAll;
      if (applyAll) syncApplyAllControls();
    };
    const applyLabel = document.createElement("span");
    applyLabel.textContent = "Edit all slots together";
    applyAllRow.append(applyToggle, applyLabel);
    const syncApplyAllControls = () => {
      if (!applyAll) return;
      slotsList.querySelectorAll("input[data-slot-idx]").forEach((s) => {
        s.value = String(s._currentPct || s.value);
        const mode = s._currentMode || "percent";
        s.disabled = mode === "custom";
        s.style.opacity = mode === "custom" ? "0.45" : "1";
      });
      slotsList.querySelectorAll("input[data-scale-input-slot]").forEach((s) => {
        s.value = String(s._currentScale || s.value);
      });
      slotsList.querySelectorAll("[data-size-label]").forEach((lab) => {
        const curPct = lab._currentPct;
        if (curPct != null) lab.textContent = `${curPct}%`;
      });
      slotsList.querySelectorAll("input[data-scale-mode-slot]").forEach((chk) => {
        const mode = chk._currentMode || "percent";
        chk.checked = mode === "custom";
      });
      slotsList.querySelectorAll("[data-custom-row-slot]").forEach((row) => {
        const mode = row._currentMode || "percent";
        row.style.display = mode === "custom" ? "flex" : "none";
      });
      slotsList.querySelectorAll("[data-slider-row-slot]").forEach((row) => {
        const mode = row._currentMode || "percent";
        row.style.display = mode === "custom" ? "none" : "";
      });
    };
    slots.forEach((slot, idx) => {
      const box = document.createElement("div");
      Object.assign(box.style, {
        border: "1px solid #2c3643",
        borderRadius: "8px",
        padding: "8px",
        background: "rgba(10,14,20,0.9)",
        display: "grid",
        gap: "6px"
      });
      const rawScale = Number(slot?.targetScale);
      const fallbackScale = computeTargetScaleFromPercent(species, 100);
      const initialScale = Number.isFinite(rawScale) ? rawScale : fallbackScale;
      const { minScale, maxScale } = getScaleBoundsForSpecies(species);
      const computePercentLoose = (scale) => {
        const { minScale: minScale2, maxScale: maxScale2 } = getScaleBoundsForSpecies(species);
        if (!maxScale2 || maxScale2 <= minScale2) return 100;
        const pct2 = 50 + (scale - minScale2) / (maxScale2 - minScale2) * 50;
        return clampSizePercent(pct2);
      };
      const pct = computePercentLoose(initialScale);
      let currentPct = pct;
      let currentScale = initialScale;
      const outOfBounds = initialScale < minScale || initialScale > maxScale;
      let currentMode = slotModeMap[idx] === "custom" ? "custom" : outOfBounds ? "custom" : "percent";
      if (!slotModeMap[idx] && outOfBounds) {
        currentItemSlotModes[modeKey] = { ...currentItemSlotModes[modeKey] || {}, [idx]: "custom" };
      }
      const sizeRow = document.createElement("div");
      sizeRow.style.display = "flex";
      sizeRow.style.justifyContent = "space-between";
      sizeRow.style.alignItems = "center";
      sizeRow.style.fontSize = "11px";
      sizeRow.style.opacity = "0.85";
      const sizeName = document.createElement("span");
      sizeName.textContent = "Size";
      const sizeValue = document.createElement("span");
      sizeValue.textContent = `${currentPct}%`;
      sizeValue.dataset.sizeLabel = String(idx);
      sizeValue._currentPct = currentPct;
      sizeRow.append(sizeName, sizeValue);
      const slider = document.createElement("input");
      slider.type = "range";
      slider.min = "50";
      slider.max = "100";
      slider.step = "1";
      slider.value = String(currentPct);
      slider.dataset.slotIdx = String(idx);
      slider._currentPct = currentPct;
      slider._currentMode = currentMode;
      Object.assign(slider.style, { width: "100%", cursor: "pointer" });
      const sliderRow = document.createElement("div");
      sliderRow.dataset.sliderRowSlot = String(idx);
      sliderRow.appendChild(slider);
      const customRow = document.createElement("div");
      customRow.style.display = "flex";
      customRow.style.alignItems = "center";
      customRow.style.gap = "6px";
      customRow.style.fontSize = "11px";
      customRow.style.opacity = "0.9";
      const customLabel = document.createElement("span");
      customLabel.textContent = "Custom scale";
      const customInput = document.createElement("input");
      customInput.type = "text";
      customInput.inputMode = "decimal";
      customInput.autocomplete = "off";
      customInput.value = String(currentScale);
      customInput.dataset.scaleInputSlot = String(idx);
      customInput._currentScale = currentScale;
      Object.assign(customInput.style, {
        width: "90px",
        padding: "4px 6px",
        borderRadius: "6px",
        border: "1px solid #2c3643",
        background: "rgba(10,14,20,0.9)",
        color: "#e7eef7"
      });
      let pendingPatch = null;
      let debounceTimer = null;
      const flushPatch = () => {
        if (!pendingPatch) return;
        const patch = pendingPatch;
        pendingPatch = null;
        void updateGardenObjectAtCurrentTile((obj) => {
          if (obj?.objectType !== "plant") return obj;
          const nextSlots = Array.isArray(obj.slots) ? obj.slots.slice() : [];
          if (applyAll) {
            for (let i = 0; i < nextSlots.length; i++) {
              nextSlots[i] = { ...nextSlots[i] || {}, ...patch };
            }
          } else {
            nextSlots[idx] = { ...nextSlots[idx] || {}, ...patch };
          }
          return { ...obj, slots: nextSlots };
        });
      };
      const queuePatch = (patch) => {
        pendingPatch = { ...pendingPatch || {}, ...patch };
        if (debounceTimer != null) window.clearTimeout(debounceTimer);
        debounceTimer = window.setTimeout(() => {
          flushPatch();
        }, 150);
      };
      const updatePercent = (nextPct) => {
        const pctVal = clampSizePercent(nextPct);
        currentPct = pctVal;
        slider._currentPct = pctVal;
        sizeValue._currentPct = pctVal;
        sizeValue.textContent = `${pctVal}%`;
        slider.value = String(pctVal);
        currentScale = computeTargetScaleFromPercent(species, pctVal);
        if (currentMode !== "custom") customInput.value = currentScale.toFixed(4);
        customInput._currentScale = currentScale;
        queuePatch({ targetScale: currentScale });
        if (applyAll) {
          slotsList.querySelectorAll("input[data-slot-idx]").forEach((s) => {
            if (s === slider) return;
            s.value = String(pctVal);
            s._currentPct = pctVal;
            s._currentMode = "percent";
            s.disabled = false;
            s.style.opacity = "1";
          });
          slotsList.querySelectorAll("input[data-scale-input-slot]").forEach((s) => {
            if (s === customInput) return;
            s.value = currentScale.toFixed(4);
            s._currentScale = currentScale;
          });
          slotsList.querySelectorAll("[data-size-label]").forEach((lab) => {
            lab.textContent = `${pctVal}%`;
            lab._currentPct = pctVal;
          });
          applyModeToAll("percent", currentScale, currentPct);
        }
      };
      const updateCustomScale = (raw) => {
        const normalized = raw.replace(",", ".").replace(/\s+/g, "");
        const n = Number(normalized);
        if (!Number.isFinite(n)) return;
        currentScale = n;
        customInput.value = normalized;
        customInput._currentScale = n;
        const pctVal = computePercentFromScale(species, n);
        currentPct = pctVal;
        slider.value = String(pctVal);
        sizeValue.textContent = `${pctVal}%`;
        queuePatch({ targetScale: n });
        if (applyAll) {
          slotsList.querySelectorAll("input[data-slot-idx]").forEach((s) => {
            if (s === slider) return;
            s.value = String(pctVal);
            s._currentPct = pctVal;
            s._currentMode = "custom";
            s.disabled = true;
            s.style.opacity = "0.45";
          });
          slotsList.querySelectorAll("input[data-scale-input-slot]").forEach((s) => {
            if (s === customInput) return;
            s.value = String(n);
            s._currentScale = n;
          });
          slotsList.querySelectorAll("[data-size-label]").forEach((lab) => {
            lab.textContent = `${pctVal}%`;
            lab._currentPct = pctVal;
          });
          applyModeToAll("custom", n, currentPct);
        }
      };
      slider.oninput = () => updatePercent(Number(slider.value));
      const commitCustomInput = () => updateCustomScale(customInput.value);
      customInput.onblur = commitCustomInput;
      customInput.onkeydown = (ev) => {
        if (ev.key === "Enter") {
          ev.preventDefault();
          commitCustomInput();
        }
      };
      customRow.append(customLabel, customInput);
      const modeRow = document.createElement("label");
      modeRow.style.display = "flex";
      modeRow.style.alignItems = "center";
      modeRow.style.gap = "6px";
      modeRow.style.fontSize = "11px";
      modeRow.style.opacity = "0.9";
      const modeToggle = document.createElement("input");
      modeToggle.type = "checkbox";
      modeToggle.dataset.scaleModeSlot = String(idx);
      modeToggle._currentMode = currentMode;
      modeToggle.checked = currentMode === "custom";
      const modeText = document.createElement("span");
      modeText.textContent = "Use custom scale";
      const syncValueLabel = () => {
        sizeValue.textContent = currentMode === "custom" ? `${currentScale.toFixed(2)}x` : `${currentPct}%`;
        sizeValue._currentPct = currentPct;
      };
      const syncControlState = () => {
        const showPercent = currentMode !== "custom";
        modeToggle._currentMode = currentMode;
        slider._currentMode = currentMode;
        slider.disabled = !showPercent;
        sliderRow.style.display = showPercent ? "" : "none";
        customRow.style.display = showPercent ? "none" : "flex";
      };
      modeToggle.onchange = () => {
        currentMode = modeToggle.checked ? "custom" : "percent";
        currentItemSlotModes[modeKey] = {
          ...currentItemSlotModes[modeKey] || {},
          [idx]: currentMode
        };
        if (currentMode === "custom") {
          queuePatch({ targetScale: currentScale });
        } else {
          const clamped = clampCustomScale(species, currentScale);
          currentScale = clamped;
          customInput._currentScale = clamped;
          customInput.value = String(clamped);
          const pctVal = computePercentFromScale(species, clamped);
          currentPct = pctVal;
          slider._currentPct = pctVal;
          slider.value = String(pctVal);
          queuePatch({ targetScale: clamped });
        }
        syncControlState();
        syncValueLabel();
        if (applyAll) syncApplyAllControls();
        if (applyAll) {
          applyModeToAll(currentMode, currentScale, currentPct);
        }
      };
      const installGameKeyBlocker = (inp) => {
        const stop2 = (ev) => {
          ev.stopImmediatePropagation?.();
          ev.stopPropagation();
        };
        const attach = () => {
          window.addEventListener("keydown", stop2, true);
          window.addEventListener("keyup", stop2, true);
        };
        const detach = () => {
          window.removeEventListener("keydown", stop2, true);
          window.removeEventListener("keyup", stop2, true);
        };
        inp.addEventListener("focus", attach);
        inp.addEventListener("blur", detach);
        inp.addEventListener("keydown", stop2);
      };
      const installCharGuard = (inp) => {
        const allowed = /* @__PURE__ */ new Set(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "."]);
        inp.addEventListener("keydown", (ev) => {
          if (ev.ctrlKey || ev.metaKey || ev.altKey) return;
          const k = ev.key;
          if (["Backspace", "Delete", "Tab", "Enter", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(k)) {
            return;
          }
          if (k.length === 1 && !allowed.has(k)) {
            ev.preventDefault();
          }
        });
        inp.addEventListener("input", () => {
          const cleaned = inp.value.replace(/[^0-9.-]/g, "");
          if (cleaned !== inp.value) inp.value = cleaned;
        });
      };
      installGameKeyBlocker(customInput);
      installCharGuard(customInput);
      modeRow.append(modeToggle, modeText);
      slider.disabled = currentMode === "custom";
      sliderRow.style.display = currentMode === "custom" ? "none" : "";
      customRow.style.display = currentMode === "custom" ? "flex" : "none";
      syncControlState();
      syncValueLabel();
      const mutWrap = document.createElement("div");
      mutWrap.style.display = "grid";
      mutWrap.style.gap = "6px";
      const mutTitle = document.createElement("div");
      mutTitle.textContent = "Mutations";
      mutTitle.style.fontSize = "11px";
      mutTitle.style.opacity = "0.85";
      const mutRow = document.createElement("div");
      mutRow.style.display = "flex";
      mutRow.style.flexWrap = "wrap";
      mutRow.style.gap = "6px";
      mutRow.style.alignItems = "center";
      const mutations = Array.isArray(slot?.mutations) ? slot.mutations.slice() : [];
      const mutationKeys = Object.keys(mutationCatalog || {});
      const applyMutationsPatch = (nextMutations) => {
        const copy2 = nextMutations.slice();
        mutations.length = 0;
        mutations.push(...copy2);
        void updateGardenObjectAtCurrentTile((obj) => {
          if (obj?.objectType !== "plant") return obj;
          const nextSlots = Array.isArray(obj.slots) ? obj.slots.slice() : [];
          if (applyAll) {
            for (let i = 0; i < nextSlots.length; i++) {
              nextSlots[i] = { ...nextSlots[i] || {}, mutations: copy2.slice() };
            }
          } else {
            nextSlots[idx] = { ...nextSlots[idx] || {}, mutations: copy2.slice() };
          }
          return { ...obj, slots: nextSlots };
        }).then(() => {
          renderMutations();
        });
      };
      const styleLetter = (target, mutId) => {
        const color = mutationColorMap[mutId];
        if (!color) return;
        if (color.startsWith("linear-gradient")) {
          target.style.backgroundImage = color;
          target.style.backgroundClip = "text";
          target.style.webkitBackgroundClip = "text";
          target.style.color = "transparent";
          target.style.webkitTextFillColor = "transparent";
        } else {
          target.style.color = color;
        }
      };
      const getLetter = (mutId) => {
        const def = mutationCatalog[mutId] || {};
        const src = def.name || mutId || "?";
        return String(src).charAt(0).toUpperCase();
      };
      const renderMutations = () => {
        mutRow.innerHTML = "";
        for (const mutId of mutations) {
          const tag = document.createElement("span");
          Object.assign(tag.style, {
            borderRadius: "999px",
            padding: "3px 8px",
            fontSize: "11px",
            fontWeight: "700",
            border: "1px solid #2c3643",
            background: "rgba(10,14,20,0.9)",
            cursor: "pointer"
          });
          const letterSpan = document.createElement("span");
          letterSpan.textContent = getLetter(mutId);
          letterSpan.style.fontWeight = "900";
          styleLetter(letterSpan, mutId);
          tag.title = "Remove mutation";
          tag.onclick = () => {
            const next = mutations.filter((m) => m !== mutId);
            applyMutationsPatch(next);
          };
          tag.appendChild(letterSpan);
          mutRow.appendChild(tag);
        }
        if (mutations.length < mutationKeys.length) {
          const toggleBtn = document.createElement("button");
          toggleBtn.type = "button";
          toggleBtn.textContent = "+";
          Object.assign(toggleBtn.style, {
            width: "28px",
            height: "28px",
            borderRadius: "50%",
            border: "1px solid #2c3643",
            background: "rgba(10,14,20,0.9)",
            color: "#e7eef7",
            fontWeight: "900",
            fontSize: "16px",
            cursor: "pointer",
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center"
          });
          toggleBtn.onclick = () => {
            const isOpen = dropdown.style.display !== "none";
            dropdown.style.display = isOpen ? "none" : "grid";
            toggleBtn.style.background = isOpen ? "rgba(10,14,20,0.9)" : "rgba(32,42,56,0.8)";
          };
          mutRow.appendChild(toggleBtn);
        }
      };
      const dropdown = document.createElement("div");
      dropdown.style.display = "none";
      dropdown.style.gridTemplateColumns = "repeat(auto-fill, minmax(90px, 1fr))";
      dropdown.style.gap = "6px";
      dropdown.style.padding = "6px";
      dropdown.style.border = "1px solid #2c3643";
      dropdown.style.borderRadius = "8px";
      dropdown.style.background = "rgba(8,12,18,0.9)";
      for (const mutKey of mutationKeys) {
        const def = mutationCatalog[mutKey] || {};
        const storedId = mutKey === "Amberlit" ? "Ambershine" : mutKey;
        const isActive = Array.isArray(slot.mutations) && slot.mutations.includes(storedId);
        if (isActive) continue;
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = def.name || mutKey || "?";
        Object.assign(btn.style, {
          padding: "6px 8px",
          borderRadius: "8px",
          border: isActive ? "1px solid #55d38a" : "1px solid #2c3643",
          background: isActive ? "rgba(85,211,138,0.22)" : "rgba(10,14,20,0.9)",
          color: "#e7eef7",
          fontSize: "11px",
          fontWeight: "700",
          cursor: "pointer",
          textAlign: "left"
        });
        const color = mutationColorMap[storedId];
        if (color) {
          btn.style.color = color.startsWith("linear-gradient") ? "#e7eef7" : color;
          if (color.startsWith("linear-gradient")) {
            btn.style.backgroundImage = color;
            btn.style.backgroundClip = "text";
            btn.style.webkitBackgroundClip = "text";
            btn.style.color = "transparent";
            btn.style.webkitTextFillColor = "transparent";
          }
        }
        btn.onclick = () => {
          const has = Array.isArray(slot.mutations) && slot.mutations.includes(storedId);
          const next = has ? (slot.mutations || []).filter((x) => x !== storedId) : [...slot.mutations || [], storedId];
          applyMutationsPatch(next);
        };
        dropdown.appendChild(btn);
      }
      mutWrap.append(mutTitle, mutRow, dropdown);
      renderMutations();
      box.append(sizeRow, modeRow, sliderRow, customRow, mutWrap);
      slotsList.appendChild(box);
    });
    const showSlotControls = maxSlots > 1;
    if (showSlotControls) {
      const slotHeader = document.createElement("div");
      slotHeader.style.display = "flex";
      slotHeader.style.alignItems = "center";
      slotHeader.style.justifyContent = "space-between";
      slotHeader.style.fontSize = "12px";
      slotHeader.style.opacity = "0.9";
      slotHeader.style.gap = "8px";
      const slotCount = document.createElement("span");
      slotCount.textContent = `Slots ${slots.length}/${maxSlots}`;
      const slotBtnWrap = document.createElement("div");
      slotBtnWrap.style.display = "flex";
      slotBtnWrap.style.gap = "6px";
      slotBtnWrap.style.alignItems = "center";
      const makeCircleBtn = (text) => {
        const b = document.createElement("button");
        b.type = "button";
        b.textContent = text;
        Object.assign(b.style, {
          width: "28px",
          height: "28px",
          borderRadius: "50%",
          border: "1px solid #2b3441",
          background: "rgba(16,21,28,0.9)",
          color: "#e7eef7",
          cursor: "pointer",
          fontSize: "14px",
          fontWeight: "600",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center"
        });
        return b;
      };
      const btnAdd = makeCircleBtn("+");
      const btnRemove = makeCircleBtn("-");
      const updateSlotHeaderState = () => {
        slotCount.textContent = `Slots ${slots.length}/${maxSlots}`;
        btnAdd.disabled = slots.length >= maxSlots;
        btnRemove.disabled = slots.length <= 1;
        btnAdd.style.opacity = btnAdd.disabled ? "0.4" : "1";
        btnRemove.style.opacity = btnRemove.disabled ? "0.4" : "1";
      };
      updateSlotHeaderState();
      const makeDefaultSlot = () => ({
        species,
        startTime: FIXED_SLOT_START,
        endTime: FIXED_SLOT_END,
        targetScale: computeTargetScaleFromPercent(species, 100),
        mutations: []
      });
      btnAdd.onclick = () => {
        if (slots.length >= maxSlots) return;
        void updateGardenObjectAtCurrentTile((obj) => {
          if (obj?.objectType !== "plant") return obj;
          const nextSlots = Array.isArray(obj.slots) ? obj.slots.slice() : [];
          if (nextSlots.length >= maxSlots) return obj;
          nextSlots.push(makeDefaultSlot());
          return { ...obj, slots: nextSlots };
        }).then((ok) => {
          if (ok) renderCurrentItemOverlay();
        });
      };
      btnRemove.onclick = () => {
        if (slots.length <= 1) return;
        void updateGardenObjectAtCurrentTile((obj) => {
          if (obj?.objectType !== "plant") return obj;
          const nextSlots = Array.isArray(obj.slots) ? obj.slots.slice(0, Math.max(1, obj.slots.length - 1)) : [];
          return { ...obj, slots: nextSlots };
        }).then((ok) => {
          if (ok) renderCurrentItemOverlay();
        });
      };
      slotBtnWrap.append(btnRemove, btnAdd);
      slotHeader.append(slotCount, slotBtnWrap);
      content.appendChild(slotHeader);
      content.appendChild(applyAllRow);
    }
    content.appendChild(slotsList);
    const applyModeToAll = (mode, refScale, refPct) => {
      slotsList.querySelectorAll("input[data-scale-mode-slot]").forEach((chk) => {
        chk.checked = mode === "custom";
        chk._currentMode = mode;
      });
      slotsList.querySelectorAll("input[data-slot-idx]").forEach((s) => {
        s._currentMode = mode;
        s.disabled = mode === "custom";
        s.style.opacity = mode === "custom" ? "0.45" : "1";
        if (mode === "percent") {
          s.value = String(s._currentPct ?? refPct);
        }
      });
      slotsList.querySelectorAll("[data-slider-row-slot]").forEach((row) => {
        row.style.display = mode === "custom" ? "none" : "";
        row._currentMode = mode;
      });
      slotsList.querySelectorAll("[data-custom-row-slot]").forEach((row) => {
        row.style.display = mode === "custom" ? "flex" : "none";
        row._currentMode = mode;
      });
      slotsList.querySelectorAll("input[data-scale-input-slot]").forEach((inp) => {
        if (mode === "custom") {
          inp.value = String(inp._currentScale ?? refScale);
        }
      });
      slotsList.querySelectorAll("[data-size-label]").forEach((lab) => {
        const pctVal = lab._currentPct ?? refPct;
        lab.textContent = mode === "custom" ? `${refScale.toFixed(2)}x` : `${pctVal}%`;
      });
      const map2 = currentItemSlotModes[modeKey] || {};
      for (let i = 0; i < slots.length; i++) map2[i] = mode;
      currentItemSlotModes[modeKey] = map2;
    };
  }
  function renderSideList() {
    if (!sideListWrap) return;
    sideListWrap.innerHTML = "";
    const list = document.createElement("div");
    list.style.display = "grid";
    list.style.gap = "4px";
    const makeItem = (key2, label2, selected) => {
      const btn = document.createElement("button");
      btn.type = "button";
      Object.assign(btn.style, {
        width: "100%",
        display: "grid",
        gridTemplateColumns: "auto 1fr",
        alignItems: "center",
        gap: "8px",
        padding: "8px",
        borderRadius: "8px",
        border: "1px solid " + (selected ? "#4a6fa5" : "#2b3441"),
        background: selected ? "rgba(74,111,165,0.18)" : "rgba(24,30,39,0.9)",
        color: "#e7eef7",
        cursor: "pointer",
        fontWeight: selected ? "700" : "600"
      });
      const sprite = createShopSprite(getSideSpriteKind(), key2, { size: 26, fallback: "\u2753" });
      sprite.style.display = "inline-block";
      const labelEl = document.createElement("span");
      labelEl.textContent = label2;
      labelEl.style.textAlign = "left";
      labelEl.style.overflow = "hidden";
      labelEl.style.textOverflow = "ellipsis";
      labelEl.style.whiteSpace = "nowrap";
      btn.onclick = () => {
        setSelectedId(key2);
        renderSideList();
        renderSideDetails();
      };
      btn.append(sprite, labelEl);
      return btn;
    };
    const selectedId = getSelectedId();
    const entries = getSideEntries();
    for (const it of entries) {
      const isSelected = selectedId === it.id;
      list.appendChild(makeItem(it.id, it.label, isSelected));
    }
    if (!list.childElementCount) {
      const empty = document.createElement("div");
      empty.style.opacity = "0.7";
      empty.textContent = "No entries.";
      sideListWrap.appendChild(empty);
      return;
    }
    sideListWrap.appendChild(list);
  }
  function renderSideDetails() {
    if (!sideRightWrap) return;
    sideRightWrap.innerHTML = "";
    const content = document.createElement("div");
    content.style.display = "grid";
    content.style.gap = "10px";
    content.style.minHeight = "0";
    content.style.overflow = "auto";
    content.style.alignContent = "flex-start";
    content.style.justifyItems = "center";
    const actionBar = document.createElement("div");
    actionBar.style.display = "grid";
    actionBar.style.gap = "6px";
    actionBar.style.justifyItems = "start";
    actionBar.style.marginTop = "4px";
    const selId = getSelectedId();
    if (!selId) {
      const empty = document.createElement("div");
      empty.style.opacity = "0.7";
      empty.style.textAlign = "center";
      empty.textContent = "Select an item on the left.";
      content.appendChild(empty);
      sideRightWrap.append(content, actionBar);
      return;
    }
    const entry = getSideEntry(selId);
    const label2 = getSideEntryLabel(selId, entry);
    const infoRow = document.createElement("div");
    infoRow.style.display = "grid";
    infoRow.style.gridTemplateColumns = "auto 1fr";
    infoRow.style.alignItems = "center";
    infoRow.style.gap = "10px";
    const sprite = createShopSprite(getSideSpriteKind(), selId, {
      size: 48,
      fallback: "\u2753",
      alt: label2
    });
    sprite.style.display = "inline-block";
    const nameEl = document.createElement("div");
    nameEl.textContent = label2;
    nameEl.style.fontWeight = "700";
    nameEl.style.fontSize = "15px";
    nameEl.style.whiteSpace = "nowrap";
    nameEl.style.overflow = "hidden";
    nameEl.style.textOverflow = "ellipsis";
    infoRow.append(sprite, nameEl);
    content.appendChild(infoRow);
    if (currentSideMode === "plants") {
      const maxSlots = getMaxSlotsForSpecies(selId);
      const slotsState = ensureEditorStateForSpecies(selId);
      const slotsConfig = slotsState.slots;
      const applyAll = slotsState.applyAll;
      const slotsPanel = document.createElement("div");
      slotsPanel.style.display = "grid";
      slotsPanel.style.gap = "6px";
      slotsPanel.style.marginTop = "6px";
      slotsPanel.style.width = "100%";
      if (maxSlots > 1) {
        const headerRow = document.createElement("div");
        headerRow.style.display = "flex";
        headerRow.style.justifyContent = "space-between";
        headerRow.style.alignItems = "center";
        headerRow.style.fontSize = "12px";
        headerRow.style.opacity = "0.9";
        const headerLabel = document.createElement("span");
        headerLabel.textContent = "Slots";
        const headerRight = document.createElement("div");
        headerRight.style.display = "flex";
        headerRight.style.gap = "6px";
        headerRight.style.alignItems = "center";
        const countLabel = document.createElement("span");
        countLabel.textContent = `${slotsConfig.length}/${maxSlots}`;
        const btnAdd = document.createElement("button");
        btnAdd.type = "button";
        btnAdd.textContent = "+";
        Object.assign(btnAdd.style, {
          width: "28px",
          height: "28px",
          borderRadius: "50%",
          border: "1px solid #2b3441",
          background: "rgba(16,21,28,0.9)",
          color: "#e7eef7",
          cursor: "pointer",
          fontSize: "14px",
          fontWeight: "600"
        });
        btnAdd.onclick = () => {
          const state2 = ensureEditorStateForSpecies(selId);
          const current = state2.slots;
          if (current.length >= maxSlots) return;
          const defaultScale = computeTargetScaleFromPercent(selId, 100);
          editorPlantSlotsState = {
            ...state2,
            species: selId,
            slots: [
              ...current,
              {
                enabled: true,
                sizePercent: 100,
                customScale: defaultScale,
                sizeMode: "percent",
                mutations: []
              }
            ]
          };
          renderSideDetails();
        };
        const btnRemove = document.createElement("button");
        btnRemove.type = "button";
        btnRemove.textContent = "\u2212";
        Object.assign(btnRemove.style, {
          width: "28px",
          height: "28px",
          borderRadius: "50%",
          border: "1px solid #2b3441",
          background: "rgba(220,80,80,0.18)",
          color: "#e7eef7",
          cursor: "pointer",
          fontSize: "14px",
          fontWeight: "600"
        });
        btnRemove.onclick = () => {
          const state2 = ensureEditorStateForSpecies(selId);
          const current = state2.slots;
          if (current.length <= 1) return;
          editorPlantSlotsState = {
            ...state2,
            species: selId,
            slots: current.slice(0, current.length - 1)
          };
          renderSideDetails();
        };
        headerRight.append(countLabel, btnRemove, btnAdd);
        headerRow.append(headerLabel, headerRight);
        slotsPanel.appendChild(headerRow);
      }
      if (maxSlots > 1) {
        const applyAllRow = document.createElement("label");
        applyAllRow.style.display = "flex";
        applyAllRow.style.alignItems = "center";
        applyAllRow.style.gap = "6px";
        applyAllRow.style.fontSize = "12px";
        applyAllRow.style.opacity = "0.9";
        const applyToggle = document.createElement("input");
        applyToggle.type = "checkbox";
        applyToggle.checked = applyAll;
        applyToggle.onchange = () => {
          editorPlantSlotsState.applyAll = applyToggle.checked;
          renderSideDetails();
        };
        const applyLabel = document.createElement("span");
        applyLabel.textContent = "Edit all slots together";
        applyAllRow.append(applyToggle, applyLabel);
        slotsPanel.appendChild(applyAllRow);
      }
      const list = document.createElement("div");
      list.style.display = "grid";
      list.style.gap = "6px";
      slotsConfig.forEach((cfg, idx) => {
        const slotBox = document.createElement("div");
        Object.assign(slotBox.style, {
          border: "1px solid #2c3643",
          borderRadius: "8px",
          padding: "8px",
          background: "rgba(10,14,20,0.9)",
          display: "grid",
          gap: "6px"
        });
        const initialPct = clampSizePercent(Number.isFinite(cfg.sizePercent) ? cfg.sizePercent : 100);
        const baseScaleFromPct = computeTargetScaleFromPercent(selId, initialPct);
        const initialCustomScale = normalizeCustomScale(
          selId,
          Number.isFinite(cfg.customScale) ? cfg.customScale : baseScaleFromPct
        );
        let currentMode = cfg.sizeMode === "custom" ? "custom" : "percent";
        let currentPct = initialPct;
        let currentScale = currentMode === "custom" ? initialCustomScale : baseScaleFromPct;
        let percentMemory = currentPct;
        let customText = String(currentScale);
        const sizeRow = document.createElement("div");
        sizeRow.style.display = "flex";
        sizeRow.style.justifyContent = "space-between";
        sizeRow.style.alignItems = "center";
        sizeRow.style.fontSize = "11px";
        sizeRow.style.opacity = "0.85";
        const sizeName = document.createElement("span");
        sizeName.textContent = "Size";
        const sizeValue = document.createElement("span");
        sizeValue.dataset.sizeLabel = String(idx);
        sizeRow.append(sizeName, sizeValue);
        const modeRow = document.createElement("label");
        modeRow.style.display = "flex";
        modeRow.style.alignItems = "center";
        modeRow.style.gap = "6px";
        modeRow.style.fontSize = "11px";
        modeRow.style.opacity = "0.9";
        const modeToggle = document.createElement("input");
        modeToggle.type = "checkbox";
        modeToggle.dataset.scaleMode = String(idx);
        modeToggle.checked = currentMode === "custom";
        const modeText = document.createElement("span");
        modeText.textContent = "Use custom scale";
        modeRow.append(modeToggle, modeText);
        const slider = document.createElement("input");
        slider.type = "range";
        slider.min = "50";
        slider.max = "100";
        slider.step = "1";
        slider.value = String(currentPct);
        slider.dataset.slotIdx = String(idx);
        Object.assign(slider.style, {
          width: "100%",
          cursor: "pointer"
        });
        const customRow = document.createElement("div");
        customRow.style.display = "flex";
        customRow.style.alignItems = "center";
        customRow.style.gap = "6px";
        customRow.style.fontSize = "11px";
        customRow.style.opacity = "0.9";
        customRow.dataset.customRow = String(idx);
        const customLabel = document.createElement("span");
        customLabel.textContent = "Custom scale";
        const customInput = document.createElement("input");
        customInput.type = "text";
        customInput.inputMode = "decimal";
        customInput.autocomplete = "off";
        customInput.value = customText;
        customInput.dataset.scaleInput = String(idx);
        Object.assign(customInput.style, {
          width: "90px",
          padding: "4px 6px",
          borderRadius: "6px",
          border: "1px solid #2c3643",
          background: "rgba(10,14,20,0.9)",
          color: "#e7eef7"
        });
        customRow.append(customLabel, customInput);
        const installGameKeyBlocker = (inp) => {
          const stop2 = (ev) => {
            ev.stopImmediatePropagation?.();
            ev.stopPropagation();
          };
          const attach = () => {
            window.addEventListener("keydown", stop2, true);
            window.addEventListener("keyup", stop2, true);
          };
          const detach = () => {
            window.removeEventListener("keydown", stop2, true);
            window.removeEventListener("keyup", stop2, true);
          };
          inp.addEventListener("focus", attach);
          inp.addEventListener("blur", detach);
          inp.addEventListener("keydown", stop2);
        };
        installGameKeyBlocker(customInput);
        const formatScaleLabel = (val) => `${val.toFixed(2)}x`;
        const formatScaleInput = (val) => val.toFixed(2);
        const parseInputNumber = (el2) => {
          const raw = el2.value;
          if (raw === "" || raw == null) return null;
          const normalized = raw.replace(",", ".").replace(/\s+/g, "");
          const n = Number(normalized);
          return Number.isFinite(n) ? n : null;
        };
        const installCharGuard = (inp) => {
          const allowed = /* @__PURE__ */ new Set(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "."]);
          inp.addEventListener("keydown", (ev) => {
            if (ev.ctrlKey || ev.metaKey || ev.altKey) return;
            const k = ev.key;
            if (k === "Backspace" || k === "Delete" || k === "Tab" || k === "Enter" || k === "ArrowLeft" || k === "ArrowRight" || k === "ArrowUp" || k === "ArrowDown" || k === "Home" || k === "End") {
              return;
            }
            if (k.length === 1 && !allowed.has(k)) {
              ev.preventDefault();
            }
          });
          inp.addEventListener("input", () => {
            const cleaned = inp.value.replace(/[^0-9.-]/g, "");
            if (cleaned !== inp.value) {
              inp.value = cleaned;
            }
            customText = inp.value;
          });
        };
        installCharGuard(customInput);
        const syncValueLabel = () => {
          sizeValue.textContent = currentMode === "custom" ? formatScaleLabel(currentScale) : `${currentPct}%`;
        };
        const syncControlState = () => {
          const showPercentMode = currentMode !== "custom";
          slider.disabled = currentMode === "custom";
          slider.style.opacity = currentMode === "custom" ? "0.45" : "1";
          customInput.disabled = currentMode !== "custom";
          customInput.style.opacity = currentMode === "custom" ? "1" : "0.5";
          slider.style.display = showPercentMode ? "" : "none";
          customRow.style.display = showPercentMode ? "none" : "flex";
        };
        const syncApplyAll = () => {
          if (!applyAll || !sideRightWrap) return;
          const showPercentMode = currentMode !== "custom";
          sideRightWrap.querySelectorAll("input[data-slot-idx]").forEach((s) => {
            s.value = String(currentPct);
            s.disabled = currentMode === "custom";
            s.style.opacity = currentMode === "custom" ? "0.45" : "1";
            s.style.display = showPercentMode ? "" : "none";
          });
          sideRightWrap.querySelectorAll("input[data-scale-input]").forEach((inp) => {
            if (currentMode === "custom") {
              inp.value = customText;
            } else {
              inp.value = formatScaleInput(currentScale);
            }
            inp.disabled = currentMode !== "custom";
            inp.style.opacity = currentMode === "custom" ? "1" : "0.5";
          });
          sideRightWrap.querySelectorAll("input[data-scale-mode]").forEach((chk) => {
            chk.checked = currentMode === "custom";
          });
          sideRightWrap.querySelectorAll("[data-size-label]").forEach((lab) => {
            lab.textContent = currentMode === "custom" ? formatScaleLabel(currentScale) : `${currentPct}%`;
          });
          sideRightWrap.querySelectorAll("[data-scale-row]").forEach((row) => {
            row.remove();
          });
          sideRightWrap.querySelectorAll("[data-custom-row]").forEach((row) => {
            row.style.display = showPercentMode ? "none" : "flex";
          });
        };
        const applySlotPatch = (patch) => {
          const base = ensureEditorStateForSpecies(selId).slots;
          editorPlantSlotsState = {
            ...editorPlantSlotsState,
            species: selId,
            slots: base.map((c, i) => {
              if (!applyAll && i !== idx) return c;
              return { ...c, sizeMode: currentMode, ...patch };
            })
          };
        };
        const updatePercent = (nextPct) => {
          const pct = clampSizePercent(nextPct);
          currentPct = pct;
          percentMemory = pct;
          slider.value = String(pct);
          if (currentMode !== "custom") {
            currentScale = computeTargetScaleFromPercent(selId, pct);
          }
          applySlotPatch({
            sizePercent: pct,
            ...currentMode !== "custom" ? { customScale: currentScale } : {}
          });
          syncValueLabel();
          syncApplyAll();
        };
        const updateCustomScale = (nextScale, rawText) => {
          const normalized = normalizeCustomScale(selId, nextScale);
          currentScale = normalized;
          if (typeof rawText === "string") customText = rawText;
          else customText = customInput.value;
          applySlotPatch({ customScale: normalized });
          syncValueLabel();
          syncApplyAll();
        };
        slider.oninput = () => {
          updatePercent(Number(slider.value));
        };
        customInput.oninput = () => {
          const raw = customInput.value;
          customText = raw;
          const n = parseInputNumber(customInput);
          if (n == null) return;
          updateCustomScale(n, raw);
        };
        modeToggle.onchange = () => {
          currentMode = modeToggle.checked ? "custom" : "percent";
          if (currentMode === "custom") {
            percentMemory = currentPct;
            currentScale = normalizeCustomScale(selId, currentScale || computeTargetScaleFromPercent(selId, currentPct));
            customText = customInput.value || String(currentScale);
            applySlotPatch({ customScale: currentScale });
          } else {
            const restoredPct = clampSizePercent(percentMemory);
            currentPct = restoredPct;
            slider.value = String(restoredPct);
            applySlotPatch({ sizePercent: restoredPct });
          }
          syncControlState();
          syncValueLabel();
          syncApplyAll();
        };
        syncControlState();
        syncValueLabel();
        const mutWrap = document.createElement("div");
        mutWrap.style.display = "grid";
        mutWrap.style.gap = "6px";
        const mutTitle = document.createElement("div");
        mutTitle.textContent = "Mutations";
        mutTitle.style.fontSize = "11px";
        mutTitle.style.opacity = "0.85";
        const toggleMutBtn = document.createElement("button");
        toggleMutBtn.type = "button";
        toggleMutBtn.textContent = "+";
        Object.assign(toggleMutBtn.style, {
          width: "28px",
          height: "28px",
          borderRadius: "50%",
          border: "1px solid #2c3643",
          background: "rgba(10,14,20,0.9)",
          color: "#e7eef7",
          fontWeight: "900",
          fontSize: "16px",
          cursor: "pointer",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center"
        });
        const activeRow = document.createElement("div");
        activeRow.style.display = "flex";
        activeRow.style.flexWrap = "wrap";
        activeRow.style.gap = "6px";
        activeRow.style.alignItems = "center";
        const mutDropdown = document.createElement("div");
        mutDropdown.style.display = "none";
        mutDropdown.style.gridTemplateColumns = "repeat(auto-fill, minmax(90px, 1fr))";
        mutDropdown.style.gap = "6px";
        mutDropdown.style.padding = "6px";
        mutDropdown.style.border = "1px solid #2c3643";
        mutDropdown.style.borderRadius = "8px";
        mutDropdown.style.background = "rgba(8,12,18,0.9)";
        const mutationKeys = Object.keys(mutationCatalog || {});
        const renderActiveTags = () => {
          activeRow.innerHTML = "";
          const active = Array.isArray(cfg.mutations) ? cfg.mutations : [];
          const allKeys = mutationKeys.map((k) => k === "Amberlit" ? "Ambershine" : k);
          const allSelected = allKeys.every((k) => active.includes(k));
          const styleLetter = (target, mutId) => {
            const color = mutationColorMap[mutId];
            if (!color) return;
            if (color.startsWith("linear-gradient")) {
              target.style.backgroundImage = color;
              target.style.backgroundClip = "text";
              target.style.webkitBackgroundClip = "text";
              target.style.color = "transparent";
              target.style.webkitTextFillColor = "transparent";
            } else {
              target.style.color = color;
            }
          };
          const getLetter = (mutId) => {
            const def = mutationCatalog[mutId] || {};
            const src = def.name || mutId || "?";
            return String(src).charAt(0).toUpperCase();
          };
          for (const mutId of active) {
            const tag = document.createElement("span");
            Object.assign(tag.style, {
              borderRadius: "999px",
              padding: "3px 8px",
              fontSize: "11px",
              fontWeight: "700",
              border: "1px solid #2c3643",
              background: "rgba(10,14,20,0.9)",
              cursor: "pointer"
            });
            const letterSpan = document.createElement("span");
            letterSpan.textContent = getLetter(mutId);
            letterSpan.style.fontWeight = "900";
            styleLetter(letterSpan, mutId);
            tag.title = "Remove mutation";
            tag.onclick = () => {
              const base = ensureEditorStateForSpecies(selId).slots;
              editorPlantSlotsState = {
                ...editorPlantSlotsState,
                species: selId,
                slots: applyAll ? base.map((c) => {
                  const prev = Array.isArray(c.mutations) ? c.mutations : [];
                  const next = prev.filter((m) => m !== mutId);
                  return { ...c, mutations: next };
                }) : base.map((c, i) => {
                  if (i !== idx) return c;
                  const prev = Array.isArray(c.mutations) ? c.mutations : [];
                  const next = prev.filter((m) => m !== mutId);
                  return { ...c, mutations: next };
                })
              };
              renderSideDetails();
            };
            tag.appendChild(letterSpan);
            activeRow.appendChild(tag);
          }
          if (!allSelected) {
            activeRow.appendChild(toggleMutBtn);
          }
        };
        const setDropdownOpen = (open) => {
          mutDropdown.style.display = open ? "grid" : "none";
          toggleMutBtn.style.background = open ? "rgba(32,42,56,0.8)" : "rgba(10,14,20,0.9)";
        };
        toggleMutBtn.onclick = () => {
          const isOpen = mutDropdown.style.display !== "none";
          setDropdownOpen(!isOpen);
        };
        for (const mutKey of mutationKeys) {
          const def = mutationCatalog[mutKey] || {};
          const storedId = mutKey === "Amberlit" ? "Ambershine" : mutKey;
          const isActive = Array.isArray(cfg.mutations) && cfg.mutations.includes(storedId);
          if (isActive) continue;
          const btn2 = document.createElement("button");
          btn2.type = "button";
          btn2.textContent = def.name || mutKey || "?";
          Object.assign(btn2.style, {
            padding: "6px 8px",
            borderRadius: "8px",
            border: isActive ? "1px solid #55d38a" : "1px solid #2c3643",
            background: isActive ? "rgba(85,211,138,0.22)" : "rgba(10,14,20,0.9)",
            color: "#e7eef7",
            fontSize: "11px",
            fontWeight: "700",
            cursor: "pointer",
            textAlign: "left"
          });
          const color = mutationColorMap[storedId];
          if (color) {
            btn2.style.color = color.startsWith("linear-gradient") ? "#e7eef7" : color;
            if (color.startsWith("linear-gradient")) {
              btn2.style.backgroundImage = color;
              btn2.style.backgroundClip = "text";
              btn2.style.webkitBackgroundClip = "text";
              btn2.style.color = "transparent";
              btn2.style.webkitTextFillColor = "transparent";
            }
          }
          btn2.onclick = () => {
            const base = ensureEditorStateForSpecies(selId).slots;
            editorPlantSlotsState = {
              ...editorPlantSlotsState,
              species: selId,
              slots: applyAll ? base.map((c) => {
                const prev = Array.isArray(c.mutations) ? c.mutations : [];
                const has = prev.includes(storedId);
                const next = has ? prev.filter((x) => x !== storedId) : [...prev, storedId];
                return { ...c, mutations: next };
              }) : base.map((c, i) => {
                if (i !== idx) return c;
                const prev = Array.isArray(c.mutations) ? c.mutations : [];
                const has = prev.includes(storedId);
                const next = has ? prev.filter((x) => x !== storedId) : [...prev, storedId];
                return { ...c, mutations: next };
              })
            };
            renderSideDetails();
          };
          mutDropdown.appendChild(btn2);
        }
        mutWrap.append(mutTitle, activeRow, mutDropdown);
        renderActiveTags();
        setDropdownOpen(false);
        slotBox.append(sizeRow, modeRow, slider, customRow, mutWrap);
        list.appendChild(slotBox);
      });
      slotsPanel.appendChild(list);
      content.appendChild(slotsPanel);
    }
    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = "Add to inventory";
    Object.assign(btn.style, {
      width: "100%",
      padding: "8px 10px",
      borderRadius: "8px",
      border: "1px solid #2b3441",
      background: "linear-gradient(180deg, rgba(42,154,255,0.12), rgba(30,91,181,0.35))",
      color: "#e7eef7",
      fontWeight: "700",
      cursor: "pointer"
    });
    btn.onclick = () => {
      console.log("[EditorService] addSelectedItemToInventory click", {
        mode: currentSideMode,
        id: selId
      });
      void addSelectedItemToInventory();
    };
    actionBar.appendChild(btn);
    sideRightWrap.append(content, actionBar);
  }
  function compareSlotKeys(a, b) {
    const ai = Number(a);
    const bi = Number(b);
    if (Number.isFinite(ai) && Number.isFinite(bi)) return ai - bi;
    return a.localeCompare(b);
  }
  function findPlayerSlot(slots, playerId2, opts = {}) {
    if (!slots || typeof slots !== "object") return null;
    const isMatch = (slot) => slot && String(slot.playerId || slot.id || "") === String(playerId2);
    if (Array.isArray(slots)) {
      const arr = slots;
      for (let i = 0; i < arr.length; i++) {
        if (isMatch(arr[i])) {
          return { isArray: true, matchSlot: arr[i], matchIndex: i, entries: null, slotsArray: arr };
        }
      }
      return null;
    }
    const entries = Object.entries(slots);
    if (opts.sortObject) entries.sort(([a], [b]) => compareSlotKeys(a, b));
    for (let i = 0; i < entries.length; i++) {
      const [, s] = entries[i];
      if (isMatch(s)) {
        return { isArray: false, matchSlot: s, matchIndex: i, entries, slotsArray: null };
      }
    }
    return null;
  }
  function rebuildUserSlots(meta, buildSlot) {
    if (meta.isArray) {
      const nextSlots = (meta.slotsArray || []).slice();
      nextSlots[meta.matchIndex] = buildSlot(meta.matchSlot);
      return nextSlots;
    }
    const nextEntries = (meta.entries || []).map(
      ([k, s], idx) => idx === meta.matchIndex ? [k, buildSlot(s)] : [k, s]
    );
    return Object.fromEntries(nextEntries);
  }
  function buildStateWithUserSlots(cur, userSlots) {
    return {
      ...cur || {},
      child: {
        ...cur?.child || {},
        data: {
          ...cur?.child?.data || {},
          userSlots
        }
      }
    };
  }
  async function withPatchedWrite(patch, op) {
    if (!patch) {
      await op();
      return;
    }
    const { atom, readKey, origRead, writeKey, origWrite } = patch;
    const savedRead = atom[readKey];
    const savedWrite = writeKey ? atom[writeKey] : void 0;
    try {
      atom[readKey] = origRead;
      if (writeKey && origWrite) atom[writeKey] = origWrite;
      await op();
    } finally {
      atom[readKey] = savedRead;
      if (writeKey) atom[writeKey] = savedWrite;
    }
  }
  async function setStateAtom(next) {
    console.log("[EditorService] setStateAtom attempt", {
      hasPatch: !!statePatch
    });
    await withPatchedWrite(statePatch, async () => {
      try {
        await Atoms.root.state.set(next);
        console.log("[EditorService] setStateAtom success");
      } catch (err) {
        console.log("[EditorService] setStateAtom failed", err);
        throw err;
      }
    });
  }
  async function addSelectedItemToInventory() {
    const selId = getSelectedId();
    if (!selId) return;
    if (currentSideMode === "decor") {
      console.log("[EditorService] addSelectedItemToInventory decor", selId);
      await addDecorToInventory(selId);
    } else {
      console.log("[EditorService] addSelectedItemToInventory plant", selId);
      await addPlantToInventory(selId);
    }
  }
  async function removeSelectedInventoryItem() {
    try {
      const pid = await getPlayerId();
      if (!pid) return false;
      const selectedIndex = await Atoms.inventory.myValidatedSelectedItemIndex.get();
      const inventoryVal = await Atoms.inventory.myInventory.get();
      const items = Array.isArray(inventoryVal?.items) ? inventoryVal.items.slice() : [];
      if (selectedIndex == null || typeof selectedIndex !== "number" || selectedIndex < 0 || selectedIndex >= items.length) {
        return false;
      }
      items.splice(selectedIndex, 1);
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const slots = cur?.child?.data?.userSlots;
      const slotMatch = findPlayerSlot(slots, pid);
      if (!slotMatch) return false;
      const slotData = slotMatch.matchSlot?.data || {};
      const slotInv = slotData.inventory || {};
      const favorited = Array.isArray(slotInv.favoritedItemIds) ? slotInv.favoritedItemIds.filter((id) => items.some((it) => it?.id === id)) : void 0;
      const nextUserSlots = rebuildUserSlots(slotMatch, (slot) => {
        const data = slot?.data || {};
        return {
          ...slot || {},
          data: {
            ...data,
            inventory: {
              ...slotInv || {},
              items,
              ...favorited ? { favoritedItemIds: favorited } : {}
            }
          }
        };
      });
      const nextState = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = nextState;
      stateOriginalValue = nextState;
      await setStateAtom(nextState);
      const newIdx = Math.max(0, Math.min(items.length - 1, selectedIndex));
      try {
        await Atoms.inventory.myValidatedSelectedItemIndex.set(newIdx);
      } catch {
      }
      return true;
    } catch (err) {
      console.log("[EditorService] removeSelectedInventoryItem failed", err);
      return false;
    }
  }
  async function addTileObjectToInventory(tileObject) {
    try {
      const pid = await getPlayerId();
      if (!pid || !tileObject) return false;
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const slots = cur?.child?.data?.userSlots;
      const slotMatch = findPlayerSlot(slots, pid);
      if (!slotMatch) return false;
      const slotData = slotMatch.matchSlot?.data || {};
      const inv = slotData.inventory;
      const items = Array.isArray(inv?.items) ? inv.items.slice() : [];
      if (tileObject.objectType === "plant") {
        const plantItem = {
          itemType: "Plant",
          species: tileObject.species,
          id: tileObject.id,
          slots: Array.isArray(tileObject.slots) ? JSON.parse(JSON.stringify(tileObject.slots)) : [],
          plantedAt: tileObject.plantedAt,
          maturedAt: tileObject.maturedAt
        };
        items.push(plantItem);
      } else if (tileObject.objectType === "decor") {
        items.push({
          itemType: "Decor",
          decorId: tileObject.decorId,
          quantity: 1,
          rotation: typeof tileObject.rotation === "number" ? tileObject.rotation : 0
        });
      } else {
        return false;
      }
      const slotInv = slotData.inventory || {};
      const nextUserSlots = rebuildUserSlots(slotMatch, (slot) => {
        const data = slot?.data || {};
        return {
          ...slot || {},
          data: {
            ...data,
            inventory: { ...slotInv || {}, items }
          }
        };
      });
      const nextState = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = nextState;
      stateOriginalValue = nextState;
      await setStateAtom(nextState);
      try {
        await Atoms.inventory.myValidatedSelectedItemIndex.set(items.length - 1);
      } catch {
      }
      return true;
    } catch (err) {
      console.log("[EditorService] addTileObjectToInventory failed", err);
      return false;
    }
  }
  async function addDecorToInventory(decorId) {
    try {
      console.log("[EditorService] addDecorToInventory", decorId);
      const pid = await getPlayerId();
      if (!pid) {
        console.log("[EditorService] addDecorToInventory: no playerId");
        return;
      }
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const slots = cur?.child?.data?.userSlots;
      if (!slots || typeof slots !== "object") {
        console.log("[EditorService] addDecorToInventory: no userSlots");
        return;
      }
      const slotMatch = findPlayerSlot(slots, pid);
      if (!slotMatch) {
        console.log("[EditorService] addDecorToInventory: player slot not found");
        return;
      }
      const slotData = slotMatch.matchSlot.data || {};
      const inv = slotData.inventory;
      const items = Array.isArray(inv?.items) ? inv.items.slice() : [];
      console.log("[EditorService] decor before add", { itemsLen: items.length });
      items.push({
        itemType: "Decor",
        decorId,
        quantity: 1
      });
      const nextUserSlots = rebuildUserSlots(slotMatch, (slot) => {
        const slotDataInner = slot?.data || {};
        const slotInv = slotDataInner.inventory;
        return {
          ...slot || {},
          data: {
            ...slotDataInner,
            inventory: { ...slotInv || {}, items }
          }
        };
      });
      const next = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = next;
      stateOriginalValue = next;
      try {
        await setStateAtom(next);
      } catch (err) {
        console.log("[EditorService] stateAtom set failed (decor)", err);
      }
      console.log("[EditorService] decor after add", { itemsLen: items.length });
      console.log("[EditorService] decor added", { decorId });
    } catch (err) {
      console.log("[EditorService] failed to add decor", err);
    }
  }
  async function addPlantToInventory(species) {
    try {
      console.log("[EditorService] addPlantToInventory", species);
      const pid = await getPlayerId();
      if (!pid) {
        console.log("[EditorService] addPlantToInventory: no playerId");
        return;
      }
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const slots = cur?.child?.data?.userSlots;
      if (!slots || typeof slots !== "object") {
        console.log("[EditorService] addPlantToInventory: no userSlots");
        return;
      }
      const slotMatch = findPlayerSlot(slots, pid);
      if (!slotMatch) {
        console.log("[EditorService] addPlantToInventory: player slot not found");
        return;
      }
      const slotData = slotMatch.matchSlot.data || {};
      const inv = slotData.inventory;
      const items = Array.isArray(inv?.items) ? inv.items.slice() : [];
      const entry = plantCatalog?.[species] ?? {};
      const plantDef = entry?.plant ?? {};
      const isMultipleHarvest = plantDef?.harvestType === "Multiple";
      console.log("[EditorService] plant before add", { itemsLen: items.length, isMultipleHarvest });
      const maxSlots = getMaxSlotsForSpecies(species);
      const slotsConfig = editorPlantSlotsState.species === species ? editorPlantSlotsState.slots.slice(0, maxSlots) : ensureEditorSlotsForSpecies(species).slice(0, maxSlots);
      const slotsArr = [];
      for (const cfg of slotsConfig) {
        if (!cfg.enabled) continue;
        const targetScale = resolveSlotTargetScale(species, cfg);
        const mutations = Array.isArray(cfg.mutations) ? cfg.mutations.slice() : [];
        slotsArr.push({
          species,
          startTime: 1760866288723,
          endTime: 1760867858782,
          targetScale,
          mutations
        });
      }
      const slotCount = slotsArr.length;
      const newItem = {
        id: typeof crypto !== "undefined" && typeof crypto.randomUUID === "function" ? crypto.randomUUID() : `plant-${Math.random().toString(16).slice(2)}`,
        itemType: "Plant",
        species,
        slots: slotsArr,
        plantedAt: 1760779438723,
        maturedAt: 1760865838723
      };
      if (!isMultipleHarvest) {
        newItem.name = entry?.crop?.name ?? plantDef?.name ?? species;
      }
      items.push(newItem);
      const nextUserSlots = rebuildUserSlots(slotMatch, (slot) => {
        const slotDataInner = slot?.data || {};
        const slotInv = slotDataInner.inventory;
        return {
          ...slot || {},
          data: {
            ...slotDataInner,
            inventory: { ...slotInv || {}, items }
          }
        };
      });
      const next = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = next;
      stateOriginalValue = next;
      try {
        await setStateAtom(next);
      } catch (err) {
        console.log("[EditorService] stateAtom set failed (plant)", err);
      }
      console.log("[EditorService] plant after add", { itemsLen: items.length + 1 });
      console.log("[EditorService] plant added", {
        species,
        isMultipleHarvest,
        slotCount
      });
    } catch (err) {
      console.log("[EditorService] failed to add plant", err);
    }
  }
  function notify(enabled) {
    listeners4.forEach((cb) => {
      try {
        cb(enabled);
      } catch {
      }
    });
  }
  function applyState(enabled, opts = {}) {
    const next = !!enabled;
    const changed = next !== currentEnabled;
    if (next && overlaysVisible) showOverlay();
    else hideOverlay();
    if (next && overlaysVisible) showSideOverlay();
    else hideSideOverlay();
    if (next && overlaysVisible) showCurrentItemOverlay();
    else hideCurrentItemOverlay();
    if (next) {
      void freezeStateAtom();
    } else {
      unfreezeStateAtom();
    }
    currentEnabled = next;
    if (opts.persist !== false) persist(next);
    if (changed && opts.emit !== false) notify(next);
  }
  var EditorService = {
    init() {
      installEditorKeybindsOnce();
      applyState(currentEnabled, { persist: false, emit: false });
    },
    isEnabled() {
      return currentEnabled;
    },
    setEnabled(enabled) {
      applyState(enabled, { persist: true, emit: true });
    },
    onChange(listener) {
      listeners4.add(listener);
      return () => listeners4.delete(listener);
    }
  };
  var EMPTY_GARDEN = { tileObjects: {}, boardwalkTileObjects: {} };
  function isGardenEmpty(val) {
    const tiles = val?.tileObjects;
    const boards = val?.boardwalkTileObjects;
    const isEmptyObj = (o) => o && typeof o === "object" && Object.keys(o).length === 0;
    return isEmptyObj(tiles) && isEmptyObj(boards);
  }
  function makeEmptyGarden() {
    return { ...EMPTY_GARDEN };
  }
  function sanitizeGarden(val) {
    const tileObjects = val && typeof val === "object" && typeof val.tileObjects === "object" ? val.tileObjects : {};
    const boardwalkTileObjects = val && typeof val === "object" && typeof val.boardwalkTileObjects === "object" ? val.boardwalkTileObjects : {};
    return {
      tileObjects: { ...tileObjects },
      boardwalkTileObjects: { ...boardwalkTileObjects }
    };
  }
  function readSavedGardens() {
    try {
      const parsed = readAriesPath(ARIES_SAVED_GARDENS_PATH);
      const arr = Array.isArray(parsed) ? parsed : [];
      return arr.map((g) => ({
        id: String(g?.id || ""),
        name: String(g?.name || "Untitled"),
        createdAt: Number(g?.createdAt) || Date.now(),
        garden: sanitizeGarden(g?.garden || {})
      })).filter((g) => !!g.id);
    } catch {
      return [];
    }
  }
  function writeSavedGardens(list) {
    try {
      writeAriesPath(ARIES_SAVED_GARDENS_PATH, list || []);
    } catch {
    }
  }
  async function getGardenForPlayer(playerId2) {
    try {
      if (!playerId2) return null;
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const slots = cur?.child?.data?.userSlots;
      const slotMatch = findPlayerSlot(slots, playerId2, { sortObject: true });
      if (!slotMatch || !slotMatch.matchSlot) return null;
      const g = slotMatch.matchSlot?.data?.garden;
      return sanitizeGarden(g || {});
    } catch {
      return null;
    }
  }
  async function setCurrentGarden(nextGarden) {
    try {
      const pid = await getPlayerId();
      if (!pid) return false;
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const slots = cur?.child?.data?.userSlots;
      const slotMatch = findPlayerSlot(slots, pid, { sortObject: true });
      if (!slotMatch || !slotMatch.matchSlot) return false;
      const updatedSlot = {
        ...slotMatch.matchSlot,
        data: {
          ...slotMatch.matchSlot?.data || {},
          garden: sanitizeGarden(nextGarden)
        }
      };
      const nextUserSlots = rebuildUserSlots(slotMatch, () => updatedSlot);
      const nextState = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = nextState;
      stateOriginalValue = nextState;
      await setStateAtom(nextState);
      return true;
    } catch (err) {
      console.log("[EditorService] setCurrentGarden failed", err);
      return false;
    }
  }
  async function applyFriendGardenPreview(garden2) {
    if (!garden2 || typeof garden2 !== "object") return false;
    try {
      await freezeStateAtom();
      const pid = await getPlayerId();
      if (!pid) return false;
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      if (!cur) return false;
      const slots = cur?.child?.data?.userSlots;
      const slotMatch = findPlayerSlot(slots, pid, { sortObject: true });
      if (!slotMatch || !slotMatch.matchSlot) return false;
      const updatedSlot = {
        ...slotMatch.matchSlot,
        data: {
          ...slotMatch.matchSlot?.data || {},
          garden: sanitizeGarden(garden2)
        }
      };
      const nextUserSlots = rebuildUserSlots(slotMatch, () => updatedSlot);
      const nextState = buildStateWithUserSlots(cur, nextUserSlots);
      await setStateAtom(nextState);
      stateFrozenValue = nextState;
      friendGardenPreviewActive = true;
      return true;
    } catch (error) {
      console.error("[EditorService] applyFriendGardenPreview failed", error);
      friendGardenPreviewActive = false;
      return false;
    }
  }
  async function clearFriendGardenPreview() {
    if (!friendGardenPreviewActive) return false;
    friendGardenPreviewActive = false;
    try {
      await unfreezeStateAtom();
      return true;
    } catch (error) {
      console.error("[EditorService] clearFriendGardenPreview failed", error);
      return false;
    }
  }
  function listSavedGardens() {
    return readSavedGardens();
  }
  async function saveCurrentGarden(name, playerId2) {
    const pid = playerId2 || await getPlayerId();
    if (!pid) return null;
    const garden2 = await getGardenForPlayer(pid);
    if (!garden2) return null;
    const now2 = Date.now();
    const all = readSavedGardens();
    const baseName = name?.trim() || "Untitled";
    const makeUniqueName = (base, existing) => {
      let idx = 1;
      let candidate = base;
      const set2 = new Set(existing);
      while (set2.has(candidate)) {
        candidate = `${base} (${idx})`;
        idx += 1;
      }
      return candidate;
    };
    const existingIdx = all.findIndex((g) => g.name === baseName);
    let finalName = baseName;
    let reuseId = null;
    if (existingIdx >= 0) {
      const canConfirm = typeof window !== "undefined" && typeof window.confirm === "function";
      const overwrite = canConfirm ? window.confirm(`A garden named "${baseName}" already exists. Overwrite it?`) : false;
      if (overwrite) {
        reuseId = all[existingIdx]?.id || null;
      } else {
        finalName = makeUniqueName(baseName, all.map((g) => g.name));
      }
    }
    const saved = {
      id: reuseId || `${now2}-${Math.random().toString(16).slice(2)}`,
      name: finalName,
      createdAt: now2,
      garden: garden2
    };
    let updated = [];
    if (reuseId) {
      updated = all.map((g) => g.id === reuseId ? saved : g);
    } else {
      all.unshift(saved);
      updated = all.slice(0, 50);
    }
    writeSavedGardens(updated);
    return saved;
  }
  async function loadSavedGarden(id) {
    if (!id) return false;
    const all = readSavedGardens();
    const found = all.find((g) => g.id === id);
    if (!found) return false;
    return setCurrentGarden(found.garden);
  }
  function deleteSavedGarden(id) {
    if (!id) return false;
    const all = readSavedGardens();
    const next = all.filter((g) => g.id !== id);
    if (next.length === all.length) return false;
    writeSavedGardens(next);
    return true;
  }
  function exportSavedGarden(id) {
    if (!id) return null;
    const all = readSavedGardens();
    const found = all.find((g) => g.id === id);
    if (!found) return null;
    return JSON.stringify(found.garden, null, 2);
  }
  async function importGarden(name, raw) {
    if (!raw) return null;
    try {
      const parsed = JSON.parse(raw);
      const garden2 = sanitizeGarden(parsed);
      const now2 = Date.now();
      const saved = {
        id: `${now2}-${Math.random().toString(16).slice(2)}`,
        name: name?.trim() || "Imported garden",
        createdAt: now2,
        garden: garden2
      };
      const all = readSavedGardens();
      all.unshift(saved);
      writeSavedGardens(all.slice(0, 50));
      return saved;
    } catch {
      return null;
    }
  }
  async function getPlayerId() {
    try {
      const id = await Atoms.player.playerId.get();
      return typeof id === "string" && id ? id : null;
    } catch {
      return null;
    }
  }
  function buildClearedState(state2, playerId2) {
    const slots = state2?.child?.data?.userSlots;
    const slotMatch = findPlayerSlot(slots, playerId2, { sortObject: true });
    if (!slotMatch || !slotMatch.matchSlot || typeof slotMatch.matchSlot !== "object") {
      return { next: state2, changed: false };
    }
    const garden2 = slotMatch.matchSlot?.data?.garden;
    const inventory = slotMatch.matchSlot?.data?.inventory;
    const hasInventory = inventory && typeof inventory === "object";
    const gardenChanged = !isGardenEmpty(garden2);
    const invChanged = hasInventory && (Array.isArray(inventory.items) ? inventory.items.length > 0 : true ? inventory?.inventory?.items?.length > 0 : false);
    if (!gardenChanged && !invChanged) return { next: state2, changed: false };
    const updatedSlot = {
      ...slotMatch.matchSlot,
      data: {
        ...slotMatch.matchSlot?.data || {},
        garden: makeEmptyGarden(),
        petSlots: buildEmptyPetSlots(slotMatch.matchSlot?.data?.petSlots),
        ...hasInventory ? { inventory: { ...inventory || {}, items: [], favoritedItemIds: [] } } : {}
      }
    };
    const nextUserSlots = rebuildUserSlots(slotMatch, () => updatedSlot);
    const nextState = buildStateWithUserSlots(state2, nextUserSlots);
    return { next: nextState, changed: true };
  }
  async function buildClearedStateSnapshot(playerId2) {
    try {
      const cur = await Atoms.root.state.get();
      const { next } = buildClearedState(cur, playerId2);
      return next;
    } catch {
      return null;
    }
  }
  async function logSelectedInventoryItemWithTile() {
    try {
      const store = await ensureStore().catch(() => null);
      let tileType;
      let localTileIndex;
      if (store) {
        const tileAtom = getAtomByLabel("myCurrentGardenTileAtom");
        if (!tileAtom) {
          console.log("[EditorService] logSelectedInventoryItemWithTile: no myCurrentGardenTileAtom");
        } else {
          const tileVal = store.get(tileAtom);
          tileType = tileVal?.tileType;
          localTileIndex = tileVal?.localTileIndex;
        }
      } else {
        console.log("[EditorService] logSelectedInventoryItemWithTile: no jotai store");
      }
      const selectedIndex = await Atoms.inventory.myValidatedSelectedItemIndex.get();
      const inventoryVal = await Atoms.inventory.myInventory.get();
      const rotation = await Atoms.inventory.mySelectedItemRotation.get();
      const items = Array.isArray(inventoryVal?.items) ? inventoryVal.items : [];
      if (selectedIndex == null || typeof selectedIndex !== "number" || selectedIndex < 0 || selectedIndex >= items.length) {
        console.log("[EditorService] logSelectedInventoryItemWithTile: invalid selected index", {
          selectedIndex,
          itemsLen: items.length
        });
        return;
      }
      const selectedItem = items[selectedIndex];
      console.log("[EditorService] selected item placement debug", {
        tileType,
        localTileIndex,
        selectedIndex,
        rotation,
        item: selectedItem
      });
    } catch (err) {
      console.log("[EditorService] logSelectedInventoryItemWithTile failed", err);
    }
  }
  async function placeSelectedItemInGardenAtCurrentTile() {
    try {
      const store = await ensureStore().catch(() => null);
      if (!store) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: no jotai store");
        return;
      }
      const tileAtom = getAtomByLabel("myCurrentGardenTileAtom");
      if (!tileAtom) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: no myCurrentGardenTileAtom");
        return;
      }
      const tileVal = store.get(tileAtom);
      if (!tileVal) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: tileVal is null");
        return;
      }
      const tileType = tileVal.tileType;
      const localTileIndex = tileVal.localTileIndex;
      const userSlotIdxRaw = tileVal.userSlotIdx;
      const userSlotIdx = typeof userSlotIdxRaw === "number" && Number.isFinite(userSlotIdxRaw) ? userSlotIdxRaw : 0;
      if (localTileIndex == null || !Number.isFinite(localTileIndex)) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: invalid localTileIndex", {
          localTileIndex
        });
        return;
      }
      const selectedIndex = await Atoms.inventory.myValidatedSelectedItemIndex.get();
      const inventoryVal = await Atoms.inventory.myInventory.get();
      const rotation = await Atoms.inventory.mySelectedItemRotation.get();
      const items = Array.isArray(inventoryVal?.items) ? inventoryVal.items : [];
      if (selectedIndex == null || typeof selectedIndex !== "number" || selectedIndex < 0 || selectedIndex >= items.length) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: invalid selected index", {
          selectedIndex,
          itemsLen: items.length
        });
        return;
      }
      const selectedItem = items[selectedIndex];
      if (selectedItem?.itemType !== "Plant" && selectedItem?.itemType !== "Decor") {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: unsupported itemType", {
          itemType: selectedItem?.itemType
        });
        return;
      }
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const userSlots = cur?.child?.data?.userSlots;
      if (!userSlots || typeof userSlots !== "object") {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: no userSlots in state");
        return;
      }
      const isArray = Array.isArray(userSlots);
      let matchSlot;
      if (isArray) {
        matchSlot = userSlots[userSlotIdx];
      } else {
        const key2 = String(userSlotIdx);
        matchSlot = userSlots[key2];
      }
      if (!matchSlot) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: slot not found", {
          userSlotIdx,
          isArray
        });
        return;
      }
      const slotData = matchSlot.data || {};
      const prevGarden = slotData.garden && typeof slotData.garden === "object" ? slotData.garden : makeEmptyGarden();
      const garden2 = {
        tileObjects: { ...prevGarden.tileObjects || {} },
        boardwalkTileObjects: { ...prevGarden.boardwalkTileObjects || {} }
      };
      const targetKey = tileType === "Dirt" ? "tileObjects" : "boardwalkTileObjects";
      const tileKey = String(localTileIndex);
      let tileObject;
      if (selectedItem.itemType === "Plant") {
        tileObject = {
          objectType: "plant",
          species: selectedItem.species,
          slots: Array.isArray(selectedItem.slots) ? selectedItem.slots : [],
          plantedAt: selectedItem.plantedAt,
          maturedAt: selectedItem.maturedAt
        };
      } else if (selectedItem.itemType === "Decor") {
        tileObject = {
          objectType: "decor",
          decorId: selectedItem.decorId,
          // rotation depuis latom, fallback sur ce quaurait dj litem (au cas o)
          rotation: typeof rotation === "number" ? rotation : selectedItem.rotation ?? 0
        };
      }
      if (!tileObject) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: failed to build tileObject");
        return;
      }
      const nextTargetMap = {
        ...garden2[targetKey],
        [tileKey]: tileObject
      };
      const nextGarden = {
        tileObjects: targetKey === "tileObjects" ? nextTargetMap : garden2.tileObjects,
        boardwalkTileObjects: targetKey === "boardwalkTileObjects" ? nextTargetMap : garden2.boardwalkTileObjects
      };
      const updatedSlot = {
        ...matchSlot,
        data: {
          ...slotData,
          garden: nextGarden
        }
      };
      const nextUserSlots = isArray ? (() => {
        const nextSlots = userSlots.slice();
        nextSlots[userSlotIdx] = updatedSlot;
        return nextSlots;
      })() : {
        ...userSlots,
        [String(userSlotIdx)]: updatedSlot
      };
      const nextState = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = nextState;
      stateOriginalValue = nextState;
      try {
        await setStateAtom(nextState);
      } catch (err) {
        console.log("[EditorService] stateAtom set failed (placeSelectedItemInGardenAtCurrentTile)", err);
      }
      console.log("[EditorService] placed item in garden", {
        tileType,
        localTileIndex,
        userSlotIdx,
        selectedIndex,
        itemType: selectedItem.itemType,
        species: selectedItem.species,
        decorId: selectedItem.decorId,
        rotation
      });
    } catch (err) {
      console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile failed", err);
    }
  }
  async function removeGardenObjectAtCurrentTile() {
    try {
      const store = await ensureStore().catch(() => null);
      if (!store) {
        console.log("[EditorService] removeItemFromGardenAtCurrentTile: no jotai store");
        return false;
      }
      const tileAtom = getAtomByLabel("myCurrentGardenTileAtom");
      if (!tileAtom) {
        console.log("[EditorService] removeItemFromGardenAtCurrentTile: no myCurrentGardenTileAtom");
        return false;
      }
      const tileVal = store.get(tileAtom);
      if (!tileVal) {
        console.log("[EditorService] removeItemFromGardenAtCurrentTile: tileVal is null");
        return false;
      }
      const tileType = tileVal.tileType;
      const localTileIndex = tileVal.localTileIndex;
      const userSlotIdxRaw = tileVal.userSlotIdx;
      const userSlotIdx = typeof userSlotIdxRaw === "number" && Number.isFinite(userSlotIdxRaw) ? userSlotIdxRaw : 0;
      if (localTileIndex == null || !Number.isFinite(localTileIndex)) {
        console.log("[EditorService] removeItemFromGardenAtCurrentTile: invalid localTileIndex", {
          localTileIndex
        });
        return false;
      }
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const userSlots = cur?.child?.data?.userSlots;
      if (!userSlots || typeof userSlots !== "object") {
        console.log("[EditorService] removeItemFromGardenAtCurrentTile: no userSlots in state");
        return false;
      }
      const isArray = Array.isArray(userSlots);
      let matchSlot;
      if (isArray) {
        matchSlot = userSlots[userSlotIdx];
      } else {
        const key2 = String(userSlotIdx);
        matchSlot = userSlots[key2];
      }
      if (!matchSlot) {
        console.log("[EditorService] removeItemFromGardenAtCurrentTile: slot not found", {
          userSlotIdx,
          isArray
        });
        return false;
      }
      const slotData = matchSlot.data || {};
      const prevGarden = slotData.garden && typeof slotData.garden === "object" ? slotData.garden : makeEmptyGarden();
      const garden2 = {
        tileObjects: { ...prevGarden.tileObjects || {} },
        boardwalkTileObjects: { ...prevGarden.boardwalkTileObjects || {} }
      };
      const targetKey = tileType === "Dirt" ? "tileObjects" : "boardwalkTileObjects";
      const tileKey = String(localTileIndex);
      const currentTargetMap = garden2[targetKey] || {};
      const nextTargetMap = { ...currentTargetMap };
      delete nextTargetMap[tileKey];
      const nextGarden = {
        tileObjects: targetKey === "tileObjects" ? nextTargetMap : garden2.tileObjects,
        boardwalkTileObjects: targetKey === "boardwalkTileObjects" ? nextTargetMap : garden2.boardwalkTileObjects
      };
      const updatedSlot = {
        ...matchSlot,
        data: {
          ...slotData,
          garden: nextGarden
        }
      };
      const nextUserSlots = isArray ? (() => {
        const nextSlots = userSlots.slice();
        nextSlots[userSlotIdx] = updatedSlot;
        return nextSlots;
      })() : {
        ...userSlots,
        [String(userSlotIdx)]: updatedSlot
      };
      const nextState = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = nextState;
      stateOriginalValue = nextState;
      try {
        await setStateAtom(nextState);
      } catch (err) {
        console.log("[EditorService] stateAtom set failed (removeItemFromGardenAtCurrentTile)", err);
      }
      console.log("[EditorService] removed item from garden", {
        tileType,
        localTileIndex,
        userSlotIdx
      });
      return true;
    } catch (err) {
      console.log("[EditorService] removeItemFromGardenAtCurrentTile failed", err);
      return false;
    }
  }
  async function removeItemFromGardenAtCurrentTile() {
    void removeGardenObjectAtCurrentTile();
  }
  async function removeDecorFromGardenAtCurrentTile() {
    void removeGardenObjectAtCurrentTile();
  }
  async function updateGardenObjectAtCurrentTile(updater) {
    try {
      const store = await ensureStore().catch(() => null);
      if (!store) return false;
      const tileAtom = getAtomByLabel("myCurrentGardenTileAtom");
      if (!tileAtom) return false;
      const tileVal = store.get(tileAtom);
      if (!tileVal) return false;
      const tileType = tileVal.tileType;
      const localTileIndex = tileVal.localTileIndex;
      const userSlotIdxRaw = tileVal.userSlotIdx;
      const userSlotIdx = typeof userSlotIdxRaw === "number" && Number.isFinite(userSlotIdxRaw) ? userSlotIdxRaw : 0;
      if (localTileIndex == null || !Number.isFinite(localTileIndex)) return false;
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const userSlots = cur?.child?.data?.userSlots;
      if (!userSlots || typeof userSlots !== "object") return false;
      const isArray = Array.isArray(userSlots);
      let matchSlot;
      if (isArray) {
        matchSlot = userSlots[userSlotIdx];
      } else {
        const key2 = String(userSlotIdx);
        matchSlot = userSlots[key2];
      }
      if (!matchSlot) return false;
      const slotData = matchSlot.data || {};
      const prevGarden = slotData.garden && typeof slotData.garden === "object" ? slotData.garden : makeEmptyGarden();
      const garden2 = {
        tileObjects: { ...prevGarden.tileObjects || {} },
        boardwalkTileObjects: { ...prevGarden.boardwalkTileObjects || {} }
      };
      const targetKey = tileType === "Dirt" ? "tileObjects" : "boardwalkTileObjects";
      const tileKey = String(localTileIndex);
      const currentTargetMap = garden2[targetKey] || {};
      const currentObj = currentTargetMap[tileKey];
      if (!currentObj) return false;
      const nextObj = updater(currentObj);
      const nextTargetMap = { ...currentTargetMap, [tileKey]: nextObj };
      const nextGarden = {
        tileObjects: targetKey === "tileObjects" ? nextTargetMap : garden2.tileObjects,
        boardwalkTileObjects: targetKey === "boardwalkTileObjects" ? nextTargetMap : garden2.boardwalkTileObjects
      };
      const updatedSlot = {
        ...matchSlot,
        data: {
          ...slotData,
          garden: nextGarden
        }
      };
      const nextUserSlots = isArray ? (() => {
        const nextSlots = userSlots.slice();
        nextSlots[userSlotIdx] = updatedSlot;
        return nextSlots;
      })() : {
        ...userSlots,
        [String(userSlotIdx)]: updatedSlot
      };
      const nextState = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = nextState;
      stateOriginalValue = nextState;
      await setStateAtom(nextState);
      return true;
    } catch {
      return false;
    }
  }
  function clampSizePercent(sizePercent) {
    const pctRaw = Number.isFinite(sizePercent) ? sizePercent : 100;
    return Math.max(50, Math.min(100, Math.round(pctRaw)));
  }
  function getScaleBoundsForSpecies(species) {
    if (!species) return { minScale: 1, maxScale: 1 };
    const entry = plantCatalog[species];
    const maxScaleRaw = Number(entry?.crop?.maxScale);
    const maxScale = Number.isFinite(maxScaleRaw) && maxScaleRaw > 1 ? maxScaleRaw : 1;
    return { minScale: 1, maxScale };
  }
  function clampCustomScale(species, scale) {
    const { minScale, maxScale } = getScaleBoundsForSpecies(species);
    if (!Number.isFinite(scale)) return minScale;
    const upper = Math.max(minScale, maxScale);
    return Math.max(minScale, Math.min(upper, scale));
  }
  function normalizeCustomScale(species, scale) {
    if (!Number.isFinite(scale)) return 1;
    return scale;
  }
  function computeTargetScaleFromPercent(species, sizePercent) {
    const pct = clampSizePercent(sizePercent);
    if (!species) return 1;
    const { minScale, maxScale } = getScaleBoundsForSpecies(species);
    if (!maxScale || maxScale <= minScale) return minScale;
    const t = (pct - 50) / 50;
    return minScale + t * (maxScale - minScale);
  }
  function computePercentFromScale(species, targetScale) {
    const { minScale, maxScale } = getScaleBoundsForSpecies(species);
    if (!maxScale || maxScale <= minScale) return 100;
    const clamped = clampCustomScale(species, targetScale);
    const pct = 50 + (clamped - minScale) / (maxScale - minScale) * 50;
    return clampSizePercent(pct);
  }
  function resolveSlotTargetScale(species, cfg) {
    if (cfg.sizeMode === "custom") {
      return normalizeCustomScale(species, cfg.customScale);
    }
    return computeTargetScaleFromPercent(species, cfg.sizePercent);
  }
  var editorPlantSlotsState = {
    species: null,
    slots: [],
    applyAll: false
  };
  function getMaxSlotsForSpecies(species) {
    const entry = plantCatalog[species];
    const plantDef = entry?.plant ?? {};
    const isMultipleHarvest = plantDef?.harvestType === "Multiple";
    const slotOffsets = Array.isArray(plantDef.slotOffsets) ? plantDef.slotOffsets : [];
    if (isMultipleHarvest && slotOffsets.length > 0) return slotOffsets.length;
    return 1;
  }
  function ensureEditorSlotsForSpecies(species) {
    const maxSlots = getMaxSlotsForSpecies(species);
    if (editorPlantSlotsState.species !== species) {
      const defaultScale = computeTargetScaleFromPercent(species, 100);
      editorPlantSlotsState = {
        species,
        slots: Array.from({ length: maxSlots }, () => ({
          enabled: true,
          sizePercent: 100,
          customScale: defaultScale,
          sizeMode: "percent",
          mutations: []
        })),
        applyAll: false
      };
      return editorPlantSlotsState.slots;
    }
    let slots = editorPlantSlotsState.slots.slice(0, maxSlots);
    if (!slots.length) {
      const defaultScale = computeTargetScaleFromPercent(species, 100);
      slots = [
        {
          enabled: true,
          sizePercent: 100,
          customScale: defaultScale,
          sizeMode: "percent",
          mutations: []
        }
      ];
    }
    slots = slots.map((slot) => {
      const pct = clampSizePercent(slot.sizePercent);
      const mode = slot.sizeMode === "custom" ? "custom" : "percent";
      const fallbackScale = computeTargetScaleFromPercent(species, pct);
      const customScale = normalizeCustomScale(
        species,
        Number.isFinite(slot.customScale) ? slot.customScale : fallbackScale
      );
      const sizePercent = mode === "custom" ? computePercentFromScale(species, customScale) : pct;
      return {
        enabled: slot.enabled !== false,
        sizePercent,
        customScale,
        sizeMode: mode,
        mutations: Array.isArray(slot.mutations) ? slot.mutations : []
      };
    });
    editorPlantSlotsState = { ...editorPlantSlotsState, slots, applyAll: !!editorPlantSlotsState.applyAll };
    return slots;
  }
  function ensureEditorStateForSpecies(species) {
    ensureEditorSlotsForSpecies(species);
    if (editorPlantSlotsState.applyAll == null) {
      editorPlantSlotsState.applyAll = false;
    }
    return editorPlantSlotsState;
  }
  function findReadKey(atom) {
    if (atom && typeof atom.read === "function") return "read";
    for (const k of Object.keys(atom || {})) {
      const v = atom[k];
      if (typeof v === "function" && k !== "write" && k !== "onMount" && k !== "toString") {
        const ar = v.length;
        if (ar === 1 || ar === 2) return k;
      }
    }
    throw new Error("stateAtom read() not found");
  }
  function findWriteKey(atom) {
    if (atom && typeof atom.write === "function") return "write";
    for (const k of Object.keys(atom || {})) {
      const v = atom[k];
      if (typeof v === "function" && k !== "read" && k !== "onMount" && k !== "toString") {
        const ar = v.length;
        if (ar >= 2) return k;
      }
    }
    return null;
  }
  async function freezeStateAtom() {
    await ensureStore().catch(() => {
    });
    const pid = await getPlayerId();
    if (!pid) return;
    const atom = getAtomByLabel("stateAtom");
    if (!atom) return;
    try {
      stateOriginalValue = await Atoms.root.state.get();
    } catch {
      stateOriginalValue = null;
    }
    const frozen = await buildClearedStateSnapshot(pid);
    if (!frozen) return;
    try {
      await Atoms.root.state.set(frozen);
    } catch {
    }
    stateFrozenValue = frozen;
    if (statePatch && statePatch.atom === atom) return;
    let readKey;
    try {
      readKey = findReadKey(atom);
    } catch {
      return;
    }
    const origRead = atom[readKey];
    const writeKey = findWriteKey(atom) || void 0;
    const origWrite = writeKey ? atom[writeKey] : void 0;
    atom[readKey] = () => stateFrozenValue;
    if (writeKey) {
      atom[writeKey] = () => stateFrozenValue;
    }
    statePatch = { atom, readKey, origRead, writeKey, origWrite };
  }
  function unfreezeStateAtom() {
    if (statePatch) {
      try {
        statePatch.atom[statePatch.readKey] = statePatch.origRead;
        if (statePatch.writeKey && statePatch.origWrite) {
          statePatch.atom[statePatch.writeKey] = statePatch.origWrite;
        }
      } catch {
      }
    }
    statePatch = null;
    stateFrozenValue = null;
    if (stateOriginalValue != null) {
      try {
        void Atoms.root.state.set(stateOriginalValue);
      } catch {
      }
    }
    stateOriginalValue = null;
  }
  function buildEmptyPetSlots(prev) {
    if (Array.isArray(prev)) return [];
    if (prev && typeof prev === "object") return {};
    return [];
  }
  shareGlobal("qwsLogSelectedInventoryItemWithTile", () => {
    void logSelectedInventoryItemWithTile();
  });
  shareGlobal("qwsPlaceSelectedItemInGardenAtCurrentTile", () => {
    void placeSelectedItemInGardenAtCurrentTile();
  });
  shareGlobal("qwsRemoveItemFromGardenAtCurrentTile", () => {
    void removeItemFromGardenAtCurrentTile();
  });
  shareGlobal("qwsRemoveDecorFromGardenAtCurrentTile", () => {
    void removeDecorFromGardenAtCurrentTile();
  });
  shareGlobal("qwsEditorListSavedGardens", () => {
    return listSavedGardens();
  });
  shareGlobal("qwsEditorSaveGarden", async (name) => {
    return await saveCurrentGarden(name || "Untitled");
  });
  shareGlobal("qwsEditorClearGarden", async () => {
    const empty = makeEmptyGarden();
    return await setCurrentGarden(empty);
  });
  shareGlobal("qwsEditorLoadGarden", async (id) => {
    return await loadSavedGarden(id);
  });
  shareGlobal("qwsEditorSaveGardenForPlayer", async (playerId2, name) => {
    return await saveCurrentGarden(name || "Untitled", playerId2);
  });
  shareGlobal("qwsEditorDeleteGarden", (id) => {
    return deleteSavedGarden(id);
  });
  shareGlobal("qwsEditorExportGarden", (id) => {
    return exportSavedGarden(id);
  });
  shareGlobal("qwsEditorImportGarden", async (name, raw) => {
    return await importGarden(name, raw);
  });
  shareGlobal("qwsEditorPreviewFriendGarden", async (garden2) => {
    return await applyFriendGardenPreview(garden2);
  });
  shareGlobal("qwsEditorClearFriendGardenPreview", async () => {
    return await clearFriendGardenPreview();
  });
  function installEditorKeybindsOnce() {
    if (editorKeybindsInstalled || typeof window === "undefined") return;
    editorKeybindsInstalled = true;
    window.addEventListener(
      "keydown",
      (ev) => {
        if (shouldIgnoreKeydown(ev)) return;
        if (eventMatchesKeybind("editor.toggle-overlays", ev)) {
          ev.preventDefault();
          ev.stopPropagation();
          if (!currentEnabled) return;
          overlaysVisible = !overlaysVisible;
          if (overlaysVisible) {
            showOverlay();
            showSideOverlay();
            showCurrentItemOverlay();
          } else {
            hideOverlay();
            hideSideOverlay();
            hideCurrentItemOverlay();
          }
          return;
        }
        if (!currentEnabled) return;
        if (eventMatchesKeybind("editor.place-remove", ev)) {
          ev.preventDefault();
          ev.stopPropagation();
          const alreadyHeld = editorActionHeld;
          editorActionHeld = true;
          void handleEditorPlaceRemove(ev, alreadyHeld);
          return;
        }
        if (eventMatchesKeybind("editor.delete-inventory", ev)) {
          ev.preventDefault();
          ev.stopPropagation();
          void removeSelectedInventoryItem();
        }
      },
      true
    );
    window.addEventListener(
      "keyup",
      (ev) => {
        const isSyntheticRF = ev?.__inGameHotkeysRapidSynthetic__ === true;
        if (isSyntheticRF) return;
        if (!currentEnabled) return;
        if (eventMatchesKeybind("editor.place-remove", ev)) {
          editorActionHeld = false;
          lastEditorPressStartTs = 0;
          lastEditorPlaceRemoveTs = 0;
          lastEditorFirstFired = false;
          lastEditorTileKey = null;
          lastEditorTileType = void 0;
          lastEditorFirstActionTs = 0;
        }
      },
      true
    );
  }
  async function hasSelectedInventoryItem() {
    try {
      const inv = await Atoms.inventory.myInventory.get();
      const idx = await Atoms.inventory.myValidatedSelectedItemIndex.get();
      const items = Array.isArray(inv?.items) ? inv.items : [];
      return typeof idx === "number" && !!items[idx];
    } catch {
      return false;
    }
  }
  async function handleEditorPlaceRemove(ev, isHeld = false) {
    const now2 = typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now();
    if (!isHeld || lastEditorPressStartTs === 0) {
      lastEditorPressStartTs = now2;
      lastEditorPlaceRemoveTs = 0;
      lastEditorFirstFired = false;
      lastEditorTileKey = null;
      lastEditorTileType = void 0;
      lastEditorFirstActionTs = 0;
    }
    const { tileObject, tileKey, tileType } = await readCurrentTileContext();
    const hasSelection = await hasSelectedInventoryItem();
    const wantsRemove = !!tileObject;
    const wantsPlace = !tileObject && hasSelection;
    if (!wantsRemove && !wantsPlace) return;
    const tileKeyStr = `${tileType ?? "?"}|${tileKey ?? "none"}`;
    const sameTile = tileKeyStr === `${lastEditorTileType ?? "?"}|${lastEditorTileKey ?? "none"}`;
    if (!sameTile) {
      lastEditorTileKey = tileKey ?? null;
      lastEditorTileType = tileType;
      lastEditorFirstFired = false;
      lastEditorPlaceRemoveTs = 0;
      lastEditorPressStartTs = now2;
      lastEditorFirstActionTs = 0;
    }
    const elapsedSincePress = now2 - lastEditorPressStartTs;
    if (!lastEditorFirstFired) {
      lastEditorFirstFired = true;
      lastEditorPlaceRemoveTs = now2;
      lastEditorFirstActionTs = now2;
    } else {
      const sinceFirstAction = lastEditorFirstActionTs > 0 ? now2 - lastEditorFirstActionTs : elapsedSincePress;
      const gateMs = sinceFirstAction < EDITOR_PLACE_REMOVE_FIRST_DELAY_MS ? EDITOR_PLACE_REMOVE_FIRST_DELAY_MS : EDITOR_PLACE_REMOVE_REPEAT_MS;
      if (now2 - lastEditorPlaceRemoveTs < gateMs) {
        return;
      }
      lastEditorPlaceRemoveTs = now2;
    }
    if (wantsRemove) {
      if (tileObject?.objectType === "plant") {
        await removeItemFromGardenAtCurrentTile();
        void triggerEditorAnimation("dig");
        return;
      }
      if (tileObject?.objectType === "decor") {
        await removeDecorFromGardenAtCurrentTile();
        void triggerEditorAnimation("dig");
        return;
      }
    }
    if (wantsPlace) {
      await placeSelectedItemInGardenAtCurrentTile();
      void triggerEditorAnimation("dropObject");
    }
  }

  // src/ui/menus/editor.ts
  function renderEditorMenu(container) {
    const ui = new Menu({ id: "editor", compact: true });
    ui.mount(container);
    const view = ui.root.querySelector(".qmm-views");
    view.innerHTML = "";
    view.style.display = "grid";
    view.style.gap = "8px";
    view.style.justifyItems = "center";
    const card = ui.card("Editor mode", { tone: "muted", align: "center" });
    card.header.style.display = "none";
    card.root.style.maxWidth = "420px";
    card.body.style.display = "grid";
    card.body.style.gap = "10px";
    const row = ui.flexRow({ align: "center", justify: "between", fullWidth: true });
    const label2 = ui.label("Editor mode");
    label2.style.margin = "0";
    const toggle = ui.switch(EditorService.isEnabled());
    toggle.setAttribute("aria-label", "Toggle editor mode");
    toggle.addEventListener("change", () => {
      const on = !!toggle.checked;
      EditorService.setEnabled(on);
    });
    row.append(label2, toggle);
    card.body.append(row);
    const hint = document.createElement("div");
    hint.textContent = "Sandbox garden editor with every plants and decors unlocked. Build, experiment, and customize without limits";
    hint.style.fontSize = "12px";
    hint.style.opacity = "0.7";
    hint.style.textAlign = "left";
    hint.style.lineHeight = "1.4";
    hint.style.width = "100%";
    card.body.append(hint);
    const hintPlaceRemove = document.createElement("div");
    hintPlaceRemove.textContent = "Place/Remove uses your action key. Toggle overlays with U.";
    hintPlaceRemove.style.fontSize = "11px";
    hintPlaceRemove.style.opacity = "0.65";
    hintPlaceRemove.style.textAlign = "center";
    hintPlaceRemove.style.lineHeight = "1.3";
    hintPlaceRemove.style.width = "100%";
    card.body.append(hintPlaceRemove);
    const hintDelete = document.createElement("div");
    hintDelete.textContent = "Remove selected item from inventory with Delete.";
    hintDelete.style.fontSize = "11px";
    hintDelete.style.opacity = "0.65";
    hintDelete.style.textAlign = "center";
    hintDelete.style.lineHeight = "1.3";
    hintDelete.style.width = "100%";
    card.body.append(hintDelete);
    const hintKeybinds = document.createElement("div");
    hintKeybinds.textContent = "Keys are editable in Keybinds > Editor.";
    hintKeybinds.style.fontSize = "11px";
    hintKeybinds.style.opacity = "0.65";
    hintKeybinds.style.textAlign = "center";
    hintKeybinds.style.lineHeight = "1.3";
    hintKeybinds.style.width = "100%";
    card.body.append(hintKeybinds);
    const cleanup2 = EditorService.onChange((enabled) => {
      toggle.checked = enabled;
      renderSavedList();
    });
    view.__cleanup__ = () => {
      try {
        cleanup2();
      } catch {
      }
    };
    const sectionCard = (title, content) => {
      const card2 = ui.card(title, { tone: "muted", align: "center" });
      card2.root.style.maxWidth = "520px";
      card2.body.style.display = "grid";
      card2.body.style.gap = "8px";
      card2.body.append(content);
      return card2;
    };
    const status = document.createElement("div");
    status.style.fontSize = "12px";
    status.style.opacity = "0.7";
    status.style.minHeight = "18px";
    const currentWrap = document.createElement("div");
    currentWrap.style.display = "grid";
    currentWrap.style.gap = "6px";
    const nameInput = ui.inputText("Garden name", "");
    nameInput.placeholder = "Garden name";
    nameInput.style.width = "100%";
    const actionsRow = document.createElement("div");
    actionsRow.style.display = "grid";
    actionsRow.style.gridTemplateColumns = "1fr 1fr";
    actionsRow.style.gap = "8px";
    const saveBtn = ui.btn("Save current garden", {
      variant: "primary",
      fullWidth: true,
      onClick: async () => {
        const fn = window.qwsEditorSaveGarden;
        if (typeof fn !== "function") return;
        const saved = await fn(nameInput.value);
        if (!saved) {
          status.textContent = "Save failed (no garden state found).";
          return;
        }
        status.textContent = `Saved "${saved.name}".`;
        renderSavedList();
      }
    });
    const clearBtn = ui.btn("Clear garden", {
      variant: "secondary",
      fullWidth: true,
      onClick: async () => {
        const fn = window.qwsEditorClearGarden;
        if (typeof fn !== "function") return;
        const ok = await fn();
        status.textContent = ok ? "Garden cleared." : "Clear failed.";
      }
    });
    actionsRow.append(saveBtn, clearBtn);
    currentWrap.append(nameInput, actionsRow);
    const importWrap = document.createElement("div");
    importWrap.style.display = "grid";
    importWrap.style.gap = "6px";
    const importArea = document.createElement("textarea");
    importArea.placeholder = "Paste garden JSON here...";
    importArea.style.width = "100%";
    importArea.style.minHeight = "80px";
    importArea.style.borderRadius = "8px";
    importArea.style.border = "1px solid #2b3441";
    importArea.style.background = "rgba(16,21,28,0.9)";
    importArea.style.color = "#e7eef7";
    importArea.style.padding = "8px";
    importArea.style.fontSize = "12px";
    importArea.style.fontFamily = "monospace";
    const importBtn = ui.btn("Import to saved gardens", {
      variant: "secondary",
      fullWidth: true,
      onClick: async () => {
        const fn = window.qwsEditorImportGarden;
        if (typeof fn !== "function") return;
        const saved = await fn(nameInput.value || "Imported garden", importArea.value);
        if (!saved) {
          status.textContent = "Import failed (invalid JSON).";
          return;
        }
        status.textContent = `Imported "${saved.name}".`;
        renderSavedList();
      }
    });
    importBtn.style.width = "100%";
    importWrap.append(importArea, importBtn);
    const listWrap = document.createElement("div");
    listWrap.style.display = "grid";
    listWrap.style.gap = "8px";
    const renderSavedList = () => {
      const listFn = window.qwsEditorListSavedGardens;
      const loadFn = window.qwsEditorLoadGarden;
      const delFn = window.qwsEditorDeleteGarden;
      const expFn = window.qwsEditorExportGarden;
      listWrap.innerHTML = "";
      const items = typeof listFn === "function" ? listFn() : [];
      if (!items || !items.length) {
        const empty = document.createElement("div");
        empty.textContent = "No saved gardens yet.";
        empty.style.opacity = "0.7";
        empty.style.fontSize = "12px";
        listWrap.appendChild(empty);
        return;
      }
      const editorOn = EditorService.isEnabled();
      for (const g of items) {
        const row2 = document.createElement("div");
        row2.style.display = "grid";
        row2.style.gridTemplateColumns = "1fr auto auto auto";
        row2.style.gap = "6px";
        row2.style.alignItems = "center";
        row2.style.padding = "8px";
        row2.style.borderRadius = "8px";
        row2.style.border = "1px solid #2b3441";
        row2.style.background = "rgba(16,21,28,0.9)";
        const name = document.createElement("div");
        name.textContent = g.name || "Untitled";
        name.style.fontWeight = "700";
        name.style.fontSize = "13px";
        name.style.overflow = "hidden";
        name.style.textOverflow = "ellipsis";
        name.style.whiteSpace = "nowrap";
        const load = ui.btn("Load", {
          size: "sm",
          onClick: async () => {
            if (!EditorService.isEnabled()) {
              status.textContent = "Enable editor mode to load a garden.";
              return;
            }
            if (typeof loadFn !== "function") return;
            const ok = await loadFn(g.id);
            if (ok) {
              status.textContent = `Loaded "${g.name}".`;
            } else {
              status.textContent = "Load failed.";
            }
          }
        });
        load.disabled = !editorOn;
        if (!editorOn) load.title = "Enable editor mode to load";
        const exp = ui.btn("Export", {
          size: "sm",
          variant: "secondary",
          onClick: async () => {
            if (typeof expFn !== "function") return;
            const json = expFn(g.id);
            if (!json) {
              status.textContent = "Export failed.";
              return;
            }
            try {
              await navigator.clipboard.writeText(json);
              status.textContent = `Exported "${g.name}" to clipboard.`;
              await toastSimple("Editor", `Copied "${g.name}" to clipboard`, "success");
            } catch {
              status.textContent = `Exported "${g.name}". Copy manually.`;
              window.prompt("Garden JSON", json);
            }
          }
        });
        const del = ui.btn("Delete", {
          size: "sm",
          variant: "danger",
          onClick: () => {
            if (typeof delFn !== "function") return;
            const ok = delFn(g.id);
            if (ok) {
              status.textContent = `Deleted "${g.name}".`;
              renderSavedList();
            }
          }
        });
        row2.append(name, load, exp, del);
        listWrap.appendChild(row2);
      }
    };
    renderSavedList();
    const currentCard = sectionCard("\u{1F331} Current garden", currentWrap);
    const importCard = sectionCard("\u{1F4E5} Import", importWrap);
    const savedCard = sectionCard("\u{1F4BE} Saved gardens", listWrap);
    savedCard.body.append(status);
    view.append(card.root, currentCard.root, importCard.root, savedCard.root);
  }

  // src/services/players.ts
  function findPlayersDeep(state2) {
    if (!state2 || typeof state2 !== "object") return [];
    const out = [];
    const seen = /* @__PURE__ */ new Set();
    const stack = [state2];
    while (stack.length) {
      const cur = stack.pop();
      if (!cur || typeof cur !== "object" || seen.has(cur)) continue;
      seen.add(cur);
      for (const k of Object.keys(cur)) {
        const v = cur[k];
        if (Array.isArray(v) && v.length && v.every((x) => x && typeof x === "object")) {
          const looks = v.some((p) => "id" in p && "name" in p);
          if (looks && /player/i.test(k)) out.push(...v);
        }
        if (v && typeof v === "object") stack.push(v);
      }
    }
    const byId = /* @__PURE__ */ new Map();
    for (const p of out) if (p?.id) byId.set(String(p.id), p);
    return [...byId.values()];
  }
  function getPlayersArray(st) {
    const direct = st?.fullState?.data?.players ?? st?.data?.players ?? st?.players;
    return Array.isArray(direct) ? direct : findPlayersDeep(st);
  }
  function getSlotsArray(st) {
    const raw = st?.child?.data?.userSlots ?? st?.fullState?.child?.data?.userSlots ?? st?.data?.userSlots;
    if (Array.isArray(raw)) return raw;
    if (raw && typeof raw === "object") {
      const entries = Object.entries(raw);
      entries.sort((a, b) => {
        const ai = Number(a[0]);
        const bi = Number(b[0]);
        if (Number.isFinite(ai) && Number.isFinite(bi)) return ai - bi;
        return a[0].localeCompare(b[0]);
      });
      return entries.map(([, v]) => v);
    }
    return [];
  }
  function extractPosFromSlot(slot) {
    const pos = slot?.data?.position ?? slot?.position ?? slot?.data?.coords ?? slot?.coords;
    const x = Number(pos?.x);
    const y = Number(pos?.y);
    return Number.isFinite(x) && Number.isFinite(y) ? { x, y } : null;
  }
  function extractInventoryFromSlot(slot) {
    const inv = slot?.data?.inventory;
    if (!inv || typeof inv !== "object") return null;
    const items = Array.isArray(inv.items) ? inv.items : [];
    const favoritedItemIds = Array.isArray(inv.favoritedItemIds) ? inv.favoritedItemIds : [];
    return { items, favoritedItemIds };
  }
  function extractJournalFromSlot(slot) {
    const j = slot?.data?.journal ?? slot?.journal;
    if (!j || typeof j !== "object") return null;
    const produce = j.produce && typeof j.produce === "object" ? j.produce : void 0;
    const pets = j.pets && typeof j.pets === "object" ? j.pets : void 0;
    const normProduce = produce ? Object.fromEntries(Object.entries(produce).map(([k, v]) => [
      String(k),
      { variantsLogged: Array.isArray(v?.variantsLogged) ? v.variantsLogged : [] }
    ])) : void 0;
    const normPets = pets ? Object.fromEntries(Object.entries(pets).map(([k, v]) => [
      String(k),
      {
        variantsLogged: Array.isArray(v?.variantsLogged) ? v.variantsLogged : [],
        abilitiesLogged: Array.isArray(v?.abilitiesLogged) ? v.abilitiesLogged : []
      }
    ])) : void 0;
    return { produce: normProduce, pets: normPets };
  }
  function extractStatsFromSlot(slot) {
    const stats = slot?.data?.stats ?? slot?.stats;
    if (!stats || typeof stats !== "object") return null;
    return stats;
  }
  function extractActivityLogsFromSlot(slot) {
    const logs = slot?.data?.activityLogs ?? slot?.activityLogs;
    if (!Array.isArray(logs)) return null;
    return logs;
  }
  function extractGardenFromSlot(slot) {
    const g = slot?.data?.garden ?? slot?.garden;
    if (!g || typeof g !== "object") return null;
    const to = g.tileObjects;
    const bto = g.boardwalkTileObjects;
    const tileObjects = to && typeof to === "object" ? to : {};
    const boardwalkTileObjects = bto && typeof bto === "object" ? bto : {};
    return { tileObjects, boardwalkTileObjects };
  }
  function getSlotByPlayerId(st, playerId2) {
    for (const s of getSlotsArray(st)) if (String(s?.playerId ?? "") === String(playerId2)) return s;
    return null;
  }
  function enrichPlayersWithSlots(players, st) {
    const byPid = /* @__PURE__ */ new Map();
    for (const slot of getSlotsArray(st)) {
      if (!slot || typeof slot !== "object") continue;
      const pid = slot.playerId != null ? String(slot.playerId) : "";
      if (!pid) continue;
      const pos = extractPosFromSlot(slot);
      const inv = extractInventoryFromSlot(slot);
      byPid.set(pid, { x: pos?.x, y: pos?.y, inventory: inv ?? null });
    }
    return players.map((p) => {
      const extra = byPid.get(String(p.id));
      return extra ? { ...p, ...extra } : { ...p, inventory: null };
    });
  }
  function orderPlayersBySlots(players, st) {
    const slots = getSlotsArray(st);
    const mapById = /* @__PURE__ */ new Map();
    for (const p of players) mapById.set(String(p.id), p);
    const out = [];
    const seen = /* @__PURE__ */ new Set();
    for (const s of slots) {
      const pid = s?.playerId != null ? String(s.playerId) : "";
      if (!pid || seen.has(pid)) continue;
      const p = mapById.get(pid);
      if (p) {
        out.push(p);
        seen.add(pid);
      }
    }
    for (const p of players) {
      const pid = String(p.id);
      if (!seen.has(pid)) {
        out.push(p);
        seen.add(pid);
      }
    }
    return out;
  }
  function clampPlayers(n) {
    const v = Math.floor(Number(n));
    if (!Number.isFinite(v)) return 1;
    return Math.max(1, Math.min(6, v));
  }
  async function getPlayersInRoom() {
    try {
      const raw = await Atoms.server.numPlayers.get();
      return clampPlayers(raw);
    } catch {
      return 1;
    }
  }
  var __cachedSpawnTiles = null;
  var __spawnLoadPromise = null;
  async function getSpawnTilesSorted() {
    if (Array.isArray(__cachedSpawnTiles)) return __cachedSpawnTiles;
    if (__spawnLoadPromise) return __spawnLoadPromise;
    __spawnLoadPromise = (async () => {
      try {
        const map2 = await Atoms.root.map.get();
        const arr = map2?.spawnTiles;
        if (Array.isArray(arr) && arr.every((n) => Number.isFinite(n))) {
          __cachedSpawnTiles = [...arr].sort((a, b) => a - b);
          return __cachedSpawnTiles;
        }
      } catch {
      }
      try {
        const st = await Atoms.root.state.get();
        const seen = /* @__PURE__ */ new Set();
        const stack = [st];
        while (stack.length) {
          const cur = stack.pop();
          if (!cur || typeof cur !== "object" || seen.has(cur)) continue;
          seen.add(cur);
          const arr = cur?.spawnTiles;
          if (Array.isArray(arr) && arr.every((n) => Number.isFinite(n))) {
            __cachedSpawnTiles = [...arr].sort((a, b) => a - b);
            return __cachedSpawnTiles;
          }
          for (const k of Object.keys(cur)) {
            const v = cur[k];
            if (v && typeof v === "object") stack.push(v);
          }
        }
      } catch {
      }
      __cachedSpawnTiles = [];
      return __cachedSpawnTiles;
    })();
    const res = await __spawnLoadPromise;
    __spawnLoadPromise = null;
    return res;
  }
  async function getMapCols() {
    try {
      const map2 = await Atoms.root.map.get();
      const cols = Number(map2?.cols);
      if (Number.isFinite(cols) && cols > 0) return cols;
    } catch {
    }
    try {
      const st = await Atoms.root.state.get();
      const maybeCols = Number(
        st?.map?.cols ?? st?.child?.data?.map?.cols ?? st?.fullState?.map?.cols
      );
      if (Number.isFinite(maybeCols) && maybeCols > 0) return maybeCols;
    } catch {
    }
    return 81;
  }
  function assignGardenPositions(players, spawnTilesSorted) {
    if (!players.length || !spawnTilesSorted.length) {
      return players.map((p) => ({ ...p, gardenPosition: null }));
    }
    const out = [];
    for (let i = 0; i < players.length; i++) {
      out.push({ ...players[i], gardenPosition: spawnTilesSorted[i] ?? null });
    }
    return out;
  }
  function nowTs() {
    return Date.now();
  }
  function normJournal(j) {
    if (!j || typeof j !== "object") return {};
    const out = {};
    if (j.produce && typeof j.produce === "object") out.produce = j.produce;
    if (j.pets && typeof j.pets === "object") out.pets = j.pets;
    return out;
  }
  function hasJournalData(j) {
    if (!j) return false;
    const hasProduce = !!j.produce && Object.values(j.produce).some((s) => (s.variantsLogged?.length ?? 0) > 0);
    const hasPets = !!j.pets && Object.values(j.pets).some((s) => (s.variantsLogged?.length ?? 0) > 0 || (s.abilitiesLogged?.length ?? 0) > 0);
    return hasProduce || hasPets;
  }
  var followingState = {
    currentTargetId: null,
    unsub: null,
    lastPos: null,
    prevPos: null,
    steps: 0
  };
  var PET_FOLLOW_INTERVAL_MS = 20;
  var PET_HISTORY_FACTOR = 3;
  var PET_SPACING_STEPS = 1;
  var petFollowState = {
    targetId: null,
    unsub: null,
    timer: null,
    pets: [],
    history: [],
    historyCap: 0
  };
  function clearPetFollowTimer() {
    if (petFollowState.timer) {
      clearInterval(petFollowState.timer);
      petFollowState.timer = null;
    }
  }
  async function resetPetFollowState() {
    if (petFollowState.unsub) {
      const fn = petFollowState.unsub;
      petFollowState.unsub = null;
      try {
        await fn();
      } catch {
      }
    } else {
      petFollowState.unsub = null;
    }
    clearPetFollowTimer();
    petFollowState.targetId = null;
    petFollowState.pets = [];
    petFollowState.history = [];
    petFollowState.historyCap = 0;
  }
  function recordPetHistory(pos, force = false) {
    const top = petFollowState.history[0];
    if (!force && top && top.x === pos.x && top.y === pos.y) return;
    petFollowState.history.unshift({ x: pos.x, y: pos.y });
    const cap = petFollowState.historyCap || petFollowState.history.length;
    if (petFollowState.history.length > cap) {
      petFollowState.history.length = cap;
    }
  }
  var PlayersService = {
    async list() {
      const st = await Atoms.root.state.get();
      if (!st) return [];
      const base = enrichPlayersWithSlots(getPlayersArray(st), st);
      const ordered = orderPlayersBySlots(base, st);
      const spawns = await getSpawnTilesSorted();
      const players = assignGardenPositions(ordered, spawns);
      return players;
    },
    async onChange(cb) {
      return Atoms.root.state.onChange(async () => {
        try {
          cb(await this.list());
        } catch {
        }
      });
    },
    async getPosition(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      const pos = extractPosFromSlot(slot);
      return pos;
    },
    async getInventory(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      const inv = extractInventoryFromSlot(slot);
      return inv;
    },
    async getJournal(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      const j = extractJournalFromSlot(slot);
      const journal = j ? normJournal(j) : null;
      return journal;
    },
    async getGarden(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      return extractGardenFromSlot(slot);
    },
    async getGardenPosition(playerId2) {
      const list = await this.list();
      const p = list.find((x) => String(x.id) === String(playerId2));
      return p?.gardenPosition ?? null;
    },
    async getPlayerNameById(playerId2) {
      try {
        const st = await Atoms.root.state.get();
        if (st) {
          const arr = getPlayersArray(st);
          const p = arr.find((x) => String(x?.id) === String(playerId2));
          if (p && typeof p.name === "string" && p.name) return p.name;
        }
      } catch {
      }
      try {
        const list = await this.list();
        const p = list.find((x) => String(x.id) === String(playerId2));
        return p?.name ?? null;
      } catch {
        return null;
      }
    },
    async teleportToPlayer(playerId2) {
      const pos = await this.getPosition(playerId2);
      if (!pos) throw new Error("Unknown position for this player");
      PlayerService.teleport(pos.x, pos.y);
      toastSimple("Teleport", `Teleported to ${await this.getPlayerNameById(playerId2)}`, "success");
    },
    async teleportToGarden(playerId2) {
      const tileId = await this.getGardenPosition(playerId2);
      if (tileId == null) {
        await toastSimple("Teleport", "No garden position for this player.", "error");
        return;
      }
      const cols = await getMapCols();
      const x = tileId % cols, y = Math.floor(tileId / cols);
      await PlayerService.teleport(x, y);
      await toastSimple("Teleport", `Teleported to ${await this.getPlayerNameById(playerId2)}'s garden`, "success");
    },
    async getInventoryValue(playerId2, opts) {
      try {
        const playersInRoom = await getPlayersInRoom();
        const inv = await this.getInventory(playerId2);
        const items = Array.isArray(inv?.items) ? inv.items : [];
        if (!items.length) return 0;
        const value = sumInventoryValue(items, opts, playersInRoom);
        return value;
      } catch {
        return 0;
      }
    },
    async getGardenValue(playerId2, opts) {
      try {
        const playersInRoom = await getPlayersInRoom();
        const garden2 = await this.getGarden(playerId2);
        if (!garden2) return 0;
        const value = sumGardenValue(garden2.tileObjects ?? {}, opts, playersInRoom);
        return value;
      } catch {
        return 0;
      }
    },
    /** Ouvre laperu dinventaire (fake modal) avec garde + toasts. */
    async openInventoryPreview(playerId2, playerName) {
      try {
        const inv = await this.getInventory(playerId2);
        if (!inv) {
          await toastSimple("Inventory", "No inventory object found for this player.", "error");
          return;
        }
        const items = Array.isArray(inv.items) ? inv.items : [];
        if (items.length === 0) {
          await toastSimple("Inventory", "Inventory is empty for this player.", "info");
          return;
        }
        try {
          await fakeInventoryShow({ ...inv, items }, { open: true });
        } catch (err) {
          await toastSimple("Inventory", err?.message || "Failed to open inventory", "error");
          return;
        }
        if (playerName) await toastSimple("Inventory", `${playerName}'s inventory displayed.`, "info");
      } catch (e) {
        await toastSimple("Inventory", e?.message || "Failed to open inventory.", "error");
      }
    },
    /** Ouvre le Journal (produce + pets) avec garde + toasts. */
    async openJournalLog(playerId2, playerName) {
      try {
        const journal = await this.getJournal(playerId2);
        if (!hasJournalData(journal)) {
          await toastSimple("Journal", "No journal data for this player.", "error");
          return;
        }
        const safe = journal ?? {};
        try {
          await fakeJournalShow(safe, { open: true });
        } catch (err) {
          await toastSimple("Journal", err?.message || "Failed to open journal.", "error");
          return;
        }
        if (playerName) await toastSimple("Journal", `${playerName}'s journal displayed.`, "info");
      } catch (e) {
        await toastSimple("Journal", e?.message || "Failed to open journal.", "error");
      }
    },
    async getStats(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      return extractStatsFromSlot(slot);
    },
    async getActivityLogs(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      return extractActivityLogsFromSlot(slot);
    },
    async openStatsModal(playerId2, playerName) {
      try {
        const stats = await this.getStats(playerId2);
        if (!stats) {
          await toastSimple("Stats", "No stats found for this player.", "error");
          return;
        }
        await fakeStatsShow(stats, { open: true });
        if (playerName) await toastSimple("Stats", `${playerName}'s stats displayed.`, "info");
      } catch (e) {
        await toastSimple("Stats", e?.message || "Failed to open stats modal.", "error");
      }
    },
    async openActivityLogModal(playerId2, playerName) {
      try {
        const logs = await this.getActivityLogs(playerId2);
        if (!logs || logs.length === 0) {
          await toastSimple("Activity log", "No activity logs for this player.", "info");
          return;
        }
        await fakeActivityLogShow(logs, { open: true });
        if (playerName) await toastSimple("Activity log", `${playerName}'s activity log displayed.`, "info");
      } catch (e) {
        await toastSimple("Activity log", e?.message || "Failed to open activity log.", "error");
      }
    },
    /* ---------------- Ajouts "fake" au journal (UI only, avec gardes) ---------------- */
    async addProduceVariant(playerId2, species, variant, createdAt = nowTs()) {
      if (!species || !variant) {
        await toastSimple("Journal", "Missing species or variant.", "error");
        return;
      }
      try {
        await fakeJournalShow({
          produce: {
            [String(species)]: {
              variantsLogged: [{ variant: String(variant), createdAt }]
            }
          }
        }, { open: true });
        const name = await this.getPlayerNameById(playerId2);
        await toastSimple("Journal", `Added produce variant "${variant}" for ${name ?? playerId2}.`, "success");
      } catch (e) {
        await toastSimple("Journal", e?.message || "Failed to add produce variant.", "error");
      }
    },
    async addPetVariant(playerId2, petSpecies, variant, createdAt = nowTs()) {
      if (!petSpecies || !variant) {
        await toastSimple("Journal", "Missing pet species or variant.", "error");
        return;
      }
      try {
        await fakeJournalShow({
          pets: {
            [String(petSpecies)]: {
              variantsLogged: [{ variant: String(variant), createdAt }]
            }
          }
        }, { open: true });
        const name = await this.getPlayerNameById(playerId2);
        await toastSimple("Journal", `Added pet variant "${variant}" for ${name ?? playerId2}.`, "success");
      } catch (e) {
        await toastSimple("Journal", e?.message || "Failed to add pet variant.", "error");
      }
    },
    async addPetAbility(playerId2, petSpecies, ability, createdAt = nowTs()) {
      if (!petSpecies || !ability) {
        await toastSimple("Journal", "Missing pet species or ability.", "error");
        return;
      }
      try {
        await fakeJournalShow({
          pets: {
            [String(petSpecies)]: {
              abilitiesLogged: [{ ability: String(ability), createdAt }]
            }
          }
        }, { open: true });
        const name = await this.getPlayerNameById(playerId2);
        await toastSimple("Journal", `Added pet ability "${ability}" for ${name ?? playerId2}.`, "success");
      } catch (e) {
        await toastSimple("Journal", e?.message || "Failed to add pet ability.", "error");
      }
    },
    /* ---------------- Follow ---------------- */
    async stopFollowing() {
      if (followingState.unsub) {
        try {
          await followingState.unsub();
        } catch {
        }
      }
      followingState.unsub = null;
      followingState.currentTargetId = null;
      followingState.lastPos = null;
      followingState.prevPos = null;
      followingState.steps = 0;
    },
    isFollowing(playerId2) {
      return followingState.currentTargetId === playerId2;
    },
    async startFollowing(playerId2) {
      if (followingState.unsub) {
        try {
          await followingState.unsub();
        } catch {
        }
        followingState.unsub = null;
      }
      followingState.currentTargetId = playerId2;
      followingState.lastPos = null;
      followingState.prevPos = null;
      followingState.steps = 0;
      const pos = await this.getPosition(playerId2);
      if (!pos) {
        await toastSimple("Follow", "Unable to retrieve player position.", "error");
        followingState.currentTargetId = null;
        return;
      }
      await PlayerService.teleport(pos.x, pos.y);
      followingState.lastPos = { x: pos.x, y: pos.y };
      followingState.prevPos = null;
      followingState.steps = 0;
      followingState.unsub = await this.onChange(async (players) => {
        if (followingState.currentTargetId !== playerId2) return;
        const target = players.find((p) => p.id === playerId2);
        if (!target || typeof target.x !== "number" || typeof target.y !== "number") {
          await this.stopFollowing();
          await toastSimple("Follow", "The target is no longer trackable (disconnected?).", "error");
          return;
        }
        const cur = { x: target.x, y: target.y };
        const last = followingState.lastPos;
        if (!last) {
          followingState.lastPos = cur;
          return;
        }
        if (cur.x !== last.x || cur.y !== last.y) {
          followingState.steps += 1;
          if (followingState.steps >= 2) {
            if (last) {
              PlayerService.move(last.x, last.y);
            }
          }
          followingState.prevPos = followingState.lastPos;
          followingState.lastPos = cur;
        }
      });
      await toastSimple("Follow", "Follow enabled", "success");
    },
    /* ---------------- Pet Follow ---------------- */
    async stopPetFollowing(opts) {
      await resetPetFollowState();
      if (!opts?.silent) {
        await toastSimple("Pet follow", opts?.message ?? "Disabled.", opts?.tone ?? "info");
      }
    },
    isPetFollowing(playerId2) {
      return petFollowState.targetId === playerId2;
    },
    async startPetFollowing(playerId2) {
      await this.stopPetFollowing({ silent: true });
      const petsRaw = await Atoms.pets.myPetInfos.get();
      const petIds = Array.isArray(petsRaw) ? petsRaw.map((entry) => entry?.slot?.id).filter((id) => typeof id === "string" && !!id) : [];
      if (!petIds.length) {
        await toastSimple("Pet follow", "You don't have any active pets.", "error");
        return;
      }
      const pos = await this.getPosition(playerId2);
      if (!pos) {
        await toastSimple("Pet follow", "Unable to retrieve player position.", "error");
        return;
      }
      petFollowState.targetId = playerId2;
      petFollowState.pets = petIds;
      petFollowState.historyCap = Math.max(petIds.length * PET_HISTORY_FACTOR, petIds.length + PET_SPACING_STEPS + 1);
      petFollowState.history = [];
      for (let i = 0; i < petFollowState.historyCap; i += 1) {
        recordPetHistory(pos, true);
      }
      const sendPositions = async () => {
        if (petFollowState.targetId !== playerId2) return;
        if (!petFollowState.pets.length || !petFollowState.history.length) return;
        const payload = {};
        for (let i = 0; i < petFollowState.pets.length; i += 1) {
          const petId = petFollowState.pets[i];
          const historyIndex = Math.min(
            petFollowState.history.length - 1,
            (i + 1) * PET_SPACING_STEPS
          );
          const targetPos = petFollowState.history[historyIndex] ?? petFollowState.history[petFollowState.history.length - 1];
          if (targetPos) {
            payload[petId] = { x: targetPos.x, y: targetPos.y };
          }
        }
        if (Object.keys(payload).length === 0) return;
        try {
          await PlayerService.petPositions(payload);
        } catch (err) {
        }
      };
      petFollowState.timer = setInterval(() => {
        sendPositions().catch(() => {
        });
      }, PET_FOLLOW_INTERVAL_MS);
      const initialSend = sendPositions();
      petFollowState.unsub = await this.onChange(async (players) => {
        if (petFollowState.targetId !== playerId2) return;
        const target = players.find((p) => p.id === playerId2);
        if (!target || typeof target.x !== "number" || typeof target.y !== "number") {
          await this.stopPetFollowing({ silent: false, message: "Target is no longer trackable.", tone: "error" });
          return;
        }
        recordPetHistory({ x: target.x, y: target.y });
      });
      await initialSend;
      await toastSimple("Pet follow", "Pets are now following the target.", "success");
    }
  };

  // src/utils/supabase.ts
  var SUPABASE_FUNCTION_BASE = "https://pquktqrngyxkvrgtfygp.supabase.co/functions/v1/";
  var SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBxdWt0cXJuZ3l4a3ZyZ3RmeWdwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk2MTQzMDMsImV4cCI6MjA3NTE5MDMwM30.-d45t6qyEO54iz2SrjaoTUQjeNb6tngDx6pOQL7-Ubg";
  var cachedFriendsView = null;
  var cachedIncomingRequests = null;
  function getCachedFriendsWithViews() {
    return cachedFriendsView ? [...cachedFriendsView] : [];
  }
  function getCachedIncomingRequestsWithViews() {
    return cachedIncomingRequests ? [...cachedIncomingRequests] : [];
  }
  function buildUrl(path, query) {
    const url = new URL(path, SUPABASE_FUNCTION_BASE);
    if (query) {
      for (const [key2, value] of Object.entries(query)) {
        if (value === void 0) continue;
        url.searchParams.set(key2, String(value));
      }
    }
    return url.toString();
  }
  function httpGet(path, query) {
    return new Promise((resolve2) => {
      const url = buildUrl(path, query);
      GM_xmlhttpRequest({
        method: "GET",
        url,
        headers: {
          apikey: SUPABASE_ANON_KEY,
          Authorization: `Bearer ${SUPABASE_ANON_KEY}`
        },
        onload: (res) => {
          if (res.status >= 200 && res.status < 300) {
            try {
              const parsed = res.responseText ? JSON.parse(res.responseText) : null;
              resolve2({ status: res.status, data: parsed });
            } catch (e) {
              console.error("[supabase] GET parse error:", e, res.responseText);
              resolve2({ status: res.status, data: null });
            }
          } else {
            console.error("[supabase] GET error:", res.status, res.responseText);
            resolve2({ status: res.status, data: null });
          }
        },
        onerror: (err) => {
          console.error("[supabase] GET request failed:", err);
          resolve2({ status: 0, data: null });
        }
      });
    });
  }
  function httpPost(path, body) {
    return new Promise((resolve2) => {
      const url = buildUrl(path);
      GM_xmlhttpRequest({
        method: "POST",
        url,
        headers: {
          "Content-Type": "application/json",
          apikey: SUPABASE_ANON_KEY,
          Authorization: `Bearer ${SUPABASE_ANON_KEY}`
        },
        data: JSON.stringify(body),
        onload: (res) => {
          if (res.status >= 200 && res.status < 300) {
            try {
              const parsed = res.responseText ? JSON.parse(res.responseText) : null;
              resolve2({ status: res.status, data: parsed });
            } catch (e) {
              console.error("[supabase] POST parse error:", e, res.responseText);
              resolve2({ status: res.status, data: null });
            }
          } else {
            console.error(
              "[supabase] POST error:",
              res.status,
              res.responseText
            );
            resolve2({ status: res.status, data: null });
          }
        },
        onerror: (err) => {
          console.error("[supabase] POST request failed:", err);
          resolve2({ status: 0, data: null });
        }
      });
    });
  }
  async function sendPlayerState(payload) {
    const { status } = await httpPost("collect-state", payload);
    if (status === 204) return true;
    if (status === 429) {
      console.warn("[supabase] sendPlayerState rate-limited");
    }
    return false;
  }
  async function fetchAvailableRooms(limit = 50) {
    const { data } = await httpGet("list-rooms", { limit });
    if (!data || !Array.isArray(data)) return [];
    return data.map((r) => ({
      id: r.id,
      isPrivate: r.is_private,
      playersCount: r.players_count,
      lastUpdatedAt: r.last_updated_at,
      lastUpdatedByPlayerId: r.last_updated_by_player_id,
      userSlots: Array.isArray(r.user_slots) ? r.user_slots.map((slot) => ({
        name: slot.name,
        avatarUrl: slot.avatar_url ?? null
      })) : void 0
    }));
  }
  async function fetchPlayersView(playerIds, options) {
    const ids = Array.from(
      new Set(
        (playerIds ?? []).map((x) => String(x).trim()).filter((x) => x.length >= 3)
      )
    );
    if (ids.length === 0) return [];
    const body = { playerIds: ids };
    if (options?.sections) {
      body.sections = Array.isArray(options.sections) ? options.sections : [options.sections];
    }
    const { status, data } = await httpPost(
      "get-players-view",
      body
    );
    if (status !== 200 || !Array.isArray(data)) return [];
    return data;
  }
  async function sendFriendRequest(fromPlayerId, toPlayerId) {
    if (!fromPlayerId || !toPlayerId || fromPlayerId === toPlayerId) {
      return false;
    }
    const { status } = await httpPost("friend-request", {
      fromPlayerId,
      toPlayerId
    });
    if (status === 204) return true;
    if (status === 409) {
      console.warn("[supabase] friend-request conflict (already exists)");
    }
    return false;
  }
  async function respondFriendRequest(params) {
    const { playerId: playerId2, otherPlayerId, action: action2 } = params;
    if (!playerId2 || !otherPlayerId || playerId2 === otherPlayerId) {
      return false;
    }
    const { status } = await httpPost("friend-respond", {
      playerId: playerId2,
      otherPlayerId,
      action: action2
    });
    if (status === 204) return true;
    return false;
  }
  async function fetchFriendsIds(playerId2) {
    if (!playerId2) return [];
    const { status, data } = await httpGet("list-friends", { playerId: playerId2 });
    if (status !== 200 || !data || !Array.isArray(data.friends)) return [];
    return data.friends;
  }
  async function fetchFriendsWithViews(playerId2) {
    const friendIds = await fetchFriendsIds(playerId2);
    if (friendIds.length === 0) {
      cachedFriendsView = [];
      return [];
    }
    const result = await fetchPlayersView(friendIds, { sections: ["profile", "room"] });
    cachedFriendsView = result;
    return [...result];
  }
  async function fetchFriendRequests(playerId2) {
    if (!playerId2) {
      return { playerId: "", incoming: [], outgoing: [] };
    }
    const { status, data } = await httpGet(
      "list-friend-requests",
      { playerId: playerId2 }
    );
    if (status !== 200 || !data) {
      return { playerId: playerId2, incoming: [], outgoing: [] };
    }
    return {
      playerId: data.playerId,
      incoming: Array.isArray(data.incoming) ? data.incoming : [],
      outgoing: Array.isArray(data.outgoing) ? data.outgoing : []
    };
  }
  async function fetchIncomingRequestsWithViews(playerId2) {
    const { incoming } = await fetchFriendRequests(playerId2);
    const ids = incoming.map((r) => r.fromPlayerId);
    if (ids.length === 0) {
      cachedIncomingRequests = [];
      return [];
    }
    const result = await fetchPlayersView(ids, { sections: ["profile"] });
    cachedIncomingRequests = result;
    return [...result];
  }
  async function removeFriend(playerId2, otherPlayerId) {
    if (!playerId2 || !otherPlayerId || playerId2 === otherPlayerId) {
      return false;
    }
    const { status } = await httpPost("friend-remove", {
      playerId: playerId2,
      otherPlayerId
    });
    return status === 204;
  }
  async function searchRoomsByPlayerName(rawQuery, options) {
    const query = rawQuery.trim();
    const minLen = options?.minQueryLength ?? 2;
    if (query.length < minLen) {
      return [];
    }
    const limitRooms = options?.limitRooms ?? 200;
    const qLower = query.toLowerCase();
    const rooms = await fetchAvailableRooms(limitRooms);
    const results = [];
    for (const room of rooms) {
      if (!room.userSlots || room.userSlots.length === 0) continue;
      const matchedSlots = room.userSlots.filter((slot) => {
        if (!slot.name) return false;
        return slot.name.toLowerCase().includes(qLower);
      });
      if (matchedSlots.length > 0) {
        results.push({
          room,
          matchedSlots
        });
      }
    }
    console.log(results);
    return results;
  }

  // src/utils/publicRooms.ts
  var ROOMS_JSON_URL = "https://raw.githubusercontent.com/Ariedam64/MagicGarden-modMenu/refs/heads/main/rooms.json";
  function resolveGmXhr() {
    if (typeof GM_xmlhttpRequest === "function") {
      return GM_xmlhttpRequest;
    }
    if (typeof GM !== "undefined" && typeof GM.xmlHttpRequest === "function") {
      return GM.xmlHttpRequest.bind(GM);
    }
    return void 0;
  }
  async function fetchTextWithFetch2(url, options) {
    const response = await fetch(url, { cache: "no-store", ...options });
    if (!response.ok) {
      throw new Error(`Failed to load remote resource: ${response.status} ${response.statusText}`);
    }
    return await response.text();
  }
  async function fetchTextWithGM2(url, options) {
    const xhr = resolveGmXhr();
    if (!xhr) {
      throw new Error("GM_xmlhttpRequest not available");
    }
    return await new Promise((resolve2, reject) => {
      xhr({
        method: "GET",
        url,
        headers: options?.headers,
        onload: (res) => {
          if (res.status >= 200 && res.status < 300) {
            resolve2(res.responseText ?? "");
          } else {
            reject(new Error(`GM_xmlhttpRequest failed: ${res.status}`));
          }
        },
        onerror: (res) => {
          reject(new Error(res.error ?? "GM_xmlhttpRequest error"));
        },
        ontimeout: () => reject(new Error("GM_xmlhttpRequest timeout")),
        onabort: () => reject(new Error("GM_xmlhttpRequest aborted"))
      });
    });
  }
  async function fetchText2(url, options) {
    const preferGM = isDiscordSurface();
    const hasGM = !!resolveGmXhr();
    if (preferGM && hasGM) {
      return await fetchTextWithGM2(url, options);
    }
    try {
      return await fetchTextWithFetch2(url, options);
    } catch (error) {
      if (hasGM) {
        return await fetchTextWithGM2(url, options);
      }
      throw error;
    }
  }
  async function fetchRemoteRooms() {
    const text = await fetchText2(ROOMS_JSON_URL);
    try {
      return JSON.parse(text);
    } catch (error) {
      throw new Error("Failed to parse rooms JSON", { cause: error });
    }
  }

  // src/services/room.ts
  var MAX_PLAYERS = 6;
  function deriveCategoryFromName(name) {
    const match = /^([a-zA-Z]+)/.exec(name);
    if (match && match[1]) {
      return match[1].toLowerCase();
    }
    return "other";
  }
  function deriveCategoryOrder(definitions, preferredOrder = []) {
    const available = new Set(definitions.map((room) => room.category));
    const seen = /* @__PURE__ */ new Set();
    const order = [];
    for (const category of preferredOrder) {
      if (!available.has(category)) continue;
      if (seen.has(category)) continue;
      seen.add(category);
      order.push(category);
    }
    for (const room of definitions) {
      if (seen.has(room.category)) continue;
      seen.add(room.category);
      order.push(room.category);
    }
    return order;
  }
  function createStateFromDefinitions(definitions, preferredOrder = []) {
    const cloned = definitions.map((room) => ({ ...room }));
    return {
      definitions: cloned,
      categoryOrder: deriveCategoryOrder(cloned, preferredOrder)
    };
  }
  function cloneState2(state2) {
    return {
      definitions: state2.definitions.map((room) => ({ ...room })),
      categoryOrder: [...state2.categoryOrder]
    };
  }
  var INITIAL_PUBLIC_ROOMS_STATE = createStateFromDefinitions([]);
  var publicRoomsState = cloneState2(INITIAL_PUBLIC_ROOMS_STATE);
  var remoteRoomsStatus = "idle";
  var remoteRoomsPromise = null;
  function parseRemoteRoomsPayload(payload) {
    if (!payload || typeof payload !== "object") {
      return null;
    }
    const record = payload.publicRooms;
    if (!record || typeof record !== "object") {
      return null;
    }
    const definitions = [];
    const categoryOrder = [];
    for (const [rawCategory, entries] of Object.entries(record)) {
      if (!Array.isArray(entries) || !entries.length) {
        continue;
      }
      const categoryName = typeof rawCategory === "string" ? rawCategory.trim() : "";
      if (!categoryName) {
        continue;
      }
      if (!categoryOrder.includes(categoryName)) {
        categoryOrder.push(categoryName);
      }
      for (const entry of entries) {
        if (typeof entry !== "string") {
          continue;
        }
        const separatorIndex = entry.indexOf(":");
        if (separatorIndex <= 0) {
          continue;
        }
        const name = entry.slice(0, separatorIndex).trim();
        const idRoom = entry.slice(separatorIndex + 1).trim();
        if (!name || !idRoom) {
          continue;
        }
        definitions.push({
          name,
          idRoom,
          category: categoryName
        });
      }
    }
    if (!definitions.length) {
      return null;
    }
    return createStateFromDefinitions(definitions, categoryOrder);
  }
  function setPublicRoomsState(next) {
    publicRoomsState = cloneState2(next);
  }
  function requestRemoteRoomsFetch() {
    if (remoteRoomsStatus === "pending" || remoteRoomsStatus === "fulfilled" || remoteRoomsStatus === "rejected") {
      return remoteRoomsPromise;
    }
    if (typeof window === "undefined") {
      return null;
    }
    remoteRoomsStatus = "pending";
    remoteRoomsPromise = (async () => {
      try {
        const payload = await fetchRemoteRooms();
        const parsed = parseRemoteRoomsPayload(payload);
        if (parsed) {
          setPublicRoomsState(parsed);
        }
        remoteRoomsStatus = "fulfilled";
      } catch (error) {
        remoteRoomsStatus = "rejected";
        console.warn("[MagicGarden] Unable to load remote rooms list", error);
      }
    })();
    return remoteRoomsPromise;
  }
  async function ensureRemoteRoomsLoaded() {
    const promise = requestRemoteRoomsFetch();
    if (promise) {
      await promise;
    }
  }
  function sanitizeRoomDefinition(room) {
    if (!room) return null;
    const name = typeof room.name === "string" ? room.name.trim() : "";
    const idRoom = typeof room.idRoom === "string" ? room.idRoom.trim() : "";
    if (!name || !idRoom) return null;
    return {
      name,
      idRoom,
      category: deriveCategoryFromName(name)
    };
  }
  function loadStoredCustomRooms() {
    const parsed = readAriesPath("room.customRooms") ?? [];
    if (!Array.isArray(parsed)) return [];
    const result = [];
    for (const entry of parsed) {
      const sanitized = sanitizeRoomDefinition(entry);
      if (sanitized) result.push(sanitized);
    }
    return result;
  }
  function persistCustomRooms(rooms) {
    const payload = rooms.map((room) => ({
      name: room.name,
      idRoom: room.idRoom
    }));
    writeAriesPath("room.customRooms", payload);
  }
  var customRoomsCache = null;
  function getCustomRoomsCache() {
    if (!customRoomsCache) {
      customRoomsCache = loadStoredCustomRooms();
    }
    return customRoomsCache.map((room) => ({ ...room }));
  }
  function setCustomRoomsCache(rooms) {
    customRoomsCache = rooms.map((room) => ({ ...room }));
    persistCustomRooms(customRoomsCache);
  }
  function normalizeIdentifier(value) {
    return value.trim().toLowerCase();
  }
  function fetchStatusesFor(definitions) {
    const now2 = Date.now();
    return Promise.all(
      definitions.map(async (def) => {
        try {
          const response = await requestRoomEndpoint(def.idRoom, {
            endpoint: "info",
            timeoutMs: 1e4
          });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = response.parsed ?? (() => {
            try {
              return JSON.parse(response.body);
            } catch {
              return void 0;
            }
          })();
          const players = clampPlayerCount(typeof payload?.numPlayers === "number" ? payload.numPlayers : 0);
          const capacity = MAX_PLAYERS;
          const currentGame = typeof payload?.currentGame === "string" && payload.currentGame.trim().length ? payload.currentGame.trim() : void 0;
          const hostPlayerId = typeof payload?.hostPlayerId === "string" && payload.hostPlayerId.trim().length ? payload.hostPlayerId.trim() : void 0;
          const playerDetails = normalizeRoomPlayers(payload?.players, hostPlayerId);
          return {
            ...def,
            players,
            capacity,
            isFull: players >= capacity,
            lastUpdatedAt: now2,
            currentGame,
            hostPlayerId,
            playerDetails
          };
        } catch (error) {
          const message = normalizeError(error);
          return {
            ...def,
            players: 0,
            capacity: MAX_PLAYERS,
            isFull: false,
            lastUpdatedAt: now2,
            hostPlayerId: void 0,
            playerDetails: [],
            error: message
          };
        }
      })
    );
  }
  function clampPlayerCount(value) {
    if (!Number.isFinite(value)) return 0;
    return Math.max(0, Math.min(MAX_PLAYERS, Math.floor(value)));
  }
  function normalizeRoomPlayers(value, hostPlayerId) {
    if (!Array.isArray(value)) return [];
    const normalized = [];
    for (const entry of value) {
      if (!entry || typeof entry !== "object") continue;
      const id = typeof entry.id === "string" && entry.id.trim().length ? entry.id.trim() : void 0;
      const databaseUserId = typeof entry.databaseUserId === "string" && entry.databaseUserId.trim().length ? entry.databaseUserId.trim() : void 0;
      const rawName = typeof entry.name === "string" ? entry.name.trim() : "";
      const name = rawName || "Unknown player";
      const isConnected = typeof entry.isConnected === "boolean" ? entry.isConnected : false;
      const discordAvatarUrl = typeof entry.discordAvatarUrl === "string" && entry.discordAvatarUrl.trim().length ? entry.discordAvatarUrl.trim() : void 0;
      normalized.push({
        id,
        databaseUserId,
        name,
        isConnected,
        discordAvatarUrl,
        isHost: Boolean(hostPlayerId && (id === hostPlayerId || databaseUserId === hostPlayerId))
      });
    }
    return normalized;
  }
  function normalizeError(error) {
    if (!error) return "Erreur inconnue.";
    if (typeof error === "string") return error;
    if (error instanceof Error) return error.message || "Erreur inconnue.";
    try {
      return JSON.stringify(error);
    } catch {
      return String(error);
    }
  }
  var RoomService = {
    getPublicRooms() {
      void requestRemoteRoomsFetch();
      return publicRoomsState.definitions.map((room) => ({ ...room }));
    },
    getPublicRoomsCategoryOrder() {
      void requestRemoteRoomsFetch();
      return [...publicRoomsState.categoryOrder];
    },
    getCustomRooms() {
      return getCustomRoomsCache();
    },
    addCustomRoom(room) {
      const name = typeof room.name === "string" ? room.name.trim() : "";
      const idRoom = typeof room.idRoom === "string" ? room.idRoom.trim() : "";
      if (!name) {
        return { ok: false, error: "Room name is required." };
      }
      if (!idRoom) {
        return { ok: false, error: "Room identifier is required." };
      }
      const normalizedName = normalizeIdentifier(name);
      const normalizedId = normalizeIdentifier(idRoom);
      const allRooms = [...this.getPublicRooms(), ...getCustomRoomsCache()];
      if (allRooms.some((existing) => normalizeIdentifier(existing.idRoom) === normalizedId)) {
        return { ok: false, error: "This room already exists." };
      }
      if (allRooms.some((existing) => normalizeIdentifier(existing.name) === normalizedName)) {
        return { ok: false, error: "A room with this name already exists." };
      }
      const definition = {
        name,
        idRoom,
        category: deriveCategoryFromName(name)
      };
      const next = [...getCustomRoomsCache(), definition];
      setCustomRoomsCache(next);
      return { ok: true, room: { ...definition } };
    },
    removeCustomRoom(idRoom) {
      const normalizedId = normalizeIdentifier(idRoom);
      const rooms = getCustomRoomsCache();
      const filtered = rooms.filter((room) => normalizeIdentifier(room.idRoom) !== normalizedId);
      if (filtered.length === rooms.length) {
        return false;
      }
      setCustomRoomsCache(filtered);
      return true;
    },
    async fetchPublicRoomsStatus() {
      await ensureRemoteRoomsLoaded();
      const definitions = publicRoomsState.definitions.map((room) => ({ ...room }));
      return fetchStatusesFor(definitions);
    },
    async fetchCustomRoomsStatus() {
      const definitions = this.getCustomRooms();
      if (!definitions.length) return [];
      return fetchStatusesFor(definitions);
    },
    canJoinPublicRoom(room) {
      if (room.error) return false;
      if (room.isFull) return false;
      if (this.isDiscordActivity()) return false;
      return true;
    },
    isDiscordActivity() {
      return isDiscordSurface();
    },
    joinPublicRoom(room) {
      const result = joinRoom(room.idRoom, { siteFallbackOnDiscord: true, preferSoft: false });
      if (!result.ok) {
      }
      return result;
    }
  };

  // src/ui/menus/room.ts
  var ROOM_MENU_STYLE_ID = "mc-room-menu-loading-style";
  function ensureRoomMenuStyles() {
    if (document.getElementById(ROOM_MENU_STYLE_ID)) return;
    const style2 = document.createElement("style");
    style2.id = ROOM_MENU_STYLE_ID;
    style2.textContent = `
@keyframes room-menu-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.qmm.qmm-room-menu .qmm-tab[data-id="public-rooms"],
.qmm.qmm-room-menu .qmm-tab[data-id="search-player"],
.qmm.qmm-room-menu .qmm-tab[data-id="players"] {
  flex: 0 1 auto;
  min-width: 160px;
}
`;
    document.head.appendChild(style2);
  }
  var TAB_ID = "public-rooms";
  var SEARCH_TAB_ID = "search-player";
  var PLAYERS_TAB_ID = "players";
  async function renderRoomMenu(root) {
    const ui = new Menu({
      id: "room",
      compact: true,
      windowSelector: ".qws-win",
      classes: "qmm-room-menu"
    });
    ui.addTab(TAB_ID, "Public Rooms", (view) => renderPublicRoomsTab(view, ui));
    ui.addTab(SEARCH_TAB_ID, "Search Player", (view) => renderSearchPlayerTab(view, ui));
    ui.addTab(PLAYERS_TAB_ID, "Players", (view) => {
      void renderPlayersTab(view).catch(() => {
      });
    });
    ui.mount(root);
  }
  function renderPublicRoomsTab(view, ui) {
    view.innerHTML = "";
    ensureRoomMenuStyles();
    const root = document.createElement("div");
    root.style.display = "flex";
    root.style.flexDirection = "column";
    root.style.alignItems = "center";
    root.style.padding = "12px";
    root.style.boxSizing = "border-box";
    root.style.height = "100%";
    root.style.minHeight = "0";
    view.appendChild(root);
    const container = document.createElement("div");
    container.style.display = "grid";
    container.style.gap = "12px";
    container.style.width = "100%";
    container.style.maxWidth = "640px";
    container.style.height = "100%";
    container.style.gridTemplateRows = "max-content max-content 1fr max-content";
    root.appendChild(container);
    const heading = document.createElement("div");
    heading.textContent = "Select a public room to quickly join a game.";
    heading.style.fontSize = "14px";
    heading.style.opacity = "0.9";
    if (RoomService.isDiscordActivity()) {
      const discordWarning = document.createElement("div");
      discordWarning.textContent = "You are using Discord: direct join is disabled. Open the official website to join a room.";
      discordWarning.style.fontSize = "13px";
      discordWarning.style.lineHeight = "1.4";
      discordWarning.style.padding = "10px 12px";
      discordWarning.style.borderRadius = "8px";
      discordWarning.style.background = "#2e1f1f";
      discordWarning.style.color = "#ffb4a2";
      discordWarning.style.border = "1px solid rgba(255, 140, 105, 0.35)";
      container.appendChild(discordWarning);
    }
    const headerRow = document.createElement("div");
    headerRow.style.display = "flex";
    headerRow.style.alignItems = "center";
    headerRow.style.gap = "12px";
    headerRow.style.width = "100%";
    headerRow.style.margin = "12px 0 6px";
    headerRow.appendChild(heading);
    container.appendChild(headerRow);
    const listWrapper = document.createElement("div");
    listWrapper.style.height = "54vh";
    listWrapper.style.maxHeight = "54vh";
    listWrapper.style.overflowY = "auto";
    listWrapper.style.padding = "6px 2px";
    listWrapper.style.borderRadius = "10px";
    listWrapper.style.background = "rgba(12, 13, 20, 0.65)";
    listWrapper.style.boxShadow = "inset 0 0 0 1px rgba(255, 255, 255, 0.04)";
    listWrapper.style.width = "100%";
    listWrapper.style.boxSizing = "border-box";
    listWrapper.style.position = "relative";
    const floatingLoadingIndicator = document.createElement("div");
    floatingLoadingIndicator.style.position = "absolute";
    floatingLoadingIndicator.style.top = "14px";
    floatingLoadingIndicator.style.right = "14px";
    floatingLoadingIndicator.style.width = "28px";
    floatingLoadingIndicator.style.height = "28px";
    floatingLoadingIndicator.style.borderRadius = "999px";
    floatingLoadingIndicator.style.display = "flex";
    floatingLoadingIndicator.style.alignItems = "center";
    floatingLoadingIndicator.style.justifyContent = "center";
    floatingLoadingIndicator.style.background = "rgba(14, 16, 25, 0.9)";
    floatingLoadingIndicator.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    floatingLoadingIndicator.style.boxShadow = "0 10px 24px rgba(0, 0, 0, 0.45)";
    floatingLoadingIndicator.style.opacity = "0";
    floatingLoadingIndicator.style.visibility = "hidden";
    floatingLoadingIndicator.style.pointerEvents = "none";
    floatingLoadingIndicator.style.transition = "opacity 160ms ease, transform 160ms ease";
    floatingLoadingIndicator.style.zIndex = "3";
    const floatingLoadingSpinner = document.createElement("div");
    floatingLoadingSpinner.style.width = "16px";
    floatingLoadingSpinner.style.height = "16px";
    floatingLoadingSpinner.style.borderRadius = "999px";
    floatingLoadingSpinner.style.border = "2px solid rgba(248, 250, 252, 0.16)";
    floatingLoadingSpinner.style.borderTopColor = "#f8fafc";
    floatingLoadingSpinner.style.animation = "room-menu-spin 1s linear infinite";
    floatingLoadingIndicator.appendChild(floatingLoadingSpinner);
    const list = document.createElement("div");
    list.style.display = "grid";
    list.style.gap = "10px";
    list.style.padding = "4px";
    listWrapper.appendChild(list);
    listWrapper.appendChild(floatingLoadingIndicator);
    container.appendChild(listWrapper);
    const updateFloatingLoadingIndicator = () => {
      floatingLoadingIndicator.style.transform = `translateY(${listWrapper.scrollTop}px)`;
    };
    let isFloatingIndicatorVisible = false;
    const setLoadingState = (loading) => {
      if (loading) {
        isFloatingIndicatorVisible = true;
        updateFloatingLoadingIndicator();
        floatingLoadingIndicator.style.visibility = "visible";
        floatingLoadingIndicator.style.opacity = "1";
      } else {
        isFloatingIndicatorVisible = false;
        floatingLoadingIndicator.style.opacity = "0";
        floatingLoadingIndicator.addEventListener(
          "transitionend",
          () => {
            if (!isFloatingIndicatorVisible) {
              floatingLoadingIndicator.style.visibility = "hidden";
            }
          },
          { once: true }
        );
        window.setTimeout(() => {
          if (!isFloatingIndicatorVisible) {
            floatingLoadingIndicator.style.visibility = "hidden";
          }
        }, 220);
      }
    };
    let savedScrollTop = 0;
    listWrapper.addEventListener("scroll", () => {
      savedScrollTop = listWrapper.scrollTop;
      if (isFloatingIndicatorVisible) {
        updateFloatingLoadingIndicator();
      }
    });
    let destroyed = false;
    let requestCounter = 0;
    let firstLoad = true;
    let selectedPlayerFilter = "any";
    let currentRooms = [];
    const refreshButton = ui.btn("Refresh rooms", { size: "sm", icon: "\u{1F504}" });
    refreshButton.style.flexShrink = "0";
    refreshButton.setAttribute("aria-label", "Refresh public rooms list");
    const statusBar = document.createElement("div");
    statusBar.style.fontSize = "12px";
    statusBar.style.opacity = "0.75";
    statusBar.style.marginLeft = "auto";
    statusBar.style.textAlign = "right";
    statusBar.textContent = "Loading rooms\u2026";
    const footer = document.createElement("div");
    footer.style.display = "flex";
    footer.style.alignItems = "center";
    footer.style.gap = "12px";
    footer.style.marginTop = "8px";
    footer.style.width = "100%";
    footer.appendChild(refreshButton);
    footer.appendChild(statusBar);
    container.appendChild(footer);
    let isRefreshing = false;
    const updateRefreshButtonState = () => {
      const enabled = !destroyed && !isRefreshing;
      ui.setButtonEnabled(refreshButton, enabled);
      refreshButton.setAttribute("aria-busy", isRefreshing ? "true" : "false");
    };
    const matchesPlayerFilter = (room) => {
      switch (selectedPlayerFilter) {
        case "any":
          return true;
        case "empty":
          return room.players === 0;
        case "few":
          return room.players > 0 && room.players <= 3;
        case "crowded":
          return !room.isFull && room.players >= 4;
        case "full":
          return room.isFull;
        default:
          return true;
      }
    };
    const renderRooms = (rooms) => {
      currentRooms = rooms;
      list.innerHTML = "";
      const visibleRooms = rooms.filter((room) => matchesPlayerFilter(room));
      if (!visibleRooms.length) {
        const empty = document.createElement("div");
        empty.textContent = rooms.length ? "No rooms match the selected filter." : "No public rooms available.";
        empty.style.padding = "16px";
        empty.style.textAlign = "center";
        empty.style.opacity = "0.7";
        list.appendChild(empty);
      } else {
        for (const room of visibleRooms) {
          list.appendChild(createRoomEntry(room, ui));
        }
      }
      requestAnimationFrame(() => {
        const maxScroll = Math.max(0, listWrapper.scrollHeight - listWrapper.clientHeight);
        const nextScroll = Math.min(savedScrollTop, maxScroll);
        listWrapper.scrollTop = nextScroll;
        savedScrollTop = nextScroll;
      });
    };
    const playerFilterContainer = document.createElement("div");
    playerFilterContainer.style.display = "flex";
    playerFilterContainer.style.alignItems = "center";
    playerFilterContainer.style.gap = "6px";
    playerFilterContainer.style.padding = "4px 6px";
    playerFilterContainer.style.background = "rgba(24, 26, 36, 0.85)";
    playerFilterContainer.style.borderRadius = "10px";
    playerFilterContainer.style.boxShadow = "inset 0 0 0 1px rgba(255, 255, 255, 0.05)";
    const playerFilterLabel = document.createElement("span");
    playerFilterLabel.textContent = "Players";
    playerFilterLabel.style.fontSize = "12px";
    playerFilterLabel.style.opacity = "0.75";
    playerFilterLabel.style.paddingLeft = "2px";
    playerFilterContainer.appendChild(playerFilterLabel);
    const playerFilterSelect = document.createElement("select");
    playerFilterSelect.style.background = "rgba(17, 18, 27, 0.95)";
    playerFilterSelect.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    playerFilterSelect.style.color = "#f8fafc";
    playerFilterSelect.style.borderRadius = "8px";
    playerFilterSelect.style.padding = "4px 10px";
    playerFilterSelect.style.fontSize = "12px";
    playerFilterSelect.style.fontWeight = "500";
    playerFilterSelect.style.outline = "none";
    playerFilterSelect.style.cursor = "pointer";
    playerFilterSelect.style.minWidth = "130px";
    const playerFilters = [
      { value: "any", label: "Any players" },
      { value: "empty", label: "Empty rooms" },
      { value: "few", label: "1 - 3 players" },
      { value: "crowded", label: "4 - 5 players" },
      { value: "full", label: "Full rooms" }
    ];
    for (const option of playerFilters) {
      const opt = document.createElement("option");
      opt.value = option.value;
      opt.textContent = option.label;
      playerFilterSelect.appendChild(opt);
    }
    playerFilterSelect.value = selectedPlayerFilter;
    playerFilterSelect.addEventListener("change", () => {
      selectedPlayerFilter = playerFilterSelect.value;
      savedScrollTop = 0;
      renderRooms(currentRooms);
    });
    playerFilterContainer.appendChild(playerFilterSelect);
    playerFilterContainer.style.marginLeft = "auto";
    headerRow.appendChild(playerFilterContainer);
    const refreshRooms = async () => {
      if (destroyed) return;
      const currentRequest = ++requestCounter;
      isRefreshing = true;
      updateRefreshButtonState();
      setLoadingState(true);
      statusBar.textContent = firstLoad ? "Loading rooms..." : "Refreshing rooms...";
      try {
        const available = await fetchAvailableRooms(100);
        if (destroyed || currentRequest !== requestCounter) return;
        const publicRooms = available.filter((room) => !room.isPrivate).map(transformSupabaseRoom).sort((a, b) => {
          if (b.players === a.players) {
            return b.lastUpdatedAt - a.lastUpdatedAt;
          }
          return b.players - a.players;
        });
        renderRooms(publicRooms);
        const time = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true
        });
        statusBar.textContent = `Last update: ${time}`;
      } catch (error) {
        if (destroyed || currentRequest !== requestCounter) return;
        statusBar.textContent = `Failed to load rooms: ${String(error?.message || error)}`;
      } finally {
        if (!destroyed && currentRequest === requestCounter) {
          setLoadingState(false);
        }
        if (currentRequest === requestCounter) {
          isRefreshing = false;
        }
        updateRefreshButtonState();
        firstLoad = false;
      }
    };
    refreshButton.addEventListener("click", () => {
      void refreshRooms();
    });
    updateRefreshButtonState();
    refreshRooms();
    const windowEl = view.closest(".qws-win");
    const computeWindowVisible = (win) => !win.classList.contains("is-hidden") && getComputedStyle(win).display !== "none";
    let visibilityObserver = null;
    if (windowEl) {
      let lastVisible = computeWindowVisible(windowEl);
      visibilityObserver = new MutationObserver(() => {
        if (destroyed) return;
        const isVisible3 = computeWindowVisible(windowEl);
        if (isVisible3 && !lastVisible) {
          void refreshRooms();
        }
        lastVisible = isVisible3;
      });
      visibilityObserver.observe(windowEl, { attributes: true, attributeFilter: ["class", "style"] });
    }
    const previousCleanup = view.__cleanup__;
    view.__cleanup__ = () => {
      destroyed = true;
      visibilityObserver?.disconnect();
      updateRefreshButtonState();
      if (typeof previousCleanup === "function") {
        try {
          previousCleanup.call(view);
        } catch {
        }
      }
    };
  }
  var DEFAULT_SUPABASE_ROOM_CAPACITY = 6;
  var SUPABASE_ROOM_CATEGORY = "Supabase";
  function transformSupabaseRoom(room) {
    const rawCount = Number.isFinite(room.playersCount) ? Math.floor(room.playersCount) : 0;
    const players = Math.max(0, rawCount);
    const capacity = DEFAULT_SUPABASE_ROOM_CAPACITY;
    const parsedTimestamp = Number.isFinite(Date.parse(room.lastUpdatedAt)) ? Date.parse(room.lastUpdatedAt) : Date.now();
    const playerDetails = (room.userSlots ?? []).map((slot, index) => {
      const name = slot?.name?.trim();
      return {
        name: name && name.length ? name : "Unknown player",
        isConnected: true,
        discordAvatarUrl: slot?.avatarUrl ?? void 0,
        isHost: index === 0
      };
    });
    return {
      name: room.id,
      idRoom: room.id,
      category: SUPABASE_ROOM_CATEGORY,
      players: Math.min(players, capacity),
      capacity,
      isFull: players >= capacity,
      lastUpdatedAt: parsedTimestamp,
      hostPlayerId: room.lastUpdatedByPlayerId ?? void 0,
      playerDetails
    };
  }
  function renderSearchPlayerTab(view, ui) {
    view.innerHTML = "";
    ensureRoomMenuStyles();
    const root = document.createElement("div");
    root.style.display = "flex";
    root.style.flexDirection = "column";
    root.style.alignItems = "center";
    root.style.padding = "12px";
    root.style.boxSizing = "border-box";
    root.style.height = "100%";
    view.appendChild(root);
    const container = document.createElement("div");
    container.style.display = "grid";
    container.style.gap = "12px";
    container.style.width = "100%";
    container.style.maxWidth = "640px";
    container.style.gridTemplateRows = "max-content max-content max-content 1fr";
    container.style.height = "100%";
    root.appendChild(container);
    const heading = document.createElement("div");
    heading.textContent = "Search for a player across all available rooms.";
    heading.style.fontSize = "14px";
    heading.style.opacity = "0.9";
    container.appendChild(heading);
    const description = document.createElement("div");
    description.textContent = "Enter at least three characters to look for matching player names.";
    description.style.fontSize = "12px";
    description.style.opacity = "0.72";
    description.style.lineHeight = "1.45";
    container.appendChild(description);
    const form = document.createElement("form");
    form.style.display = "flex";
    form.style.flexWrap = "wrap";
    form.style.alignItems = "center";
    form.style.gap = "8px";
    container.appendChild(form);
    const searchInput = document.createElement("input");
    searchInput.type = "search";
    searchInput.placeholder = "Player name\u2026";
    searchInput.autocomplete = "off";
    searchInput.spellcheck = false;
    searchInput.style.flex = "1";
    searchInput.style.minWidth = "200px";
    searchInput.style.padding = "10px 12px";
    searchInput.style.borderRadius = "10px";
    searchInput.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    searchInput.style.background = "rgba(17, 18, 27, 0.95)";
    searchInput.style.color = "#f8fafc";
    searchInput.style.fontSize = "13px";
    searchInput.style.fontWeight = "500";
    searchInput.style.outline = "none";
    searchInput.style.boxShadow = "0 6px 16px rgba(15, 23, 42, 0.45)";
    form.appendChild(searchInput);
    const searchButton = ui.btn("Search", { size: "sm", icon: "search", variant: "primary" });
    searchButton.type = "submit";
    searchButton.style.flexShrink = "0";
    searchButton.title = "Search for a player across rooms";
    form.appendChild(searchButton);
    const statusMessage = document.createElement("div");
    statusMessage.style.fontSize = "12px";
    statusMessage.style.opacity = "0.75";
    statusMessage.style.minHeight = "18px";
    statusMessage.textContent = "Enter a player name to search across rooms.";
    container.appendChild(statusMessage);
    const listWrapper = document.createElement("div");
    listWrapper.style.height = "54vh";
    listWrapper.style.maxHeight = "54vh";
    listWrapper.style.overflowY = "auto";
    listWrapper.style.padding = "6px 2px";
    listWrapper.style.borderRadius = "10px";
    listWrapper.style.background = "rgba(12, 13, 20, 0.65)";
    listWrapper.style.boxShadow = "inset 0 0 0 1px rgba(255, 255, 255, 0.04)";
    listWrapper.style.width = "100%";
    listWrapper.style.boxSizing = "border-box";
    listWrapper.style.position = "relative";
    const floatingLoadingIndicator = document.createElement("div");
    floatingLoadingIndicator.style.position = "absolute";
    floatingLoadingIndicator.style.top = "14px";
    floatingLoadingIndicator.style.right = "14px";
    floatingLoadingIndicator.style.width = "28px";
    floatingLoadingIndicator.style.height = "28px";
    floatingLoadingIndicator.style.borderRadius = "999px";
    floatingLoadingIndicator.style.display = "flex";
    floatingLoadingIndicator.style.alignItems = "center";
    floatingLoadingIndicator.style.justifyContent = "center";
    floatingLoadingIndicator.style.background = "rgba(14, 16, 25, 0.9)";
    floatingLoadingIndicator.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    floatingLoadingIndicator.style.boxShadow = "0 10px 24px rgba(0, 0, 0, 0.45)";
    floatingLoadingIndicator.style.opacity = "0";
    floatingLoadingIndicator.style.visibility = "hidden";
    floatingLoadingIndicator.style.pointerEvents = "none";
    floatingLoadingIndicator.style.transition = "opacity 160ms ease, transform 160ms ease";
    floatingLoadingIndicator.style.zIndex = "3";
    const floatingLoadingSpinner = document.createElement("div");
    floatingLoadingSpinner.style.width = "16px";
    floatingLoadingSpinner.style.height = "16px";
    floatingLoadingSpinner.style.borderRadius = "999px";
    floatingLoadingSpinner.style.border = "2px solid rgba(248, 250, 252, 0.16)";
    floatingLoadingSpinner.style.borderTopColor = "#f8fafc";
    floatingLoadingSpinner.style.animation = "room-menu-spin 1s linear infinite";
    floatingLoadingIndicator.appendChild(floatingLoadingSpinner);
    const list = document.createElement("div");
    list.style.display = "grid";
    list.style.gap = "10px";
    list.style.padding = "4px";
    listWrapper.appendChild(list);
    listWrapper.appendChild(floatingLoadingIndicator);
    container.appendChild(listWrapper);
    const renderEmptyState = (message) => {
      list.innerHTML = "";
      const empty = document.createElement("div");
      empty.textContent = message;
      empty.style.padding = "16px";
      empty.style.textAlign = "center";
      empty.style.opacity = "0.7";
      empty.style.fontSize = "13px";
      list.appendChild(empty);
    };
    renderEmptyState("Search results will appear here.");
    const updateFloatingLoadingIndicator = () => {
      floatingLoadingIndicator.style.transform = `translateY(${listWrapper.scrollTop}px)`;
    };
    let isFloatingIndicatorVisible = false;
    const setLoadingState = (loading) => {
      if (loading) {
        isFloatingIndicatorVisible = true;
        updateFloatingLoadingIndicator();
        floatingLoadingIndicator.style.visibility = "visible";
        floatingLoadingIndicator.style.opacity = "1";
      } else {
        isFloatingIndicatorVisible = false;
        floatingLoadingIndicator.style.opacity = "0";
        floatingLoadingIndicator.addEventListener(
          "transitionend",
          () => {
            if (!isFloatingIndicatorVisible) {
              floatingLoadingIndicator.style.visibility = "hidden";
            }
          },
          { once: true }
        );
        window.setTimeout(() => {
          if (!isFloatingIndicatorVisible) {
            floatingLoadingIndicator.style.visibility = "hidden";
          }
        }, 220);
      }
    };
    listWrapper.addEventListener("scroll", () => {
      if (isFloatingIndicatorVisible) {
        updateFloatingLoadingIndicator();
      }
    });
    let isLoading = false;
    let destroyed = false;
    let requestCounter = 0;
    let lastQueryLabel = "";
    const updateSearchButtonState = () => {
      const hasQuery = searchInput.value.trim().length >= 3;
      ui.setButtonEnabled(searchButton, hasQuery && !isLoading);
      searchButton.setAttribute("aria-busy", isLoading ? "true" : "false");
    };
    const normalizeSearchText = (value) => {
      const trimmed = value.trim();
      if (!trimmed) return "";
      try {
        return trimmed.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
      } catch {
        return trimmed.toLowerCase();
      }
    };
    const createHighlightMatcher = (players) => {
      const ids = /* @__PURE__ */ new Set();
      const databaseIds = /* @__PURE__ */ new Set();
      const names = /* @__PURE__ */ new Set();
      for (const player2 of players) {
        if (player2.id) ids.add(player2.id);
        if (player2.databaseUserId) databaseIds.add(player2.databaseUserId);
        names.add(normalizeSearchText(player2.name));
      }
      return (player2) => {
        if (player2.id && ids.has(player2.id)) return true;
        if (player2.databaseUserId && databaseIds.has(player2.databaseUserId)) return true;
        return names.has(normalizeSearchText(player2.name));
      };
    };
    const performSearch = async (rawQuery) => {
      const trimmedQuery = rawQuery.trim();
      const normalizedQuery = normalizeSearchText(trimmedQuery);
      if (!normalizedQuery) {
        statusMessage.textContent = "Enter a player name to search across rooms.";
        renderEmptyState("Search results will appear here.");
        lastQueryLabel = "";
        return;
      }
      if (trimmedQuery.length < 3) {
        statusMessage.textContent = "Please enter at least three characters.";
        renderEmptyState("Type a longer name to search for players.");
        lastQueryLabel = "";
        return;
      }
      const currentRequest = ++requestCounter;
      isLoading = true;
      updateSearchButtonState();
      setLoadingState(true);
      statusMessage.textContent = "Searching players...";
      try {
        const results = await searchRoomsByPlayerName(trimmedQuery, {
          limitRooms: 200,
          minQueryLength: 3
        });
        if (destroyed || currentRequest !== requestCounter) return;
        if (!results.length) {
          statusMessage.textContent = `No players found matching "${trimmedQuery}".`;
          renderEmptyState("No rooms contain a player with this name.");
          lastQueryLabel = trimmedQuery;
          return;
        }
        const matches = results.map((result) => {
          const baseRoom = transformSupabaseRoom(result.room);
          const matchedPlayers = result.matchedSlots?.map((slot) => ({
            name: slot.name?.trim() || "Unknown player",
            isConnected: true,
            isHost: false,
            discordAvatarUrl: slot.avatarUrl ?? void 0
          })) ?? [];
          return {
            room: baseRoom,
            players: matchedPlayers
          };
        }).filter((match) => match.players.length > 0);
        if (!matches.length) {
          statusMessage.textContent = `No players found matching "${trimmedQuery}".`;
          renderEmptyState("No rooms contain a player with this name.");
          lastQueryLabel = trimmedQuery;
          return;
        }
        matches.sort((a, b) => {
          const diffPlayers = b.room.players - a.room.players;
          if (diffPlayers !== 0) return diffPlayers;
          if (b.players.length !== a.players.length) {
            return b.players.length - a.players.length;
          }
          return a.room.name.localeCompare(b.room.name);
        });
        const totalPlayers = matches.reduce((sum, match) => sum + match.players.length, 0);
        const roomsLabel = matches.length === 1 ? "room" : "rooms";
        const playersLabel = totalPlayers === 1 ? "player" : "players";
        statusMessage.textContent = `Found ${totalPlayers} ${playersLabel} in ${matches.length} ${roomsLabel}.`;
        list.innerHTML = "";
        let isFirstMatch = true;
        for (const match of matches) {
          const highlightMatcher = createHighlightMatcher(match.players);
          const entry = createRoomEntry(match.room, ui, {
            highlightPlayers: highlightMatcher,
            defaultDetailsOpen: true,
            scrollHighlightedPlayersIntoView: isFirstMatch
          });
          list.appendChild(entry);
          isFirstMatch = false;
        }
        lastQueryLabel = trimmedQuery;
      } catch (error) {
        if (destroyed || currentRequest !== requestCounter) return;
        const message = error?.message || String(error);
        statusMessage.textContent = `Search failed: ${message}`;
        renderEmptyState("Unable to complete the search. Please try again.");
      } finally {
        if (!destroyed && currentRequest === requestCounter) {
          isLoading = false;
          setLoadingState(false);
          updateSearchButtonState();
        }
      }
    };
    form.addEventListener("submit", (event) => {
      event.preventDefault();
      void performSearch(searchInput.value);
    });
    searchInput.addEventListener("input", () => {
      updateSearchButtonState();
      const trimmed = searchInput.value.trim();
      if (!trimmed && lastQueryLabel) {
        statusMessage.textContent = "Enter a player name to search across rooms.";
        renderEmptyState("Search results will appear here.");
        lastQueryLabel = "";
      } else if (!isLoading && trimmed.length > 0 && trimmed.length < 3) {
        statusMessage.textContent = "Type at least three characters to start a search.";
      }
    });
    updateSearchButtonState();
    view.__cleanup__ = () => {
      destroyed = true;
    };
  }
  function getCurrentRoomCode() {
    const match = /^\/r\/([^/]+)/.exec(location.pathname);
    if (!match) return null;
    try {
      return decodeURIComponent(match[1]);
    } catch {
      return match[1];
    }
  }
  function createRoomEntry(room, ui, options) {
    const isDiscord = RoomService.isDiscordActivity();
    const currentRoomCode = getCurrentRoomCode();
    const isCurrentRoom = currentRoomCode === room.idRoom;
    const playerDetails = Array.isArray(room.playerDetails) ? room.playerDetails : [];
    const wrapper = document.createElement("div");
    wrapper.style.display = "grid";
    wrapper.style.gap = "8px";
    wrapper.style.padding = "14px 16px";
    wrapper.style.borderRadius = "14px";
    wrapper.style.background = "linear-gradient(135deg, rgba(30, 33, 46, 0.95), rgba(18, 19, 28, 0.95))";
    wrapper.style.boxShadow = "0 10px 20px rgba(0, 0, 0, 0.35)";
    wrapper.style.position = "relative";
    const detailsContainer = document.createElement("div");
    detailsContainer.style.overflow = "hidden";
    detailsContainer.style.maxHeight = "0";
    detailsContainer.style.opacity = "0";
    detailsContainer.style.transition = "max-height 0.25s ease, opacity 0.2s ease, margin-top 0.2s ease";
    detailsContainer.style.marginTop = "0";
    const detailsContent = document.createElement("div");
    detailsContent.style.display = "grid";
    detailsContent.style.gap = "10px";
    detailsContent.style.paddingTop = "12px";
    detailsContent.style.paddingLeft = "6px";
    detailsContent.style.paddingRight = "6px";
    detailsContent.style.paddingBottom = "4px";
    detailsContent.style.borderTop = "1px solid rgba(148, 163, 184, 0.16)";
    detailsContainer.appendChild(detailsContent);
    const detailsTitle = document.createElement("div");
    detailsTitle.textContent = "Players";
    detailsTitle.style.fontSize = "13px";
    detailsTitle.style.fontWeight = "600";
    detailsTitle.style.letterSpacing = "0.02em";
    detailsTitle.style.color = "#e2e8f0";
    detailsContent.appendChild(detailsTitle);
    const highlightedPlayerElements = [];
    if (playerDetails.length) {
      const list = document.createElement("ul");
      list.style.listStyle = "none";
      list.style.margin = "0";
      list.style.padding = "0";
      list.style.display = "grid";
      list.style.gap = "10px";
      list.style.gridTemplateColumns = "repeat(2, minmax(0, 1fr))";
      for (const player2 of playerDetails) {
        const item = document.createElement("li");
        item.style.display = "flex";
        item.style.alignItems = "center";
        item.style.gap = "12px";
        item.style.padding = "6px 0";
        const avatarWrapper = document.createElement("div");
        avatarWrapper.style.width = "36px";
        avatarWrapper.style.height = "36px";
        avatarWrapper.style.borderRadius = "999px";
        avatarWrapper.style.overflow = "hidden";
        avatarWrapper.style.flexShrink = "0";
        avatarWrapper.style.display = "grid";
        avatarWrapper.style.placeItems = "center";
        avatarWrapper.style.border = "1px solid rgba(148, 163, 184, 0.25)";
        avatarWrapper.style.background = "linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(14, 165, 233, 0.2))";
        if (player2.discordAvatarUrl) {
          const img = document.createElement("img");
          img.src = player2.discordAvatarUrl;
          img.alt = `${player2.name}'s avatar`;
          img.loading = "lazy";
          img.style.width = "100%";
          img.style.height = "100%";
          img.style.objectFit = "cover";
          avatarWrapper.appendChild(img);
        } else {
          const initials = document.createElement("span");
          initials.textContent = player2.name.charAt(0)?.toUpperCase() || "?";
          initials.style.fontWeight = "600";
          initials.style.fontSize = "14px";
          initials.style.color = "#e2e8f0";
          avatarWrapper.appendChild(initials);
        }
        const playerInfo = document.createElement("div");
        playerInfo.style.display = "grid";
        playerInfo.style.gap = "4px";
        const nameRow2 = document.createElement("div");
        nameRow2.style.display = "flex";
        nameRow2.style.alignItems = "center";
        nameRow2.style.gap = "8px";
        const playerName = document.createElement("div");
        playerName.textContent = player2.name;
        playerName.style.fontWeight = "600";
        playerName.style.fontSize = "14px";
        playerName.style.color = "#f8fafc";
        nameRow2.appendChild(playerName);
        const statusRow = document.createElement("div");
        statusRow.style.display = "flex";
        statusRow.style.alignItems = "center";
        statusRow.style.gap = "10px";
        statusRow.style.fontSize = "11px";
        statusRow.style.color = "rgba(226, 232, 240, 0.75)";
        const presence = document.createElement("span");
        presence.style.display = "inline-flex";
        presence.style.alignItems = "center";
        presence.style.gap = "6px";
        const presenceDot = document.createElement("span");
        presenceDot.style.width = "8px";
        presenceDot.style.height = "8px";
        presenceDot.style.borderRadius = "999px";
        presenceDot.style.background = player2.isConnected ? "#34d399" : "#f97316";
        presence.appendChild(presenceDot);
        presence.append(player2.isConnected ? "Online" : "Offline");
        statusRow.appendChild(presence);
        playerInfo.append(nameRow2, statusRow);
        item.append(avatarWrapper, playerInfo);
        if (options?.highlightPlayers?.(player2)) {
          item.style.background = "rgba(34, 197, 94, 0.12)";
          item.style.borderRadius = "12px";
          item.style.padding = "10px";
          item.style.margin = "-2px";
          item.style.boxShadow = "inset 0 0 0 1px rgba(34, 197, 94, 0.35)";
          avatarWrapper.style.border = "1px solid rgba(74, 222, 128, 0.65)";
          playerName.style.color = "#bbf7d0";
          statusRow.style.color = "rgba(190, 242, 100, 0.85)";
          presenceDot.style.background = "#4ade80";
          item.dataset.highlightedPlayer = "true";
          highlightedPlayerElements.push(item);
        }
        list.appendChild(item);
      }
      detailsContent.appendChild(list);
    } else {
      const emptyState = document.createElement("div");
      emptyState.textContent = room.error ? "Player details unavailable." : "No player details available.";
      emptyState.style.fontSize = "12px";
      emptyState.style.color = "rgba(226, 232, 240, 0.7)";
      detailsContent.appendChild(emptyState);
    }
    const accentColor = (() => {
      if (room.error) return "rgba(248, 180, 127, 0.9)";
      if (room.isFull) return "rgba(248, 113, 113, 0.85)";
      if (room.players <= 5) return "rgba(74, 222, 128, 0.75)";
      return "rgba(96, 165, 250, 0.45)";
    })();
    wrapper.style.setProperty("--accent-color", accentColor);
    wrapper.style.outline = "2px solid transparent";
    wrapper.style.outlineOffset = "0";
    wrapper.style.border = "1px solid rgba(255, 255, 255, 0.05)";
    wrapper.style.boxShadow = "0 10px 20px rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(255, 255, 255, 0.04), 0 0 0 2px var(--accent-color)";
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.flexWrap = "wrap";
    header.style.alignItems = "center";
    header.style.justifyContent = "space-between";
    header.style.gap = "12px";
    const nameBlock = document.createElement("div");
    nameBlock.style.display = "grid";
    nameBlock.style.gap = "6px";
    const nameRow = document.createElement("div");
    nameRow.style.display = "flex";
    nameRow.style.alignItems = "center";
    nameRow.style.gap = "10px";
    const name = document.createElement("div");
    name.textContent = room.name;
    name.style.fontWeight = "600";
    name.style.fontSize = "16px";
    name.style.letterSpacing = "0.01em";
    name.style.color = "#f8fafc";
    const categoryPill = document.createElement("span");
    categoryPill.textContent = room.category;
    categoryPill.style.fontSize = "11px";
    categoryPill.style.letterSpacing = "0.08em";
    categoryPill.style.textTransform = "uppercase";
    categoryPill.style.padding = "4px 8px";
    categoryPill.style.borderRadius = "999px";
    categoryPill.style.background = "rgba(148, 163, 184, 0.12)";
    categoryPill.style.border = "1px solid rgba(148, 163, 184, 0.22)";
    categoryPill.style.color = "#cbd5f5";
    nameRow.append(name, categoryPill);
    nameBlock.appendChild(nameRow);
    if (room.currentGame && room.currentGame.toLowerCase() !== "quinoa") {
      const gameLabel = document.createElement("div");
      gameLabel.textContent = room.currentGame;
      gameLabel.style.fontSize = "12px";
      gameLabel.style.opacity = "0.7";
      gameLabel.style.color = "#e0f2fe";
      nameBlock.appendChild(gameLabel);
    }
    const occupancyBlock = document.createElement("div");
    occupancyBlock.style.display = "grid";
    occupancyBlock.style.gap = "6px";
    occupancyBlock.style.minWidth = "120px";
    const meter = document.createElement("div");
    meter.style.position = "relative";
    meter.style.height = "20px";
    meter.style.borderRadius = "999px";
    meter.style.background = "rgba(255, 255, 255, 0.08)";
    meter.style.overflow = "hidden";
    meter.style.display = "flex";
    meter.style.alignItems = "center";
    meter.style.justifyContent = "center";
    meter.style.fontWeight = "600";
    meter.style.fontSize = "12px";
    meter.style.color = "#f8fafc";
    meter.style.fontVariantNumeric = "tabular-nums";
    meter.style.textShadow = "0 1px 2px rgba(0, 0, 0, 0.55)";
    const meterFill = document.createElement("div");
    meterFill.style.position = "absolute";
    meterFill.style.left = "0";
    meterFill.style.top = "0";
    meterFill.style.bottom = "0";
    meterFill.style.height = "100%";
    meterFill.style.width = `${Math.min(100, room.players / room.capacity * 100)}%`;
    meterFill.style.background = room.isFull ? "linear-gradient(90deg, #ef4444, #f87171)" : "linear-gradient(90deg, #34d399, #2dd4bf)";
    meterFill.style.borderRadius = "inherit";
    meter.appendChild(meterFill);
    const meterLabel = document.createElement("span");
    meterLabel.textContent = `${room.players} / ${room.capacity} players`;
    meterLabel.style.position = "relative";
    meterLabel.style.zIndex = "1";
    meter.appendChild(meterLabel);
    occupancyBlock.appendChild(meter);
    const actionBlock = document.createElement("div");
    actionBlock.style.display = "grid";
    actionBlock.style.justifyItems = "end";
    actionBlock.style.gap = "6px";
    const chevron = document.createElement("span");
    chevron.textContent = "\u25BE";
    chevron.style.display = "inline-block";
    chevron.style.transition = "transform 0.2s ease";
    chevron.style.transform = "rotate(-90deg)";
    const detailsBtn = ui.btn("Details", { size: "sm", variant: "ghost", icon: chevron });
    detailsBtn.style.minWidth = "86px";
    detailsBtn.style.justifyContent = "center";
    detailsBtn.title = playerDetails.length ? "Show the players currently in this room." : room.error ? "Player details unavailable." : "No player details available.";
    actionBlock.appendChild(detailsBtn);
    const joinBtn = ui.btn("Join", { size: "sm", variant: "primary" });
    joinBtn.style.minWidth = "86px";
    joinBtn.style.boxShadow = "0 4px 10px rgba(56, 189, 248, 0.35)";
    actionBlock.appendChild(joinBtn);
    if (options?.onRemove) {
      const removeBtn = ui.btn("Remove", { size: "sm", variant: "danger" });
      removeBtn.style.minWidth = "86px";
      removeBtn.addEventListener("click", (event) => {
        event.stopPropagation();
        options.onRemove?.();
      });
      removeBtn.title = `Remove ${room.name} from custom rooms`;
      actionBlock.appendChild(removeBtn);
    }
    const reasons = [];
    if (room.error) reasons.push("Status unavailable");
    if (room.isFull) reasons.push("Room is full");
    if (isDiscord) reasons.push("Join is blocked on Discord");
    if (isCurrentRoom) reasons.push("Already in this room");
    const canJoin = !isCurrentRoom && RoomService.canJoinPublicRoom(room);
    ui.setButtonEnabled(joinBtn, canJoin);
    joinBtn.title = canJoin ? `Join ${room.name}` : reasons.join(" \xB7 ");
    joinBtn.addEventListener("click", () => {
      if (isCurrentRoom) return;
      if (!RoomService.canJoinPublicRoom(room)) return;
      RoomService.joinPublicRoom(room);
    });
    const labelSpan = detailsBtn.querySelector(".label");
    let detailsExpanded = options?.defaultDetailsOpen ?? false;
    const applyDetailsState = () => {
      if (detailsExpanded) {
        const targetHeight = `${detailsContent.scrollHeight}px`;
        detailsContainer.style.maxHeight = targetHeight;
        detailsContainer.style.opacity = "1";
        detailsContainer.style.marginTop = "8px";
        detailsBtn.setAttribute("aria-expanded", "true");
        if (labelSpan) labelSpan.textContent = "Hide details";
        chevron.style.transform = "rotate(0deg)";
      } else {
        detailsContainer.style.maxHeight = "0";
        detailsContainer.style.opacity = "0";
        detailsContainer.style.marginTop = "0";
        detailsBtn.setAttribute("aria-expanded", "false");
        if (labelSpan) labelSpan.textContent = "Details";
        chevron.style.transform = "rotate(-90deg)";
      }
    };
    detailsBtn.addEventListener("click", () => {
      detailsExpanded = !detailsExpanded;
      applyDetailsState();
    });
    header.append(nameBlock, occupancyBlock, actionBlock);
    wrapper.appendChild(header);
    const badgeRow = document.createElement("div");
    badgeRow.style.display = "flex";
    badgeRow.style.flexWrap = "wrap";
    badgeRow.style.gap = "6px";
    const addBadge = (label2, color, background) => {
      const badge = document.createElement("span");
      badge.textContent = label2;
      badge.style.fontSize = "11px";
      badge.style.padding = "4px 8px";
      badge.style.borderRadius = "999px";
      badge.style.fontWeight = "600";
      badge.style.letterSpacing = "0.04em";
      badge.style.textTransform = "uppercase";
      badge.style.color = color;
      badge.style.background = background;
      badge.style.border = `1px solid ${color}33`;
      badgeRow.appendChild(badge);
    };
    if (isCurrentRoom) {
      addBadge("Current room", "#86efac", "rgba(34, 197, 94, 0.12)");
    }
    if (room.error) {
      addBadge("Status unavailable", "#fbbf24", "rgba(250, 204, 21, 0.1)");
    }
    if (isDiscord) {
      addBadge("Discord activity", "#facc15", "rgba(251, 191, 36, 0.12)");
    }
    if (badgeRow.childElementCount > 0) {
      wrapper.appendChild(badgeRow);
    }
    wrapper.appendChild(detailsContainer);
    applyDetailsState();
    if (detailsExpanded || options?.scrollHighlightedPlayersIntoView) {
      window.requestAnimationFrame(() => {
        if (!detailsExpanded) return;
        applyDetailsState();
        if (options?.scrollHighlightedPlayersIntoView && highlightedPlayerElements.length) {
          const target = highlightedPlayerElements[0];
          window.requestAnimationFrame(() => {
            target.scrollIntoView({ block: "nearest", behavior: "smooth" });
          });
        }
      });
    }
    return wrapper;
  }
  async function readPlayers() {
    return PlayersService.list();
  }
  var NF_US_INT = new Intl.NumberFormat("en-US", { maximumFractionDigits: 0 });
  function truncateLabel(s, max = 22) {
    if (!s) return "";
    return s.length <= max ? s : s.slice(0, max - 1) + "\u2026";
  }
  var vItem = (p) => ({
    id: p.id,
    title: truncateLabel(p.name || p.id, 9),
    subtitle: p.isConnected ? "Online" : "Offline",
    avatarUrl: p.discordAvatarUrl || "",
    statusColor: p.isConnected ? "#48d170" : "#999a"
  });
  async function renderPlayersTab(root) {
    const ui = new Menu({ id: "players", compact: true, windowSelector: ".qws-win" });
    ui.mount(root);
    const panel = ui.root.querySelector(".qmm-views");
    const { root: split, left, right } = ui.split2("260px");
    panel.appendChild(split);
    split.style.height = "100%";
    split.style.minHeight = "0";
    left.style.display = "flex";
    left.style.flexDirection = "column";
    left.style.minHeight = "0";
    right.style.minHeight = "0";
    right.style.overflow = "auto";
    const vt = ui.vtabs({
      filterPlaceholder: "Find player\u2026",
      onSelect: (_id, item) => renderRight(item?.id || null),
      fillAvailableHeight: true
    });
    vt.root.style.display = "flex";
    vt.root.style.flexDirection = "column";
    vt.root.style.flex = "1 1 auto";
    vt.root.style.minHeight = "0";
    left.appendChild(vt.root);
    const filter = vt.root.querySelector(".filter");
    if (filter) {
      filter.remove();
    }
    async function renderRight(playerId2) {
      right.innerHTML = "";
      const p = playerId2 ? players.find((x) => x.id === playerId2) || null : null;
      if (!p) {
        const empty = document.createElement("div");
        empty.style.opacity = "0.75";
        empty.textContent = "Select a player on the left.";
        right.appendChild(empty);
        return;
      }
      const col = document.createElement("div");
      col.style.display = "grid";
      col.style.gridAutoRows = "min-content";
      col.style.justifyItems = "center";
      col.style.gap = "10px";
      col.style.overflow = "auto";
      right.appendChild(col);
      const prof = document.createElement("div");
      prof.style.display = "grid";
      prof.style.gap = "8px";
      prof.style.justifyItems = "center";
      const head = document.createElement("div");
      head.style.display = "flex";
      head.style.alignItems = "center";
      head.style.gap = "12px";
      const avatar = document.createElement("img");
      avatar.src = p.discordAvatarUrl || "";
      avatar.alt = p.name;
      avatar.width = 48;
      avatar.height = 48;
      avatar.style.borderRadius = "50%";
      avatar.style.objectFit = "cover";
      avatar.style.border = "1px solid #4446";
      const title = document.createElement("div");
      const nameEl = document.createElement("div");
      nameEl.textContent = p.name || p.id;
      nameEl.style.fontWeight = "600";
      nameEl.style.fontSize = "16px";
      const sub = document.createElement("div");
      sub.style.opacity = "0.8";
      sub.style.fontSize = "12px";
      sub.textContent = p.isConnected ? "Online" : "Offline";
      title.append(nameEl, sub);
      head.append(avatar, title);
      const info = document.createElement("div");
      info.style.opacity = "0.9";
      prof.append(head, info);
      col.appendChild(prof);
      const infoWrap = document.createElement("div");
      infoWrap.style.display = "grid";
      infoWrap.style.gap = "6px";
      infoWrap.style.justifySelf = "stretch";
      infoWrap.style.width = "100%";
      const invValueRow = ui.flexRow({ justify: "start", fullWidth: true, gap: 6 });
      const invLabel = document.createElement("div");
      invLabel.textContent = "Inventory: ";
      invLabel.style.fontSize = "14px";
      invLabel.style.opacity = "0.85";
      const invValue = document.createElement("div");
      invValue.textContent = "\u2026";
      invValue.style.fontSize = "15px";
      invValue.style.fontWeight = "700";
      invValue.style.color = "#FFD84D";
      invValueRow.append(invLabel, invValue);
      const gardenValueRow = ui.flexRow({ justify: "start", fullWidth: true, gap: 6 });
      const gardenLabel = document.createElement("div");
      gardenLabel.textContent = "Garden: ";
      gardenLabel.style.fontSize = "14px";
      gardenLabel.style.opacity = "0.85";
      const gardenValue = document.createElement("div");
      gardenValue.textContent = "\u2026";
      gardenValue.style.fontWeight = "700";
      gardenValue.style.fontSize = "15px";
      gardenValue.style.color = "#FFD84D";
      gardenValueRow.append(gardenLabel, gardenValue);
      infoWrap.append(invValueRow, gardenValueRow);
      const infoCard = ui.card("\u{1F331} Crops values", { tone: "muted", align: "center" });
      infoCard.body.append(infoWrap);
      col.appendChild(infoCard.root);
      const editorCard = ui.card("\u270F\uFE0F Editor", { tone: "muted", align: "center" });
      editorCard.body.style.display = "grid";
      editorCard.body.style.gap = "8px";
      const savePlayerBtn = ui.btn("Save player garden", {
        fullWidth: true,
        onClick: async () => {
          try {
            const saveFn = window.qwsEditorSaveGardenForPlayer || pageWindow?.qwsEditorSaveGardenForPlayer;
            if (typeof saveFn !== "function") {
              await toastSimple("Save garden", "Editor save unavailable", "error");
              return;
            }
            const name = `${p.name || p.id || "Player"}'s garden`;
            const saved = await saveFn(p.id, name);
            if (!saved) {
              await toastSimple("Save garden", "Save failed (no garden state)", "error");
              return;
            }
            await toastSimple(`Saved "${saved.name}".`, "success");
          } catch {
            await toastSimple(`Save failed`, "error");
          }
        }
      });
      editorCard.body.append(savePlayerBtn);
      col.appendChild(editorCard.root);
      const teleRow = ui.flexRow({ justify: "center" });
      const btnToPlayer = ui.btn("To player", { size: "sm" });
      btnToPlayer.style.minWidth = "120px";
      const btnToGarden = ui.btn("To garden", { size: "sm" });
      btnToGarden.style.minWidth = "120px";
      btnToPlayer.onclick = async () => {
        try {
          const fn = PlayersService.teleportToPlayer ?? PlayersService.teleportTo;
          await fn.call(PlayersService, p.id);
        } catch (e) {
          await toastSimple("Teleport", e?.message || "Error during teleport.", "error");
        }
      };
      btnToGarden.onclick = async () => {
        try {
          const fn = PlayersService.teleportToGarden ?? PlayersService.tptogarden;
          await fn.call(PlayersService, p.id);
        } catch (e) {
          await toastSimple("Teleport", e?.message || "Error during teleport.", "error");
        }
      };
      teleRow.append(btnToPlayer, btnToGarden);
      const teleportCard = ui.card("\u{1F30C} Teleport", { tone: "muted", align: "center" });
      teleportCard.body.append(teleRow);
      col.appendChild(teleportCard.root);
      const invRow = ui.flexRow({ justify: "center" });
      const btnInv = ui.btn("Inventory", { size: "sm" });
      btnInv.style.minWidth = "120px";
      const btnJournal = ui.btn("Journal", { size: "sm" });
      btnJournal.style.minWidth = "120px";
      const btnStats = ui.btn("Stats", { size: "sm" });
      btnStats.style.minWidth = "120px";
      const btnActivityLog = ui.btn("Activity log", { size: "sm" });
      btnActivityLog.style.minWidth = "120px";
      btnInv.onclick = async () => {
        try {
          ui.setWindowVisible(false);
          await PlayersService.openInventoryPreview(p.id, p.name);
          if (await isInventoryPanelOpen()) {
            await waitInventoryPanelClosed();
          }
        } finally {
          ui.setWindowVisible(true);
        }
      };
      btnJournal.onclick = async () => {
        try {
          ui.setWindowVisible(false);
          await PlayersService.openJournalLog(p.id, p.name);
          if (await isJournalModalOpen()) {
            await waitJournalModalClosed();
          }
        } finally {
          ui.setWindowVisible(true);
        }
      };
      btnStats.onclick = async () => {
        try {
          ui.setWindowVisible(false);
          await PlayersService.openStatsModal(p.id, p.name);
          if (await isStatsModalOpenAsync()) {
            await waitStatsModalClosed();
          }
        } finally {
          ui.setWindowVisible(true);
        }
      };
      btnActivityLog.onclick = async () => {
        try {
          ui.setWindowVisible(false);
          await PlayersService.openActivityLogModal(p.id, p.name);
          if (await isActivityLogModalOpenAsync()) {
            await waitActivityLogModalClosed();
          }
        } finally {
          ui.setWindowVisible(true);
        }
      };
      const inspectGrid = document.createElement("div");
      inspectGrid.style.display = "grid";
      inspectGrid.style.gap = "6px";
      const activityRow = ui.flexRow({ justify: "center" });
      invRow.append(btnInv, btnJournal);
      activityRow.append(btnStats, btnActivityLog);
      inspectGrid.append(invRow, activityRow);
      const inspectCard = ui.card("\u{1F50D} Inspect", { tone: "muted", align: "center" });
      inspectCard.body.append(inspectGrid);
      col.appendChild(inspectCard.root);
      const funWrap = document.createElement("div");
      funWrap.style.display = "grid";
      funWrap.style.gap = "10px";
      const followRow = ui.flexRow({ justify: "center" });
      followRow.style.gap = "16px";
      const playerFollowGroup = document.createElement("div");
      playerFollowGroup.style.display = "flex";
      playerFollowGroup.style.alignItems = "center";
      playerFollowGroup.style.gap = "8px";
      const label2 = document.createElement("div");
      label2.textContent = "Follow player";
      label2.style.fontSize = "14px";
      label2.style.opacity = "0.85";
      const sw = ui.switch(PlayersService.isFollowing(p.id));
      sw.addEventListener("change", async () => {
        try {
          if (sw.checked) {
            await PlayersService.startFollowing(p.id);
            await toastSimple("Follow", "Enabled.", "success");
          } else {
            PlayersService.stopFollowing();
            await toastSimple("Follow", "Disable.", "info");
          }
        } catch (e) {
          await toastSimple("Follow", e?.message || "Error", "error");
          sw.checked = !sw.checked;
        }
      });
      playerFollowGroup.append(label2, sw);
      const petFollowGroup = document.createElement("div");
      petFollowGroup.style.display = "flex";
      petFollowGroup.style.alignItems = "center";
      petFollowGroup.style.gap = "4px";
      const petsLabel = document.createElement("div");
      petsLabel.textContent = "Pet follow";
      petsLabel.style.fontSize = "14px";
      petsLabel.style.opacity = "0.85";
      const petsSwitch = ui.switch(PlayersService.isPetFollowing(p.id));
      petsSwitch.addEventListener("change", async () => {
        try {
          if (petsSwitch.checked) {
            await PlayersService.startPetFollowing(p.id);
          } else {
            await PlayersService.stopPetFollowing();
          }
        } catch (e) {
          await toastSimple("Pet follow", e?.message || "Error", "error");
          petsSwitch.checked = !petsSwitch.checked;
        }
      });
      petFollowGroup.append(petsLabel, petsSwitch);
      followRow.append(playerFollowGroup, petFollowGroup);
      funWrap.append(followRow);
      const funCard = ui.card("\u{1F389} Fun", { tone: "muted", align: "center" });
      funCard.body.append(funWrap);
      col.appendChild(funCard.root);
      (async () => {
        try {
          const total = await PlayersService.getInventoryValue(p.id);
          invValue.textContent = `${NF_US_INT.format(Math.round(total))}`;
          invValue.title = "Total inventory value";
        } catch {
          invValue.textContent = "\u2014";
        }
        try {
          const total = await PlayersService.getGardenValue(p.id);
          gardenValue.textContent = `${NF_US_INT.format(Math.round(total))}`;
          gardenValue.title = "Total garden value";
        } catch {
          gardenValue.textContent = "\u2014";
        }
      })();
    }
    let players = [];
    let lastSig = "";
    function signature(ps) {
      return ps.map(
        (p) => `${p.id}|${p.name ?? ""}|${p.isConnected ? 1 : 0}|${p.inventory?.items?.length ?? 0}`
      ).join(";");
    }
    async function refreshAll(keepSelection = true) {
      const prevSel = vt.getSelected()?.id ?? null;
      const next = await readPlayers();
      const sig = signature(next);
      if (sig === lastSig) {
        return;
      }
      lastSig = sig;
      players = next;
      vt.setItems(players.map(vItem));
      const sel = keepSelection && prevSel && players.some((p) => p.id === prevSel) ? prevSel : players[0]?.id ?? null;
      if (sel !== null) vt.select(sel);
      else renderRight(null);
    }
    await PlayersService.onChange(() => {
      refreshAll(true).catch(() => {
      });
    });
    await refreshAll(true);
  }

  // src/ui/menus/keybinds.ts
  function createKeybindRow(ui, action2) {
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    controls.style.flexWrap = "nowrap";
    controls.style.gap = "8px";
    const button = ui.hotkeyButton(
      getKeybind(action2.id),
      (hk) => setKeybind(action2.id, hk),
      {
        emptyLabel: "Unassigned",
        listeningLabel: "Press a key\u2026",
        clearable: true,
        allowModifierOnly: action2.allowModifierOnly
      }
    );
    button.style.flexShrink = "0";
    controls.appendChild(button);
    let detachHoldListener = null;
    if (action2.holdDetection) {
      if (action2.id === "game.action") {
        const holdContainer = document.createElement("div");
        holdContainer.style.display = "flex";
        holdContainer.style.flexDirection = "column";
        holdContainer.style.alignItems = "center";
        holdContainer.style.gap = "4px";
        holdContainer.style.flex = "0 1 160px";
        holdContainer.style.alignSelf = "center";
        const holdButton = ui.btn("Hold", { size: "sm", variant: "secondary" });
        holdButton.style.display = "inline-flex";
        holdButton.style.alignItems = "center";
        holdButton.style.gap = "6px";
        holdButton.setAttribute("aria-label", action2.holdDetection.label);
        holdButton.title = action2.holdDetection.label;
        const holdIndicator = document.createElement("span");
        holdIndicator.textContent = "\u25CF";
        holdIndicator.style.fontSize = "10px";
        holdIndicator.style.lineHeight = "1";
        holdIndicator.setAttribute("aria-hidden", "true");
        const holdText = document.createElement("span");
        holdText.textContent = "Hold";
        holdButton.replaceChildren(holdIndicator, holdText);
        let holdEnabled = getKeybindHoldDetection(action2.id);
        const updateHoldButton = (enabled) => {
          holdEnabled = enabled;
          holdButton.setAttribute("aria-pressed", enabled ? "true" : "false");
          holdIndicator.style.color = enabled ? "#34c759" : "#ff3b30";
        };
        updateHoldButton(holdEnabled);
        holdButton.addEventListener("click", () => {
          setKeybindHoldDetection(action2.id, !holdEnabled);
        });
        detachHoldListener = onKeybindHoldDetectionChange(action2.id, (enabled) => {
          updateHoldButton(enabled);
        });
        holdContainer.appendChild(holdButton);
        if (action2.holdDetection.description) {
          const holdDesc = document.createElement("div");
          holdDesc.textContent = action2.holdDetection.description;
          holdDesc.style.fontSize = "11px";
          holdDesc.style.opacity = "0.65";
          holdDesc.style.maxWidth = "100%";
          holdDesc.style.textAlign = "center";
          holdContainer.appendChild(holdDesc);
        }
        controls.appendChild(holdContainer);
      } else {
        const holdContainer = document.createElement("div");
        holdContainer.style.display = "flex";
        holdContainer.style.flexDirection = "column";
        holdContainer.style.alignItems = "flex-start";
        holdContainer.style.gap = "2px";
        holdContainer.style.padding = "2px 4px";
        holdContainer.style.borderRadius = "8px";
        holdContainer.style.background = "rgba(255, 255, 255, 0.04)";
        holdContainer.style.flex = "0 1 180px";
        holdContainer.style.maxWidth = "180px";
        const holdLabel = document.createElement("label");
        holdLabel.style.display = "inline-flex";
        holdLabel.style.alignItems = "center";
        holdLabel.style.gap = "6px";
        holdLabel.style.fontSize = "12px";
        holdLabel.style.cursor = "pointer";
        const holdToggle = ui.switch(getKeybindHoldDetection(action2.id));
        holdToggle.style.margin = "0";
        holdToggle.setAttribute("aria-label", action2.holdDetection.label);
        const holdText = document.createElement("span");
        holdText.textContent = action2.holdDetection.label;
        holdText.style.opacity = "0.85";
        holdLabel.append(holdToggle, holdText);
        holdContainer.appendChild(holdLabel);
        if (action2.holdDetection.description) {
          const holdDesc = document.createElement("div");
          holdDesc.textContent = action2.holdDetection.description;
          holdDesc.style.fontSize = "11px";
          holdDesc.style.opacity = "0.65";
          holdDesc.style.maxWidth = "100%";
          holdContainer.appendChild(holdDesc);
        }
        holdToggle.addEventListener("change", () => {
          setKeybindHoldDetection(action2.id, holdToggle.checked);
        });
        detachHoldListener = onKeybindHoldDetectionChange(action2.id, (enabled) => {
          holdToggle.checked = enabled;
        });
        controls.appendChild(holdContainer);
      }
    }
    const actionsWrap = document.createElement("div");
    actionsWrap.style.display = "flex";
    actionsWrap.style.alignItems = "center";
    actionsWrap.style.gap = "4px";
    actionsWrap.style.marginLeft = "auto";
    const clearBtn = action2.sectionId === "game" ? null : ui.btn("", {
      icon: "\u{1F5D1}\uFE0F",
      variant: "danger",
      size: "sm",
      tooltip: "Remove this shortcut",
      ariaLabel: "Remove keybind"
    });
    if (clearBtn) {
      actionsWrap.appendChild(clearBtn);
    }
    const defaultHotkey = getDefaultKeybind(action2.id);
    const defaultString = hotkeyToString(defaultHotkey);
    let resetBtn = null;
    if (defaultHotkey) {
      resetBtn = ui.btn("", {
        icon: "\u{1F504}",
        variant: "primary",
        size: "sm",
        tooltip: "Restore default shortcut",
        ariaLabel: "Reset keybind to default"
      });
      actionsWrap.appendChild(resetBtn);
    }
    const setButtonEnabled = (btn, enabled) => {
      if (!btn) return;
      const setter = btn.setEnabled;
      if (setter) {
        setter(enabled);
      } else {
        btn.disabled = !enabled;
        btn.classList.toggle("is-disabled", !enabled);
        btn.setAttribute("aria-disabled", (!enabled).toString());
      }
    };
    const updateButtons2 = (current) => {
      const hasHotkey = hotkeyToString(current).length > 0;
      if (clearBtn) {
        setButtonEnabled(clearBtn, hasHotkey);
      }
      if (resetBtn) {
        const isDefault = hotkeyToString(current) === defaultString;
        setButtonEnabled(resetBtn, !isDefault);
      }
    };
    if (clearBtn) {
      clearBtn.addEventListener("click", () => {
        setKeybind(action2.id, null);
        const refreshed = getKeybind(action2.id);
        button.refreshHotkey(refreshed);
        updateButtons2(refreshed);
      });
    }
    if (resetBtn) {
      resetBtn.addEventListener("click", () => {
        resetKeybind(action2.id);
        const refreshed = getKeybind(action2.id);
        button.refreshHotkey(refreshed);
        updateButtons2(refreshed);
      });
    }
    controls.appendChild(actionsWrap);
    updateButtons2(getKeybind(action2.id));
    const stop2 = onKeybindChange(action2.id, (hk) => {
      button.refreshHotkey(hk);
      updateButtons2(hk);
    });
    ui.on("unmounted", stop2);
    if (detachHoldListener) ui.on("unmounted", detachHoldListener);
    const row = ui.formRow(action2.label, controls, { labelWidth: "180px" });
    row.label.style.fontSize = "13px";
    row.label.style.opacity = "0.92";
    if (action2.hint) {
      const hintEl = document.createElement("div");
      hintEl.textContent = action2.hint;
      hintEl.style.fontSize = "11px";
      hintEl.style.opacity = "0.7";
      hintEl.style.marginTop = "2px";
      hintEl.style.gridColumn = "2 / 3";
      row.root.appendChild(hintEl);
    }
    return row.root;
  }
  async function renderKeybindsMenu(container) {
    const ui = new Menu({ id: "keybinds", compact: true });
    ui.mount(container);
    const view = ui.root.querySelector(".qmm-views");
    view.innerHTML = "";
    view.style.display = "flex";
    view.style.flexDirection = "column";
    view.style.gap = "12px";
    view.style.padding = "8px";
    view.style.maxHeight = "60vh";
    view.style.overflowY = "auto";
    const wrapper = document.createElement("div");
    wrapper.style.display = "grid";
    wrapper.style.gap = "12px";
    wrapper.style.width = "100%";
    wrapper.style.maxWidth = "720px";
    wrapper.style.margin = "0 auto";
    for (const section of getKeybindSections()) {
      const card = ui.card(`${section.icon} ${section.title}`, { tone: "muted", align: "stretch" });
      card.root.dataset.section = section.id;
      card.body.style.display = "flex";
      card.body.style.flexDirection = "column";
      card.body.style.gap = "10px";
      const desc = document.createElement("p");
      desc.textContent = section.description;
      desc.style.margin = "0";
      desc.style.fontSize = "12px";
      desc.style.opacity = "0.78";
      card.body.appendChild(desc);
      for (const action2 of section.actions) {
        const row = createKeybindRow(ui, action2);
        card.body.appendChild(row);
      }
      wrapper.appendChild(card.root);
    }
    view.appendChild(wrapper);
  }

  // src/utils/friendSettings.ts
  var subscribers = /* @__PURE__ */ new Set();
  var currentSettings = null;
  var initialized = false;
  function persistSettings(settings) {
    try {
      writeAriesPath(FRIEND_SETTINGS_PATH, settings);
    } catch {
    }
  }
  function ensureSettingsInitialized() {
    if (initialized && currentSettings) {
      return currentSettings;
    }
    initialized = true;
    const stored = readAriesPath(FRIEND_SETTINGS_PATH);
    const next = buildSettings(stored);
    currentSettings = next;
    if (!stored) {
      persistSettings(next);
    }
    return next;
  }
  function notifySubscribers(next) {
    for (const cb of subscribers) {
      try {
        cb(next);
      } catch (error) {
        console.error("[FriendSettings] subscriber error", error);
      }
    }
  }
  function buildSettings(raw) {
    return { ...DEFAULT_FRIEND_SETTINGS, ...raw ?? {} };
  }
  function getFriendSettings() {
    return ensureSettingsInitialized();
  }
  function setFriendSettings(settings) {
    ensureSettingsInitialized();
    const next = buildSettings(settings);
    currentSettings = next;
    notifySubscribers(next);
    persistSettings(next);
    return next;
  }
  function patchFriendSettings(patch) {
    const base = ensureSettingsInitialized();
    return setFriendSettings({ ...base, ...patch });
  }
  function onFriendSettingsChange(cb) {
    subscribers.add(cb);
    return () => subscribers.delete(cb);
  }

  // src/ui/menus/friends.ts
  var activeGardenPreview = null;
  async function stopActiveGardenPreview(keepButton) {
    if (!activeGardenPreview) return;
    const clearFn = window.qwsEditorClearFriendGardenPreview;
    if (typeof clearFn === "function") {
      try {
        await clearFn();
      } catch (error) {
        console.error("[FriendsMenu] clear garden preview", error);
      }
    }
    const prevButton = activeGardenPreview.button;
    if (!keepButton || keepButton !== prevButton) {
      const defaultLabel = prevButton.dataset.gardenDefaultLabel ?? "Garden";
      prevButton.textContent = defaultLabel;
    }
    activeGardenPreview = null;
  }
  var refreshAllFriends = null;
  function formatLastSeen2(timestamp) {
    if (!timestamp) return null;
    const parsed = Date.parse(timestamp);
    if (!Number.isFinite(parsed)) return null;
    const deltaSeconds = Math.max(0, Math.floor((Date.now() - parsed) / 1e3));
    if (deltaSeconds < 60) {
      return deltaSeconds <= 15 ? "just now" : `${deltaSeconds}s`;
    }
    const minutes = Math.floor(deltaSeconds / 60);
    if (minutes < 60) {
      return `${minutes}min`;
    }
    const hours = Math.floor(minutes / 60);
    if (hours < 24) {
      return `${hours}h`;
    }
    const days = Math.floor(hours / 24);
    return `${days}d`;
  }
  function formatCoinAmount(value) {
    if (value == null || !Number.isFinite(value)) return null;
    const abs = Math.abs(value);
    const units = [
      { threshold: 1e12, suffix: "T" },
      { threshold: 1e9, suffix: "B" },
      { threshold: 1e6, suffix: "M" },
      { threshold: 1e3, suffix: "K" }
    ];
    for (const { threshold, suffix } of units) {
      if (abs >= threshold) {
        const normalized = value / threshold;
        return `${normalized.toFixed(2)}${suffix}`;
      }
    }
    return value.toLocaleString("en-US");
  }
  function createPrivacyBadge(label2, enabled) {
    const badge = document.createElement("span");
    badge.textContent = label2;
    badge.style.fontSize = "16px";
    badge.style.lineHeight = "1";
    badge.style.opacity = enabled ? "1" : "0.3";
    badge.style.display = "inline-flex";
    badge.style.alignItems = "center";
    badge.style.justifyContent = "center";
    badge.style.width = "auto";
    badge.style.height = "auto";
    badge.style.fontWeight = "500";
    return badge;
  }
  function createFriendRow(ui, friend) {
    const card = document.createElement("div");
    card.style.display = "grid";
    card.style.gridTemplateColumns = "1fr";
    card.style.alignItems = "stretch";
    card.style.gap = "8px";
    card.style.padding = "10px 12px";
    card.style.borderRadius = "10px";
    card.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    card.style.background = "rgba(255, 255, 255, 0.02)";
    card.style.boxShadow = "0 1px 0 rgba(0, 0, 0, 0.35) inset";
    card.style.cursor = "default";
    const roomInfo = friend.room ?? {};
    const joinRoomId = typeof roomInfo.id === "string" ? roomInfo.id.trim() : typeof roomInfo.roomId === "string" ? roomInfo.roomId.trim() : null;
    const rawPlayerCount = roomInfo.playersCount ?? roomInfo.players_count ?? roomInfo.players ?? null;
    const playersCount = Number.isFinite(Number(rawPlayerCount)) && rawPlayerCount !== null ? Math.floor(Number(rawPlayerCount)) : null;
    const isDiscordTarget = RoomService.isDiscordActivity();
    const ROOM_CAPACITY = 6;
    const seatsLeft = typeof playersCount === "number" ? Math.max(0, ROOM_CAPACITY - playersCount) : null;
    const canJoinRoom = Boolean(joinRoomId) && typeof playersCount === "number" && seatsLeft !== null && seatsLeft > 0 && !isDiscordTarget;
    const joinButtonTitle = canJoinRoom ? "Join this room" : isDiscordTarget ? "Joining rooms is disabled on Discord" : playersCount !== null && playersCount >= 6 ? "Room is full" : "Unable to join this room";
    const avatar = document.createElement("div");
    avatar.style.width = "48px";
    avatar.style.height = "48px";
    avatar.style.display = "grid";
    avatar.style.placeItems = "center";
    avatar.style.borderRadius = "50%";
    avatar.style.background = "rgba(255, 255, 255, 0.07)";
    avatar.style.fontWeight = "600";
    avatar.style.fontSize = "14px";
    avatar.style.color = "#f8fafc";
    avatar.style.overflow = "hidden";
    if (friend.avatarUrl) {
      const img = document.createElement("img");
      img.src = friend.avatarUrl;
      img.alt = friend.playerName ?? friend.playerId ?? "Friend avatar";
      img.width = 48;
      img.height = 48;
      img.style.borderRadius = "50%";
      img.style.objectFit = "cover";
      avatar.appendChild(img);
    } else {
      const fallback = document.createElement("span");
      const label2 = (friend.playerName ?? friend.playerId ?? "F").trim();
      fallback.textContent = label2.charAt(0).toUpperCase();
      fallback.style.fontSize = "15px";
      avatar.appendChild(fallback);
    }
    const infoColumn = document.createElement("div");
    infoColumn.style.display = "grid";
    infoColumn.style.gridTemplateColumns = "52px 1fr";
    infoColumn.style.alignItems = "center";
    infoColumn.style.gap = "10px";
    infoColumn.style.minWidth = "0";
    const textGrid = document.createElement("div");
    textGrid.style.display = "grid";
    textGrid.style.gridTemplateColumns = "1fr auto";
    textGrid.style.alignItems = "stretch";
    textGrid.style.gap = "12px";
    const textStack = document.createElement("div");
    textStack.style.display = "grid";
    textStack.style.gap = "4px";
    textStack.style.minWidth = "0";
    textStack.style.alignItems = "flex-start";
    const nameEl = document.createElement("div");
    nameEl.textContent = friend.playerName ?? friend.playerId ?? "Unknown friend";
    nameEl.style.fontWeight = "600";
    nameEl.style.fontSize = "13px";
    nameEl.style.whiteSpace = "nowrap";
    nameEl.style.overflow = "hidden";
    nameEl.style.textOverflow = "ellipsis";
    nameEl.style.flex = "1";
    const statusRow = document.createElement("div");
    statusRow.style.display = "flex";
    statusRow.style.alignItems = "center";
    statusRow.style.gap = "6px";
    const statusIndicator = document.createElement("span");
    const isOnline = Boolean(friend.isOnline);
    statusIndicator.style.width = "10px";
    statusIndicator.style.height = "10px";
    statusIndicator.style.borderRadius = "50%";
    statusIndicator.style.background = isOnline ? "#34d399" : "#f87171";
    statusIndicator.style.display = "inline-block";
    const statusText = document.createElement("span");
    statusText.textContent = isOnline ? "Online" : "Offline";
    statusText.style.fontSize = "11px";
    statusText.style.opacity = "0.7";
    statusRow.append(statusIndicator, statusText);
    const metaColumn = document.createElement("div");
    metaColumn.style.display = "flex";
    metaColumn.style.flexDirection = "column";
    metaColumn.style.alignItems = "flex-end";
    metaColumn.style.justifyContent = "flex-start";
    metaColumn.style.height = "100%";
    metaColumn.style.minHeight = "38px";
    metaColumn.style.alignSelf = "stretch";
    metaColumn.style.gap = "4px";
    const lastSeenText = formatLastSeen2(friend.lastEventAt);
    let lastSeenEl = null;
    if (lastSeenText) {
      lastSeenEl = document.createElement("div");
      lastSeenEl.style.fontSize = "11px";
      lastSeenEl.style.opacity = "0.65";
      lastSeenEl.style.whiteSpace = "nowrap";
      lastSeenEl.textContent = `Last seen ${lastSeenText}`;
    }
    textStack.append(nameEl, statusRow);
    if (lastSeenEl) {
      textStack.append(lastSeenEl);
    }
    textGrid.append(textStack, metaColumn);
    infoColumn.append(avatar, textGrid);
    const actionBlock = document.createElement("div");
    actionBlock.style.display = "grid";
    actionBlock.style.justifyItems = "end";
    actionBlock.style.alignItems = "end";
    actionBlock.style.alignContent = "stretch";
    actionBlock.style.gridAutoFlow = "row";
    actionBlock.style.gridTemplateRows = "repeat(3, min-content)";
    actionBlock.style.gap = "6px";
    const chevron = document.createElement("span");
    chevron.textContent = "\u25BE";
    chevron.style.display = "inline-block";
    chevron.style.transition = "transform 0.2s ease";
    chevron.style.transform = "rotate(-90deg)";
    const detailsBtn = ui.btn("Details", { size: "sm", variant: "ghost", icon: chevron });
    detailsBtn.style.minWidth = "86px";
    detailsBtn.style.justifyContent = "center";
    detailsBtn.title = "Show friend privacy badges and coins information when available.";
    const joinButton = ui.btn("Join", { size: "sm", variant: "primary" });
    joinButton.style.minWidth = "86px";
    joinButton.style.boxShadow = "0 4px 10px rgba(56, 189, 248, 0.35)";
    ui.setButtonEnabled(joinButton, canJoinRoom);
    joinButton.title = joinButtonTitle;
    joinButton.addEventListener("click", () => {
      if (!canJoinRoom || !joinRoomId) return;
      RoomService.joinPublicRoom({ idRoom: joinRoomId });
    });
    const joinControl = document.createElement("div");
    joinControl.style.display = "grid";
    joinControl.style.gap = "4px";
    joinControl.style.justifyItems = "center";
    joinControl.append(joinButton);
    const seatsInfo = document.createElement("div");
    seatsInfo.style.fontSize = "11px";
    seatsInfo.style.opacity = "0.6";
    seatsInfo.style.whiteSpace = "nowrap";
    seatsInfo.style.textAlign = "center";
    seatsInfo.style.margin = "0";
    if (seatsLeft !== null) {
      seatsInfo.textContent = seatsLeft > 0 ? `${seatsLeft} slot${seatsLeft === 1 ? "" : "s"} left` : "Room full";
    } else {
      seatsInfo.textContent = "Room size unknown";
    }
    joinControl.appendChild(seatsInfo);
    actionBlock.append(detailsBtn, joinControl);
    const rowHeader = document.createElement("div");
    rowHeader.style.display = "grid";
    rowHeader.style.gridTemplateColumns = "minmax(0, 1fr) auto";
    rowHeader.style.alignItems = "stretch";
    rowHeader.style.gap = "10px";
    rowHeader.append(infoColumn, actionBlock);
    const detailsContainer = document.createElement("div");
    detailsContainer.style.overflow = "hidden";
    detailsContainer.style.maxHeight = "0";
    detailsContainer.style.opacity = "0";
    detailsContainer.style.marginTop = "0";
    detailsContainer.style.transition = "max-height 160ms ease, opacity 160ms ease, margin-top 160ms ease";
    const coinsText = formatCoinAmount(friend.coins);
    const detailsContent = document.createElement("div");
    detailsContent.style.display = "grid";
    detailsContent.style.gridTemplateColumns = "minmax(0, 1fr)";
    detailsContent.style.alignItems = "stretch";
    detailsContent.style.gap = "6px";
    detailsContent.style.padding = "6px 0 0 0";
    const badgesRow = document.createElement("div");
    badgesRow.style.display = "flex";
    badgesRow.style.alignItems = "center";
    badgesRow.style.gap = "0";
    badgesRow.style.flexWrap = "nowrap";
    badgesRow.style.minHeight = "0";
    badgesRow.style.justifyContent = "flex-start";
    badgesRow.style.width = "auto";
    [
      { label: "\u{1F4B0}", enabled: Boolean(friend.privacy?.showCoins) },
      { label: "\u{1F392}", enabled: Boolean(friend.privacy?.showInventory) },
      { label: "\u{1F331}", enabled: Boolean(friend.privacy?.showGarden) },
      { label: "\u{1F4CB}", enabled: Boolean(friend.privacy?.showActivityLog) },
      { label: "\u{1F4F0}", enabled: Boolean(friend.privacy?.showJournal) },
      { label: "\u{1F4CA}", enabled: Boolean(friend.privacy?.showStats) }
    ].forEach(({ label: label2, enabled }) => {
      badgesRow.append(createPrivacyBadge(label2, enabled));
    });
    if (coinsText) {
      const coinsRow = document.createElement("div");
      coinsRow.style.display = "flex";
      coinsRow.style.justifyContent = "flex-end";
      coinsRow.style.paddingRight = "16px";
      const coinsEl = document.createElement("div");
      coinsEl.textContent = `${coinsText} coins`;
      coinsEl.style.fontSize = "12px";
      coinsEl.style.opacity = "0.8";
      coinsEl.style.whiteSpace = "nowrap";
      coinsEl.style.justifySelf = "end";
      coinsRow.append(coinsEl);
      detailsContent.append(coinsRow);
    }
    const privacyRow = document.createElement("div");
    privacyRow.style.display = "flex";
    privacyRow.style.alignItems = "center";
    privacyRow.style.gap = "8px";
    const privacyLabel = document.createElement("span");
    privacyLabel.textContent = "Privacy";
    privacyLabel.style.fontSize = "12px";
    privacyLabel.style.fontWeight = "600";
    privacyLabel.style.opacity = "0.8";
    privacyRow.append(privacyLabel, badgesRow);
    detailsContent.append(privacyRow);
    const styleDetailButton = (btn) => {
      btn.style.textTransform = "none";
      btn.style.padding = "6px 10px";
      btn.style.background = "rgba(148, 163, 184, 0.12)";
      btn.style.color = "#f8fafc";
      btn.style.border = "1px solid rgba(248, 250, 252, 0.3)";
      btn.style.boxShadow = "0 2px 6px rgba(0, 0, 0, 0.2)";
      btn.addEventListener("mouseenter", () => {
        btn.style.background = "rgba(248, 250, 252, 0.12)";
      });
      btn.addEventListener("mouseleave", () => {
        btn.style.background = "rgba(148, 163, 184, 0.12)";
      });
    };
    let gardenToggleBtn = null;
    const buttonRow = ui.flexRow({ gap: 6, align: "center" });
    buttonRow.style.flexWrap = "wrap";
    buttonRow.style.marginTop = "4px";
    buttonRow.style.justifyContent = "flex-start";
    buttonRow.style.alignSelf = "flex-start";
    const detailButton = (label2, section, resolver, showModal) => {
      const btn = ui.btn(label2, { size: "sm", variant: "ghost" });
      styleDetailButton(btn);
      btn.addEventListener("click", async () => {
        if (!friend.playerId) return;
        btn.disabled = true;
        try {
          const views = await fetchPlayersView([friend.playerId], { sections: [section] });
          const view = views[0];
          const payload = resolver(view);
          if (!payload) {
            await toastSimple(label2, `${label2} data unavailable.`, "info");
            return;
          }
          await showModal(payload);
        } catch (error) {
          console.error(`[FriendsMenu] Failed to load ${label2.toLowerCase()}`, error);
          await toastSimple(label2, `Unable to load ${label2.toLowerCase()}.`, "error");
        } finally {
          btn.disabled = false;
        }
      });
      return btn;
    };
    buttonRow.appendChild(
      detailButton(
        "Inventory",
        "inventory",
        (view) => view?.state?.inventory ?? null,
        (payload) => fakeInventoryShow(payload, { open: true })
      )
    );
    gardenToggleBtn = ui.btn("Garden", { size: "sm", variant: "ghost" });
    styleDetailButton(gardenToggleBtn);
    gardenToggleBtn.dataset.gardenDefaultLabel = "Garden";
    const setGardenButtonLabel = (label2) => {
      if (gardenToggleBtn) {
        gardenToggleBtn.textContent = label2;
      }
    };
    gardenToggleBtn.addEventListener("click", async () => {
      if (!gardenToggleBtn) return;
      const isActive = activeGardenPreview?.button === gardenToggleBtn;
      gardenToggleBtn.disabled = true;
      const resetLabel = () => setGardenButtonLabel("Garden");
      if (isActive) {
        try {
          await stopActiveGardenPreview(gardenToggleBtn);
        } finally {
          gardenToggleBtn.disabled = false;
          resetLabel();
        }
        return;
      }
      gardenToggleBtn.textContent = "Loading...";
      await stopActiveGardenPreview();
      try {
        if (!friend.playerId) {
          await toastSimple("Garden", "Player ID unavailable.", "error");
          return;
        }
        const [view] = await fetchPlayersView([friend.playerId], { sections: ["garden"] });
        const gardenData = view?.state?.garden ?? null;
        if (!gardenData) {
          await toastSimple("Garden", "Garden data unavailable.", "info");
          return;
        }
        const previewFn = window.qwsEditorPreviewFriendGarden;
        if (typeof previewFn !== "function") {
          await toastSimple("Garden", "Garden preview unavailable.", "error");
          return;
        }
        const applied = await previewFn(gardenData);
        if (!applied) {
          await toastSimple("Garden", "Unable to preview garden.", "error");
          return;
        }
        activeGardenPreview = { button: gardenToggleBtn, playerId: friend.playerId };
        setGardenButtonLabel("Stop garden");
      } catch (error) {
        console.error("[FriendsMenu] garden preview failed", error);
        await stopActiveGardenPreview();
        await toastSimple("Garden", "Unable to load garden.", "error");
      } finally {
        gardenToggleBtn.disabled = false;
        if (activeGardenPreview?.button !== gardenToggleBtn) {
          resetLabel();
        }
      }
    });
    buttonRow.appendChild(gardenToggleBtn);
    buttonRow.appendChild(
      detailButton(
        "Activity Log",
        "activityLog",
        (view) => view?.state?.activityLog ?? view?.state?.activityLogs ?? null,
        (payload) => fakeActivityLogShow(payload, { open: true })
      )
    );
    buttonRow.appendChild(
      detailButton(
        "Stats",
        "stats",
        (view) => view?.state?.stats ?? null,
        (payload) => fakeStatsShow(payload, { open: true })
      )
    );
    buttonRow.appendChild(
      detailButton(
        "Journal",
        "journal",
        (view) => view?.state?.journal ?? null,
        (payload) => fakeJournalShow(payload, { open: true })
      )
    );
    detailsContent.append(buttonRow);
    const removeFriendBtn = ui.btn("Remove friend", { size: "sm", variant: "danger" });
    removeFriendBtn.style.textTransform = "none";
    removeFriendBtn.style.padding = "6px 10px";
    removeFriendBtn.style.alignSelf = "flex-start";
    removeFriendBtn.addEventListener("click", async () => {
      const targetId = friend.playerId;
      if (!targetId) return;
      const me = await playerDatabaseUserId.get();
      if (!me) return;
      const original = removeFriendBtn.textContent;
      removeFriendBtn.disabled = true;
      removeFriendBtn.textContent = "Removing...";
      try {
        const removed = await removeFriend(me, targetId);
        if (removed) {
          removeFriendBtn.textContent = "Removed";
          void refreshAllFriends?.({ force: true });
        } else {
          removeFriendBtn.textContent = original;
        }
      } catch (error) {
        console.error("[FriendsMenu] removeFriend", error);
        removeFriendBtn.textContent = original;
      } finally {
        removeFriendBtn.disabled = false;
      }
    });
    detailsContent.append(removeFriendBtn);
    detailsContainer.append(detailsContent);
    const labelSpan = detailsBtn.querySelector(".label");
    let detailsExpanded = false;
    const applyDetailsState = () => {
      if (detailsExpanded) {
        const targetHeight = `${detailsContent.scrollHeight}px`;
        detailsContainer.style.maxHeight = targetHeight;
        detailsContainer.style.opacity = "1";
        detailsContainer.style.marginTop = "6px";
        detailsBtn.setAttribute("aria-expanded", "true");
        if (labelSpan) labelSpan.textContent = "Hide details";
        chevron.style.transform = "rotate(0deg)";
      } else {
        detailsContainer.style.maxHeight = "0";
        detailsContainer.style.opacity = "0";
        detailsContainer.style.marginTop = "0";
        detailsBtn.setAttribute("aria-expanded", "false");
        if (labelSpan) labelSpan.textContent = "Details";
        chevron.style.transform = "rotate(-90deg)";
      }
    };
    detailsBtn.addEventListener("click", () => {
      detailsExpanded = !detailsExpanded;
      applyDetailsState();
      if (!detailsExpanded && gardenToggleBtn) {
        void (async () => {
          await stopActiveGardenPreview(gardenToggleBtn);
          setGardenButtonLabel("Garden");
        })();
      }
    });
    applyDetailsState();
    card.append(rowHeader, detailsContainer);
    return card;
  }
  function renderAllTab(view, ui) {
    view.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "grid";
    wrap.style.gap = "10px";
    const controls = ui.flexRow({ align: "center", gap: 8 });
    const search = ui.inputText("Search for a friend...");
    search.style.flex = "1";
    search.style.minWidth = "0";
    const refresh = ui.btn("Refresh", { size: "sm", variant: "ghost" });
    refresh.style.background = "rgba(248, 250, 252, 0.08)";
    refresh.style.color = "#f8fafc";
    refresh.style.border = "1px solid rgba(248, 250, 252, 0.15)";
    refresh.style.boxShadow = "0 2px 6px rgba(0,0,0,0.35)";
    controls.append(search, refresh);
    const statusMessage = document.createElement("div");
    statusMessage.style.fontSize = "12px";
    statusMessage.style.opacity = "0.7";
    statusMessage.textContent = "Loading friends...";
    const list = document.createElement("div");
    list.style.display = "grid";
    list.style.gap = "8px";
    list.style.padding = "10px";
    list.style.borderRadius = "10px";
    list.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    list.style.background = "rgba(255, 255, 255, 0.02)";
    list.style.maxHeight = "36vh";
    list.style.overflow = "auto";
    wrap.append(controls, statusMessage, list);
    view.appendChild(wrap);
    let friends = [];
    let isLoading = false;
    let destroyed = false;
    const renderPlaceholder = (text) => {
      list.innerHTML = "";
      const placeholder = document.createElement("div");
      placeholder.textContent = text;
      placeholder.style.opacity = "0.6";
      placeholder.style.fontSize = "12px";
      placeholder.style.textAlign = "center";
      list.appendChild(placeholder);
    };
    const normalizeQuery = (term) => term.trim().toLowerCase();
    const renderList = () => {
      if (destroyed) return;
      list.innerHTML = "";
      if (isLoading) {
        renderPlaceholder("Loading friends...");
        return;
      }
      const showOnlineOnly = getFriendSettings().showOnlineFriendsOnly;
      const query = normalizeQuery(search.value);
      const matching = friends.filter((friend) => {
        const label2 = (friend.playerName ?? friend.playerId ?? "").toLowerCase();
        return label2.includes(query);
      });
      const filtered = showOnlineOnly ? matching.filter((friend) => Boolean(friend.isOnline)) : matching;
      if (!filtered.length) {
        if (friends.length === 0) {
          renderPlaceholder("You have no friends yet.");
          statusMessage.textContent = "No friends available.";
        } else if (query.length > 0) {
          renderPlaceholder("No friends match that search.");
          statusMessage.textContent = `${friends.length} friends loaded.`;
        } else if (showOnlineOnly) {
          renderPlaceholder("No online friends right now.");
          statusMessage.textContent = `${friends.length} friends loaded (online filter).`;
        } else {
          renderPlaceholder("Nothing to show.");
          statusMessage.textContent = `${friends.length} friends loaded.`;
        }
        return;
      }
      for (const friend of filtered) {
        list.appendChild(createFriendRow(ui, friend));
      }
      if (showOnlineOnly) {
        statusMessage.textContent = `${filtered.length} online friend${filtered.length !== 1 ? "s" : ""} shown.`;
      } else {
        statusMessage.textContent = `${friends.length} friends loaded.`;
      }
    };
    const loadFriends = async (options) => {
      if (destroyed) return;
      isLoading = true;
      statusMessage.textContent = "Loading friends...";
      refresh.disabled = true;
      renderList();
      try {
        const player2 = await playerDatabaseUserId.get();
        if (!player2) {
          friends = [];
          statusMessage.textContent = "Player ID unavailable.";
          renderPlaceholder("Unable to identify your player.");
          return;
        }
        if (!options?.force) {
          const cached = getCachedFriendsWithViews();
          if (cached.length) {
            friends = cached;
            statusMessage.textContent = `${friends.length} friends loaded.`;
            return;
          }
        }
        friends = await fetchFriendsWithViews(player2);
        statusMessage.textContent = friends.length ? `${friends.length} friends loaded.` : "You have no friends yet.";
      } catch (error) {
        console.error("[FriendsMenu] Failed to load friends", error);
        friends = [];
        statusMessage.textContent = "Failed to load friends.";
        renderPlaceholder("Unable to load friends.");
        return;
      } finally {
        isLoading = false;
        refresh.disabled = false;
        renderList();
      }
    };
    search.addEventListener("input", () => {
      renderList();
    });
    refresh.addEventListener("click", () => {
      void loadFriends({ force: true });
    });
    const unsubscribeSettings = onFriendSettingsChange(() => {
      if (!destroyed) {
        renderList();
      }
    });
    refreshAllFriends = loadFriends;
    void loadFriends();
    view.__cleanup__ = () => {
      destroyed = true;
      unsubscribeSettings();
      if (refreshAllFriends === loadFriends) {
        refreshAllFriends = null;
      }
    };
  }
  function renderAddFriendTab(view, ui) {
    view.innerHTML = "";
    const layout = document.createElement("div");
    layout.style.display = "grid";
    layout.style.gap = "12px";
    const profileCard = ui.card("My profile");
    profileCard.body.style.display = "grid";
    profileCard.body.style.gap = "12px";
    const profileHeader = document.createElement("div");
    profileHeader.style.display = "flex";
    profileHeader.style.alignItems = "center";
    profileHeader.style.gap = "12px";
    const avatarWrapper = document.createElement("div");
    avatarWrapper.style.width = "48px";
    avatarWrapper.style.height = "48px";
    avatarWrapper.style.borderRadius = "50%";
    avatarWrapper.style.background = "rgba(255, 255, 255, 0.04)";
    avatarWrapper.style.display = "flex";
    avatarWrapper.style.alignItems = "center";
    avatarWrapper.style.justifyContent = "center";
    avatarWrapper.style.overflow = "hidden";
    avatarWrapper.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    const avatarImg = document.createElement("img");
    avatarImg.alt = "Player avatar";
    avatarImg.style.width = "100%";
    avatarImg.style.height = "100%";
    avatarImg.style.objectFit = "cover";
    avatarImg.style.borderRadius = "50%";
    avatarImg.style.display = "none";
    const avatarFallback = document.createElement("span");
    avatarFallback.style.fontSize = "18px";
    avatarFallback.style.fontWeight = "600";
    avatarFallback.style.color = "#f8fafc";
    avatarFallback.style.display = "block";
    avatarWrapper.append(avatarImg, avatarFallback);
    const profileText = document.createElement("div");
    profileText.style.display = "grid";
    profileText.style.gap = "4px";
    profileText.style.flex = "1";
    const profileNameLabel = document.createElement("div");
    profileNameLabel.textContent = "Loading profile...";
    profileNameLabel.style.fontSize = "14px";
    profileNameLabel.style.fontWeight = "600";
    const profileIdLabel = document.createElement("div");
    profileIdLabel.textContent = "Loading player ID...";
    profileIdLabel.style.fontSize = "12px";
    profileIdLabel.style.opacity = "0.8";
    profileText.append(profileNameLabel, profileIdLabel);
    profileHeader.append(avatarWrapper, profileText);
    profileCard.body.appendChild(profileHeader);
    const formCard = ui.card("Add friend");
    formCard.body.style.display = "flex";
    formCard.body.style.flexDirection = "column";
    formCard.body.style.gap = "10px";
    const input = ui.inputText("Player ID");
    input.style.width = "100%";
    const status = document.createElement("div");
    status.style.fontSize = "12px";
    status.style.opacity = "0.7";
    status.style.minHeight = "18px";
    const submit = ui.btn("Send request", { variant: "primary", fullWidth: true });
    submit.disabled = true;
    submit.title = "Waiting for profile info...";
    formCard.body.append(input, status, submit);
    layout.append(profileCard.root, formCard.root);
    view.appendChild(layout);
    let myId = null;
    let isSending = false;
    const updateSubmitState = () => {
      const target = input.value.trim();
      submit.disabled = isSending || !myId || !target;
    };
    input.addEventListener("input", updateSubmitState);
    submit.addEventListener("click", async () => {
      if (!myId) {
        status.textContent = "Player ID missing.";
        return;
      }
      const target = input.value.trim();
      if (!target) {
        status.textContent = "Enter a player ID or name.";
        return;
      }
      isSending = true;
      updateSubmitState();
      status.textContent = "Sending request...";
      try {
        const sent = await sendFriendRequest(myId, target);
        status.textContent = sent ? "Friend request sent." : "Unable to send request (maybe already friends).";
        if (sent) {
          input.value = "";
        }
      } catch (error) {
        console.error("[FriendsMenu] sendFriendRequest failed", error);
        status.textContent = "Failed to send request.";
      } finally {
        isSending = false;
        updateSubmitState();
      }
    });
    const updateProfileInfo = async () => {
      const [resolved, playerInfo] = await Promise.all([
        playerDatabaseUserId.get(),
        player.get()
      ]);
      myId = resolved;
      const displayName = (playerInfo?.name ?? "").trim();
      profileNameLabel.textContent = displayName || "Your profile";
      profileIdLabel.textContent = resolved ? `Player ID: ${resolved}` : "Player ID unavailable.";
      const avatarUrl = (playerInfo?.discordAvatarUrl ?? "").trim();
      if (avatarUrl) {
        avatarImg.src = avatarUrl;
        avatarImg.style.display = "";
        avatarFallback.style.display = "none";
      } else {
        avatarImg.src = "";
        avatarImg.style.display = "none";
        const fallbackLabel = (displayName || resolved || "P").trim();
        avatarFallback.textContent = fallbackLabel ? fallbackLabel.charAt(0).toUpperCase() : "P";
        avatarFallback.style.display = "";
      }
      updateSubmitState();
    };
    void updateProfileInfo();
  }
  function renderFriendRequestsTab(view, ui) {
    view.innerHTML = "";
    const card = ui.card("Incoming requests");
    card.body.style.display = "grid";
    card.body.style.gap = "10px";
    const controls = ui.flexRow({ justify: "end", align: "center" });
    const requestsRefresh = ui.btn("Refresh", { size: "sm", variant: "ghost" });
    requestsRefresh.style.background = "rgba(248, 250, 252, 0.08)";
    requestsRefresh.style.color = "#f8fafc";
    requestsRefresh.style.border = "1px solid rgba(248, 250, 252, 0.15)";
    requestsRefresh.style.boxShadow = "0 2px 6px rgba(0,0,0,0.35)";
    requestsRefresh.title = "Reload friend requests";
    requestsRefresh.addEventListener("click", () => {
      void loadRequests({ force: true });
    });
    controls.appendChild(requestsRefresh);
    card.body.appendChild(controls);
    const requestsStatus = document.createElement("div");
    requestsStatus.style.fontSize = "12px";
    requestsStatus.style.opacity = "0.8";
    requestsStatus.textContent = "";
    card.body.appendChild(requestsStatus);
    const requestsList = document.createElement("div");
    requestsList.style.display = "grid";
    requestsList.style.gap = "8px";
    requestsList.style.maxHeight = "26vh";
    requestsList.style.overflow = "auto";
    card.body.appendChild(requestsList);
    view.appendChild(card.root);
    let myId = null;
    let requests = [];
    let loadingRequests = false;
    let destroyedRequests = false;
    const requestActionInProgress = /* @__PURE__ */ new Set();
    const renderRequests = () => {
      if (destroyedRequests) return;
      requestsList.innerHTML = "";
      if (loadingRequests) {
        const placeholder = document.createElement("div");
        placeholder.textContent = "Loading friend requests...";
        placeholder.style.opacity = "0.6";
        placeholder.style.fontSize = "12px";
        placeholder.style.textAlign = "center";
        requestsList.appendChild(placeholder);
        requestsStatus.textContent = "";
        return;
      }
      if (!requests.length) {
        const placeholder = document.createElement("div");
        placeholder.textContent = "No incoming friend requests.";
        placeholder.style.opacity = "0.6";
        placeholder.style.fontSize = "12px";
        placeholder.style.textAlign = "center";
        requestsList.appendChild(placeholder);
        return;
      }
      for (const request of requests) {
        const row = document.createElement("div");
        row.style.display = "grid";
        row.style.gridTemplateColumns = "40px 1fr auto";
        row.style.alignItems = "center";
        row.style.gap = "10px";
        row.style.padding = "8px 12px";
        row.style.borderRadius = "10px";
        row.style.background = "rgba(255, 255, 255, 0.03)";
        row.style.border = "1px solid rgba(255, 255, 255, 0.04)";
        const avatar = document.createElement("div");
        avatar.style.width = "36px";
        avatar.style.height = "36px";
        avatar.style.borderRadius = "50%";
        avatar.style.display = "grid";
        avatar.style.placeItems = "center";
        avatar.style.background = "rgba(255, 255, 255, 0.05)";
        if (request.avatarUrl) {
          const img = document.createElement("img");
          img.src = request.avatarUrl;
          img.alt = request.playerName ?? request.playerId ?? "Friend request avatar";
          img.width = 36;
          img.height = 36;
          img.style.borderRadius = "50%";
          img.style.objectFit = "cover";
          avatar.appendChild(img);
        } else {
          const fallback = document.createElement("span");
          const label2 = (request.playerName ?? request.playerId ?? "F").trim();
          fallback.textContent = label2.charAt(0).toUpperCase();
          fallback.style.fontWeight = "600";
          fallback.style.fontSize = "15px";
          avatar.appendChild(fallback);
        }
        const info = document.createElement("div");
        info.style.display = "flex";
        info.style.flexDirection = "column";
        info.style.gap = "2px";
        const nameEl = document.createElement("div");
        nameEl.textContent = request.playerName ?? request.playerId ?? "Unknown player";
        nameEl.style.fontWeight = "600";
        nameEl.style.fontSize = "13px";
        const subEl = document.createElement("div");
        subEl.textContent = request.room?.id ? `In room ${request.room.id}` : "No room information";
        subEl.style.fontSize = "11px";
        subEl.style.opacity = "0.7";
        info.append(nameEl, subEl);
        const actions = ui.flexRow({ gap: 4, align: "center" });
        const reject = ui.btn("\u274C", { size: "sm" });
        reject.title = "Reject request";
        const accept = ui.btn("\u2705", { size: "sm" });
        accept.title = "Accept request";
        const applyAction = (action2) => {
          return async () => {
            if (!myId || !request.playerId) return;
            if (requestActionInProgress.has(request.playerId)) return;
            requestActionInProgress.add(request.playerId);
            requestsStatus.textContent = `${action2 === "accept" ? "Accepting" : "Rejecting"} ${request.playerName ?? request.playerId}...`;
            try {
              await respondFriendRequest({
                playerId: myId,
                otherPlayerId: request.playerId,
                action: action2
              });
            } catch (error) {
              console.error("[FriendsMenu] respondFriendRequest", error);
            } finally {
              requestActionInProgress.delete(request.playerId);
              await loadRequests({ force: true });
              void refreshAllFriends?.({ force: true });
            }
          };
        };
        reject.addEventListener("click", applyAction("reject"));
        accept.addEventListener("click", applyAction("accept"));
        actions.append(reject, accept);
        row.append(avatar, info, actions);
        requestsList.appendChild(row);
      }
      requestsStatus.textContent = `${requests.length} pending request${requests.length > 1 ? "s" : ""}.`;
    };
    async function loadRequests(options) {
      if (destroyedRequests) return;
      if (!myId) {
        requestsStatus.textContent = "Waiting for player ID to load requests...";
        requestsList.innerHTML = "";
        const placeholder = document.createElement("div");
        placeholder.textContent = "Waiting for player ID to load requests.";
        placeholder.style.opacity = "0.6";
        placeholder.style.fontSize = "12px";
        placeholder.style.textAlign = "center";
        requestsList.appendChild(placeholder);
        return;
      }
      loadingRequests = true;
      renderRequests();
      try {
        if (!options?.force) {
          const cached = getCachedIncomingRequestsWithViews();
          if (cached.length) {
            requests = cached;
            return;
          }
        }
        requests = await fetchIncomingRequestsWithViews(myId);
      } catch (error) {
        console.error("[FriendsMenu] fetchIncomingRequestsWithViews", error);
        requests = [];
      } finally {
        loadingRequests = false;
        renderRequests();
      }
    }
    const refreshPlayerId = async () => {
      const resolved = await playerDatabaseUserId.get();
      myId = resolved;
      if (!resolved) {
        requestsStatus.textContent = "Waiting for player ID to load requests...";
        requestsList.innerHTML = "";
        const placeholder = document.createElement("div");
        placeholder.textContent = "Waiting for player ID to load requests.";
        placeholder.style.opacity = "0.6";
        placeholder.style.fontSize = "12px";
        placeholder.style.textAlign = "center";
        requestsList.appendChild(placeholder);
        return;
      }
      await loadRequests();
    };
    void refreshPlayerId();
    view.__cleanup__ = () => {
      destroyedRequests = true;
    };
  }
  function renderSettingsTab2(view, ui) {
    view.innerHTML = "";
    const settings = getFriendSettings();
    const layout = document.createElement("div");
    layout.style.display = "grid";
    layout.style.gap = "12px";
    const globalCard = ui.card("Global settings");
    globalCard.body.style.display = "grid";
    globalCard.body.style.gap = "12px";
    const privacyCard = ui.card("Privacy");
    privacyCard.body.style.display = "grid";
    privacyCard.body.style.gap = "12px";
    const applyPatch = (patch) => patchFriendSettings(patch);
    const buildToggleRow = (label2, checked, description, onToggle) => {
      const row = document.createElement("div");
      row.style.display = "grid";
      row.style.gridTemplateColumns = "1fr auto";
      row.style.alignItems = "center";
      row.style.gap = "12px";
      const text = document.createElement("div");
      text.style.display = "grid";
      text.style.gap = "2px";
      const labelEl = document.createElement("div");
      labelEl.textContent = label2;
      labelEl.style.fontWeight = "600";
      labelEl.style.fontSize = "13px";
      if (description) {
        const descriptionEl = document.createElement("div");
        descriptionEl.textContent = description;
        descriptionEl.style.fontSize = "12px";
        descriptionEl.style.opacity = "0.7";
        text.append(labelEl, descriptionEl);
      } else {
        text.append(labelEl);
      }
      const toggle = ui.switch(checked);
      toggle.addEventListener("input", () => {
        onToggle(toggle.checked);
      });
      row.append(text, toggle);
      return row;
    };
    globalCard.body.append(
      buildToggleRow(
        "Show online friends only",
        settings.showOnlineFriendsOnly,
        void 0,
        (next) => applyPatch({ showOnlineFriendsOnly: next })
      ),
      buildToggleRow(
        "Auto-accept incoming requests",
        settings.autoAcceptIncomingRequests,
        void 0,
        (next) => applyPatch({ autoAcceptIncomingRequests: next })
      ),
      buildToggleRow(
        "Hide my room from the public list",
        settings.hideRoomFromPublicList,
        "If another player in your room keeps this option disabled, the room will still appear in the public list.",
        (next) => applyPatch({ hideRoomFromPublicList: next })
      )
    );
    privacyCard.body.append(
      buildToggleRow(
        "Friends can view my garden",
        settings.showGarden,
        void 0,
        (next) => applyPatch({ showGarden: next })
      ),
      buildToggleRow(
        "Friends can view my inventory",
        settings.showInventory,
        void 0,
        (next) => applyPatch({ showInventory: next })
      ),
      buildToggleRow(
        "Friends can see my coins",
        settings.showCoins,
        void 0,
        (next) => applyPatch({ showCoins: next })
      ),
      buildToggleRow(
        "Friends can see my activity log",
        settings.showActivityLog,
        void 0,
        (next) => applyPatch({ showActivityLog: next })
      ),
      buildToggleRow(
        "Friends can view my journal",
        settings.showJournal,
        void 0,
        (next) => applyPatch({ showJournal: next })
      ),
      buildToggleRow(
        "Friends can see my stats",
        settings.showStats,
        void 0,
        (next) => applyPatch({ showStats: next })
      )
    );
    layout.append(globalCard.root, privacyCard.root);
    view.appendChild(layout);
  }
  function renderFriendsMenu(root) {
    const ui = new Menu({ id: "friends", compact: true });
    ui.mount(root);
    ui.root.style.width = "420px";
    ui.root.style.maxWidth = "420px";
    ui.root.style.minWidth = "340px";
    ui.addTabs([
      { id: "friends-all", title: "Friend list", render: (view) => renderAllTab(view, ui) },
      { id: "friends-add", title: "Add friend", render: (view) => renderAddFriendTab(view, ui) },
      { id: "friends-requests", title: "Request", render: (view) => renderFriendRequestsTab(view, ui) },
      { id: "friends-settings", title: "Settings", render: (view) => renderSettingsTab2(view, ui) }
    ]);
    ui.switchTo("friends-all");
  }

  // src/utils/antiafk.ts
  function createAntiAfkController(deps) {
    const STOP_EVENTS = ["visibilitychange", "blur", "focus", "focusout", "pagehide", "freeze", "resume"];
    const listeners5 = [];
    function swallowAll() {
      const add = (target, t) => {
        const h = (e) => {
          e.stopImmediatePropagation();
          e.preventDefault?.();
        };
        target.addEventListener(t, h, { capture: true });
        listeners5.push({ t, h, target });
      };
      STOP_EVENTS.forEach((t) => {
        add(document, t);
        add(window, t);
      });
    }
    function unswallowAll() {
      for (const { t, h, target } of listeners5) try {
        target.removeEventListener(t, h, { capture: true });
      } catch {
      }
      listeners5.length = 0;
    }
    const docProto = Object.getPrototypeOf(document);
    const saved = {
      hidden: Object.getOwnPropertyDescriptor(docProto, "hidden"),
      visibilityState: Object.getOwnPropertyDescriptor(docProto, "visibilityState"),
      hasFocus: document.hasFocus ? document.hasFocus.bind(document) : null
    };
    function patchProps() {
      try {
        Object.defineProperty(docProto, "hidden", { configurable: true, get() {
          return false;
        } });
      } catch {
      }
      try {
        Object.defineProperty(docProto, "visibilityState", { configurable: true, get() {
          return "visible";
        } });
      } catch {
      }
      try {
        document.hasFocus = () => true;
      } catch {
      }
    }
    function restoreProps() {
      try {
        if (saved.hidden) Object.defineProperty(docProto, "hidden", saved.hidden);
      } catch {
      }
      try {
        if (saved.visibilityState) Object.defineProperty(docProto, "visibilityState", saved.visibilityState);
      } catch {
      }
      try {
        if (saved.hasFocus) document.hasFocus = saved.hasFocus;
      } catch {
      }
    }
    let audioCtx = null;
    let osc = null;
    let gain = null;
    const resumeIfSuspended = () => {
      if (audioCtx && audioCtx.state !== "running") audioCtx.resume?.().catch(() => {
      });
    };
    function startAudioKeepAlive() {
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: "interactive" });
        gain = audioCtx.createGain();
        gain.gain.value = 1e-5;
        osc = audioCtx.createOscillator();
        osc.frequency.value = 1;
        osc.connect(gain).connect(audioCtx.destination);
        osc.start();
        document.addEventListener("visibilitychange", resumeIfSuspended, { capture: true });
        window.addEventListener("focus", resumeIfSuspended, { capture: true });
      } catch {
        stopAudioKeepAlive();
      }
    }
    function stopAudioKeepAlive() {
      try {
        osc?.stop();
      } catch {
      }
      try {
        osc?.disconnect();
        gain?.disconnect();
      } catch {
      }
      try {
        audioCtx?.close?.();
      } catch {
      }
      document.removeEventListener("visibilitychange", resumeIfSuspended, { capture: true });
      window.removeEventListener("focus", resumeIfSuspended, { capture: true });
      osc = null;
      gain = null;
      audioCtx = null;
    }
    let hb = null;
    function startHeartbeat() {
      const targetEl = document.querySelector("canvas") || document.body || document.documentElement;
      hb = window.setInterval(() => {
        try {
          targetEl.dispatchEvent(new MouseEvent("mousemove", { bubbles: true, clientX: 1, clientY: 1 }));
        } catch {
        }
      }, 25e3);
    }
    function stopHeartbeat() {
      if (hb !== null) {
        clearInterval(hb);
        hb = null;
      }
    }
    let pingTimer = null;
    async function pingPosition() {
      try {
        const cur = await deps.getPosition();
        if (!cur) return;
        await deps.move(Math.round(cur.x), Math.round(cur.y));
      } catch {
      }
    }
    function startPing() {
      pingTimer = window.setInterval(pingPosition, 6e4);
      void pingPosition();
    }
    function stopPing() {
      if (pingTimer !== null) {
        clearInterval(pingTimer);
        pingTimer = null;
      }
    }
    return {
      start() {
        patchProps();
        swallowAll();
        startAudioKeepAlive();
        startHeartbeat();
        startPing();
      },
      stop() {
        stopPing();
        stopHeartbeat();
        stopAudioKeepAlive();
        unswallowAll();
        restoreProps();
      }
    };
  }

  // src/utils/ariesModApi.ts
  var pageContext = pageWindow;
  function buildDefaultServices() {
    return {
      PlayerService,
      EditorService,
      PetsService,
      StatsService,
      lockerService,
      MiscService,
      NotifierService,
      RoomService
    };
  }
  function createAriesModApi(services) {
    return {
      readyAt: Date.now(),
      services: services ?? buildDefaultServices()
    };
  }
  function installAriesModApi(api) {
    const resolved = api ?? createAriesModApi();
    pageContext.AriesMod = resolved;
    shareGlobal("AriesMod", resolved);
    return resolved;
  }

  // src/utils/payload.ts
  var DEFAULT_PRIVACY = {
    showProfile: true,
    showGarden: true,
    showInventory: true,
    showCoins: true,
    showActivityLog: true,
    showJournal: true,
    hideRoomFromPublicList: false,
    showStats: true
  };
  function clampPlayers2(n) {
    const value = Math.floor(Number(n));
    if (!Number.isFinite(value)) return 1;
    return Math.max(1, Math.min(6, value));
  }
  function findPlayersDeep2(state2) {
    if (!state2 || typeof state2 !== "object") return [];
    const out = [];
    const seen = /* @__PURE__ */ new Set();
    const stack = [state2];
    while (stack.length) {
      const cur = stack.pop();
      if (!cur || typeof cur !== "object" || seen.has(cur)) continue;
      seen.add(cur);
      for (const key2 of Object.keys(cur)) {
        const value = cur[key2];
        if (Array.isArray(value) && value.length > 0 && value.every((item) => item && typeof item === "object")) {
          const looksLikePlayer = value.some(
            (item) => "id" in item && "name" in item
          );
          if (looksLikePlayer && /player/i.test(key2)) {
            out.push(...value);
          }
        }
        if (value && typeof value === "object") {
          stack.push(value);
        }
      }
    }
    const byId = /* @__PURE__ */ new Map();
    for (const entry of out) {
      if (entry?.id) {
        byId.set(String(entry.id), entry);
      }
    }
    return [...byId.values()];
  }
  function getPlayersArray2(state2) {
    const direct = state2?.fullState?.data?.players ?? state2?.data?.players ?? state2?.players;
    return Array.isArray(direct) ? direct : findPlayersDeep2(state2);
  }
  function getSlotsArray2(state2) {
    const raw = state2?.child?.data?.userSlots ?? state2?.fullState?.child?.data?.userSlots ?? state2?.data?.userSlots;
    if (Array.isArray(raw)) return raw;
    if (raw && typeof raw === "object") {
      const entries = Object.entries(raw);
      entries.sort((a, b) => {
        const ai = Number(a[0]);
        const bi = Number(b[0]);
        if (Number.isFinite(ai) && Number.isFinite(bi)) return ai - bi;
        return a[0].localeCompare(b[0]);
      });
      return entries.map(([, value]) => value);
    }
    return [];
  }
  function selectSlot(slots, options) {
    if (!Array.isArray(slots) || slots.length === 0) return null;
    const { slotIndex, playerId: playerId2 } = options;
    if (typeof slotIndex === "number" && Number.isInteger(slotIndex)) {
      const candidate = slots[slotIndex];
      if (candidate && typeof candidate === "object") return candidate;
    }
    const normalizedId = playerId2 != null ? String(playerId2) : null;
    if (normalizedId) {
      for (const slot of slots) {
        if (!slot || typeof slot !== "object") continue;
        if (String(
          slot.databaseUserId ?? slot.playerId ?? slot.data?.databaseUserId ?? slot.data?.playerId ?? ""
        ) === normalizedId) {
          return slot;
        }
      }
    }
    for (const slot of slots) {
      if (!slot || typeof slot !== "object") continue;
      if (slot.playerId || slot.databaseUserId || slot.data) return slot;
    }
    return null;
  }
  function resolvePlayer(players, slot, options) {
    const candidate = options.playerId ?? slot?.playerId ?? slot?.databaseUserId ?? slot?.data?.playerId ?? slot?.data?.databaseUserId ?? null;
    const normalized = candidate != null ? String(candidate) : null;
    if (normalized) {
      for (const player2 of players) {
        if (!player2 || typeof player2 !== "object") continue;
        if (String(player2.id ?? "") === normalized) return player2;
        if (String(player2.databaseUserId ?? "") === normalized) return player2;
      }
    }
    return players[0] ?? null;
  }
  function normalizeActivityLog(slotData) {
    const logs = slotData?.activityLog ?? slotData?.activityLogs ?? slotData?.activitylog;
    return Array.isArray(logs) ? logs : null;
  }
  async function buildPlayerStatePayload(options = {}) {
    try {
      const state2 = await Atoms.root.state.get();
      if (!state2 || typeof state2 !== "object") return null;
      const settings = getFriendSettings();
      const privacy = {
        showProfile: DEFAULT_PRIVACY.showProfile,
        showGarden: settings.showGarden,
        showInventory: settings.showInventory,
        showCoins: settings.showCoins,
        showActivityLog: settings.showActivityLog,
        showJournal: settings.showJournal,
        showStats: settings.showStats,
        hideRoomFromPublicList: settings.hideRoomFromPublicList
      };
      const players = getPlayersArray2(state2);
      const normalizedPlayers = Array.isArray(players) ? players : [];
      const slots = getSlotsArray2(state2).filter((slot2) => !!slot2);
      const userSlots = slots.map((slot2, idx) => {
        const slotData2 = slot2?.data ?? slot2;
        const coinCandidate2 = slotData2?.coinsCount ?? slotData2?.data?.coinsCount ?? slot2?.coinsCount ?? slot2?.data?.coinsCount ?? null;
        const coinValue2 = Number(coinCandidate2);
        const coins = Number.isFinite(coinValue2) ? coinValue2 : null;
        const playerEntry = normalizedPlayers[idx] ?? null;
        return {
          name: typeof playerEntry?.name === "string" ? playerEntry.name : typeof slotData2?.name === "string" ? slotData2.name : null,
          discordAvatarUrl: typeof playerEntry?.discordAvatarUrl === "string" ? playerEntry.discordAvatarUrl : typeof slotData2?.discordAvatarUrl === "string" ? slotData2.discordAvatarUrl : null,
          playerId: slotData2?.databaseUserId ?? slot2?.databaseUserId ?? (slotData2?.playerId ?? null),
          coins
        };
      });
      const myDatabaseUserId = await playerDatabaseUserId.get();
      if (slots.length === 0) return null;
      const slot = selectSlot(slots, {
        ...options,
        playerId: options.playerId ?? myDatabaseUserId ?? void 0
      });
      if (!slot || typeof slot !== "object") return null;
      const slotData = slot.data ?? slot;
      if (!slotData || typeof slotData !== "object") return null;
      const resolvedPlayer = resolvePlayer(normalizedPlayers, slot, options);
      const playerId2 = slot.databaseUserId ?? resolvedPlayer?.databaseUserId ?? slot.playerId ?? (resolvedPlayer?.id ?? null);
      const playerName = resolvedPlayer?.name ?? slotData?.name ?? slot?.name ?? null;
      const avatarUrl = resolvedPlayer?.discordAvatarUrl ?? slotData?.discordAvatarUrl ?? slot?.discordAvatarUrl ?? null;
      const coinCandidate = slotData?.coinsCount ?? slot?.coinsCount ?? slotData?.coins ?? slot?.coins ?? null;
      const coinValue = Number(coinCandidate);
      const coinsRaw = Number.isFinite(coinValue) ? coinValue : null;
      const roomId = state2?.data?.roomId ?? state2?.fullState?.data?.roomId ?? state2?.roomId ?? null;
      let playersCount = normalizedPlayers.length > 0 ? normalizedPlayers.length : slots.length;
      try {
        const atomValue = await Atoms.server.numPlayers.get();
        playersCount = clampPlayers2(atomValue);
      } catch {
      }
      const persistedActivityLog = readAriesPath("activityLog.history");
      const activityLog = Array.isArray(persistedActivityLog) ? persistedActivityLog : normalizeActivityLog(slotData);
      const journalEntry = slotData?.journal ?? slotData?.data?.journal ?? slot?.journal ?? slot?.data?.journal ?? null;
      return {
        playerId: playerId2 != null ? String(playerId2) : null,
        playerName: privacy.showProfile ? playerName : null,
        avatarUrl: privacy.showProfile ? avatarUrl : null,
        coins: privacy.showCoins ? coinsRaw : null,
        room: {
          id: roomId,
          isPrivate: privacy.hideRoomFromPublicList ?? null,
          playersCount,
          userSlots
        },
        privacy,
        state: {
          garden: privacy.showGarden ? slotData?.garden ?? null : null,
          inventory: privacy.showInventory ? slotData?.inventory ?? slot?.inventory ?? null : null,
          stats: privacy.showStats && typeof slotData?.stats === "object" && slotData?.stats ? slotData.stats : null,
          activityLog: privacy.showActivityLog ? activityLog : null,
          journal: privacy.showJournal ? journalEntry : null
        }
      };
    } catch {
      return null;
    }
  }
  async function logPlayerStatePayload(options) {
    const payload = await buildPlayerStatePayload(options);
    return payload;
  }
  shareGlobal("buildPlayerStatePayload", buildPlayerStatePayload);
  shareGlobal("logPlayerStatePayload", logPlayerStatePayload);
  var gameReadyWatcherInitialized = false;
  var gameReadyTriggered = false;
  var preferredReportingIntervalMs;
  var FRIEND_REFRESH_INTERVAL_MS = 6e4;
  var AUTO_ACCEPT_INTERVAL_MS = 6e4;
  var friendRefreshLoopStarted = false;
  var autoAcceptedRequestIds = /* @__PURE__ */ new Set();
  var autoAcceptTimer = null;
  var autoAcceptWatcherInitialized = false;
  var autoAcceptSettingsUnsubscribe = null;
  async function warmSupabaseInitialFetch() {
    try {
      const dbId = await playerDatabaseUserId.get();
      if (!dbId) return;
      const requests = await fetchIncomingRequestsWithViews(dbId);
      const acceptedCount = await maybeAutoAcceptIncomingRequests(dbId, requests);
      if (acceptedCount > 0) {
        await fetchIncomingRequestsWithViews(dbId);
      }
      await fetchFriendsWithViews(dbId);
    } catch (error) {
      console.error("[PlayerPayload] Failed to prefetch friends data", error);
    }
  }
  async function maybeAutoAcceptIncomingRequests(playerId2, requests) {
    if (!requests || !requests.length) return 0;
    const { autoAcceptIncomingRequests } = getFriendSettings();
    if (!autoAcceptIncomingRequests) return 0;
    let acceptedCount = 0;
    for (const request of requests) {
      const otherId = request?.playerId;
      if (!otherId) continue;
      if (autoAcceptedRequestIds.has(otherId)) continue;
      try {
        const wasAccepted = await respondFriendRequest({
          playerId: playerId2,
          otherPlayerId: otherId,
          action: "accept"
        });
        if (wasAccepted) {
          autoAcceptedRequestIds.add(otherId);
          acceptedCount += 1;
          void toastSimple(
            "Friends",
            `Auto-accepted incoming request from ${request.playerName ?? otherId}.`,
            "success"
          );
        }
      } catch (error) {
        console.error("[PlayerPayload] auto-accept request failed", error);
      }
    }
    return acceptedCount;
  }
  function startFriendDataRefreshLoop(intervalMs = FRIEND_REFRESH_INTERVAL_MS) {
    if (friendRefreshLoopStarted) return;
    friendRefreshLoopStarted = true;
    const normalizedMs = Number.isFinite(intervalMs) && intervalMs > 0 ? intervalMs : FRIEND_REFRESH_INTERVAL_MS;
    void warmSupabaseInitialFetch();
    setInterval(() => {
      void warmSupabaseInitialFetch();
    }, normalizedMs);
  }
  async function pollIncomingRequestsForAutoAccept() {
    try {
      const playerId2 = await playerDatabaseUserId.get();
      if (!playerId2) return;
      const requests = await fetchIncomingRequestsWithViews(playerId2);
      await maybeAutoAcceptIncomingRequests(playerId2, requests);
    } catch (error) {
      console.error("[PlayerPayload] auto-accept poll failed", error);
    }
  }
  function stopAutoAcceptLoop() {
    if (autoAcceptTimer === null) return;
    clearInterval(autoAcceptTimer);
    autoAcceptTimer = null;
  }
  function startAutoAcceptLoopIfEnabled() {
    const { autoAcceptIncomingRequests } = getFriendSettings();
    if (!autoAcceptIncomingRequests) {
      stopAutoAcceptLoop();
      return;
    }
    if (autoAcceptTimer !== null) return;
    void pollIncomingRequestsForAutoAccept();
    autoAcceptTimer = setInterval(() => {
      void pollIncomingRequestsForAutoAccept();
    }, AUTO_ACCEPT_INTERVAL_MS);
  }
  function startAutoAcceptWatcher() {
    if (autoAcceptWatcherInitialized) return;
    autoAcceptWatcherInitialized = true;
    startAutoAcceptLoopIfEnabled();
    autoAcceptSettingsUnsubscribe = onFriendSettingsChange(() => {
      startAutoAcceptLoopIfEnabled();
    });
  }
  async function tryInitializeReporting(state2) {
    if (gameReadyTriggered) return;
    const snapshot = state2 ?? await Atoms.root.state.get();
    const players = Array.isArray(snapshot?.data?.players) ? snapshot.data.players : [];
    if (players.length === 0) return;
    gameReadyTriggered = true;
    startPlayerStateReporting(preferredReportingIntervalMs);
    startFriendDataRefreshLoop();
  }
  function startPlayerStateReportingWhenGameReady(intervalMs) {
    if (gameReadyWatcherInitialized) return;
    gameReadyWatcherInitialized = true;
    preferredReportingIntervalMs = intervalMs;
    void tryInitializeReporting();
    void Atoms.root.state.onChange((next) => {
      void tryInitializeReporting(next);
    });
    startAutoAcceptWatcher();
  }
  var payloadReportingTimer = null;
  var isPayloadReporting = false;
  async function buildAndSendPlayerState() {
    if (isPayloadReporting) return;
    isPayloadReporting = true;
    try {
      const payload = await buildPlayerStatePayload();
      if (payload) {
        await sendPlayerState(payload);
      }
    } catch (error) {
      console.error("[PlayerPayload] Failed to send payload:", error);
    } finally {
      isPayloadReporting = false;
    }
  }
  function startPlayerStateReporting(intervalMs = 6e4) {
    if (payloadReportingTimer !== null) return;
    const normalizedMs = Number.isFinite(intervalMs) && intervalMs > 0 ? intervalMs : 6e4;
    void buildAndSendPlayerState();
    payloadReportingTimer = setInterval(() => {
      void buildAndSendPlayerState();
    }, normalizedMs);
  }

  // src/main.ts
  var ariesMod = installAriesModApi();
  var TILE_SHEETS_TO_PRELOAD = ["plants", "mutations", "pets", "animations", "items", "decor"];
  async function preloadAllTiles() {
    const tasks = TILE_SHEETS_TO_PRELOAD.map(async (base) => {
      const result = await loadTileSheet(base);
      return result;
    });
    await Promise.all(tasks);
  }
  (async function() {
    "use strict";
    migrateLocalStorageToAries();
    installPageWebSocketHook();
    initGameVersion();
    void prefetchManifest({ registerSprites: true, waitForVersionMs: 3e3 });
    initSprites({
      config: {
        blackBelow: 10,
        skipAlphaBelow: 1,
        tolerance: 5e-3
      },
      onAsset: (url) => {
        recordAssetUrlHint(url);
        void prefetchManifest({ registerSprites: true });
      }
    });
    await ensureSpritesReady();
    await preloadAllTiles();
    await warmUpAllSprites();
    EditorService.init();
    mountHUD({
      onRegister(register) {
        register("players", "\u{1F465} Friends", renderFriendsMenu);
        register("pets", "\u{1F43E} Pets", renderPetsMenu);
        register("room", "\u{1F3E0} Room", renderRoomMenu);
        register("locker", "\u{1F512} Locker", renderLockerMenu);
        register("alerts", "\u{1F514} Alerts", renderNotifierMenu);
        register("calculator", "\u{1F913} Calculator", renderCalculatorMenu);
        register("editor", "\u{1F4DD} Editor", renderEditorMenu);
        register("stats", "\u{1F4CA} Stats", renderStatsMenu);
        register("misc", "\u{1F9E9} Misc", renderMiscMenu);
        register("keybinds", "\u2328\uFE0F Keybinds", renderKeybindsMenu);
        register("tools", "\u{1F6E0}\uFE0F Tools", renderToolsMenu);
        register("settings", "\u2699\uFE0F Settings", renderSettingsMenu);
        register("debug-data", "\u{1F41E} Debug", renderDebugDataMenu);
      }
    });
    initWatchers();
    const antiAfk = createAntiAfkController({
      getPosition: () => PlayerService.getPosition(),
      move: (x, y) => PlayerService.move(x, y)
    });
    ariesMod.antiAfkController = antiAfk;
    antiAfk.start();
    startPlayerStateReportingWhenGameReady();
  })();
})();
